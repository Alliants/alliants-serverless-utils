import 'source-map-support/register.js';
import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      __name(hooks, "hooks");
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      __name(setHookCallback, "setHookCallback");
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      __name(isArray, "isArray");
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      __name(isObject, "isObject");
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      __name(hasOwnProp, "hasOwnProp");
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      __name(isObjectEmpty, "isObjectEmpty");
      function isUndefined(input) {
        return input === void 0;
      }
      __name(isUndefined, "isUndefined");
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      __name(isNumber, "isNumber");
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      __name(isDate, "isDate");
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      __name(map, "map");
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      __name(extend, "extend");
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      __name(createUTC, "createUTC");
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      __name(defaultParsingFlags, "defaultParsingFlags");
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      __name(getParsingFlags, "getParsingFlags");
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = /* @__PURE__ */ __name(function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        }, "some");
      }
      function isValid(m) {
        var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m);
          parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m._isValid;
      }
      __name(isValid, "isValid");
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      __name(createInvalid, "createInvalid");
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      __name(copyConfig, "copyConfig");
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      __name(Moment, "Moment");
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      __name(isMoment, "isMoment");
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      __name(warn, "warn");
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      __name(deprecate, "deprecate");
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      __name(deprecateSimple, "deprecateSimple");
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      __name(isFunction, "isFunction");
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      __name(set, "set");
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      __name(mergeConfigs, "mergeConfigs");
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      __name(Locale, "Locale");
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = /* @__PURE__ */ __name(function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        }, "keys");
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      __name(calendar, "calendar");
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      __name(zeroFill, "zeroFill");
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = /* @__PURE__ */ __name(function() {
            return this[callback]();
          }, "func");
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      __name(addFormatToken, "addFormatToken");
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      __name(removeFormattingTokens, "removeFormattingTokens");
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      __name(makeFormatFunction, "makeFormatFunction");
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      __name(formatMoment, "formatMoment");
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        __name(replaceLongDateFormatTokens, "replaceLongDateFormatTokens");
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      __name(expandFormat, "expandFormat");
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      __name(longDateFormat, "longDateFormat");
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      __name(invalidDate, "invalidDate");
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      __name(ordinal, "ordinal");
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      __name(relativeTime, "relativeTime");
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      __name(pastFuture, "pastFuture");
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      __name(normalizeUnits, "normalizeUnits");
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      __name(normalizeObjectUnits, "normalizeObjectUnits");
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      __name(getPrioritizedUnits, "getPrioritizedUnits");
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      __name(addRegexToken, "addRegexToken");
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      __name(getParseRegexForToken, "getParseRegexForToken");
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      __name(unescapeFormat, "unescapeFormat");
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      __name(regexEscape, "regexEscape");
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      __name(absFloor, "absFloor");
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      __name(toInt, "toInt");
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = /* @__PURE__ */ __name(function(input, array) {
            array[callback] = toInt(input);
          }, "func");
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      __name(addParseToken, "addParseToken");
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      __name(addWeekParseToken, "addWeekParseToken");
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      __name(addTimeToArrayFromToken, "addTimeToArrayFromToken");
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      __name(isLeapYear, "isLeapYear");
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      __name(daysInYear, "daysInYear");
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      __name(getIsLeapYear, "getIsLeapYear");
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      __name(makeGetSet, "makeGetSet");
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case "Seconds":
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case "Minutes":
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case "Hours":
            return isUTC ? d.getUTCHours() : d.getHours();
          case "Date":
            return isUTC ? d.getUTCDate() : d.getDate();
          case "Day":
            return isUTC ? d.getUTCDay() : d.getDay();
          case "Month":
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case "FullYear":
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
        }
      }
      __name(get, "get");
      function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case "Hours":
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case "Date":
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          case "FullYear":
            break;
          default:
            return;
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
      }
      __name(set$1, "set$1");
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      __name(stringGet, "stringGet");
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      __name(stringSet, "stringSet");
      function mod(n, x) {
        return (n % x + x) % x;
      }
      __name(mod, "mod");
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = /* @__PURE__ */ __name(function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        }, "indexOf");
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      __name(daysInMonth, "daysInMonth");
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonths, "localeMonths");
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonthsShort, "localeMonthsShort");
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse, "handleStrictParse");
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      __name(localeMonthsParse, "localeMonthsParse");
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        var month = value, date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      __name(setMonth, "setMonth");
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      __name(getSetMonth, "getSetMonth");
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      __name(getDaysInMonth, "getDaysInMonth");
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      __name(monthsShortRegex, "monthsShortRegex");
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      __name(monthsRegex, "monthsRegex");
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeMonthsParse, "computeMonthsParse");
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      __name(createDate, "createDate");
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      __name(createUTCDate, "createUTCDate");
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      __name(firstWeekOffset, "firstWeekOffset");
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      __name(dayOfYearFromWeeks, "dayOfYearFromWeeks");
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      __name(weekOfYear, "weekOfYear");
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      __name(weeksInYear, "weeksInYear");
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      __name(localeWeek, "localeWeek");
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      __name(localeFirstDayOfWeek, "localeFirstDayOfWeek");
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      __name(localeFirstDayOfYear, "localeFirstDayOfYear");
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetWeek, "getSetWeek");
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetISOWeek, "getSetISOWeek");
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      __name(parseWeekday, "parseWeekday");
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      __name(parseIsoWeekday, "parseIsoWeekday");
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      __name(shiftWeekdays, "shiftWeekdays");
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      __name(localeWeekdays, "localeWeekdays");
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      __name(localeWeekdaysShort, "localeWeekdaysShort");
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      __name(localeWeekdaysMin, "localeWeekdaysMin");
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse$1, "handleStrictParse$1");
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      __name(localeWeekdaysParse, "localeWeekdaysParse");
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      __name(getSetDayOfWeek, "getSetDayOfWeek");
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      __name(getSetLocaleDayOfWeek, "getSetLocaleDayOfWeek");
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      __name(getSetISODayOfWeek, "getSetISODayOfWeek");
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      __name(weekdaysRegex, "weekdaysRegex");
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      __name(weekdaysShortRegex, "weekdaysShortRegex");
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      __name(weekdaysMinRegex, "weekdaysMinRegex");
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeWeekdaysParse, "computeWeekdaysParse");
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      __name(hFormat, "hFormat");
      function kFormat() {
        return this.hours() || 24;
      }
      __name(kFormat, "kFormat");
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      __name(meridiem, "meridiem");
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      __name(matchMeridiem, "matchMeridiem");
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      __name(localeIsPM, "localeIsPM");
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      __name(localeMeridiem, "localeMeridiem");
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      __name(commonPrefix, "commonPrefix");
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      __name(normalizeLocale, "normalizeLocale");
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      __name(chooseLocale, "chooseLocale");
      function isLocaleNameSane(name) {
        return !!(name && name.match("^[^/\\\\]*$"));
      }
      __name(isLocaleNameSane, "isLocaleNameSane");
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = __require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      __name(loadLocale, "loadLocale");
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      __name(getSetGlobalLocale, "getSetGlobalLocale");
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      __name(defineLocale, "defineLocale");
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      __name(updateLocale, "updateLocale");
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      __name(getLocale, "getLocale");
      function listLocales() {
        return keys(locales);
      }
      __name(listLocales, "listLocales");
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      __name(checkOverflow, "checkOverflow");
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      __name(configFromISO, "configFromISO");
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      __name(extractFromRFC2822Strings, "extractFromRFC2822Strings");
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      __name(untruncateYear, "untruncateYear");
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      __name(preprocessRFC2822, "preprocessRFC2822");
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      __name(checkWeekday, "checkWeekday");
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      __name(calculateOffset, "calculateOffset");
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      __name(configFromRFC2822, "configFromRFC2822");
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromString, "configFromString");
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      __name(defaults, "defaults");
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      __name(currentDateArray, "currentDateArray");
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      __name(configFromArray, "configFromArray");
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      __name(dayOfYearFromWeekInfo, "dayOfYearFromWeekInfo");
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      __name(configFromStringAndFormat, "configFromStringAndFormat");
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      __name(meridiemFixWrap, "meridiemFixWrap");
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      __name(configFromStringAndArray, "configFromStringAndArray");
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      __name(configFromObject, "configFromObject");
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      __name(createFromConfig, "createFromConfig");
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      __name(prepareConfig, "prepareConfig");
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromInput, "configFromInput");
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      __name(createLocalOrUTC, "createLocalOrUTC");
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      __name(createLocal, "createLocal");
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      __name(pickBy, "pickBy");
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      __name(min, "min");
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      __name(max, "max");
      var now = /* @__PURE__ */ __name(function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      }, "now");
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      __name(isDurationValid, "isDurationValid");
      function isValid$1() {
        return this._isValid;
      }
      __name(isValid$1, "isValid$1");
      function createInvalid$1() {
        return createDuration(NaN);
      }
      __name(createInvalid$1, "createInvalid$1");
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      __name(Duration, "Duration");
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      __name(isDuration, "isDuration");
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      __name(absRound, "absRound");
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      __name(compareArrays, "compareArrays");
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      __name(offset, "offset");
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      __name(offsetFromString, "offsetFromString");
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      __name(cloneWithOffset, "cloneWithOffset");
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      __name(getDateOffset, "getDateOffset");
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      __name(getSetOffset, "getSetOffset");
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      __name(getSetZone, "getSetZone");
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      __name(setOffsetToUTC, "setOffsetToUTC");
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      __name(setOffsetToLocal, "setOffsetToLocal");
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      __name(setOffsetToParsedOffset, "setOffsetToParsedOffset");
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      __name(hasAlignedHourOffset, "hasAlignedHourOffset");
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      __name(isDaylightSavingTime, "isDaylightSavingTime");
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      __name(isDaylightSavingTimeShifted, "isDaylightSavingTimeShifted");
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      __name(isLocal, "isLocal");
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      __name(isUtcOffset, "isUtcOffset");
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      __name(isUtc, "isUtc");
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      __name(createDuration, "createDuration");
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      __name(parseIso, "parseIso");
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      __name(positiveMomentsDifference, "positiveMomentsDifference");
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      __name(momentsDifference, "momentsDifference");
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      __name(createAdder, "createAdder");
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      __name(addSubtract, "addSubtract");
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      __name(isString, "isString");
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      __name(isMomentInput, "isMomentInput");
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isMomentInputObject, "isMomentInputObject");
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      __name(isNumberOrStringArray, "isNumberOrStringArray");
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isCalendarSpec, "isCalendarSpec");
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      __name(getCalendarFormat, "getCalendarFormat");
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      __name(calendar$1, "calendar$1");
      function clone() {
        return new Moment(this);
      }
      __name(clone, "clone");
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      __name(isAfter, "isAfter");
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      __name(isBefore, "isBefore");
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      __name(isBetween, "isBetween");
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      __name(isSame, "isSame");
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      __name(isSameOrAfter, "isSameOrAfter");
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      __name(isSameOrBefore, "isSameOrBefore");
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      __name(diff, "diff");
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      __name(monthDiff, "monthDiff");
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      __name(toString, "toString");
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      __name(toISOString, "toISOString");
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      __name(inspect, "inspect");
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      __name(format, "format");
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(from, "from");
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      __name(fromNow, "fromNow");
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(to, "to");
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      __name(toNow, "toNow");
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      __name(locale, "locale");
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      __name(localeData, "localeData");
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      __name(mod$1, "mod$1");
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      __name(localStartOfDate, "localStartOfDate");
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      __name(utcStartOfDate, "utcStartOfDate");
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(startOf, "startOf");
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(endOf, "endOf");
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      __name(valueOf, "valueOf");
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      __name(unix, "unix");
      function toDate() {
        return new Date(this.valueOf());
      }
      __name(toDate, "toDate");
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      __name(toArray, "toArray");
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      __name(toObject, "toObject");
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      __name(toJSON, "toJSON");
      function isValid$2() {
        return isValid(this);
      }
      __name(isValid$2, "isValid$2");
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      __name(parsingFlags, "parsingFlags");
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      __name(invalidAt, "invalidAt");
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      __name(creationData, "creationData");
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      __name(localeEras, "localeEras");
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      __name(localeErasParse, "localeErasParse");
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      __name(localeErasConvertYear, "localeErasConvertYear");
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      __name(getEraName, "getEraName");
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      __name(getEraNarrow, "getEraNarrow");
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      __name(getEraAbbr, "getEraAbbr");
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      __name(getEraYear, "getEraYear");
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      __name(erasNameRegex, "erasNameRegex");
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      __name(erasAbbrRegex, "erasAbbrRegex");
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      __name(erasNarrowRegex, "erasNarrowRegex");
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      __name(matchEraAbbr, "matchEraAbbr");
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      __name(matchEraName, "matchEraName");
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      __name(matchEraNarrow, "matchEraNarrow");
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      __name(matchEraYearOrdinal, "matchEraYearOrdinal");
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeErasParse, "computeErasParse");
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      __name(addWeekYearFormatToken, "addWeekYearFormatToken");
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      __name(getSetWeekYear, "getSetWeekYear");
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      __name(getSetISOWeekYear, "getSetISOWeekYear");
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      __name(getISOWeeksInYear, "getISOWeeksInYear");
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      __name(getISOWeeksInISOWeekYear, "getISOWeeksInISOWeekYear");
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInYear, "getWeeksInYear");
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInWeekYear, "getWeeksInWeekYear");
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      __name(getSetWeekYearHelper, "getSetWeekYearHelper");
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      __name(setWeekAll, "setWeekAll");
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      __name(getSetQuarter, "getSetQuarter");
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      __name(getSetDayOfYear, "getSetDayOfYear");
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      __name(parseMs, "parseMs");
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      __name(getZoneAbbr, "getZoneAbbr");
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      __name(getZoneName, "getZoneName");
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      __name(createUnix, "createUnix");
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      __name(createInZone, "createInZone");
      function preParsePostFormat(string) {
        return string;
      }
      __name(preParsePostFormat, "preParsePostFormat");
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      __name(get$1, "get$1");
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      __name(listMonthsImpl, "listMonthsImpl");
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      __name(listWeekdaysImpl, "listWeekdaysImpl");
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      __name(listMonths, "listMonths");
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      __name(listMonthsShort, "listMonthsShort");
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      __name(listWeekdays, "listWeekdays");
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      __name(listWeekdaysShort, "listWeekdaysShort");
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      __name(listWeekdaysMin, "listWeekdaysMin");
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      __name(abs, "abs");
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      __name(addSubtract$1, "addSubtract$1");
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      __name(add$1, "add$1");
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      __name(subtract$1, "subtract$1");
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      __name(absCeil, "absCeil");
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      __name(bubble, "bubble");
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      __name(daysToMonths, "daysToMonths");
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      __name(monthsToDays, "monthsToDays");
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      __name(as, "as");
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      __name(makeAs, "makeAs");
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      __name(clone$1, "clone$1");
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      __name(get$2, "get$2");
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      __name(makeGetter, "makeGetter");
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      __name(weeks, "weeks");
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      __name(substituteTimeAgo, "substituteTimeAgo");
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      __name(relativeTime$1, "relativeTime$1");
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      __name(getSetRelativeTimeRounding, "getSetRelativeTimeRounding");
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      __name(getSetRelativeTimeThreshold, "getSetRelativeTimeThreshold");
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      __name(humanize, "humanize");
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      __name(sign, "sign");
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      __name(toISOString$1, "toISOString$1");
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/@joi/date/lib/index.js
var require_lib = __commonJS({
  "node_modules/@joi/date/lib/index.js"(exports, module) {
    "use strict";
    var Moment = require_moment();
    module.exports = (joi) => {
      const args = {
        format: joi.alternatives([
          joi.string(),
          joi.array().items(joi.string().invalid("iso", "javascript", "unix"))
        ])
      };
      return {
        type: "date",
        base: joi.date(),
        coerce: {
          from: "string",
          method: function(value, { schema: schema2 }) {
            const format = schema2.$_getFlag("format");
            if (!format) {
              return;
            }
            const date = schema2.$_getFlag("utc") ? Moment.utc(value, format, true) : Moment(value, format, true);
            if (date.isValid()) {
              return { value: date.toDate() };
            }
          }
        },
        rules: {
          utc: {
            method: function(enabled = true) {
              return this.$_setFlag("utc", enabled);
            }
          }
        },
        overrides: {
          format: function(format) {
            joi.attempt(format, args.format, "Invalid format");
            if (["iso", "javascript", "unix"].includes(format)) {
              return this.$_super.format(format);
            }
            return this.$_setFlag("format", format);
          }
        }
      };
    };
    module.exports.default = module.exports;
  }
});

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@hapi/hoek/lib/stringify.js"(exports, module) {
    "use strict";
    module.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/error.js
var require_error = __commonJS({
  "node_modules/@hapi/hoek/lib/error.js"(exports, module) {
    "use strict";
    var Stringify = require_stringify();
    module.exports = class extends Error {
      constructor(args) {
        const msgs = args.filter((arg) => arg !== "").map((arg) => {
          return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });
        super(msgs.join(" ") || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, exports.assert);
        }
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS({
  "node_modules/@hapi/hoek/lib/assert.js"(exports, module) {
    "use strict";
    var AssertError = require_error();
    module.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      throw new AssertError(args);
    };
  }
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS({
  "node_modules/@hapi/hoek/lib/reach.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    module.exports = function(obj, chain, options) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number = Number(key);
          if (Number.isInteger(number)) {
            key = number < 0 ? ref.length + number : number;
          }
        }
        if (!ref || typeof ref === "function" && options.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS({
  "node_modules/@hapi/hoek/lib/types.js"(exports, module) {
    "use strict";
    var internals = {};
    exports = module.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports.error],
      ["[object Map]", exports.map],
      ["[object Promise]", exports.promise],
      ["[object Set]", exports.set],
      ["[object WeakMap]", exports.weakMap],
      ["[object WeakSet]", exports.weakSet]
    ]);
    exports.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports.buffer;
      }
      if (obj instanceof Date) {
        return exports.date;
      }
      if (obj instanceof RegExp) {
        return exports.regex;
      }
      if (obj instanceof Error) {
        return exports.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports.generic;
    };
  }
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@hapi/hoek/lib/utils.js"(exports) {
    "use strict";
    exports.keys = function(obj, options = {}) {
      return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS({
  "node_modules/@hapi/hoek/lib/clone.js"(exports, module) {
    "use strict";
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
    };
    module.exports = internals.clone = function(obj, options = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone = internals.clone;
      let seen = _seen;
      if (options.shallow) {
        if (options.shallow !== true) {
          return internals.cloneWithShallow(obj, options);
        }
        clone = /* @__PURE__ */ __name((value) => value, "clone");
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);
      }
      if (baseProto === Types.date) {
        return new Date(obj.getTime());
      }
      if (baseProto === Types.regex) {
        return new RegExp(obj);
      }
      const newObj = internals.base(obj, baseProto, options);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone(value, options, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone(value, options, seen));
        }
      }
      const keys = Utils.keys(obj, options);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone(obj[key], options, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone(obj[key], options, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options) {
      const keys = options.shallow;
      options = Object.assign({}, options);
      options.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options, seen);
    };
    internals.base = function(obj, baseProto, options) {
      if (options.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto = Object.getPrototypeOf(obj);
      if (proto && proto.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      return Object.create(proto);
    };
  }
});

// node_modules/joi/package.json
var require_package = __commonJS({
  "node_modules/joi/package.json"(exports, module) {
    module.exports = {
      name: "joi",
      description: "Object schema validation",
      version: "17.11.1",
      repository: "git://github.com/hapijs/joi",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/hoek": "^9.3.0",
        "@hapi/topo": "^5.1.0",
        "@sideway/address": "^4.1.4",
        "@sideway/formula": "^3.0.1",
        "@sideway/pinpoint": "^2.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "2.x.x",
        "@hapi/code": "8.x.x",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
        "@hapi/lab": "^25.1.3",
        "@types/node": "^14.18.63",
        typescript: "4.3.x"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L -Y",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/joi/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/joi/lib/schemas.js"(exports) {
    "use strict";
    var Joi2 = require_lib5();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      artifacts: Joi2.boolean(),
      cache: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      debug: Joi2.boolean(),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap,
          string: internals.wrap
        }
      },
      externals: Joi2.boolean(),
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi2.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi2.object({
      alias: Joi2.array().items(Joi2.string().pattern(internals.nameRx)).single(),
      args: Joi2.array().items(
        Joi2.string(),
        Joi2.object({
          name: Joi2.string().pattern(internals.nameRx).required(),
          ref: Joi2.boolean(),
          assert: Joi2.alternatives([
            Joi2.function(),
            Joi2.object().schema()
          ]).conditional("ref", { is: true, then: Joi2.required() }),
          normalize: Joi2.function(),
          message: Joi2.string().when("assert", { is: Joi2.function(), then: Joi2.required() })
        })
      ),
      convert: Joi2.boolean(),
      manifest: Joi2.boolean(),
      method: Joi2.function().allow(false),
      multi: Joi2.boolean(),
      validate: Joi2.function()
    });
    exports.extension = Joi2.object({
      type: Joi2.alternatives([
        Joi2.string(),
        Joi2.object().regex()
      ]).required(),
      args: Joi2.function(),
      cast: Joi2.object().pattern(internals.nameRx, Joi2.object({
        from: Joi2.function().maxArity(1).required(),
        to: Joi2.function().minArity(1).maxArity(2).required()
      })),
      base: Joi2.object().schema().when("type", { is: Joi2.object().regex(), then: Joi2.forbidden() }),
      coerce: [
        Joi2.function().maxArity(3),
        Joi2.object({ method: Joi2.function().maxArity(3).required(), from: Joi2.array().items(Joi2.string()).single() })
      ],
      flags: Joi2.object().pattern(internals.nameRx, Joi2.object({
        setter: Joi2.string(),
        default: Joi2.any()
      })),
      manifest: {
        build: Joi2.function().arity(2)
      },
      messages: [Joi2.object(), Joi2.string()],
      modifiers: Joi2.object().pattern(internals.nameRx, Joi2.function().minArity(1).maxArity(2)),
      overrides: Joi2.object().pattern(internals.nameRx, Joi2.function()),
      prepare: Joi2.function().maxArity(3),
      rebuild: Joi2.function().arity(1),
      rules: Joi2.object().pattern(internals.nameRx, internals.rule),
      terms: Joi2.object().pattern(internals.nameRx, Joi2.object({
        init: Joi2.array().allow(null).required(),
        manifest: Joi2.object().pattern(/.+/, [
          Joi2.valid("schema", "single"),
          Joi2.object({
            mapped: Joi2.object({
              from: Joi2.string().required(),
              to: Joi2.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi2.function().maxArity(3)
    }).strict();
    exports.extensions = Joi2.array().items(Joi2.object(), Joi2.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi2.object({
        buffer: Joi2.string()
      }),
      func: Joi2.object({
        function: Joi2.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi2.object({
        override: true
      }),
      ref: Joi2.object({
        ref: Joi2.object({
          type: Joi2.valid("value", "global", "local"),
          path: Joi2.array().required(),
          separator: Joi2.string().length(1).allow(false),
          ancestor: Joi2.number().min(0).integer().allow("root"),
          map: Joi2.array().items(Joi2.array().length(2)).min(1),
          adjust: Joi2.function(),
          iterables: Joi2.boolean(),
          in: Joi2.boolean(),
          render: Joi2.boolean()
        }).required()
      }),
      regex: Joi2.object({
        regex: Joi2.string().min(3)
      }),
      special: Joi2.object({
        special: Joi2.valid("deep").required()
      }),
      template: Joi2.object({
        template: Joi2.string().required(),
        options: Joi2.object()
      }),
      value: Joi2.object({
        value: Joi2.alternatives([Joi2.object(), Joi2.array()]).required()
      })
    };
    internals.desc.entity = Joi2.alternatives([
      Joi2.array().items(Joi2.link("...")),
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number(),
      Joi2.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi2.link("/")
    ]);
    internals.desc.values = Joi2.array().items(
      null,
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number().allow(Infinity, -Infinity),
      Joi2.string().allow(""),
      Joi2.symbol(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.override,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.template,
      internals.desc.value
    );
    internals.desc.messages = Joi2.object().pattern(/.+/, [
      Joi2.string(),
      internals.desc.template,
      Joi2.object().pattern(/.+/, [Joi2.string(), internals.desc.template])
    ]);
    exports.description = Joi2.object({
      type: Joi2.string().required(),
      flags: Joi2.object({
        cast: Joi2.string(),
        default: Joi2.any(),
        description: Joi2.string(),
        empty: Joi2.link("/"),
        failover: internals.desc.entity,
        id: Joi2.string(),
        label: Joi2.string(),
        only: true,
        presence: ["optional", "required", "forbidden"],
        result: ["raw", "strip"],
        strip: Joi2.boolean(),
        unit: Joi2.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi2.boolean(),
        abortEarly: Joi2.boolean(),
        artifacts: Joi2.boolean(),
        cache: Joi2.boolean(),
        convert: Joi2.boolean(),
        dateFormat: ["date", "iso", "string", "time", "utc"],
        errors: {
          escapeHtml: Joi2.boolean(),
          label: ["path", "key"],
          language: [
            Joi2.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi2.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi2.boolean(),
        nonEnumerables: Joi2.boolean(),
        presence: ["required", "optional", "forbidden"],
        skipFunctions: Joi2.boolean(),
        stripUnknown: Joi2.object({
          arrays: Joi2.boolean(),
          objects: Joi2.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi2.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi2.array().min(1).items({
        name: Joi2.string().required(),
        args: Joi2.object().min(1),
        keep: Joi2.boolean(),
        message: [
          Joi2.string(),
          internals.desc.messages
        ],
        warn: Joi2.boolean()
      }),
      // Terms
      keys: Joi2.object().pattern(/.*/, Joi2.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi2.any());
  }
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeHtml.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || // a-z
        i >= 65 && i <= 90 || // A-Z
        i >= 48 && i <= 57 || // 0-9
        i === 32 || // space
        i === 46 || // .
        i === 44 || // ,
        i === 45 || // -
        i === 58 || // :
        i === 95) {
          safe.add(i);
        }
      }
      return safe;
    }();
  }
});

// node_modules/@sideway/formula/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@sideway/formula/lib/index.js"(exports) {
    "use strict";
    var internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports.Parser = class {
      constructor(string, options = {}) {
        if (!options[internals.settings] && options.constants) {
          for (const constant in options.constants) {
            const value = options.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;
        this._parts = null;
        this._parse(string);
      }
      _parse(string) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = /* @__PURE__ */ __name((inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        }, "flush");
        for (const c of string) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i) => {
          if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = /* @__PURE__ */ __name(() => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
            }
            args.push(current);
            current = "";
          }, "flush");
          for (let i = 0; i < string.length; ++i) {
            const c = string[i];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i = parts.length - 2; i >= 0; --i) {
          const part = parts[i];
          if (part && part.type === "operator") {
            const current = parts[i + 1];
            parts.splice(i + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i = 1; i < parts.length - 1; ) {
            if (set.includes(parts[i])) {
              const operator = parts[i];
              const left = internals.evaluate(parts[i - 1], context);
              const right = internals.evaluate(parts[i + 1], context);
              parts.splice(i, 2);
              const result = internals.calculate(operator, left, right);
              parts[i - 1] = result === 0 ? 0 : result;
            } else {
              i += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});

// node_modules/joi/lib/annotate.js
var require_annotate = __commonJS({
  "node_modules/joi/lib/annotate.js"(exports) {
    "use strict";
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = /* @__PURE__ */ __name((key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      }, "cycleReplacer");
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/joi/lib/errors.js
var require_errors = __commonJS({
  "node_modules/joi/lib/errors.js"(exports) {
    "use strict";
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports.Report = class {
      constructor(code, value, local, flags, messages, state, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code) {
        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
      }
    };
    exports.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports.template = function(value, messages, code, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang]) {
        if (messages[lang][code] !== void 0) {
          return messages[lang][code];
        }
        if (messages[lang]["*"] !== void 0) {
          return messages[lang]["*"];
        }
      }
      if (!messages[code]) {
        return messages["*"];
      }
      return messages[code];
    };
    exports.label = function(flags, state, prefs, messages) {
      if (flags.label) {
        return flags.label;
      }
      if (!prefs.errors.label) {
        return "";
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports.path(path);
      if (normalized) {
        return normalized;
      }
      return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
    };
    exports.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports.details = function(errors, options = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports.ValidationError;
      }
    };
    exports.ValidationError.prototype.isJoi = true;
    exports.ValidationError.prototype.name = "ValidationError";
    exports.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/joi/lib/ref.js
var require_ref = __commonJS({
  "node_modules/joi/lib/ref.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports.in = function(key, options = {}) {
      return exports.create(key, { ...options, in: true });
    };
    exports.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
      }
      _resolve(target, state, options) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = { path: this.path };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [...this.map];
        }
        for (const key of ["adjust", "iterables", "render"]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return { ref };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports.toSibling = 0;
    exports.toParent = 1;
    exports.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || require_template();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/joi/lib/template.js
var require_template = __commonJS({
  "node_modules/joi/lib/template.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Formula = require_lib2();
    var Common = require_common();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module.exports = exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options) {
          const { functions, ...opts } = options;
          this._settings = Object.keys(opts).length ? Clone(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date);
      }
      describe(options = {}) {
        if (!this._settings && options.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state, prefs, local);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state,
              prefs,
              local,
              options
              /*] */
            );
            const string = internals.stringify(rendered, value, state, prefs, local, options);
            if (string !== void 0) {
              const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = /* @__PURE__ */ __name((variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => {
            const resolved = ref.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        }, "reference");
        try {
          const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
          var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref = refs[0];
            return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string) {
      return string.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string) {
      return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string.length; ++i) {
        const char = string[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string.length && string[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state, prefs, local, options = {}) {
      const type = typeof value;
      const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
      }
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return internals.wrap(value, options.arrayItems && wrap.string);
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values = [];
      for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
      }
      return internals.wrap(values.join(", "), !skipWrap && wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code) {
        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local, options);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});

// node_modules/joi/lib/messages.js
var require_messages = __commonJS({
  "node_modules/joi/lib/messages.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports.decompile = function(messages) {
      const target = {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code] = message.describe({ compact: true });
          continue;
        }
        const language = code;
        target[language] = {};
        for (code in message) {
          const localized = message[code];
          if (code === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports.merge = function(base, extended) {
      if (!base) {
        return exports.compile(extended);
      }
      if (!extended) {
        return base;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/common.js
var require_common = __commonJS({
  "node_modules/joi/lib/common.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var AssertError = require_error();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports.version = Pkg.version;
    exports.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports.assertOptions = function(options, keys, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports.isIsoDate = function(date) {
      return internals.isoDate.test(date);
    };
    exports.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports.symbols.ref] || obj[exports.symbols.template];
    };
    exports.isSchema = function(schema2, options = {}) {
      const any = schema2 && schema2[exports.symbols.any];
      if (!any) {
        return false;
      }
      Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports.isValues = function(obj) {
      return obj[exports.symbols.values];
    };
    exports.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports.symbols.prefs];
      return merged;
    };
    exports.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports.validateArg = function(value, label, { assert, message }) {
      if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/joi/lib/cache.js
var require_cache = __commonJS({
  "node_modules/joi/lib/cache.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
    };
    exports.provider = {
      provision(options) {
        return new internals.Cache(options);
      }
    };
    internals.Cache = class {
      constructor(options = {}) {
        Common.assertOptions(options, ["max"]);
        Assert(options.max === void 0 || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
        this._max = options.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return Clone(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});

// node_modules/joi/lib/compile.js
var require_compile = __commonJS({
  "node_modules/joi/lib/compile.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.schema = function(Joi2, config, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config, options) {
      Assert(config !== void 0, "Invalid undefined schema");
      if (Array.isArray(config)) {
        Assert(config.length, "Invalid empty array schema");
        if (config.length === 1) {
          config = config[0];
        }
      }
      const valid = /* @__PURE__ */ __name((base, ...values) => {
        if (options.override !== false) {
          return base.valid(Joi2.override, ...values);
        }
        return base.valid(...values);
      }, "valid");
      if (internals.simple(config)) {
        return valid(Joi2, config);
      }
      if (typeof config === "function") {
        return Joi2.custom(config);
      }
      Assert(typeof config === "object", "Invalid schema content:", typeof config);
      if (Common.isResolvable(config)) {
        return valid(Joi2, config);
      }
      if (Common.isSchema(config)) {
        return config;
      }
      if (Array.isArray(config)) {
        for (const item of config) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config);
          }
        }
        return valid(Joi2, ...config);
      }
      if (config instanceof RegExp) {
        return Joi2.string().regex(config);
      }
      if (config instanceof Date) {
        return valid(Joi2.date(), config);
      }
      Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config);
    };
    exports.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports.compile = function(root, schema2, options = {}) {
      Common.assertOptions(options, ["legacy"]);
      const any = schema2 && schema2[Common.symbols.any];
      if (any) {
        Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema2;
      }
      if (typeof schema2 !== "object" || !options.legacy) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      const compiler = internals.walk(schema2);
      if (!compiler) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema2);
    };
    internals.walk = function(schema2) {
      if (typeof schema2 !== "object") {
        return null;
      }
      if (Array.isArray(schema2)) {
        for (const item of schema2) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any = schema2[Common.symbols.any];
      if (any) {
        return { root: schema2[any.root], compile: any.compile };
      }
      Assert(Object.getPrototypeOf(schema2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema2) {
        const compiler = internals.walk(schema2[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports.when = function(schema2, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema2, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema2.$_compile(rule2.is) : schema2.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema2, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema2.$_compile(test.is),
          then: schema2.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema2.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema2, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema2.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/joi/lib/extend.js
var require_extend = __commonJS({
  "node_modules/joi/lib/extend.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var internals = {};
    exports.type = function(from, options) {
      const base = Object.getPrototypeOf(from);
      const prototype = Clone(base);
      const schema2 = from._assign(Object.create(prototype));
      const def = Object.assign({}, options);
      delete def.base;
      prototype._definition = def;
      const parent = base._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema2.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema2.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema2.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = /* @__PURE__ */ __name(function() {
              return this.$_addRule(name);
            }, "method");
          }
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = /* @__PURE__ */ __name(function(arg) {
            return this.rule({ [name]: arg });
          }, "method");
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base;
        schema2.$_super = {};
        for (const override in def.overrides) {
          Assert(base[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base[override];
          schema2.$_super[override] = base[override].bind(schema2);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest = Object.assign({}, parent.manifest, def.manifest);
      manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema2;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema2) {
        parent(schema2);
        child(schema2);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});

// node_modules/joi/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/joi/lib/manifest.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var Ref = require_ref();
    var Template = require_template();
    var Schemas;
    var internals = {};
    exports.describe = function(schema2) {
      const def = schema2._definition;
      const desc = {
        type: schema2.type,
        flags: {},
        rules: []
      };
      for (const flag in schema2._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema2._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema2._preferences) {
        desc.preferences = Clone(schema2._preferences, { shallow: ["messages"] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema2._valids) {
        desc.allow = schema2._valids.describe();
      }
      if (schema2._invalids) {
        desc.invalid = schema2._invalids.describe();
      }
      for (const rule of schema2._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = { name: rule.name };
        for (const custom in def.modifiers) {
          if (rule[custom] !== void 0) {
            item[custom] = internals.describe(rule[custom]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, { assign: key });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema2.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema2.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [...items.entries()];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        Assert(def.terms[term], "Term", term, "missing configuration");
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from, to } = manifest.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from];
          }
          continue;
        }
        if (manifest === "single") {
          Assert(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema2.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return { special: "deep" };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options.assign === "options") {
        return Clone(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return { buffer: item.toString("binary") };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options.assign === "regex") {
          return item.toString();
        }
        return { regex: item.toString() };
      }
      if (item[Common.symbols.literal]) {
        return { function: item.literal };
      }
      if (typeof item.describe === "function") {
        if (options.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, { assign: key });
      }
      return normalized;
    };
    exports.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema2 = this.joi[desc.type]()._bare();
        const def = schema2._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            Assert(typeof schema2[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema2 = schema2[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema2 = schema2.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema2 = schema2.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema2 = schema2.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            Assert(typeof schema2[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], { assign: key });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema2 = schema2[rule.name](...args);
            const options = {};
            for (const custom in def.modifiers) {
              if (rule[custom] !== void 0) {
                options[custom] = this.build(rule[custom]);
              }
            }
            if (Object.keys(options).length) {
              schema2 = schema2.rule(options);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
            continue;
          }
          Assert(def.terms[key], "Term", key, "missing configuration");
          const manifest = def.terms[key].manifest;
          if (manifest === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema2 = def.manifest.build(schema2, terms);
        schema2.$_temp.ruleset = false;
        return schema2;
      }
      build(desc, options = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options.assign === "options") {
          return Clone(desc);
        }
        if (options.assign === "regex") {
          return internals.regex(desc);
        }
        if (options.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            Assert(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return { [Common.symbols.literal]: true, literal: desc.function };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return Clone(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], { assign: key });
        }
        return normalized;
      }
    };
    internals.regex = function(string) {
      const end = string.lastIndexOf("/");
      const exp = string.slice(1, end);
      const flags = string.slice(end + 1);
      return new RegExp(exp, flags);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas();
      joi.assert(desc, Schemas.description);
    };
  }
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS({
  "node_modules/@hapi/hoek/lib/deepEqual.js"(exports, module) {
    "use strict";
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module.exports = function(obj, ref, options) {
      options = Object.assign({ prototype: true }, options);
      return !!internals.isDeepEqual(obj, ref, options, []);
    };
    internals.isDeepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
          return obj === ref;
        case Types.regex:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i = 0; i < obj.length; ++i) {
            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options.skip && options.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      if (!options.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options.skip || !options.skip.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});

// node_modules/@sideway/pinpoint/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@sideway/pinpoint/lib/index.js"(exports) {
    "use strict";
    exports.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});

// node_modules/joi/lib/trace.js
var require_trace = __commonJS({
  "node_modules/joi/lib/trace.js"(exports) {
    "use strict";
    var DeepEqual = require_deepEqual();
    var Pinpoint = require_lib3();
    var Errors = require_errors();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports.setup = function(root) {
      const trace = /* @__PURE__ */ __name(function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      }, "trace");
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports.location = function(schema2) {
      return schema2.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema2) {
        const existing = this._schemas.get(schema2);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema2);
        const { filename, line } = schema2._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema2, { filename, line, store });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file && file !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema2, log] of store._sources.entries()) {
            if (internals.sub(log.paths, skipped)) {
              continue;
            }
            if (!log.entry) {
              missing.push({
                status: "never reached",
                paths: [...log.paths]
              });
              skipped.push(...log.paths);
              continue;
            }
            for (const type of ["valid", "invalid"]) {
              const set = schema2[`_${type}s`];
              if (!set) {
                continue;
              }
              const values = new Set(set._values);
              const refs = new Set(set._refs);
              for (const { value, ref } of log[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [...values, ...[...refs].map((ref) => ref.display)],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema2._rules.map((rule) => rule.name);
            for (const type of ["default", "failover"]) {
              if (schema2._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log.rule[name] || 0];
              if (status) {
                const report = { rule: name, status };
                if (log.paths.size) {
                  report.paths = [...log.paths];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema2) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema2);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
      }
      entry(schema2, state) {
        internals.debug(state, { type: "entry" });
        this._record(schema2, (log) => {
          log.entry = true;
        });
      }
      filter(schema2, state, source, value) {
        internals.debug(state, { type: source, ...value });
        this._record(schema2, (log) => {
          log[source].add(value);
        });
      }
      log(schema2, state, source, name, result) {
        internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
        this._record(schema2, (log) => {
          log[source][name] = log[source][name] || 0;
          log[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log = { type: "resolve", ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
      }
      value(state, by, from, to, name) {
        if (!state.mainstay.debug || DeepEqual(from, to)) {
          return;
        }
        const log = { type: "value", by, from, to, path: state.path };
        if (name) {
          log.name = name;
        }
        state.mainstay.debug.push(log);
      }
      _record(schema2, each) {
        const log = this._sources.get(schema2);
        if (log) {
          each(log);
          return;
        }
        const sources = this._combos.get(schema2);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema2, _path) {
        const path = _path || [];
        let log = this._sources.get(schema2);
        if (!log) {
          log = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema2, log);
        }
        if (path.length) {
          log.paths.add(path);
        }
        const each = /* @__PURE__ */ __name((sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path.concat(subId));
        }, "each");
        schema2.$_modify({ each, ref: false });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema2, { source, name, path, key }) {
      if (schema2._flags.id) {
        return schema2._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [name, path[Math.min(path.length - 1, 1)]];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path of paths) {
        for (const skip of skipped) {
          if (DeepEqual(path.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS({
  "node_modules/@hapi/hoek/lib/merge.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module.exports = internals.merge = function(target, source, options) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options.mergeArrays) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(Clone(source[i], { symbols: options.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options.symbols });
          } else {
            internals.merge(target[key], value, options);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/modify.js
var require_modify = __commonJS({
  "node_modules/joi/lib/modify.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        if (!node) {
          return [...behind, ...path].join(".");
        }
        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema2, { key } = {}) {
        if (!schema2 || !Common.isSchema(schema2)) {
          return;
        }
        if (schema2.$_property("schemaChain") || schema2._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema2._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema2, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema: schema2, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema: schema2, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        nodes = [node, ...nodes];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema2, id, replacement) {
      const each = /* @__PURE__ */ __name((item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      }, "each");
      const obj = exports.schema(schema2, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema2;
    };
    exports.schema = function(schema2, options) {
      let obj;
      for (const name in schema2._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema2._rules.length; ++i) {
        const rule = schema2._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          const clone = Object.assign({}, rule);
          clone.args = result;
          obj._rules[i] = clone;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone);
          }
        }
      }
      for (const name in schema2.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.source === "terms" && source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone = clone || item.slice();
            clone[i] = result;
          }
        }
        return clone;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone = clone || Object.assign({}, item);
          clone[key] = result;
        }
      }
      return clone;
    };
  }
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS({
  "node_modules/@hapi/hoek/lib/ignore.js"(exports, module) {
    "use strict";
    module.exports = function() {
    };
  }
});

// node_modules/joi/lib/state.js
var require_state = __commonJS({
  "node_modules/joi/lib/state.js"(exports, module) {
    "use strict";
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path, ancestors = null, schema2 = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema2 && state.schemas) {
          state.schemas = [internals.schemas(schema2), ...state.schemas];
        }
        return state;
      }
      nest(schema2, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema2), ...state.schemas];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
        this.mainstay.snapshot();
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.restore();
      }
      commit() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.commit();
      }
    };
    internals.schemas = function(schema2) {
      if (Common.isSchema(schema2)) {
        return { schema: schema2 };
      }
      return schema2;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
          const segment = path[i];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, { iterables: true });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/joi/lib/validator.js
var require_validator = __commonJS({
  "node_modules/joi/lib/validator.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Ignore = require_ignore();
    var Reach = require_reach();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports.entry = function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        Assert(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        Assert(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports.entryAsync = async function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
          const path = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node = root;
          let key;
          let parent;
          const ancestors = path.length ? [root] : [];
          const original = path.length ? Reach(value, path) : value;
          if (path.length) {
            key = path[path.length - 1];
            let current = root;
            for (const segment of path.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node = parent[key];
          }
          try {
            const createError = /* @__PURE__ */ __name((code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings), "createError");
            const output = await external.method(node, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),
              message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages })
            });
            if (output === void 0 || output === node) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors.length) {
          result.error = Errors.process(errors, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema2, prefs) {
      const { tracer, cleanup } = internals.tracer(schema2, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema2._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas = schema2._ids._schemaChain ? [{ schema: schema2 }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports.validate(value, schema2, state, prefs);
      if (cleanup) {
        schema2.$_root.untrace();
      }
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    internals.tracer = function(schema2, prefs) {
      if (schema2.$_root._tracer) {
        return { tracer: schema2.$_root._tracer._register(schema2) };
      }
      if (prefs.debug) {
        Assert(schema2.$_root.trace, "Debug mode not supported");
        return { tracer: schema2.$_root.trace()._register(schema2), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports.validate = function(value, schema2, state, prefs, overrides = {}) {
      if (schema2.$_terms.whens) {
        schema2 = schema2._generate(value, state, prefs).schema;
      }
      if (schema2._preferences) {
        prefs = internals.prefs(schema2, prefs);
      }
      if (schema2._cache && prefs.cache) {
        const result = schema2._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = /* @__PURE__ */ __name((code, local, localState) => schema2.$_createError(code, value, local, localState || state, prefs), "createError");
      const helpers = {
        original: value,
        prefs,
        schema: schema2,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema2.$_createError("custom", value, local, state, prefs, { messages })
      };
      state.mainstay.tracer.entry(schema2, state);
      const def = schema2._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty = schema2._flags.empty;
      if (empty && empty.$_match(internals.trim(value, schema2), state.nest(empty), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema2._flags.presence || (schema2._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema2.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema2._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema2.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema2._valids) {
        const match = schema2._valids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema2, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema2._flags.only) {
          const report = schema2.$_createError("any.only", value, { valids: schema2._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema2._invalids) {
        const match = schema2._invalids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema2, state, "invalid", match);
          const report = schema2.$_createError("any.invalid", value, { invalids: schema2._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
          state.mainstay.tracer.value(state, "base", value, base.value);
          value = base.value;
          if (base.errors) {
            if (!Array.isArray(base.errors)) {
              errors.push(base.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base.errors.length) {
              errors.push(...base.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema2._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      for (const rule of schema2._rules) {
        const definition = schema2._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema2.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema: schema2, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema2._flags.error) {
        if (typeof schema2._flags.error === "function") {
          errors = schema2._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema2._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema2._flags.cast && value !== void 0) {
        const caster = schema2._definition.cast[schema2._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema2._flags.cast);
          value = casted;
        }
      }
      if (schema2.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema2.$_terms.externals) {
          state.mainstay.externals.push({ method, schema: schema2, state, label: Errors.label(schema2._flags, state, prefs) });
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema2._flags.result) {
        result.value = schema2._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.mainstay.tracer.value(state, schema2._flags.result, value, result.value);
        state.shadow(value, schema2._flags.result);
      }
      if (schema2._cache && prefs.cache !== false && !schema2._refs.length) {
        schema2._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema2._flags.artifact !== void 0) {
        state.mainstay.artifacts = state.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state.mainstay.artifacts.has(schema2._flags.artifact)) {
          state.mainstay.artifacts.set(schema2._flags.artifact, []);
        }
        state.mainstay.artifacts.get(schema2._flags.artifact).push(state.path);
      }
      return result;
    };
    internals.prefs = function(schema2, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema2._preferences[Common.symbols.prefs]) {
        return schema2._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema2._preferences);
      if (isDefaultOptions) {
        schema2._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      const source = schema2._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema2, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema2.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema2) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema2.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: Ignore,
      entry: Ignore,
      filter: Ignore,
      log: Ignore,
      resolve: Ignore,
      value: Ignore
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/joi/lib/values.js
var require_values = __commonJS({
  "node_modules/joi/lib/values.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options) {
        if (options && options.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({ override: true });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? { value } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from) {
      const map = /* @__PURE__ */ new Map();
      if (from) {
        for (const value of from) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});

// node_modules/joi/lib/base.js
var require_base = __commonJS({
  "node_modules/joi/lib/base.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Trace = require_trace();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._reset();
      }
      _reset() {
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          // Runtime state (not cloned)
          ruleset: null,
          // null: use last, false: error, number: start position
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Manifest
      describe() {
        Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({ target, adjuster });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      artifact(id) {
        Assert(id !== void 0, "Artifact cannot be undefined");
        Assert(!this._cache, "Cannot set an artifact with a rule cache");
        return this.$_setFlag("artifact", id);
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options) {
        return this._default("default", value, options);
      }
      description(desc) {
        Assert(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema2) {
        const obj = this.clone();
        if (schema2 !== void 0) {
          schema2 = obj.$_compile(schema2, { override: false });
        }
        return obj.$_setFlag("empty", schema2, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options = {}) {
        Assert(example !== void 0, "Missing example");
        Common.assertOptions(options, ["override"]);
        return this._inner("examples", example, { single: true, override: options.override });
      }
      external(method, description) {
        if (typeof method === "object") {
          Assert(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        Assert(typeof method === "function", "Method must be a function");
        Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", { method, description }, { single: true });
      }
      failover(value, options) {
        return this._default("failover", value, options);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        Assert(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        Assert(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, { single: true });
      }
      note(...notes) {
        Assert(notes.length, "Missing notes");
        for (const note of notes) {
          Assert(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Assert(prefs.externals === void 0, "Cannot override externals");
        Assert(prefs.warnings === void 0, "Cannot override warnings");
        Assert(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled = true) {
        return this.$_setFlag("result", enabled ? "raw" : void 0);
      }
      result(mode) {
        Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled) {
        const obj = this.clone();
        const convert = enabled === void 0 ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled = true) {
        return this.$_setFlag("result", enabled ? "strip" : void 0);
      }
      tag(...tags) {
        Assert(tags.length, "Missing tags");
        for (const tag of tags) {
          Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        Assert(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      cache(cache) {
        Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
        Assert(!this._cache, "Cannot override schema cache");
        Assert(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, source]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options) {
        Assert(!options.base, "Cannot extend type with another base");
        return Extend.type(this, options);
      }
      extract(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.reach(path);
      }
      fork(paths, adjuster) {
        Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path of [].concat(paths)) {
          path = Array.isArray(path) ? path : path.split(".");
          obj = obj._ids.fork(path, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      rule(options) {
        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));
        Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i = start; i < obj._rules.length; ++i) {
          const original = obj._rules[i];
          const rule = Clone(original);
          for (const name in options) {
            def.modifiers[name](rule, options[name]);
            Assert(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options) {
        return Validator.entry(value, this, options);
      }
      validateAsync(value, options) {
        return Validator.entryAsync(value, this, options);
      }
      // Extensions
      $_addRule(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        Assert(options && typeof options === "object", "Invalid options");
        Assert(options.name && typeof options.name === "string", "Invalid rule name");
        for (const key in options) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, { clone: false });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema2, options) {
        return Compile.schema(this.$_root, schema2, options);
      }
      $_createError(code, value, local, state, prefs, options = {}) {
        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.labels(path);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options) {
        Common.assertOptions(options, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options) || this;
      }
      $_mutateRebuild() {
        Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = /* @__PURE__ */ __name((item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        }, "each");
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema2, { family, key } = {}) {
        this._refs.register(schema2, family);
        this._ids.register(schema2, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options = {}) {
        Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _bare() {
        const obj = this.clone();
        obj._reset();
        const terms = obj._definition.terms;
        for (const name in terms) {
          const term = terms[name];
          obj.$_terms[name] = term.init;
        }
        return obj.$_mutateRebuild();
      }
      _default(flag, value, options = {}) {
        Common.assertOptions(options, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
        if (typeof value === "function" && options.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
          const when = this.$_terms.whens[i];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return { schema: this };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, ...whens]);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _inner(type, values, options = {}) {
        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options.override) {
          obj.$_terms[type] = [];
        }
        if (options.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
          const test = obj._rules[i];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module.exports = new internals.Base();
  }
});

// node_modules/joi/lib/types/any.js
var require_any = __commonJS({
  "node_modules/joi/lib/types/any.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    var Messages = require_messages();
    module.exports = Base.extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema2) {
            Assert(Common.isSchema(schema2) && schema2._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema2);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        warning: {
          method(code, local) {
            Assert(code && typeof code === "string", "Invalid warning code");
            return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
          },
          validate(value, helpers, { code, local }) {
            return helpers.error(code, local);
          },
          args: ["code", "local"],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled = true) {
          rule.keep = enabled;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled = true) {
          rule.warn = enabled;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat } = value;
                if (concat) {
                  obj = obj.concat(concat);
                } else if (ref) {
                  obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                } else {
                  obj = obj.when(is, { then, otherwise, break: value.break });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/joi/lib/types/alternatives.js
var require_alternatives = __commonJS({
  "node_modules/joi/lib/types/alternatives.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Merge = require_merge();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema2, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema2.try(...schemas[0]);
          }
        }
        return schema2.try(...schemas);
      },
      validate(value, helpers) {
        const { schema: schema2, error, state, prefs } = helpers;
        if (schema2._flags.match) {
          const matched = [];
          const failed = [];
          for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
            const item = schema2.$_terms.matches[i];
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              matched.push(result.value);
              localState.commit();
            } else {
              failed.push(result.errors);
              localState.restore();
            }
          }
          if (matched.length === 0) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.any", context) };
          }
          if (schema2._flags.match === "one") {
            return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
          }
          if (matched.length !== schema2.$_terms.matches.length) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.all", context) };
          }
          const isAnyObj = /* @__PURE__ */ __name((alternative) => {
            return alternative.$_terms.matches.some((v) => {
              return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
            });
          }, "isAnyObj");
          return isAnyObj(schema2) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }
        const errors = [];
        for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
          const item = schema2.$_terms.matches[i];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              localState.commit();
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema2 of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema2) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_parent("label", name);
          const each = /* @__PURE__ */ __name((item, source) => {
            return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
          }, "each");
          return obj.$_modify({ each, ref: false });
        }
      },
      rebuild(schema2) {
        const each = /* @__PURE__ */ __name((item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema2.$_setFlag("_arrayItems", true, { clone: false });
          }
        }, "each");
        schema2.$_modify({ each });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema: schema2, ref, is, not, then, otherwise } = match;
              if (schema2) {
                obj = obj.try(schema2);
              } else if (ref) {
                obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
              } else {
                obj = obj.conditional(is, { then, otherwise });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema: schema2 } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema2.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code] = report.code.split(".");
        if (code !== "base") {
          complex.push({ type: schema2.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});

// node_modules/joi/lib/types/array.js
var require_array = __commonJS({
  "node_modules/joi/lib/types/array.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module.exports = Any.extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [], manifest: "schema" },
        ordered: { init: [], manifest: "schema" },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema: schema2, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema2.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema2, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema: schema2, error }) {
        if (!Array.isArray(value)) {
          if (schema2._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema2.$_getRule("items") && !schema2.$_terms.externals) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema2) {
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema: schema2 } });
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has }) {
            const ancestors = [value, ...state.ancestors];
            for (let i = 0; i < value.length; ++i) {
              const localState = state.localize([...state.path, i], ancestors, has);
              if (has.$_match(value[i], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has._flags.label;
            if (patternLabel) {
              return error("array.hasKnown", { patternLabel });
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema: schema2, error, state, prefs, errorsArray }) {
            const requireds = schema2.$_terms._requireds.slice();
            const ordereds = schema2.$_terms.ordered.slice();
            const inclusions = [...schema2.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i = 0; i < il; ++i) {
              const item = value[i];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i : new Number(i);
              const path = [...state.path, key];
              if (!schema2._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema2.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema2.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema2.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i, limit: schema2.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  localState.commit();
                  value[i] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema2._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    localState.commit();
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if ((schema2.$_terms._inclusions.length || schema2.$_terms._requireds.length) && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema2, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema2, errors, ordereds, value, state, prefs);
              if (!errors.length) {
                internals.fillDefault(ordereds, value, state, prefs);
              }
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options = {}) {
            Common.assertOptions(options, ["by", "order"]);
            const settings = {
              order: options.order || "ascending"
            };
            if (options.by) {
              settings.by = Compile.ref(options.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema: schema2 }, { options }) {
            const { value: sorted, errors } = internals.sort(schema2, value, options, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i = 0; i < value.length; ++i) {
              if (value[i] !== sorted[i]) {
                return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema: schema2 }, { comparator: raw, options }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options.ignoreUndefined;
            for (let i = 0; i < value.length; ++i) {
              const item = path ? Reach(value[i], path) : value[i];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema2) {
        schema2.$_terms._inclusions = [];
        schema2.$_terms._exclusions = [];
        schema2.$_terms._requireds = [];
        for (const type of schema2.$_terms.items) {
          internals.validateSingle(type, schema2);
          if (type._flags.presence === "required") {
            schema2.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema2.$_terms._exclusions.push(type);
          } else {
            schema2.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema2.$_terms.ordered) {
          internals.validateSingle(type, schema2);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema2, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema2.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
        } else {
          errors.push(schema2.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
        }
      } else {
        errors.push(schema2.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema2, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema2, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fillDefault = function(ordereds, value, state, prefs) {
      const overrides = [];
      let trailingUndefined = true;
      for (let i = ordereds.length - 1; i >= 0; --i) {
        const ordered = ordereds[i];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(void 0, state.localize(state.path, ancestors, ordered), prefs).value;
        if (trailingUndefined) {
          if (override === void 0) {
            continue;
          }
          trailingUndefined = false;
        }
        overrides.unshift(override);
      }
      if (overrides.length) {
        value.push(...overrides);
      }
    };
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema2, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = /* @__PURE__ */ __name((a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema2.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema2.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      }, "sort");
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/joi/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/joi/lib/types/boolean.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema: schema2 }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema2._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema2.$_terms.truthy && schema2.$_terms.truthy.has(value, null, null, !schema2._flags.sensitive) || (schema2.$_terms.falsy && schema2.$_terms.falsy.has(value, null, null, !schema2._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled = true) {
            return this.$_setFlag("sensitive", enabled);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/joi/lib/types/date.js
var require_date = __commonJS({
  "node_modules/joi/lib/types/date.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module.exports = Any.extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema: schema2 }) {
          return { value: internals.parse(value, schema2._flags.format) || value };
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format = schema2._flags.format;
        if (!prefs.convert || !format || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date }, { name, operator, args }) {
            const to = date === "now" ? Date.now() : date.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date) => {
                return date === "now" ? date : internals.parse(date);
              },
              assert: (date) => date !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format) {
            Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
            return this.$_setFlag("format", format);
          }
        },
        greater: {
          method(date) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date) {
            return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
          }
        },
        max: {
          method(date) {
            return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
          }
        },
        min: {
          method(date) {
            return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
        // Messages used in date.format
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format) {
        if (format === "javascript") {
          return internals.date(1 * value);
        }
        if (format === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date;
      }
      return null;
    };
  }
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS({
  "node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module.exports = function(defaults, source, options = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
      }
      const copy = Clone(defaults);
      if (source === true) {
        return copy;
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options) {
      const keys = options.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge && Reach(source, key) || ref);
        } else if (merge) {
          merge.add(key);
        }
      }
      const copy = Clone(defaults, {}, seen);
      if (!merge) {
        return copy;
      }
      for (const key of merge) {
        internals.reachCopy(copy, source, key);
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src, path) {
      for (const segment of path) {
        if (!(segment in src)) {
          return;
        }
        const val = src[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src = val;
      }
      const value = src;
      let ref = dst;
      for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path[path.length - 1]] = value;
    };
  }
});

// node_modules/@hapi/topo/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@hapi/topo/lib/index.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    exports.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options) {
        options = options || {};
        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || "?";
        const sort = options.sort || 0;
        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes("?"), "Item cannot come before unassociated items");
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options.manual) {
          const valid = this._sort();
          Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [others];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
          this._items[i].seq = i;
        }
        const valid = this._sort();
        Assert(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        Assert(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] || [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] || [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] || [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] || [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i = 0; i < this._items.length; ++i) {
          let next = i;
          if (ancestors[i]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// node_modules/joi/lib/types/keys.js
var require_keys = __commonJS({
  "node_modules/joi/lib/types/keys.js"(exports, module) {
    "use strict";
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib4();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var Template = require_template();
    var internals = {
      renameDefaults: {
        alias: false,
        // Keep old value in place
        multiple: false,
        // Allow renaming multiple keys into the same target
        override: false
        // Overrides an existing key
      }
    };
    module.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema2, keys) {
        return schema2.keys(keys);
      },
      validate(value, { schema: schema2, error, state, prefs }) {
        if (!value || typeof value !== schema2.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema2.$_property("typeof") }) };
        }
        if (!schema2.$_terms.renames && !schema2.$_terms.dependencies && !schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema2.$_terms.renames && !internals.rename(schema2, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema2.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema2.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              if (result.value !== void 0) {
                value[key] = result.value;
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema2._flags._hasPatternMatch) {
          const early = internals.unknown(schema2, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema2.$_terms.dependencies) {
          for (const dep of schema2.$_terms.dependencies) {
            if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema2, dep, value, state, prefs);
            if (failed) {
              const report = schema2.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema2) {
            if (schema2 === null || schema2 === void 0 || Object.keys(schema2).length === 0) {
              return this;
            }
            return this.keys(schema2);
          }
        },
        assert: {
          method(subject, schema2, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema: schema2, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema: schema2, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema2.$_match(about, state.localize(path, [value, ...state.ancestors], schema2), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema2) {
            Assert(schema2 === void 0 || typeof schema2 === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema2), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema2) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema2).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema2.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema2) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema2[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema2, options = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema2 !== void 0, "Invalid rule");
            Common.assertOptions(options, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema2 };
            if (options.matches) {
              config.matches = this.$_compile(options.matches);
              if (config.matches.type !== "array") {
                config.matches = config.matches.$_root.array().items(config.matches);
              }
              obj.$_mutateRegister(config.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options.fallthrough) {
              config.fallthrough = true;
            }
            obj.$_terms.patterns.push(config);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from, to, options = {}) {
            Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            Assert(to !== from, "Cannot rename key to same name:", from);
            Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "with", key, peers, options);
          }
        },
        without: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "without", key, peers, options);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options);
        }
      },
      rebuild(schema2) {
        if (schema2.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema2.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema2.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema: schema2, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema2, rule, { fallthrough, matches });
            }
          }
          if (desc.renames) {
            for (const { from, to, options } of desc.renames) {
              obj = obj.rename(from, to, options);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone2 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone2, value);
        return clone2;
      }
      const clone = /* @__PURE__ */ __name(function(...args) {
        return value.apply(this, args);
      }, "clone");
      clone.prototype = Clone(value.prototype);
      Object.defineProperty(clone, "name", { value: value.name, writable: false });
      Object.defineProperty(clone, "length", { value: value.length, writable: false });
      Object.assign(clone, value);
      return clone;
    };
    internals.dependency = function(schema2, rel, key, peers, options) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options, ["separator", "isPresent"]);
      peers = [].concat(peers);
      const separator = Common.default(options.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be strings");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema2.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
      return obj;
    };
    internals.dependencies = {
      and(schema2, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema2, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema2, missing)
            }
          };
        }
      },
      nand(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema2, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema2, values)
          }
        };
      },
      or(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema2, dep.paths)
          }
        };
      },
      oxor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.oxor", context };
      },
      with(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      without(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      xor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.xor", context };
      }
    };
    internals.keysToLabels = function(schema2, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema2.$_mapLabels(key));
      }
      return schema2.$_mapLabels(keys);
    };
    internals.isPresent = function(options) {
      return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== void 0;
    };
    internals.rename = function(schema2, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema2.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from in value) {
            if (value[from] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from === rename.to) {
              continue;
            }
            const match = rename.from.exec(from);
            if (!match) {
              continue;
            }
            matches.push({ from, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema2.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema2.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema2, value, unprocessed, errors, state, prefs) {
      if (schema2.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema2.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [...state.path, key];
          for (let i = 0; i < schema2.$_terms.patterns.length; ++i) {
            const pattern = schema2.$_terms.patterns[i];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i = 0; i < matches.length; ++i) {
            const match = matches[i];
            if (!match) {
              continue;
            }
            const stpm = schema2.$_terms.patterns[i].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema2.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema2.$_terms.keys && !schema2.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema2._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema2._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema2.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths, options) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = { ...desc.options, separator: this.peers[0].separator };
        }
        if (this.options.isPresent) {
          desc.options = { ...desc.options, isPresent: this.options.isPresent };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i = 0; i < result.length; ++i) {
          keys.set(result[i].key, i);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/joi/lib/types/function.js
var require_function = __commonJS({
  "node_modules/joi/lib/types/function.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/joi/lib/types/link.js
var require_link = __commonJS({
  "node_modules/joi/lib/types/link.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, manifest: "single", register: false }
      },
      args(schema2, ref) {
        return schema2.ref(ref);
      },
      validate(value, { schema: schema2, state, prefs }) {
        Assert(schema2.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema2, value, state, prefs);
        const ref = schema2.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema2, value, state, prefs) {
        return internals.generate(schema2, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled = true) {
            return this.$_setFlag("relative", enabled);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          Assert(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema2, value, state, prefs) {
      let linked = state.mainstay.links.get(schema2);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema2.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema2, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema2, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema2, state, prefs);
      if (!schema2._flags.relative) {
        state.mainstay.links.set(schema2, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema: schema2, key } of state.schemas) {
          const id = schema2._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema2, path: ref.path.slice(1) };
          }
          if (schema2.$_terms.shared) {
            for (const shared of schema2.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema2, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema2._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/joi/lib/types/number.js
var require_number = __commonJS({
  "node_modules/joi/lib/types/number.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
      exponentialPartRegex: /[eE][+-]?\d+$/,
      leadingSignAndZerosRegex: /^[+-]?(0*)?/,
      dotRegex: /\./,
      trailingZerosRegex: /0+$/,
      decimalPlaces(value) {
        const str = value.toString();
        const dindex = str.indexOf(".");
        const eindex = str.indexOf("e");
        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
      }
    };
    module.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema2._flags.unsafe) {
            if (value.match(/e/i)) {
              if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string = result.value.toString();
              if (string.match(/e/i)) {
                return result;
              }
              if (string !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema2.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema2._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base) {
            const baseDecimalPlace = typeof base === "number" ? internals.decimalPlaces(base) : null;
            const pfactor = Math.pow(10, baseDecimalPlace);
            return this.$_addRule({
              name: "multiple",
              args: {
                base,
                baseDecimalPlace,
                pfactor
              }
            });
          },
          validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {
            const valueDecimalPlace = internals.decimalPlaces(value);
            if (valueDecimalPlace > baseDecimalPlace) {
              return helpers.error("number.multiple", { multiple: options.args.base, value });
            }
            return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ? value : helpers.error("number.multiple", { multiple: options.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            },
            "baseDecimalPlace",
            "pfactor"
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign) {
            Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
            return this.$_addRule({ name: "sign", args: { sign } });
          },
          validate(value, helpers, { sign }) {
            if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign}`);
          }
        },
        unsafe: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.extractSignificantDigits = function(value) {
      return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/joi/lib/types/object.js
var require_object = __commonJS({
  "node_modules/joi/lib/types/object.js"(exports, module) {
    "use strict";
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/@sideway/address/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/@sideway/address/lib/errors.js"(exports) {
    "use strict";
    exports.codes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    exports.code = function(code) {
      return { code, error: exports.codes[code] };
    };
  }
});

// node_modules/@sideway/address/lib/domain.js
var require_domain = __commonJS({
  "node_modules/@sideway/address/lib/domain.js"(exports) {
    "use strict";
    var Url = __require("url");
    var Errors = require_errors2();
    var internals = {
      minDomainSegments: 2,
      nonAsciiRx: /[^\x00-\x7f]/,
      domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
      // Control + space + separators
      tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      URL: Url.URL || URL
      // $lab:coverage:ignore$
    };
    exports.analyze = function(domain, options = {}) {
      if (!domain) {
        return Errors.code("DOMAIN_NON_EMPTY_STRING");
      }
      if (typeof domain !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (domain.length > 256) {
        return Errors.code("DOMAIN_TOO_LONG");
      }
      const ascii = !internals.nonAsciiRx.test(domain);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain = domain.normalize("NFC");
      }
      if (internals.domainControlRx.test(domain)) {
        return Errors.code("DOMAIN_INVALID_CHARS");
      }
      domain = internals.punycode(domain);
      if (options.allowFullyQualified && domain[domain.length - 1] === ".") {
        domain = domain.slice(0, -1);
      }
      const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
      const segments = domain.split(".");
      if (segments.length < minDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT");
      }
      if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
          return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds = options.tlds;
      if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
          return Errors.code("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return Errors.code("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return Errors.code("DOMAIN_LONG_SEGMENT");
        }
        if (i < segments.length - 1) {
          if (!internals.domainSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_CHARS");
          }
        } else {
          if (!internals.tldSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    };
    exports.isValid = function(domain, options) {
      return !exports.analyze(domain, options);
    };
    internals.punycode = function(domain) {
      if (domain.includes("%")) {
        domain = domain.replace(/%/g, "%25");
      }
      try {
        return new internals.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});

// node_modules/@sideway/address/lib/email.js
var require_email = __commonJS({
  "node_modules/@sideway/address/lib/email.js"(exports) {
    "use strict";
    var Util = __require("util");
    var Domain = require_domain();
    var Errors = require_errors2();
    var internals = {
      nonAsciiRx: /[^\x00-\x7f]/,
      encoder: new (Util.TextEncoder || TextEncoder)()
      // $lab:coverage:ignore$
    };
    exports.analyze = function(email, options) {
      return internals.email(email, options);
    };
    exports.isValid = function(email, options) {
      return !internals.email(email, options);
    };
    internals.email = function(email, options = {}) {
      if (typeof email !== "string") {
        throw new Error("Invalid input: email must be a string");
      }
      if (!email) {
        return Errors.code("EMPTY_STRING");
      }
      const ascii = !internals.nonAsciiRx.test(email);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("FORBIDDEN_UNICODE");
        }
        email = email.normalize("NFC");
      }
      const parts = email.split("@");
      if (parts.length !== 2) {
        return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
      }
      const [local, domain] = parts;
      if (!local) {
        return Errors.code("EMPTY_LOCAL");
      }
      if (!options.ignoreLength) {
        if (email.length > 254) {
          return Errors.code("ADDRESS_TOO_LONG");
        }
        if (internals.encoder.encode(local).length > 64) {
          return Errors.code("LOCAL_TOO_LONG");
        }
      }
      return internals.local(local, ascii) || Domain.analyze(domain, options);
    };
    internals.local = function(local, ascii) {
      const segments = local.split(".");
      for (const segment of segments) {
        if (!segment.length) {
          return Errors.code("EMPTY_LOCAL_SEGMENT");
        }
        if (ascii) {
          if (!internals.atextRx.test(segment)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
          continue;
        }
        for (const char of segment) {
          if (internals.atextRx.test(char)) {
            continue;
          }
          const binary = internals.binary(char);
          if (!internals.atomRx.test(binary)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
        }
      }
    };
    internals.binary = function(char) {
      return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
    };
    internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    internals.atomRx = new RegExp([
      //  %xC2-DF UTF8-tail
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeRegex.js"(exports, module) {
    "use strict";
    module.exports = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});

// node_modules/@sideway/address/lib/uri.js
var require_uri = __commonJS({
  "node_modules/@sideway/address/lib/uri.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var internals = {};
    internals.generate = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
      rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
      const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
      const port = "\\d*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
      rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
      rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
      rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
      rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      return rfc3986;
    };
    internals.rfc3986 = internals.generate();
    exports.ip = {
      v4Cidr: internals.rfc3986.ipv4Cidr,
      v6Cidr: internals.rfc3986.ipv6Cidr,
      ipv4: internals.rfc3986.ipv4address,
      ipv6: internals.rfc3986.ipv6address,
      ipvfuture: internals.rfc3986.ipvFuture
    };
    internals.createRegex = function(options) {
      const rfc = internals.rfc3986;
      const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
      const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
      const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
      if (options.relativeOnly) {
        return internals.wrap(relative + suffix);
      }
      let customScheme = "";
      if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
          const scheme2 = schemes[i];
          Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
          if (scheme2 instanceof RegExp) {
            selections.push(scheme2.source.toString());
          } else {
            Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
            selections.push(EscapeRegex(scheme2));
          }
        }
        customScheme = selections.join("|");
      }
      const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
      const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
      const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
      return internals.wrap(prefix + suffix, customScheme);
    };
    internals.wrap = function(raw, scheme) {
      raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
      return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
      };
    };
    internals.uriRegex = internals.createRegex({});
    exports.regex = function(options = {}) {
      if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
        return internals.createRegex(options);
      }
      return internals.uriRegex;
    };
  }
});

// node_modules/@sideway/address/lib/ip.js
var require_ip = __commonJS({
  "node_modules/@sideway/address/lib/ip.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Uri = require_uri();
    exports.regex = function(options = {}) {
      Assert(options.cidr === void 0 || typeof options.cidr === "string", "options.cidr must be a string");
      const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
      Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
      Assert(options.version === void 0 || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
      let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      Assert(versions.length >= 1, "options.version must have at least 1 version specified");
      for (let i = 0; i < versions.length; ++i) {
        Assert(typeof versions[i] === "string", "options.version must only contain strings");
        versions[i] = versions[i].toLowerCase();
        Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
      }
      versions = Array.from(new Set(versions));
      const parts = versions.map((version) => {
        if (cidr === "forbidden") {
          return Uri.ip[version];
        }
        const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
        if (cidr === "required") {
          return `${Uri.ip[version]}${cidrpart}`;
        }
        return `${Uri.ip[version]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      const regex = new RegExp(`^${raw}$`);
      return { cidr, versions, regex, raw };
    };
  }
});

// node_modules/@sideway/address/lib/tlds.js
var require_tlds = __commonJS({
  "node_modules/@sideway/address/lib/tlds.js"(exports, module) {
    "use strict";
    var internals = {};
    internals.tlds = [
      "AAA",
      "AARP",
      "ABARTH",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADAC",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALFAROMEO",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMAZON",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AVIANCA",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BANANAREPUBLIC",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BENTLEY",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUGATTI",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANCERRESEARCH",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CASA",
      "CASE",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CBS",
      "CC",
      "CD",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CITYEATS",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMCAST",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOKINGCHANNEL",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CPA",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DABUR",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ET",
      "ETISALAT",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIAT",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOODNETWORK",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTDOOR",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUARDIAN",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HGTV",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELES",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYLOGISTICS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIM",
      "KINDER",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LAMBORGHINI",
      "LAMER",
      "LANCASTER",
      "LANCIA",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINDE",
      "LINK",
      "LIPSY",
      "LIVE",
      "LIVING",
      "LK",
      "LLC",
      "LLP",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOFT",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MACYS",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MASERATI",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUSIC",
      "MUTUAL",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NAGOYA",
      "NAME",
      "NATURA",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTHWESTERNMUTUAL",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLDNAVY",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PASSAGENS",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAMERICA",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "RACING",
      "RADIO",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDSTONE",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIL",
      "RIO",
      "RIP",
      "RO",
      "ROCHER",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCA",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHAW",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SHOWTIME",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPA",
      "SPACE",
      "SPORT",
      "SPOT",
      "SR",
      "SRL",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIFFANY",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELCHANNEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLKSWAGEN",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "VUELOS",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XFINITY",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4DBRK0CE",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CCKWCXETD",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ480N2RG",
      "XN--JLQ61U9W7B",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAKC7DVF",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBCPQ6GPA1A",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q7CE6A",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
    module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
  }
});

// node_modules/joi/lib/types/string.js
var require_string = __commonJS({
  "node_modules/joi/lib/types/string.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Domain = require_domain();
    var Email = require_email();
    var Ip = require_ip();
    var EscapeRegex = require_escapeRegex();
    var Tlds = require_tlds();
    var Uri = require_uri();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
      // $lab:coverage:ignore$
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: /^[a-f0-9]+$/i,
      ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5",
        uuidv6: "6",
        uuidv7: "7",
        uuidv8: "8"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    module.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, state, prefs }) {
          const normalize = schema2.$_getRule("normalize");
          if (normalize) {
            value = value.normalize(normalize.args.form);
          }
          const casing = schema2.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema2.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema2.$_terms.replacements) {
            for (const replacement of schema2.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema2.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema2.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema2._flags.truncate) {
            const rule = schema2.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema2.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { schema: schema2, error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          const min = schema2.$_getRule("min");
          if (min && min.args.limit === 0) {
            return;
          }
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
            options = { urlSafe: false, paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options } });
          },
          validate(value, helpers, { options }) {
            const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i = value.length;
            let sum = 0;
            let mul = 1;
            while (i--) {
              const char = value.charAt(i) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired"]);
            options = { paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options } });
          },
          validate(value, helpers, { options }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options) {
            if (options) {
              Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const address = internals.addressOptions(options);
            return this.$_addRule({ name: "domain", args: { options }, address });
          },
          validate(value, helpers, args, { address }) {
            if (Domain.isValid(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options = {}) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
            Assert(options.multiple === void 0 || typeof options.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options);
            const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
            return this.$_addRule({ name: "email", args: { options }, regex, address });
          },
          validate(value, helpers, { options }, { regex, address }) {
            const emails = options.multiple ? value.split(regex) : [value];
            const invalids = [];
            for (const email of emails) {
              if (!Email.isValid(email, address)) {
                invalids.push(email);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", { value, invalids });
          }
        },
        guid: {
          alias: "uuid",
          method(options = {}) {
            Common.assertOptions(options, ["version", "separator"]);
            let versionNumbers = "";
            if (options.version) {
              const versions = [].concat(options.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i = 0; i < versions.length; ++i) {
                const version = versions[i];
                Assert(typeof version === "string", "version at position " + i + " must be a string");
                const versionNumber = internals.guidVersions[version.toLowerCase()];
                Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options.separator === void 0 ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options = {}) {
            Common.assertOptions(options, ["byteAligned"]);
            options = { byteAligned: false, ...options };
            Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
            return this.$_addRule({ name: "hex", args: { options } });
          },
          validate(value, helpers, { options }) {
            if (!internals.hexRegex.test(value)) {
              return helpers.error("string.hex");
            }
            if (options.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options = {}) {
            Common.assertOptions(options, ["cidr", "version"]);
            const { cidr, versions, regex } = Ip.regex(options);
            const version = options.version ? versions : void 0;
            return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
          },
          validate(value, helpers, { options }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options.version) {
              return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
            }
            return helpers.error("string.ip", { value, cidr: options.cidr });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options === "string") {
              options = { name: options };
            }
            Common.assertOptions(options, ["invert", "name"]);
            const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
          },
          validate(value, helpers, { regex, options }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled } });
          },
          validate(value, helpers, { enabled }) {
            if (!enabled || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options = {}) {
            Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]);
            if (options.domain) {
              Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const { regex, scheme } = Uri.regex(options);
            const domain = options.domain ? internals.addressOptions(options.domain) : null;
            return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
          },
          validate(value, helpers, { options }, { regex, domain, scheme }) {
            if (["http:/", "https:/"].includes(value)) {
              return helpers.error("string.uri");
            }
            const match = regex.exec(value);
            if (match) {
              const matched = match[1] || match[2];
              if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {
                return helpers.error("string.domain", { value: matched });
              }
              return value;
            }
            if (options.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options.scheme) {
              return helpers.error("string.uriCustomScheme", { scheme, value });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options) {
      if (!options) {
        return options;
      }
      Assert(options.minDomainSegments === void 0 || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      Assert(options.maxDomainSegments === void 0 || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
      if (options.tlds === false) {
        return options;
      }
      if (options.tlds === true || options.tlds === void 0) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
      const deny = options.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }
        Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        internals.validateTlds(options.tlds.deny, "tlds.deny");
        return options;
      }
      const allow = options.tlds.allow;
      if (!allow) {
        return options;
      }
      if (allow === true) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
      }
      Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      internals.validateTlds(options.tlds.allow, "tlds.allow");
      return options;
    };
    internals.validateTlds = function(set, source) {
      for (const tld of set) {
        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
      }
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      if (/.*T.*[+-]\d\d$/.test(value)) {
        value += "00";
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date.toISOString();
    };
    internals.length = function(schema2, name, limit, operator, encoding) {
      Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema2.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
  }
});

// node_modules/joi/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/joi/lib/types/symbol.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module.exports = Any.extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema: schema2, error }) {
          const lookup = schema2.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema2._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema2.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols.push(value);
            }
            return obj.valid(...symbols);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/joi/lib/types/binary.js
var require_binary = __commonJS({
  "node_modules/joi/lib/types/binary.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module.exports = Any.extend({
      type: "binary",
      coerce: {
        from: ["string", "object"],
        method(value, { schema: schema2 }) {
          if (typeof value === "string" || value !== null && value.type === "Buffer") {
            try {
              return { value: Buffer.from(value, schema2._flags.encoding) };
            } catch (ignoreErr) {
            }
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/joi/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/joi/lib/index.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Ref = require_ref();
    var Template = require_template();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema2, ...args) {
        internals.assert(value, schema2, true, args);
      },
      attempt(value, schema2, ...args) {
        return internals.assert(value, schema2, false, args);
      },
      build(desc) {
        Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema2, options) {
        return Compile.compile(this, schema2, options);
      },
      defaults(modifier) {
        Assert(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema2 = modifier(joi[type]());
          Assert(Common.isSchema(schema2), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema2, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas();
        Assert(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            Assert(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base = item.base || this.any();
            const schema2 = Extend.type(base, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema2, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema2, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options = message !== null ? args[1] : args[0];
      const result = schema2.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema2, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema2.$_root = root;
      if (!schema2._definition.args || !args.length) {
        return schema2;
      }
      return schema2._definition.args(schema2, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [extension];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module.exports = internals.root();
  }
});

// src/schemas/common.js
function generateErrorResponses(statusCodes, when) {
  const responses = [];
  const postText = "The examples show all possible `code` and `message` values, not limited to this endpoint.";
  if (statusCodes.includes(400)) {
    responses.push({
      statusCode: 400,
      responseBody: {
        description: `An error message when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ErrorResponse"
      }
    });
  }
  if (statusCodes.includes(401)) {
    responses.push({
      statusCode: 401,
      responseBody: {
        description: `Unauthorised user when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "UnauthorizedResponse"
      }
    });
  }
  if (statusCodes.includes(403)) {
    responses.push({
      statusCode: 403,
      responseBody: {
        description: `Forbidden when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ForbiddenResponse"
      }
    });
  }
  if (statusCodes.includes(404)) {
    responses.push({
      statusCode: 404,
      responseBody: {
        description: `Resource not found when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "NotFoundResponse"
      }
    });
  }
  if (statusCodes.includes(429)) {
    responses.push({
      statusCode: 429,
      responseBody: {
        description: `Rate limited when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "RateLimitedResponse"
      }
    });
  }
  if (statusCodes.includes(500)) {
    responses.push({
      statusCode: 500,
      responseBody: {
        description: `A server error when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ServerErrorResponse"
      }
    });
  }
  return responses;
}
__name(generateErrorResponses, "generateErrorResponses");

// src/schemas/validator.js
var import_date = __toESM(require_lib(), 1);
var import_joi = __toESM(require_lib5(), 1);
var Joi = import_joi.default.extend(import_date.default);

// src/handlers/hello1.js
var documentation = {
  summary: "Hello 1",
  tags: ["Hello One Section"],
  description: "Hello 1 template.",
  methodResponses: [
    {
      statusCode: 200,
      responseBody: {
        description: "An object returning hello1: true."
      },
      responseModels: {
        "application/json": "HelloOneSchema"
      }
    },
    ...generateErrorResponses([400, 401, 404, 500], "getting hello 1")
  ]
};
var schema = {
  response: Joi.object({
    hello1: Joi.boolean().required()
  })
};
var handler = /* @__PURE__ */ __name(async () => {
  return {
    statusCode: 200,
    body: JSON.stringify({
      hello1: true
    })
  };
}, "handler");
export {
  documentation,
  handler,
  schema
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bqb2kvZGF0ZS9saWIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3N0cmluZ2lmeS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXJyb3IuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Fzc2VydC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvcmVhY2guanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3R5cGVzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi91dGlscy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvY2xvbmUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9wYWNrYWdlLmpzb24iLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvc2NoZW1hcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvZm9ybXVsYS9saWIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvYW5ub3RhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXJyb3JzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3JlZi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90ZW1wbGF0ZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tZXNzYWdlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY2FjaGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY29tcGlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9leHRlbmQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWFuaWZlc3QuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvcGlucG9pbnQvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3RyYWNlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9tZXJnZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tb2RpZnkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2lnbm9yZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdmFsdWVzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Jhc2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYW55LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FsdGVybmF0aXZlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hcnJheS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2RhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2FwcGx5VG9EZWZhdWx0cy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvdG9wby9saWIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMva2V5cy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9mdW5jdGlvbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9saW5rLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL251bWJlci5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9vYmplY3QuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2Vycm9ycy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvYWRkcmVzcy9saWIvZG9tYWluLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi9lbWFpbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL3VyaS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvYWRkcmVzcy9saWIvaXAuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL3RsZHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvc3RyaW5nLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N5bWJvbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9iaW5hcnkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vc3JjL3NjaGVtYXMvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9zY2hlbWFzL3ZhbGlkYXRvci5qcyIsICIuLi8uLi8uLi8uLi9zcmMvaGFuZGxlcnMvaGVsbG8xLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMzAuMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VuczogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGg6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzOiBbXSxcbiAgICAgICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWVtOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMjogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGZsYWdzID0gbnVsbCxcbiAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gZmFsc2UsXG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gbS5fZCAmJiAhaXNOYU4obS5fZC5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoaXNOb3dWYWxpZCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IChob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW10pLFxuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIG1vbWVudFByb3BlcnRpZXNMZW4gPSBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXNMZW4gPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudChvYmopIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBhcmdMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChhcmd1bWVudHNbMF0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICBtc2cgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbkFyZ3VtZW50czogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodHlwZW9mIEZ1bmN0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNvbmZpZywgaSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgICAgICAvXFxkezEsMn0vLnNvdXJjZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksXG4gICAgICAgICAgICBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheTogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5OiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheTogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWs6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICtcbiAgICAgICAgICAgIGFic051bWJlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID1cbiAgICAgICAgICAgIC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98TnsxLDV9fFlZWVlZWXxZWVlZWXxZWVlZfFlZfHl7Miw0fXx5bz98Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKVxuICAgICAgICAgICAgICAgICAgICA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID1cbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUzogJ2g6bW06c3MgQScsXG4gICAgICAgIExUOiAnaDptbSBBJyxcbiAgICAgICAgTDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0KGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyXG4gICAgICAgICAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRvaykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU1NTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ0REJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdkZGRkJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCcsXG4gICAgICAgIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlOiAnaW4gJXMnLFxuICAgICAgICBwYXN0OiAnJXMgYWdvJyxcbiAgICAgICAgczogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzczogJyVkIHNlY29uZHMnLFxuICAgICAgICBtOiAnYSBtaW51dGUnLFxuICAgICAgICBtbTogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoOiAnYW4gaG91cicsXG4gICAgICAgIGhoOiAnJWQgaG91cnMnLFxuICAgICAgICBkOiAnYSBkYXknLFxuICAgICAgICBkZDogJyVkIGRheXMnLFxuICAgICAgICB3OiAnYSB3ZWVrJyxcbiAgICAgICAgd3c6ICclZCB3ZWVrcycsXG4gICAgICAgIE06ICdhIG1vbnRoJyxcbiAgICAgICAgTU06ICclZCBtb250aHMnLFxuICAgICAgICB5OiAnYSB5ZWFyJyxcbiAgICAgICAgeXk6ICclZCB5ZWFycycsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpXG4gICAgICAgICAgICA/IG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpXG4gICAgICAgICAgICA6IG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge1xuICAgICAgICBEOiAnZGF0ZScsXG4gICAgICAgIGRhdGVzOiAnZGF0ZScsXG4gICAgICAgIGRhdGU6ICdkYXRlJyxcbiAgICAgICAgZDogJ2RheScsXG4gICAgICAgIGRheXM6ICdkYXknLFxuICAgICAgICBkYXk6ICdkYXknLFxuICAgICAgICBlOiAnd2Vla2RheScsXG4gICAgICAgIHdlZWtkYXlzOiAnd2Vla2RheScsXG4gICAgICAgIHdlZWtkYXk6ICd3ZWVrZGF5JyxcbiAgICAgICAgRTogJ2lzb1dlZWtkYXknLFxuICAgICAgICBpc293ZWVrZGF5czogJ2lzb1dlZWtkYXknLFxuICAgICAgICBpc293ZWVrZGF5OiAnaXNvV2Vla2RheScsXG4gICAgICAgIERERDogJ2RheU9mWWVhcicsXG4gICAgICAgIGRheW9meWVhcnM6ICdkYXlPZlllYXInLFxuICAgICAgICBkYXlvZnllYXI6ICdkYXlPZlllYXInLFxuICAgICAgICBoOiAnaG91cicsXG4gICAgICAgIGhvdXJzOiAnaG91cicsXG4gICAgICAgIGhvdXI6ICdob3VyJyxcbiAgICAgICAgbXM6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgIG1pbGxpc2Vjb25kczogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgbWlsbGlzZWNvbmQ6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgIG06ICdtaW51dGUnLFxuICAgICAgICBtaW51dGVzOiAnbWludXRlJyxcbiAgICAgICAgbWludXRlOiAnbWludXRlJyxcbiAgICAgICAgTTogJ21vbnRoJyxcbiAgICAgICAgbW9udGhzOiAnbW9udGgnLFxuICAgICAgICBtb250aDogJ21vbnRoJyxcbiAgICAgICAgUTogJ3F1YXJ0ZXInLFxuICAgICAgICBxdWFydGVyczogJ3F1YXJ0ZXInLFxuICAgICAgICBxdWFydGVyOiAncXVhcnRlcicsXG4gICAgICAgIHM6ICdzZWNvbmQnLFxuICAgICAgICBzZWNvbmRzOiAnc2Vjb25kJyxcbiAgICAgICAgc2Vjb25kOiAnc2Vjb25kJyxcbiAgICAgICAgZ2c6ICd3ZWVrWWVhcicsXG4gICAgICAgIHdlZWt5ZWFyczogJ3dlZWtZZWFyJyxcbiAgICAgICAgd2Vla3llYXI6ICd3ZWVrWWVhcicsXG4gICAgICAgIEdHOiAnaXNvV2Vla1llYXInLFxuICAgICAgICBpc293ZWVreWVhcnM6ICdpc29XZWVrWWVhcicsXG4gICAgICAgIGlzb3dlZWt5ZWFyOiAnaXNvV2Vla1llYXInLFxuICAgICAgICB3OiAnd2VlaycsXG4gICAgICAgIHdlZWtzOiAnd2VlaycsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgVzogJ2lzb1dlZWsnLFxuICAgICAgICBpc293ZWVrczogJ2lzb1dlZWsnLFxuICAgICAgICBpc293ZWVrOiAnaXNvV2VlaycsXG4gICAgICAgIHk6ICd5ZWFyJyxcbiAgICAgICAgeWVhcnM6ICd5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHtcbiAgICAgICAgZGF0ZTogOSxcbiAgICAgICAgZGF5OiAxMSxcbiAgICAgICAgd2Vla2RheTogMTEsXG4gICAgICAgIGlzb1dlZWtkYXk6IDExLFxuICAgICAgICBkYXlPZlllYXI6IDQsXG4gICAgICAgIGhvdXI6IDEzLFxuICAgICAgICBtaWxsaXNlY29uZDogMTYsXG4gICAgICAgIG1pbnV0ZTogMTQsXG4gICAgICAgIG1vbnRoOiA4LFxuICAgICAgICBxdWFydGVyOiA3LFxuICAgICAgICBzZWNvbmQ6IDE1LFxuICAgICAgICB3ZWVrWWVhcjogMSxcbiAgICAgICAgaXNvV2Vla1llYXI6IDEsXG4gICAgICAgIHdlZWs6IDUsXG4gICAgICAgIGlzb1dlZWs6IDUsXG4gICAgICAgIHllYXI6IDEsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPVxuICAgICAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgICAgIG1hdGNoMXRvMk5vTGVhZGluZ1plcm8gPSAvXlsxLTldXFxkPy8sIC8vICAgICAgICAgMS05OVxuICAgICAgICBtYXRjaDF0bzJIYXNaZXJvID0gL14oWzEtOV1cXGR8XFxkKS8sIC8vICAgICAgICAgICAwLTk5XG4gICAgICAgIHJlZ2V4ZXM7XG5cbiAgICByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KVxuICAgICAgICAgICAgPyByZWdleFxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cmljdCAmJiBzdHJpY3RSZWdleCA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFxcXCcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrLFxuICAgICAgICAgICAgdG9rZW5MZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIHZhciBZRUFSID0gMCxcbiAgICAgICAgTU9OVEggPSAxLFxuICAgICAgICBEQVRFID0gMixcbiAgICAgICAgSE9VUiA9IDMsXG4gICAgICAgIE1JTlVURSA9IDQsXG4gICAgICAgIFNFQ09ORCA9IDUsXG4gICAgICAgIE1JTExJU0VDT05EID0gNixcbiAgICAgICAgV0VFSyA9IDcsXG4gICAgICAgIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyB6ZXJvRmlsbCh5LCA0KSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgNF0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsIDVdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9XG4gICAgICAgICAgICBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQobW9tLCB1bml0KSB7XG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkID0gbW9tLl9kLFxuICAgICAgICAgICAgaXNVVEMgPSBtb20uX2lzVVRDO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICAgICAgY2FzZSAnTWlsbGlzZWNvbmRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ01pbGxpc2Vjb25kcygpIDogZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGNhc2UgJ1NlY29uZHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1VUQyA/IGQuZ2V0VVRDU2Vjb25kcygpIDogZC5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICBjYXNlICdNaW51dGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ01pbnV0ZXMoKSA6IGQuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgY2FzZSAnSG91cnMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1VUQyA/IGQuZ2V0VVRDSG91cnMoKSA6IGQuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1VUQyA/IGQuZ2V0VVRDRGF0ZSgpIDogZC5nZXREYXRlKCk7XG4gICAgICAgICAgICBjYXNlICdEYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1VUQyA/IGQuZ2V0VVRDRGF5KCkgOiBkLmdldERheSgpO1xuICAgICAgICAgICAgY2FzZSAnTW9udGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1VUQyA/IGQuZ2V0VVRDTW9udGgoKSA6IGQuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIGNhc2UgJ0Z1bGxZZWFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0Z1bGxZZWFyKCkgOiBkLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47IC8vIEp1c3QgaW4gY2FzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZCwgaXNVVEMsIHllYXIsIG1vbnRoLCBkYXRlO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGQgPSBtb20uX2Q7XG4gICAgICAgIGlzVVRDID0gbW9tLl9pc1VUQztcblxuICAgICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ01pbGxpc2Vjb25kcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKGlzVVRDXG4gICAgICAgICAgICAgICAgICAgID8gZC5zZXRVVENNaWxsaXNlY29uZHModmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogZC5zZXRNaWxsaXNlY29uZHModmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgJ1NlY29uZHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpc1VUQyA/IGQuc2V0VVRDU2Vjb25kcyh2YWx1ZSkgOiBkLnNldFNlY29uZHModmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgJ01pbnV0ZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpc1VUQyA/IGQuc2V0VVRDTWludXRlcyh2YWx1ZSkgOiBkLnNldE1pbnV0ZXModmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgJ0hvdXJzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ0hvdXJzKHZhbHVlKSA6IGQuc2V0SG91cnModmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpc1VUQyA/IGQuc2V0VVRDRGF0ZSh2YWx1ZSkgOiBkLnNldERhdGUodmFsdWUpKTtcbiAgICAgICAgICAgIC8vIGNhc2UgJ0RheSc6IC8vIE5vdCByZWFsXG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ0RheSh2YWx1ZSkgOiBkLnNldERheSh2YWx1ZSkpO1xuICAgICAgICAgICAgLy8gY2FzZSAnTW9udGgnOiAvLyBOb3QgdXNlZCBiZWNhdXNlIHdlIG5lZWQgdG8gcGFzcyB0d28gdmFyaWFibGVzXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHZvaWQgKGlzVVRDID8gZC5zZXRVVENNb250aCh2YWx1ZSkgOiBkLnNldE1vbnRoKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdGdWxsWWVhcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIFNlZSBiZWxvdyAuLi5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBKdXN0IGluIGNhc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHllYXIgPSB2YWx1ZTtcbiAgICAgICAgbW9udGggPSBtb20ubW9udGgoKTtcbiAgICAgICAgZGF0ZSA9IG1vbS5kYXRlKCk7XG4gICAgICAgIGRhdGUgPSBkYXRlID09PSAyOSAmJiBtb250aCA9PT0gMSAmJiAhaXNMZWFwWWVhcih5ZWFyKSA/IDI4IDogZGF0ZTtcbiAgICAgICAgdm9pZCAoaXNVVENcbiAgICAgICAgICAgID8gZC5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aCwgZGF0ZSlcbiAgICAgICAgICAgIDogZC5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgZGF0ZSkpO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgcHJpb3JpdGl6ZWRMZW4gPSBwcmlvcml0aXplZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9XG4gICAgICAgICAgICAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAgICAgJ18nXG4gICAgICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPVxuICAgICAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb250aCA9IHZhbHVlLFxuICAgICAgICAgICAgZGF0ZSA9IG1vbS5kYXRlKCk7XG5cbiAgICAgICAgZGF0ZSA9IGRhdGUgPCAyOSA/IGRhdGUgOiBNYXRoLm1pbihkYXRlLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCBtb250aCkpO1xuICAgICAgICB2b2lkIChtb20uX2lzVVRDXG4gICAgICAgICAgICA/IG1vbS5fZC5zZXRVVENNb250aChtb250aCwgZGF0ZSlcbiAgICAgICAgICAgIDogbW9tLl9kLnNldE1vbnRoKG1vbnRoLCBkYXRlKSk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIHNob3J0UCxcbiAgICAgICAgICAgIGxvbmdQO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UCA9IHJlZ2V4RXNjYXBlKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1AgPSByZWdleEVzY2FwZSh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0UCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ1ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25nUCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0UCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ3cnLCAnd3cnLCAnVycsICdXVyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID1cbiAgICAgICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgICAgPyB3ZWVrZGF5c1ttLmRheSgpXVxuICAgICAgICAgICAgICA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQobSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4obSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldXG4gICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRheSA9IGdldCh0aGlzLCAnRGF5Jyk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIG1pbnAsXG4gICAgICAgICAgICBzaG9ydHAsXG4gICAgICAgICAgICBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ3AgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgaEZvcm1hdC5hcHBseSh0aGlzKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKFxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIsIG1hdGNoMXRvMkhhc1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCBtYXRjaDF0bzIsIG1hdGNoMXRvMk5vTGVhZGluZ1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIsIG1hdGNoMXRvMk5vTGVhZGluZ1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0oaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuIChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbShob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgbG9jYWxlRmFtaWxpZXMgPSB7fSxcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtaW5sID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlubDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUHJlZml4KHNwbGl0LCBuZXh0KSA+PSBqIC0gMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpIHtcbiAgICAgICAgLy8gUHJldmVudCBuYW1lcyB0aGF0IGxvb2sgbGlrZSBmaWxlc3lzdGVtIHBhdGhzLCBpLmUgY29udGFpbiAnLycgb3IgJ1xcJ1xuICAgICAgICAvLyBFbnN1cmUgbmFtZSBpcyBhdmFpbGFibGUgYW5kIGZ1bmN0aW9uIHJldHVybnMgYm9vbGVhblxuICAgICAgICByZXR1cm4gISEobmFtZSAmJiBuYW1lLm1hdGNoKCdeW14vXFxcXFxcXFxdKiQnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICAgICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICAgID8gREFURVxuICAgICAgICAgICAgICAgICAgICAgIDogYVtIT1VSXSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFbTUlOVVRFXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gSE9VUlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhW01JTlVURV0gPCAwIHx8IGFbTUlOVVRFXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gU0VDT05EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUlMTElTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLTE7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkfCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vLFxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NJywgL1xcZHs2fS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWScsIC9cXGR7NH0vLCBmYWxzZV0sXG4gICAgICAgIF0sXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISCcsIC9cXGRcXGQvXSxcbiAgICAgICAgXSxcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKCgtP1xcZCspL2ksXG4gICAgICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICAgICAgcmZjMjgyMiA9XG4gICAgICAgICAgICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxuICAgICAgICBvYnNPZmZzZXRzID0ge1xuICAgICAgICAgICAgVVQ6IDAsXG4gICAgICAgICAgICBHTVQ6IDAsXG4gICAgICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgICAgIH07XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICAgIHR6Rm9ybWF0LFxuICAgICAgICAgICAgaXNvRGF0ZXNMZW4gPSBpc29EYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICBpc29UaW1lc0xlbiA9IGlzb1RpbWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICB5ZWFyU3RyLFxuICAgICAgICBtb250aFN0cixcbiAgICAgICAgZGF5U3RyLFxuICAgICAgICBob3VyU3RyLFxuICAgICAgICBtaW51dGVTdHIsXG4gICAgICAgIHNlY29uZFN0clxuICAgICkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhLFxuICAgICAgICAgICAgdG9rZW5MZW47XG5cbiAgICAgICAgdG9rZW5zID1cbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlnZkxlbiA9IGNvbmZpZy5fZi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbmZpZ2ZMZW4gPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWdmTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmICghYmVzdEZvcm1hdElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChcbiAgICAgICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ3F1YXJ0ZXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnd2VlaycsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3JkZXJMZW4gPSBvcmRlcmluZy5sZW5ndGg7XG4gICAgICAgIGZvciAoa2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKG0sIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJMZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRocyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpIHx8ICFpc05hTigraW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9ICtpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiwgLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19pc1ZhbGlkJykpIHtcbiAgICAgICAgICAgIHJldC5faXNWYWxpZCA9IGlucHV0Ll9pc1ZhbGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28oaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID1cbiAgICAgICAgICAgIG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgKyAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XG4gICAgICAgICAgICAgICAgdmFsID0gcGVyaW9kO1xuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcbiAgICAgICAgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICAvLyB0eXBlIE1vbWVudElucHV0ID0gTW9tZW50IHwgRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IChudW1iZXIgfCBzdHJpbmcpW10gfCBNb21lbnRJbnB1dE9iamVjdCB8IHZvaWQ7IC8vIG51bGwgfCB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc01vbWVudChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzU3RyaW5nKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXIoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAneWVhcnMnLFxuICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAneScsXG4gICAgICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAnTScsXG4gICAgICAgICAgICAgICAgJ2RheXMnLFxuICAgICAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgICAgICAnZGF0ZXMnLFxuICAgICAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAgICAgJ2gnLFxuICAgICAgICAgICAgICAgICdtaW51dGVzJyxcbiAgICAgICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdtcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgcHJvcGVydHlMZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydHlMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3NhbWVEYXknLFxuICAgICAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXG4gICAgICAgICAgICAgICAgJ25leHRXZWVrJyxcbiAgICAgICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxuICAgICAgICAgICAgPyAnc2FtZUVsc2UnXG4gICAgICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICAgICAgICA/ICdsYXN0V2VlaydcbiAgICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgICAgID8gJ2xhc3REYXknXG4gICAgICAgICAgICAgICAgOiBkaWZmIDwgMVxuICAgICAgICAgICAgICAgICAgPyAnc2FtZURheSdcbiAgICAgICAgICAgICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgICAgICAgICAgICAgPyAnbmV4dERheSdcbiAgICAgICAgICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgICAgICAgICAgID8gJ25leHRXZWVrJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3Igc2luZ2xlIHBhcmFtZXRlciwgZm9ybWF0cyBvbmx5IG92ZXJsb2FkIHRvIHRoZSBjYWxlbmRhciBmdW5jdGlvblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICBmb3JtYXRzICYmXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdylcbiAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgICAgIG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiZcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCwgem9uZURlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICAgICAgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgdXRjXG4gICAgICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCcsXG4gICAgICAgICAgICB6b25lID0gJycsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgICAgICBzdWZmaXg7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxuICAgICAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgICAgIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyB0bzogdGhpcywgZnJvbTogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMCxcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcbiAgICAgICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgICAgIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMykgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9XG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSIC1cbiAgICAgICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgbS5ob3VyKCksXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxuICAgICAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgICAgIG0ubWlsbGlzZWNvbmQoKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ04nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk4nLCAwLCAwLCAnZXJhTmFtZScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5JywgMV0sICd5bycsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5JywgMl0sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXl5JywgNF0sIDAsICdlcmFZZWFyJyk7XG5cbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oXG4gICAgICAgIFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgICAgaWYgKGVyYSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEVyYSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzTmFtZSxcbiAgICAgICAgICAgIGVyYXNBYmJyLFxuICAgICAgICAgICAgZXJhc05hcnJvdyxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGVyYXNOYW1lID0gcmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKTtcbiAgICAgICAgICAgIGVyYXNBYmJyID0gcmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKTtcbiAgICAgICAgICAgIGVyYXNOYXJyb3cgPSByZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdyk7XG5cbiAgICAgICAgICAgIG5hbWVQaWVjZXMucHVzaChlcmFzTmFtZSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2goZXJhc0FiYnIpO1xuICAgICAgICAgICAgbmFycm93UGllY2VzLnB1c2goZXJhc05hcnJvdyk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGVyYXNOYW1lKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goZXJhc0FiYnIpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChlcmFzTmFycm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSArIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrKCksXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoKSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy5pc29XZWVrWWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLndlZWtZZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsXG4gICAgICAgICAgICA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKVxuICAgICAgICAgICAgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArICh0aGlzLm1vbnRoKCkgJSAzKSk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgICAgICA/IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZVxuICAgICAgICAgICAgOiBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMiwgbWF0Y2gxdG8ySGFzWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIsIG1hdGNoMXRvMkhhc1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbiwgZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uYWRkID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgPSBkaWZmO1xuICAgIHByb3RvLmVuZE9mID0gZW5kT2Y7XG4gICAgcHJvdG8uZm9ybWF0ID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gPSBmcm9tO1xuICAgIHByb3RvLmZyb21Ob3cgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvID0gdG87XG4gICAgcHJvdG8udG9Ob3cgPSB0b05vdztcbiAgICBwcm90by5nZXQgPSBzdHJpbmdHZXQ7XG4gICAgcHJvdG8uaW52YWxpZEF0ID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgPSBpc0FmdGVyO1xuICAgIHByb3RvLmlzQmVmb3JlID0gaXNCZWZvcmU7XG4gICAgcHJvdG8uaXNCZXR3ZWVuID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgPSBpc1ZhbGlkJDI7XG4gICAgcHJvdG8ubGFuZyA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCA9IHByb3RvdHlwZU1heDtcbiAgICBwcm90by5taW4gPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCA9IHN0cmluZ1NldDtcbiAgICBwcm90by5zdGFydE9mID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgIT0gbnVsbCkge1xuICAgICAgICBwcm90b1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW9tZW50PCcgKyB0aGlzLmZvcm1hdCgpICsgJz4nO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwcm90by50b0pTT04gPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ID0gdW5peDtcbiAgICBwcm90by52YWx1ZU9mID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgPSBjcmVhdGlvbkRhdGE7XG4gICAgcHJvdG8uZXJhTmFtZSA9IGdldEVyYU5hbWU7XG4gICAgcHJvdG8uZXJhTmFycm93ID0gZ2V0RXJhTmFycm93O1xuICAgIHByb3RvLmVyYUFiYnIgPSBnZXRFcmFBYmJyO1xuICAgIHByb3RvLmVyYVllYXIgPSBnZXRFcmFZZWFyO1xuICAgIHByb3RvLnllYXIgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrID0gcHJvdG8ud2Vla3MgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgPSBwcm90by5pc29XZWVrcyA9IGdldFNldElTT1dlZWs7XG4gICAgcHJvdG8ud2Vla3NJblllYXIgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBwcm90by53ZWVrc0luV2Vla1llYXIgPSBnZXRXZWVrc0luV2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luSVNPV2Vla1llYXIgPSBnZXRJU09XZWVrc0luSVNPV2Vla1llYXI7XG4gICAgcHJvdG8uZGF0ZSA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ID0gcHJvdG8uZGF5cyA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyID0gZ2V0U2V0RGF5T2ZZZWFyO1xuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG4gICAgcHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgcHJvdG8udXRjT2Zmc2V0ID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIHByb3RvLmlzRFNUID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgcHJvdG8uaXNMb2NhbCA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzID0gZGVwcmVjYXRlKFxuICAgICAgICAnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXREYXlPZk1vbnRoXG4gICAgKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRNb250aFxuICAgICk7XG4gICAgcHJvdG8ueWVhcnMgPSBkZXByZWNhdGUoXG4gICAgICAgICd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0WWVhclxuICAgICk7XG4gICAgcHJvdG8uem9uZSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJyxcbiAgICAgICAgZ2V0U2V0Wm9uZVxuICAgICk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKFxuICAgICAgICAnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsXG4gICAgICAgIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZFxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbml4KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDEuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSA9IGludmFsaWREYXRlO1xuICAgIHByb3RvJDEub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCA9IHNldDtcbiAgICBwcm90byQxLmVyYXMgPSBsb2NhbGVFcmFzO1xuICAgIHByb3RvJDEuZXJhc1BhcnNlID0gbG9jYWxlRXJhc1BhcnNlO1xuICAgIHByb3RvJDEuZXJhc0NvbnZlcnRZZWFyID0gbG9jYWxlRXJhc0NvbnZlcnRZZWFyO1xuICAgIHByb3RvJDEuZXJhc0FiYnJSZWdleCA9IGVyYXNBYmJyUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFtZVJlZ2V4ID0gZXJhc05hbWVSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYXJyb3dSZWdleCA9IGVyYXNOYXJyb3dSZWdleDtcblxuICAgIHByb3RvJDEubW9udGhzID0gbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgPSBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlID0gbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG8kMS5tb250aHNSZWdleCA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyA9IGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gPSBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgPSBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSA9IGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggPSB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ID0gd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCA9IHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDAsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4obG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZXJhczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMS0wMS0wMScsXG4gICAgICAgICAgICAgICAgdW50aWw6ICtJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0Fubm8gRG9taW5pJyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdBRCcsXG4gICAgICAgICAgICAgICAgYWJicjogJ0FEJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAwLTEyLTMxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogLUluZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQmVmb3JlIENocmlzdCcsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQkMnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdCQycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgICAgICB0b0ludCgobnVtYmVyICUgMTAwKSAvIDEwKSA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAndGgnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAncmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlXG4gICAgKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLFxuICAgICAgICBnZXRMb2NhbGVcbiAgICApO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicygpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIChkYXlzICogNDgwMCkgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIChtb250aHMgKiAxNDYwOTcpIC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzLFxuICAgICAgICAgICAgbW9udGhzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgLyA3ICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMjQgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMTQ0MCArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpLFxuICAgICAgICB2YWx1ZU9mJDEgPSBhc01pbGxpc2Vjb25kcztcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMih1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpLFxuICAgICAgICBzZWNvbmRzID0gbWFrZUdldHRlcignc2Vjb25kcycpLFxuICAgICAgICBtaW51dGVzID0gbWFrZUdldHRlcignbWludXRlcycpLFxuICAgICAgICBob3VycyA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyksXG4gICAgICAgIGRheXMgPSBtYWtlR2V0dGVyKCdkYXlzJyksXG4gICAgICAgIG1vbnRocyA9IG1ha2VHZXR0ZXIoJ21vbnRocycpLFxuICAgICAgICB5ZWFycyA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcygpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgICAgIHNzOiA0NCwgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgICAgICBzOiA0NSwgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgICAgIG06IDQ1LCAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgICAgIGg6IDIyLCAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICAgIGQ6IDI2LCAvLyBkYXlzIHRvIG1vbnRoL3dlZWtcbiAgICAgICAgICAgIHc6IG51bGwsIC8vIHdlZWtzIHRvIG1vbnRoXG4gICAgICAgICAgICBNOiAxMSwgLy8gbW9udGhzIHRvIHllYXJcbiAgICAgICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIHRocmVzaG9sZHMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCksXG4gICAgICAgICAgICBzZWNvbmRzID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSksXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSksXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpLFxuICAgICAgICAgICAgbW9udGhzID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSksXG4gICAgICAgICAgICB3ZWVrcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd3JykpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkdXJhdGlvbi5hcygneScpKSxcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzcycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDw9IDEgJiYgWydtJ10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8PSAxICYmIFsnaCddKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDw9IDEgJiYgWydkJ10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdKTtcblxuICAgICAgICBpZiAodGhyZXNob2xkcy53ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIGEgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPD0gMSAmJiBbJ3cnXSkgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPCB0aHJlc2hvbGRzLncgJiYgWyd3dycsIHdlZWtzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEgfHxcbiAgICAgICAgICAgIChtb250aHMgPD0gMSAmJiBbJ00nXSkgfHxcbiAgICAgICAgICAgIChtb250aHMgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10pIHx8XG4gICAgICAgICAgICAoeWVhcnMgPD0gMSAmJiBbJ3knXSkgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3VuZGluZ0Z1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZShhcmdXaXRoU3VmZml4LCBhcmdUaHJlc2hvbGRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpdGhTdWZmaXggPSBmYWxzZSxcbiAgICAgICAgICAgIHRoID0gdGhyZXNob2xkcyxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhcmdUaHJlc2hvbGRzID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgICAgIGFyZ1dpdGhTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd2l0aFN1ZmZpeCA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdUaHJlc2hvbGRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGggPSBPYmplY3QuYXNzaWduKHt9LCB0aHJlc2hvbGRzLCBhcmdUaHJlc2hvbGRzKTtcbiAgICAgICAgICAgIGlmIChhcmdUaHJlc2hvbGRzLnMgIT0gbnVsbCAmJiBhcmdUaHJlc2hvbGRzLnNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aC5zcyA9IGFyZ1RocmVzaG9sZHMucyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIHRoLCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwLFxuICAgICAgICAgICAgZGF5cyA9IGFicyQxKHRoaXMuX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzJDEodGhpcy5fbW9udGhzKSxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKSxcbiAgICAgICAgICAgIHRvdGFsU2lnbixcbiAgICAgICAgICAgIHltU2lnbixcbiAgICAgICAgICAgIGRheXNTaWduLFxuICAgICAgICAgICAgaG1zU2lnbjtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuXG4gICAgICAgIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdG90YWxTaWduICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoeWVhcnMgPyB5bVNpZ24gKyB5ZWFycyArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAobW9udGhzID8geW1TaWduICsgbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChkYXlzID8gZGF5c1NpZ24gKyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyB8fCBtaW51dGVzIHx8IHNlY29uZHMgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzID8gaG1zU2lnbiArIGhvdXJzICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtaW51dGVzID8gaG1zU2lnbiArIG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHNlY29uZHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzID0gYWJzO1xuICAgIHByb3RvJDIuYWRkID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJyxcbiAgICAgICAgdG9JU09TdHJpbmckMVxuICAgICk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0KSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vISBtb21lbnQuanNcblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4zMC4xJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiA9IG1pbjtcbiAgICBob29rcy5tYXggPSBtYXg7XG4gICAgaG9va3Mubm93ID0gbm93O1xuICAgIGhvb2tzLnV0YyA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nLCAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoam9pKSA9PiB7XG5cbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICBmb3JtYXQ6IGpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgam9pLnN0cmluZygpLFxuICAgICAgICAgICAgam9pLmFycmF5KCkuaXRlbXMoam9pLnN0cmluZygpLmludmFsaWQoJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnKSlcbiAgICAgICAgXSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICB0eXBlOiAnZGF0ZScsXG4gICAgICAgIGJhc2U6IGpvaS5kYXRlKCksXG5cbiAgICAgICAgY29lcmNlOiB7XG4gICAgICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBzY2hlbWEuJF9nZXRGbGFnKCdmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHNjaGVtYS4kX2dldEZsYWcoJ3V0YycpID8gTW9tZW50LnV0Yyh2YWx1ZSwgZm9ybWF0LCB0cnVlKSA6IE1vbWVudCh2YWx1ZSwgZm9ybWF0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGRhdGUudG9EYXRlKCkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAgIHV0Yzoge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1dGMnLCBlbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcblxuICAgICAgICAgICAgICAgIGpvaS5hdHRlbXB0KGZvcm1hdCwgYXJncy5mb3JtYXQsICdJbnZhbGlkIGZvcm1hdCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKFsnaXNvJywgJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zdXBlci5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Zvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gRGVmYXVsdCBleHBvcnQgZm9yIFR5cGVTY3JpcHQgbW9kdWxlIGludGVyb3BcblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiAnW0Nhbm5vdCBkaXNwbGF5IG9iamVjdDogJyArIGVyci5tZXNzYWdlICsgJ10nO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG5cbiAgICAgICAgY29uc3QgbXNncyA9IGFyZ3NcbiAgICAgICAgICAgIC5maWx0ZXIoKGFyZykgPT4gYXJnICE9PSAnJylcbiAgICAgICAgICAgIC5tYXAoKGFyZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnIDogYXJnIGluc3RhbmNlb2YgRXJyb3IgPyBhcmcubWVzc2FnZSA6IFN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIobXNncy5qb2luKCcgJykgfHwgJ1Vua25vd24gZXJyb3InKTtcblxuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7ICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBleHBvcnRzLmFzc2VydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgYXJnc1swXSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cbiAgICAgICAgdGhyb3cgYXJnc1swXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgQXNzZXJ0RXJyb3IoYXJncyk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNoYWluLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoY2hhaW4gPT09IGZhbHNlIHx8XG4gICAgICAgIGNoYWluID09PSBudWxsIHx8XG4gICAgICAgIGNoYWluID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc2VwYXJhdG9yOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNDaGFpbkFycmF5ID0gQXJyYXkuaXNBcnJheShjaGFpbik7XG5cbiAgICBBc3NlcnQoIWlzQ2hhaW5BcnJheSB8fCAhb3B0aW9ucy5zZXBhcmF0b3IsICdTZXBhcmF0b3Igb3B0aW9uIGlzIG5vdCB2YWxpZCBmb3IgYXJyYXktYmFzZWQgY2hhaW4nKTtcblxuICAgIGNvbnN0IHBhdGggPSBpc0NoYWluQXJyYXkgPyBjaGFpbiA6IGNoYWluLnNwbGl0KG9wdGlvbnMuc2VwYXJhdG9yIHx8ICcuJyk7XG4gICAgbGV0IHJlZiA9IG9iajtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IGtleSA9IHBhdGhbaV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLml0ZXJhYmxlcyAmJiBpbnRlcm5hbHMuaXRlcmFibGVzKHJlZik7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmKSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gJ3NldCcpIHtcblxuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gTnVtYmVyKGtleSk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gbnVtYmVyIDwgMCA/IHJlZi5sZW5ndGggKyBudW1iZXIgOiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZiB8fFxuICAgICAgICAgICAgdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmZ1bmN0aW9ucyA9PT0gZmFsc2UgfHwgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAhdHlwZSAmJiByZWZba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCghb3B0aW9ucy5zdHJpY3QgfHwgaSArIDEgPT09IHBhdGgubGVuZ3RoLCAnTWlzc2luZyBzZWdtZW50Jywga2V5LCAnaW4gcmVhY2ggcGF0aCAnLCBjaGFpbik7XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcgfHwgb3B0aW9ucy5mdW5jdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIHJlZiAhPT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgc2VnbWVudCcsIGtleSwgJ2luIHJlYWNoIHBhdGggJywgY2hhaW4pO1xuICAgICAgICAgICAgcmVmID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJlZiA9IHJlZltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICByZWYgPSBbLi4ucmVmXVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgLy8gdHlwZSA9PT0gJ21hcCdcbiAgICAgICAgICAgIHJlZiA9IHJlZi5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWY7XG59O1xuXG5cbmludGVybmFscy5pdGVyYWJsZXMgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICBpZiAocmVmIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiAnc2V0JztcbiAgICB9XG5cbiAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiAnbWFwJztcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5OiBBcnJheS5wcm90b3R5cGUsXG4gICAgYnVmZmVyOiBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZSwgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgZGF0ZTogRGF0ZS5wcm90b3R5cGUsXG4gICAgZXJyb3I6IEVycm9yLnByb3RvdHlwZSxcbiAgICBnZW5lcmljOiBPYmplY3QucHJvdG90eXBlLFxuICAgIG1hcDogTWFwLnByb3RvdHlwZSxcbiAgICBwcm9taXNlOiBQcm9taXNlLnByb3RvdHlwZSxcbiAgICByZWdleDogUmVnRXhwLnByb3RvdHlwZSxcbiAgICBzZXQ6IFNldC5wcm90b3R5cGUsXG4gICAgd2Vha01hcDogV2Vha01hcC5wcm90b3R5cGUsXG4gICAgd2Vha1NldDogV2Vha1NldC5wcm90b3R5cGVcbn07XG5cblxuaW50ZXJuYWxzLnR5cGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbJ1tvYmplY3QgRXJyb3JdJywgZXhwb3J0cy5lcnJvcl0sXG4gICAgWydbb2JqZWN0IE1hcF0nLCBleHBvcnRzLm1hcF0sXG4gICAgWydbb2JqZWN0IFByb21pc2VdJywgZXhwb3J0cy5wcm9taXNlXSxcbiAgICBbJ1tvYmplY3QgU2V0XScsIGV4cG9ydHMuc2V0XSxcbiAgICBbJ1tvYmplY3QgV2Vha01hcF0nLCBleHBvcnRzLndlYWtNYXBdLFxuICAgIFsnW29iamVjdCBXZWFrU2V0XScsIGV4cG9ydHMud2Vha1NldF1cbl0pO1xuXG5cbmV4cG9ydHMuZ2V0SW50ZXJuYWxQcm90byA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXJyYXk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBCdWZmZXIpIHsgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5kYXRlO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVnZXg7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVycm9yO1xuICAgIH1cblxuICAgIGNvbnN0IG9iak5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLnR5cGVNYXAuZ2V0KG9iak5hbWUpIHx8IGV4cG9ydHMuZ2VuZXJpYztcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBvcHRpb25zLnN5bWJvbHMgIT09IGZhbHNlID8gUmVmbGVjdC5vd25LZXlzKG9iaikgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopOyAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbmVlZHNQcm90b0hhY2s6IG5ldyBTZXQoW1R5cGVzLnNldCwgVHlwZXMubWFwLCBUeXBlcy53ZWFrU2V0LCBUeXBlcy53ZWFrTWFwXSlcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30sIF9zZWVuID0gbnVsbCkge1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbGV0IGNsb25lID0gaW50ZXJuYWxzLmNsb25lO1xuICAgIGxldCBzZWVuID0gX3NlZW47XG5cbiAgICBpZiAob3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNoYWxsb3cgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2xvbmVXaXRoU2hhbGxvdyhvYmosIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvbmUgPSAodmFsdWUpID0+IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWVuKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cCA9IHNlZW4uZ2V0KG9iaik7XG4gICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbHQtaW4gb2JqZWN0IHR5cGVzXG5cbiAgICBjb25zdCBiYXNlUHJvdG8gPSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLmZyb20ob2JqKTsgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLnJlZ2V4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJpYyBvYmplY3RzXG5cbiAgICBjb25zdCBuZXdPYmogPSBpbnRlcm5hbHMuYmFzZShvYmosIGJhc2VQcm90bywgb3B0aW9ucyk7XG4gICAgaWYgKG5ld09iaiA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgICAgc2Vlbi5zZXQob2JqLCBuZXdPYmopOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBzZWVuLCBzaW5jZSBvYmogY291bGQgcmVjdXJzZVxuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLnNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iaikge1xuICAgICAgICAgICAgbmV3T2JqLmFkZChjbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMubWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG9iaikge1xuICAgICAgICAgICAgbmV3T2JqLnNldChrZXksIGNsb25lKHZhbHVlLCBvcHRpb25zLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhvYmosIG9wdGlvbnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ2xlbmd0aCcpIHtcblxuICAgICAgICAgICAgbmV3T2JqLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0KSB7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIHsgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2VlbikgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmo7XG59O1xuXG5cbmludGVybmFscy5jbG9uZVdpdGhTaGFsbG93ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3Qga2V5cyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFsbG93ID0gZmFsc2U7XG5cbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCByZWYgPSBSZWFjaChzb3VyY2UsIGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICBzZWVuLnNldChyZWYsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmNsb25lKHNvdXJjZSwgb3B0aW9ucywgc2Vlbik7XG59O1xuXG5cbmludGVybmFscy5iYXNlID0gZnVuY3Rpb24gKG9iaiwgYmFzZVByb3RvLCBvcHRpb25zKSB7XG5cbiAgICBpZiAob3B0aW9ucy5wcm90b3R5cGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJhc2VQcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkgPyBbXSA6IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKHByb3RvICYmXG4gICAgICAgIHByb3RvLmlzSW1tdXRhYmxlKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5hcnJheSkge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBbXTtcbiAgICAgICAgaWYgKHByb3RvICE9PSBiYXNlUHJvdG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmosIHByb3RvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBuZXcgcHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgaWYgKHByb3RvICE9PSBiYXNlUHJvdG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmosIHByb3RvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG8pO1xufTtcbiIsICJ7XG4gICAgXCJuYW1lXCI6IFwiam9pXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk9iamVjdCBzY2hlbWEgdmFsaWRhdGlvblwiLFxuICAgIFwidmVyc2lvblwiOiBcIjE3LjExLjFcIixcbiAgICBcInJlcG9zaXRvcnlcIjogXCJnaXQ6Ly9naXRodWIuY29tL2hhcGlqcy9qb2lcIixcbiAgICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgICBcInR5cGVzXCI6IFwibGliL2luZGV4LmQudHNcIixcbiAgICBcImJyb3dzZXJcIjogXCJkaXN0L2pvaS1icm93c2VyLm1pbi5qc1wiLFxuICAgIFwiZmlsZXNcIjogW1xuICAgICAgICBcImxpYi8qKi8qXCIsXG4gICAgICAgIFwiZGlzdC8qXCJcbiAgICBdLFxuICAgIFwia2V5d29yZHNcIjogW1xuICAgICAgICBcInNjaGVtYVwiLFxuICAgICAgICBcInZhbGlkYXRpb25cIlxuICAgIF0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICBcIkBoYXBpL2hvZWtcIjogXCJeOS4zLjBcIixcbiAgICAgICAgXCJAaGFwaS90b3BvXCI6IFwiXjUuMS4wXCIsXG4gICAgICAgIFwiQHNpZGV3YXkvYWRkcmVzc1wiOiBcIl40LjEuNFwiLFxuICAgICAgICBcIkBzaWRld2F5L2Zvcm11bGFcIjogXCJeMy4wLjFcIixcbiAgICAgICAgXCJAc2lkZXdheS9waW5wb2ludFwiOiBcIl4yLjAuMFwiXG4gICAgfSxcbiAgICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgIFwiQGhhcGkvYm91cm5lXCI6IFwiMi54LnhcIixcbiAgICAgICAgXCJAaGFwaS9jb2RlXCI6IFwiOC54LnhcIixcbiAgICAgICAgXCJAaGFwaS9qb2ktbGVnYWN5LXRlc3RcIjogXCJucG06QGhhcGkvam9pQDE1LngueFwiLFxuICAgICAgICBcIkBoYXBpL2xhYlwiOiBcIl4yNS4xLjNcIixcbiAgICAgICAgXCJAdHlwZXMvbm9kZVwiOiBcIl4xNC4xOC42M1wiLFxuICAgICAgICBcInR5cGVzY3JpcHRcIjogXCI0LjMueFwiXG4gICAgfSxcbiAgICBcInNjcmlwdHNcIjoge1xuICAgICAgICBcInByZXB1Ymxpc2hPbmx5XCI6IFwiY2QgYnJvd3NlciAmJiBucG0gaW5zdGFsbCAmJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgICAgIFwidGVzdFwiOiBcImxhYiAtdCAxMDAgLWEgQGhhcGkvY29kZSAtTCAtWVwiLFxuICAgICAgICBcInRlc3QtY292LWh0bWxcIjogXCJsYWIgLXIgaHRtbCAtbyBjb3ZlcmFnZS5odG1sIC1hIEBoYXBpL2NvZGVcIlxuICAgIH0sXG4gICAgXCJsaWNlbnNlXCI6IFwiQlNELTMtQ2xhdXNlXCJcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpvaSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBQcmVmZXJlbmNlc1xuXG5pbnRlcm5hbHMud3JhcCA9IEpvaS5zdHJpbmcoKVxuICAgIC5taW4oMSlcbiAgICAubWF4KDIpXG4gICAgLmFsbG93KGZhbHNlKTtcblxuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gSm9pLm9iamVjdCh7XG4gICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgIGFib3J0RWFybHk6IEpvaS5ib29sZWFuKCksXG4gICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgIGNhY2hlOiBKb2kuYm9vbGVhbigpLFxuICAgIGNvbnRleHQ6IEpvaS5vYmplY3QoKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIGRhdGVGb3JtYXQ6IEpvaS52YWxpZCgnZGF0ZScsICdpc28nLCAnc3RyaW5nJywgJ3RpbWUnLCAndXRjJyksXG4gICAgZGVidWc6IEpvaS5ib29sZWFuKCksXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGxhYmVsOiBKb2kudmFsaWQoJ3BhdGgnLCAna2V5JywgZmFsc2UpLFxuICAgICAgICBsYW5ndWFnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCgpLnJlZigpXG4gICAgICAgIF0sXG4gICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RhY2s6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgIGxhYmVsOiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgIGFycmF5OiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgIHN0cmluZzogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgIG1lc3NhZ2VzOiBKb2kub2JqZWN0KCksXG4gICAgbm9EZWZhdWx0czogSm9pLmJvb2xlYW4oKSxcbiAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICBwcmVzZW5jZTogSm9pLnZhbGlkKCdyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nKSxcbiAgICBza2lwRnVuY3Rpb25zOiBKb2kuYm9vbGVhbigpLFxuICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgb2JqZWN0czogSm9pLmJvb2xlYW4oKVxuICAgIH0pXG4gICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAuYWxsb3codHJ1ZSwgZmFsc2UpLFxuICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG4vLyBFeHRlbnNpb25zXG5cbmludGVybmFscy5uYW1lUnggPSAvXlthLXpBLVowLTldXFx3KiQvO1xuXG5cbmludGVybmFscy5ydWxlID0gSm9pLm9iamVjdCh7XG4gICAgYWxpYXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpKS5zaW5nbGUoKSxcbiAgICBhcmdzOiBKb2kuYXJyYXkoKS5pdGVtcyhcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICByZWY6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBhc3NlcnQ6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgIEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoJ3JlZicsIHsgaXM6IHRydWUsIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpvaS5zdHJpbmcoKS53aGVuKCdhc3NlcnQnLCB7IGlzOiBKb2kuZnVuY3Rpb24oKSwgdGhlbjogSm9pLnJlcXVpcmVkKCkgfSlcbiAgICAgICAgfSlcbiAgICApLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgbWFuaWZlc3Q6IEpvaS5ib29sZWFuKCksXG4gICAgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5hbGxvdyhmYWxzZSksXG4gICAgbXVsdGk6IEpvaS5ib29sZWFuKCksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpXG59KTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbiA9IEpvaS5vYmplY3Qoe1xuICAgIHR5cGU6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5vYmplY3QoKS5yZWdleCgpXG4gICAgXSlcbiAgICAgICAgLnJlcXVpcmVkKCksXG4gICAgYXJnczogSm9pLmZ1bmN0aW9uKCksXG4gICAgY2FzdDogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGZyb206IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDEpLnJlcXVpcmVkKCksXG4gICAgICAgIHRvOiBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKS5yZXF1aXJlZCgpXG4gICAgfSkpLFxuICAgIGJhc2U6IEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAud2hlbigndHlwZScsIHsgaXM6IEpvaS5vYmplY3QoKS5yZWdleCgpLCB0aGVuOiBKb2kuZm9yYmlkZGVuKCkgfSksXG4gICAgY29lcmNlOiBbXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpLFxuICAgICAgICBKb2kub2JqZWN0KHsgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKS5yZXF1aXJlZCgpLCBmcm9tOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpIH0pXG4gICAgXSxcbiAgICBmbGFnczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIHNldHRlcjogSm9pLnN0cmluZygpLFxuICAgICAgICBkZWZhdWx0OiBKb2kuYW55KClcbiAgICB9KSksXG4gICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgYnVpbGQ6IEpvaS5mdW5jdGlvbigpLmFyaXR5KDIpXG4gICAgfSxcbiAgICBtZXNzYWdlczogW0pvaS5vYmplY3QoKSwgSm9pLnN0cmluZygpXSxcbiAgICBtb2RpZmllcnM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpLm1pbkFyaXR5KDEpLm1heEFyaXR5KDIpKSxcbiAgICBvdmVycmlkZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpKSxcbiAgICBwcmVwYXJlOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICByZWJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgxKSxcbiAgICBydWxlczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgaW50ZXJuYWxzLnJ1bGUpLFxuICAgIHRlcm1zOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kub2JqZWN0KHtcbiAgICAgICAgaW5pdDogSm9pLmFycmF5KCkuYWxsb3cobnVsbCkucmVxdWlyZWQoKSxcbiAgICAgICAgbWFuaWZlc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgICAgIEpvaS52YWxpZCgnc2NoZW1hJywgJ3NpbmdsZScpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFwcGVkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICAgICAgICAgIHRvOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZXF1aXJlZCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgIH0pKSxcbiAgICB2YWxpZGF0ZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMylcbn0pXG4gICAgLnN0cmljdCgpO1xuXG5cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5vYmplY3QoKSwgSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSkpLnN0cmljdCgpO1xuXG5cbi8vIE1hbmlmZXN0XG5cbmludGVybmFscy5kZXNjID0ge1xuXG4gICAgYnVmZmVyOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYnVmZmVyOiBKb2kuc3RyaW5nKClcbiAgICB9KSxcblxuICAgIGZ1bmM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBmdW5jdGlvbjogSm9pLmZ1bmN0aW9uKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBvdmVycmlkZTogSm9pLm9iamVjdCh7XG4gICAgICAgIG92ZXJyaWRlOiB0cnVlXG4gICAgfSksXG5cbiAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogSm9pLnZhbGlkKCd2YWx1ZScsICdnbG9iYWwnLCAnbG9jYWwnKSxcbiAgICAgICAgICAgIHBhdGg6IEpvaS5hcnJheSgpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6IEpvaS5zdHJpbmcoKS5sZW5ndGgoMSkuYWxsb3coZmFsc2UpLFxuICAgICAgICAgICAgYW5jZXN0b3I6IEpvaS5udW1iZXIoKS5taW4oMCkuaW50ZWdlcigpLmFsbG93KCdyb290JyksXG4gICAgICAgICAgICBtYXA6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5hcnJheSgpLmxlbmd0aCgyKSkubWluKDEpLFxuICAgICAgICAgICAgYWRqdXN0OiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIGl0ZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGluOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgcmVuZGVyOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgIH0pLFxuXG4gICAgcmVnZXg6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWdleDogSm9pLnN0cmluZygpLm1pbigzKVxuICAgIH0pLFxuXG4gICAgc3BlY2lhbDogSm9pLm9iamVjdCh7XG4gICAgICAgIHNwZWNpYWw6IEpvaS52YWxpZCgnZGVlcCcpLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHRlbXBsYXRlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdGVtcGxhdGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbiAgICB9KSxcblxuICAgIHZhbHVlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdmFsdWU6IEpvaS5hbHRlcm5hdGl2ZXMoW0pvaS5vYmplY3QoKSwgSm9pLmFycmF5KCldKS5yZXF1aXJlZCgpXG4gICAgfSlcbn07XG5cblxuaW50ZXJuYWxzLmRlc2MuZW50aXR5ID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmFycmF5KCkuaXRlbXMoSm9pLmxpbmsoJy4uLicpKSxcbiAgICBKb2kuYm9vbGVhbigpLFxuICAgIEpvaS5mdW5jdGlvbigpLFxuICAgIEpvaS5udW1iZXIoKSxcbiAgICBKb2kuc3RyaW5nKCksXG4gICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgIGludGVybmFscy5kZXNjLmZ1bmMsXG4gICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgIGludGVybmFscy5kZXNjLnJlZ2V4LFxuICAgIGludGVybmFscy5kZXNjLnNwZWNpYWwsXG4gICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgaW50ZXJuYWxzLmRlc2MudmFsdWUsXG4gICAgSm9pLmxpbmsoJy8nKVxuXSk7XG5cblxuaW50ZXJuYWxzLmRlc2MudmFsdWVzID0gSm9pLmFycmF5KClcbiAgICAuaXRlbXMoXG4gICAgICAgIG51bGwsXG4gICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICBKb2kubnVtYmVyKCkuYWxsb3coSW5maW5pdHksIC1JbmZpbml0eSksXG4gICAgICAgIEpvaS5zdHJpbmcoKS5hbGxvdygnJyksXG4gICAgICAgIEpvaS5zeW1ib2woKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5vdmVycmlkZSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnZhbHVlXG4gICAgKTtcblxuXG5pbnRlcm5hbHMuZGVzYy5tZXNzYWdlcyA9IEpvaS5vYmplY3QoKVxuICAgIC5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy50ZW1wbGF0ZSxcbiAgICAgICAgSm9pLm9iamVjdCgpLnBhdHRlcm4oLy4rLywgW0pvaS5zdHJpbmcoKSwgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGVdKVxuICAgIF0pO1xuXG5cbmV4cG9ydHMuZGVzY3JpcHRpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICBmbGFnczogSm9pLm9iamVjdCh7XG4gICAgICAgIGNhc3Q6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogSm9pLnN0cmluZygpLFxuICAgICAgICBlbXB0eTogSm9pLmxpbmsoJy8nKSxcbiAgICAgICAgZmFpbG92ZXI6IGludGVybmFscy5kZXNjLmVudGl0eSxcbiAgICAgICAgaWQ6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgbGFiZWw6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgb25seTogdHJ1ZSxcbiAgICAgICAgcHJlc2VuY2U6IFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHJlc3VsdDogWydyYXcnLCAnc3RyaXAnXSxcbiAgICAgICAgc3RyaXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHVuaXQ6IEpvaS5zdHJpbmcoKVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKCksXG4gICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhcnRpZmFjdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGNhY2hlOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBkYXRlRm9ybWF0OiBbJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YyddLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBsYWJlbDogWydwYXRoJywgJ2tleSddLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgd3JhcDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBtZXNzYWdlczogaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMsXG4gICAgICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG5vbkVudW1lcmFibGVzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBwcmVzZW5jZTogWydyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nXSxcbiAgICAgICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RyaXBVbmtub3duOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICAgICAgd2FybmluZ3M6IEpvaS5ib29sZWFuKClcbiAgICB9LFxuICAgIGFsbG93OiBpbnRlcm5hbHMuZGVzYy52YWx1ZXMsXG4gICAgaW52YWxpZDogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIHJ1bGVzOiBKb2kuYXJyYXkoKS5taW4oMSkuaXRlbXMoe1xuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgYXJnczogSm9pLm9iamVjdCgpLm1pbigxKSxcbiAgICAgICAga2VlcDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MubWVzc2FnZXNcbiAgICAgICAgXSxcbiAgICAgICAgd2FybjogSm9pLmJvb2xlYW4oKVxuICAgIH0pLFxuXG4gICAgLy8gVGVybXNcblxuICAgIGtleXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKi8sIEpvaS5saW5rKCcvJykpLFxuICAgIGxpbms6IGludGVybmFscy5kZXNjLnJlZlxufSlcbiAgICAucGF0dGVybigvXlthLXpdXFx3KiQvLCBKb2kuYW55KCkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBlc2NhcGVkID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGVkO1xufTtcblxuXG5pbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIGNvbnN0IG5hbWVkRXNjYXBlID0gaW50ZXJuYWxzLm5hbWVkSHRtbC5nZXQoY2hhckNvZGUpO1xuICAgIGlmIChuYW1lZEVzY2FwZSkge1xuICAgICAgICByZXR1cm4gbmFtZWRFc2NhcGU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xuICAgICAgICByZXR1cm4gJyYjJyArIGNoYXJDb2RlICsgJzsnO1xuICAgIH1cblxuICAgIGNvbnN0IGhleFZhbHVlID0gY2hhckNvZGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgcmV0dXJuIGAmI3gke2hleFZhbHVlfTtgO1xufTtcblxuXG5pbnRlcm5hbHMuaXNTYWZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMuaGFzKGNoYXJDb2RlKTtcbn07XG5cblxuaW50ZXJuYWxzLm5hbWVkSHRtbCA9IG5ldyBNYXAoW1xuICAgIFszOCwgJyZhbXA7J10sXG4gICAgWzYwLCAnJmx0OyddLFxuICAgIFs2MiwgJyZndDsnXSxcbiAgICBbMzQsICcmcXVvdDsnXSxcbiAgICBbMTYwLCAnJm5ic3A7J10sXG4gICAgWzE2MiwgJyZjZW50OyddLFxuICAgIFsxNjMsICcmcG91bmQ7J10sXG4gICAgWzE2NCwgJyZjdXJyZW47J10sXG4gICAgWzE2OSwgJyZjb3B5OyddLFxuICAgIFsxNzQsICcmcmVnOyddXG5dKTtcblxuXG5pbnRlcm5hbHMuc2FmZUNoYXJDb2RlcyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBzYWZlID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcblxuICAgICAgICBpZiAoKGkgPj0gOTcpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBhLXpcbiAgICAgICAgICAgIChpID49IDY1ICYmIGkgPD0gOTApIHx8ICAgICAgICAgLy8gQS1aXG4gICAgICAgICAgICAoaSA+PSA0OCAmJiBpIDw9IDU3KSB8fCAgICAgICAgIC8vIDAtOVxuICAgICAgICAgICAgaSA9PT0gMzIgfHwgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZVxuICAgICAgICAgICAgaSA9PT0gNDYgfHwgICAgICAgICAgICAgICAgICAgICAvLyAuXG4gICAgICAgICAgICBpID09PSA0NCB8fCAgICAgICAgICAgICAgICAgICAgIC8vICxcbiAgICAgICAgICAgIGkgPT09IDQ1IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLVxuICAgICAgICAgICAgaSA9PT0gNTggfHwgICAgICAgICAgICAgICAgICAgICAvLyA6XG4gICAgICAgICAgICBpID09PSA5NSkgeyAgICAgICAgICAgICAgICAgICAgIC8vIF9cblxuICAgICAgICAgICAgc2FmZS5hZGQoaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2FmZTtcbn0oKSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgb3BlcmF0b3JzOiBbJyEnLCAnXicsICcqJywgJy8nLCAnJScsICcrJywgJy0nLCAnPCcsICc8PScsICc+JywgJz49JywgJz09JywgJyE9JywgJyYmJywgJ3x8JywgJz8/J10sXG4gICAgb3BlcmF0b3JDaGFyYWN0ZXJzOiBbJyEnLCAnXicsICcqJywgJy8nLCAnJScsICcrJywgJy0nLCAnPCcsICc9JywgJz4nLCAnJicsICd8JywgJz8nXSxcbiAgICBvcGVyYXRvcnNPcmRlcjogW1snXiddLCBbJyonLCAnLycsICclJ10sIFsnKycsICctJ10sIFsnPCcsICc8PScsICc+JywgJz49J10sIFsnPT0nLCAnIT0nXSwgWycmJiddLCBbJ3x8JywgJz8/J11dLFxuICAgIG9wZXJhdG9yc1ByZWZpeDogWychJywgJ24nXSxcblxuICAgIGxpdGVyYWxzOiB7XG4gICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICdgJzogJ2AnLFxuICAgICAgICAnXFwnJzogJ1xcJycsXG4gICAgICAgICdbJzogJ10nXG4gICAgfSxcblxuICAgIG51bWJlclJ4OiAvXig/OlswLTldKihcXC5bMC05XSopPyl7MX0kLyxcbiAgICB0b2tlblJ4OiAvXltcXHdcXCRcXCNcXC5cXEBcXDpcXHtcXH1dKyQvLFxuXG4gICAgc3ltYm9sOiBTeW1ib2woJ2Zvcm11bGEnKSxcbiAgICBzZXR0aW5nczogU3ltYm9sKCdzZXR0aW5ncycpXG59O1xuXG5cbmV4cG9ydHMuUGFyc2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoIW9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb25zdGFudHMpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjb25zdGFudCBpbiBvcHRpb25zLmNvbnN0YW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5jb25zdGFudHNbY29uc3RhbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhWydib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnN0YW50ICR7Y29uc3RhbnR9IGNvbnRhaW5zIGludmFsaWQgJHt0eXBlb2YgdmFsdWV9IHZhbHVlIHR5cGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9uc1tpbnRlcm5hbHMuc2V0dGluZ3NdID8gb3B0aW9ucyA6IE9iamVjdC5hc3NpZ24oeyBbaW50ZXJuYWxzLnNldHRpbmdzXTogdHJ1ZSwgY29uc3RhbnRzOiB7fSwgZnVuY3Rpb25zOiB7fSB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyc2Uoc3RyaW5nKTtcbiAgICB9XG5cbiAgICBfcGFyc2Uoc3RyaW5nKSB7XG5cbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnRoZXNpcyA9IDA7XG4gICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgZmx1c2ggPSAoaW5uZXIpID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcGFydHMubGVuZ3RoID8gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIWxpdGVyYWwgJiZcbiAgICAgICAgICAgICAgICAhY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICFpbm5lcikge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ3JlZmVyZW5jZScgJiZcbiAgICAgICAgICAgICAgICBpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uXG5cbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgIGxhc3QudmFsdWUgPSB0aGlzLl9zdWJGb3JtdWxhKGN1cnJlbnQsIGxhc3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZ21lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgZXhwb3J0cy5QYXJzZXIoY3VycmVudCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdzZWdtZW50JywgdmFsdWU6IHN1YiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCA9PT0gJ10nKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogY3VycmVudCB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpdGVyYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5vcGVyYXRvckNoYXJhY3RlcnMuaW5jbHVkZXMoY3VycmVudCkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdG9yXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC50eXBlID09PSAnb3BlcmF0b3InICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMobGFzdC52YWx1ZSArIGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyAyIGNoYXJhY3RlcnMgb3BlcmF0b3JcblxuICAgICAgICAgICAgICAgICAgICBsYXN0LnZhbHVlICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudC5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiBwYXJzZUZsb2F0KGN1cnJlbnQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jb25zdGFudHNbY3VycmVudF0gIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnRcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2NvbnN0YW50JywgdmFsdWU6IHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoKGludGVybmFscy50b2tlblJ4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCB0b2tlbjogJHtjdXJyZW50fWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAncmVmZXJlbmNlJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscykge1xuICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICsrcGFyZW50aGVzaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBwcmVmaXggLSB0byBpbnRlcm5hbCBuZWdhdGl2ZSBvcGVyYXRvclxuXG4gICAgICAgIHBhcnRzID0gcGFydHMubWFwKChwYXJ0LCBpKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdvcGVyYXRvcicgfHxcbiAgICAgICAgICAgICAgICBwYXJ0LnZhbHVlICE9PSAnLScgfHxcbiAgICAgICAgICAgICAgICBpICYmIHBhcnRzW2kgLSAxXS50eXBlICE9PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6ICduJyB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0b2tlbnMgb3JkZXJcblxuICAgICAgICBsZXQgb3BlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgYW4gb3BlcmF0b3IgaW4gaW52YWxpZCBwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLm9wZXJhdG9ycy5pbmNsdWRlcyhwYXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgYW4gdW5rbm93biBvcGVyYXRvciAke3BhcnQudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbWlzc2luZyBleHBlY3RlZCBvcGVyYXRvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRvciA9ICFvcGVyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBjb250YWlucyBpbnZhbGlkIHRyYWlsaW5nIG9wZXJhdG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZGVudGlmeSBzaW5nbGUgcGFydFxuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIFsncmVmZXJlbmNlJywgJ2xpdGVyYWwnLCAnY29uc3RhbnQnXS5pbmNsdWRlcyhwYXJ0c1swXS50eXBlKSkge1xuXG4gICAgICAgICAgICB0aGlzLnNpbmdsZSA9IHsgdHlwZTogcGFydHNbMF0udHlwZSA9PT0gJ3JlZmVyZW5jZScgPyAncmVmZXJlbmNlJyA6ICd2YWx1ZScsIHZhbHVlOiBwYXJ0c1swXS52YWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhdG9yc1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkgPyBwYXJ0IDogcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGl0ZXJhbHMsIGNvbnN0YW50cywgc2VnbWVudHNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50b2tlblJ4ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuc2V0dGluZ3MudG9rZW5SeC50ZXN0KHBhcnQudmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCByZWZlcmVuY2UgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UocGFydC52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc3ViRm9ybXVsYShzdHJpbmcsIG5hbWUpIHtcblxuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLnNldHRpbmdzLmZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyB1bmtub3duIGZ1bmN0aW9uICR7bmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICAgICAgbGV0IGxpdGVyYWwgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGZ1bmN0aW9uICR7bmFtZX0gd2l0aCBpbnZhbGlkIGFyZ3VtZW50cyAke3N0cmluZ31gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcsJyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBhcmdzLm1hcCgoYXJnKSA9PiBuZXcgZXhwb3J0cy5QYXJzZXIoYXJnLCB0aGlzLnNldHRpbmdzKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyVmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJWYWx1ZXMucHVzaChhcmcuZXZhbHVhdGUoY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwoY29udGV4dCwgLi4uaW5uZXJWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcblxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX3BhcnRzLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gUHJlZml4IG9wZXJhdG9yc1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgJiZcbiAgICAgICAgICAgICAgICBwYXJ0LnR5cGUgPT09ICdvcGVyYXRvcicpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGludGVybmFscy5ldmFsdWF0ZShjdXJyZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGludGVybmFscy5zaW5nbGUocGFydC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGVmdC1yaWdodCBvcGVyYXRvcnNcblxuICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzT3JkZXIuZm9yRWFjaCgoc2V0KSA9PiB7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0LmluY2x1ZGVzKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgLSAxXSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgKyAxXSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuY2FsY3VsYXRlKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW2kgLSAxXSA9IHJlc3VsdCA9PT0gMCA/IDAgOiByZXN1bHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgLTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXZhbHVhdGUocGFydHNbMF0sIGNvbnRleHQpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5QYXJzZXIucHJvdG90eXBlW2ludGVybmFscy5zeW1ib2xdID0gdHJ1ZTtcblxuXG5pbnRlcm5hbHMucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgIHJldHVybiBjb250ZXh0ICYmIGNvbnRleHRbbmFtZV0gIT09IHVuZGVmaW5lZCA/IGNvbnRleHRbbmFtZV0gOiBudWxsO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChwYXJ0LCBjb250ZXh0KSB7XG5cbiAgICBpZiAocGFydCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRbaW50ZXJuYWxzLnN5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnQ7XG59O1xuXG5cbmludGVybmFscy5zaW5nbGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHZhbHVlKSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICchJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgLy8gb3BlcmF0b3IgPT09ICduJ1xuXG4gICAgY29uc3QgbmVnYXRpdmUgPSAtdmFsdWU7XG4gICAgaWYgKG5lZ2F0aXZlID09PSAwKSB7ICAgICAgIC8vIE92ZXJyaWRlIC0wXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZWdhdGl2ZTtcbn07XG5cblxuaW50ZXJuYWxzLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcblxuICAgIGlmIChvcGVyYXRvciA9PT0gJz8/Jykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV4aXN0cyhsZWZ0KSA/IGxlZnQgOiByaWdodDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcrJykge1xuICAgICAgICAgICAgbGVmdCA9IGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogJyc7XG4gICAgICAgICAgICByaWdodCA9IGludGVybmFscy5leGlzdHMocmlnaHQpID8gcmlnaHQgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ14nOiByZXR1cm4gTWF0aC5wb3cobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBsZWZ0IDwgcmlnaHQ7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gbGVmdCA+IHJpZ2h0O1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBsZWZ0ID49IHJpZ2h0O1xuICAgICAgICBjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgY2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyYmJzogcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgIGNhc2UgJ3x8JzogcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5leGlzdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgYW5ub3RhdGlvbnM6IFN5bWJvbCgnYW5ub3RhdGlvbnMnKVxufTtcblxuXG5leHBvcnRzLmVycm9yID0gZnVuY3Rpb24gKHN0cmlwQ29sb3JDb2Rlcykge1xuXG4gICAgaWYgKCF0aGlzLl9vcmlnaW5hbCB8fFxuICAgICAgICB0eXBlb2YgdGhpcy5fb3JpZ2luYWwgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsc1swXS5tZXNzYWdlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZEZnRXNjYXBlID0gc3RyaXBDb2xvckNvZGVzID8gJycgOiAnXFx1MDAxYlszMW0nO1xuICAgIGNvbnN0IHJlZEJnRXNjYXBlID0gc3RyaXBDb2xvckNvZGVzID8gJycgOiAnXFx1MDAxYls0MW0nO1xuICAgIGNvbnN0IGVuZENvbG9yID0gc3RyaXBDb2xvckNvZGVzID8gJycgOiAnXFx1MDAxYlswbSc7XG5cbiAgICBjb25zdCBvYmogPSBDbG9uZSh0aGlzLl9vcmlnaW5hbCk7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5kZXRhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7ICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIHRvIHByb2Nlc3MgZGVlcGVzdCBjaGlsZCBmaXJzdFxuICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmRldGFpbHNbaV07XG4gICAgICAgIGNvbnN0IHBhdGggPSBlcnJvci5wYXRoO1xuICAgICAgICBsZXQgbm9kZSA9IG9iajtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBzZWcgPSBwYXRoW2pdO1xuXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqb2kgc2NoZW1hcyBhcmUgbm90IGNsb25lZCBieSBob2VrLCB3ZSBoYXZlIHRvIHRha2UgdGhpcyBleHRyYSBzdGVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqICsgMSA8IHBhdGgubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGVbc2VnXSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlW3NlZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZBbm5vdGF0aW9ucyA9IG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSB8fCB7IGVycm9yczoge30sIG1pc3Npbmc6IHt9IH07XG4gICAgICAgICAgICAgICAgbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdID0gcmVmQW5ub3RhdGlvbnM7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNlZyB8fCBlcnJvci5jb250ZXh0LmtleTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlW3NlZ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldID0gcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5taXNzaW5nW2NhY2hlS2V5XSA9IHBvcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcGxhY2VycyA9IHtcbiAgICAgICAga2V5OiAvX1xcJGtleVxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIi9nLFxuICAgICAgICBtaXNzaW5nOiAvXCJfXFwkbWlzc1xcJF8oW158XSspXFx8KFxcZCspX1xcJGVuZFxcJF9cIjogXCJfX21pc3NpbmdfX1wiL2csXG4gICAgICAgIGFycmF5SW5kZXg6IC9cXHMqXCJfXFwkaWR4XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiLD9cXG4oLiopL2csXG4gICAgICAgIHNwZWNpYWxzOiAvXCJcXFsoTmFOfFN5bWJvbC4qfC0/SW5maW5pdHl8ZnVuY3Rpb24uKnxcXCguKildXCIvZ1xuICAgIH07XG5cbiAgICBsZXQgbWVzc2FnZSA9IGludGVybmFscy5zYWZlU3RyaW5naWZ5KG9iaiwgMilcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmtleSwgKCQwLCAkMSkgPT4gYFwiICR7cmVkRmdFc2NhcGV9WyR7JDF9XSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLm1pc3NpbmcsICgkMCwgJDEsICQyKSA9PiBgJHtyZWRCZ0VzY2FwZX1cIiR7JDF9XCIke2VuZENvbG9yfSR7cmVkRmdFc2NhcGV9IFskeyQyfV06IC0tIG1pc3NpbmcgLS0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5hcnJheUluZGV4LCAoJDAsICQxLCAkMikgPT4gYFxcbiR7JDJ9ICR7cmVkRmdFc2NhcGV9WyR7JDF9XSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLnNwZWNpYWxzLCAoJDAsICQxKSA9PiAkMSk7XG5cbiAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG4ke3JlZEZnRXNjYXBlfWA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGV0YWlscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuWyR7cG9zfV0gJHt0aGlzLmRldGFpbHNbaV0ubWVzc2FnZX1gO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgZW5kQ29sb3I7XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG5cblxuLy8gSW5zcGlyZWQgYnkganNvbi1zdHJpbmdpZnktc2FmZVxuXG5pbnRlcm5hbHMuc2FmZVN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIHNwYWNlcykge1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgaW50ZXJuYWxzLnNlcmlhbGl6ZXIoKSwgc3BhY2VzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICAgIGNvbnN0IGN5Y2xlUmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKH50aGlzUG9zKSB7XG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzW3RoaXNQb3NdID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3ljbGVSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gdmFsdWVbaW50ZXJuYWxzLmFubm90YXRpb25zXTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0ZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuZXJyb3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2goYF8kaWR4JF8ke2Fubm90YXRpb25zLmVycm9yc1tpXS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW5ub3RhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlcnJvcktleSBpbiBhbm5vdGF0aW9ucy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Ake2Vycm9yS2V5fV8ka2V5JF8ke2Fubm90YXRpb25zLmVycm9yc1tlcnJvcktleV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2BdID0gdmFsdWVbZXJyb3JLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbZXJyb3JLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaXNzaW5nS2V5IGluIGFubm90YXRpb25zLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2BfJG1pc3MkXyR7bWlzc2luZ0tleX18JHthbm5vdGF0aW9ucy5taXNzaW5nW21pc3NpbmdLZXldfV8kZW5kJF9gXSA9ICdfX21pc3NpbmdfXyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gLUluZmluaXR5IHx8XG4gICAgICAgICAgICBOdW1iZXIuaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuICdbJyArIHZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbm5vdGF0ZSA9IHJlcXVpcmUoJy4vYW5ub3RhdGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSkge1xuXG4gICAgICAgIGlmIChtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bY29kZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bJyonXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bJyonXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWVzc2FnZXNbY29kZV0pIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzWycqJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzW2NvZGVdO1xufTtcblxuXG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGZsYWdzLCBzdGF0ZSwgcHJlZnMsIG1lc3NhZ2VzKSB7XG5cbiAgICBpZiAoZmxhZ3MubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzLmxhYmVsO1xuICAgIH1cblxuICAgIGlmICghcHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgaWYgKHByZWZzLmVycm9ycy5sYWJlbCA9PT0gJ2tleScgJiZcbiAgICAgICAgc3RhdGUucGF0aC5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgcGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoLTEpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBleHBvcnRzLnBhdGgocGF0aCk7XG4gICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgcHJlZnMubWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICBtZXNzYWdlcyAmJiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIG1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgJ3ZhbHVlJztcbn07XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKGVycm9ycywgb3JpZ2luYWwsIHByZWZzKSB7XG5cbiAgICBpZiAoIWVycm9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG92ZXJyaWRlLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBleHBvcnRzLmRldGFpbHMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5lcnJvcnMuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuZGV0YWlscyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgZGV0YWlscyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGVycm9ycykge1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcnJpZGU6IGl0ZW0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgZXJyb3I6IGl0ZW0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aC5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyksXG4gICAgICAgICAgICB0eXBlOiBpdGVtLmNvZGUsXG4gICAgICAgICAgICBjb250ZXh0OiBpdGVtLmxvY2FsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gWy4uLm5ldyBTZXQobWVzc2FnZXMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKCcuICcpLCBkZXRhaWxzIH07XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCkge1xuXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IG9yaWdpbmFsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Vycm9yKGVycikge1xuXG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBleHBvcnRzLlZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pc0pvaSA9IHRydWU7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5hbm5vdGF0ZSA9IEFubm90YXRlLmVycm9yO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbmxldCBUZW1wbGF0ZTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3ltYm9sOiBTeW1ib2woJ3JlZicpLCAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSByZWZlcmVuY2VzIChzaGFyZWQgd2l0aCBvdGhlciBqb2kgdmVyc2lvbnMpXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWRqdXN0OiBudWxsLFxuICAgICAgICBpbjogZmFsc2UsXG4gICAgICAgIGl0ZXJhYmxlczogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICBzZXBhcmF0b3I6ICcuJyxcbiAgICAgICAgdHlwZTogJ3ZhbHVlJ1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIEFzc2VydCh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcmVmZXJlbmNlIGtleTonLCBrZXkpO1xuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWRqdXN0JywgJ2FuY2VzdG9yJywgJ2luJywgJ2l0ZXJhYmxlcycsICdtYXAnLCAncHJlZml4JywgJ3JlbmRlcicsICdzZXBhcmF0b3InXSk7XG4gICAgQXNzZXJ0KCFvcHRpb25zLnByZWZpeCB8fCB0eXBlb2Ygb3B0aW9ucy5wcmVmaXggPT09ICdvYmplY3QnLCAnb3B0aW9ucy5wcmVmaXggbXVzdCBiZSBvZiB0eXBlIG9iamVjdCcpO1xuXG4gICAgY29uc3QgcmVmID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICBkZWxldGUgcmVmLnByZWZpeDtcblxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHJlZi5zZXBhcmF0b3I7XG4gICAgY29uc3QgY29udGV4dCA9IGludGVybmFscy5jb250ZXh0KGtleSwgc2VwYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgcmVmLnR5cGUgPSBjb250ZXh0LnR5cGU7XG4gICAga2V5ID0gY29udGV4dC5rZXk7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgaWYgKGNvbnRleHQucm9vdCkge1xuICAgICAgICAgICAgQXNzZXJ0KCFzZXBhcmF0b3IgfHwga2V5WzBdICE9PSBzZXBhcmF0b3IsICdDYW5ub3Qgc3BlY2lmeSByZWxhdGl2ZSBwYXRoIHdpdGggcm9vdCBwcmVmaXgnKTtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9ICdyb290JztcbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIHNlcGFyYXRvciA9PT0ga2V5KSB7XG5cbiAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlZi5hbmNlc3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXBhcmF0b3IgfHwgIWtleSB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBjb21iaW5lIHByZWZpeCB3aXRoIGFuY2VzdG9yIG9wdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2FuY2VzdG9yLCBzbGljZV0gPSBpbnRlcm5hbHMuYW5jZXN0b3Ioa2V5LCBzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc2xpY2Uoc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IGFuY2VzdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVmLnBhdGggPSBzZXBhcmF0b3IgPyAoa2V5ID09PSBudWxsID8gW10gOiBrZXkuc3BsaXQoc2VwYXJhdG9yKSkgOiBba2V5XTtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJlZihyZWYpO1xufTtcblxuXG5leHBvcnRzLmluID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGUoa2V5LCB7IC4uLm9wdGlvbnMsIGluOiB0cnVlIH0pO1xufTtcblxuXG5leHBvcnRzLmlzUmVmID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgcmV0dXJuIHJlZiA/ICEhcmVmW0NvbW1vbi5zeW1ib2xzLnJlZl0gOiBmYWxzZTtcbn07XG5cblxuaW50ZXJuYWxzLlJlZiA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCByZWZlcmVuY2UgY29uc3RydWN0aW9uJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFtcbiAgICAgICAgICAgICdhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwYXRoJywgJ3JlbmRlcicsICdzZXBhcmF0b3InLCAndHlwZScsICAvLyBDb3BpZWRcbiAgICAgICAgICAgICdkZXB0aCcsICdrZXknLCAncm9vdCcsICdkaXNwbGF5JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZGVuXG4gICAgICAgIF0pO1xuXG4gICAgICAgIEFzc2VydChbZmFsc2UsIHVuZGVmaW5lZF0uaW5jbHVkZXMob3B0aW9ucy5zZXBhcmF0b3IpIHx8IHR5cGVvZiBvcHRpb25zLnNlcGFyYXRvciA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5zZXBhcmF0b3IubGVuZ3RoID09PSAxLCAnSW52YWxpZCBzZXBhcmF0b3InKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLmFkanVzdCB8fCB0eXBlb2Ygb3B0aW9ucy5hZGp1c3QgPT09ICdmdW5jdGlvbicsICdvcHRpb25zLmFkanVzdCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLm1hcCB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMubWFwKSwgJ29wdGlvbnMubWFwIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLm1hcCB8fCAhb3B0aW9ucy5hZGp1c3QsICdDYW5ub3Qgc2V0IGJvdGggbWFwIGFuZCBhZGp1c3Qgb3B0aW9ucycpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBBc3NlcnQodGhpcy50eXBlID09PSAndmFsdWUnIHx8IHRoaXMuYW5jZXN0b3IgPT09IHVuZGVmaW5lZCwgJ05vbi12YWx1ZSByZWZlcmVuY2VzIGNhbm5vdCByZWZlcmVuY2UgYW5jZXN0b3JzJyk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5tYXApKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy5tYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMucGF0aC5sZW5ndGg7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5wYXRoLmxlbmd0aCA/IHRoaXMucGF0aC5qb2luKHRoaXMuc2VwYXJhdG9yKSA6IG51bGw7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGF0aFswXTtcblxuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9XG5cbiAgICByZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuaW4gfHwgb3B0aW9ucy5pbiwgJ0ludmFsaWQgaW4oKSByZWZlcmVuY2UgdXNhZ2UnKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUocHJlZnMuY29udGV4dCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUobG9jYWwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hbmNlc3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1tzdGF0ZS5hbmNlc3RvcnMubGVuZ3RoIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0aGlzLmFuY2VzdG9yIDw9IHN0YXRlLmFuY2VzdG9ycy5sZW5ndGgsICdJbnZhbGlkIHJlZmVyZW5jZSBleGNlZWRzIHRoZSBzY2hlbWEgcm9vdDonLCB0aGlzLmRpc3BsYXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShzdGF0ZS5hbmNlc3RvcnNbdGhpcy5hbmNlc3RvciAtIDFdLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX3Jlc29sdmUodGFyZ2V0LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGxldCByZXNvbHZlZDtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5zaGFkb3cgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuc2hhZG93ICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgICByZXNvbHZlZCA9IHN0YXRlLm1haW5zdGF5LnNoYWRvdy5nZXQodGhpcy5hYnNvbHV0ZShzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gUmVhY2godGFyZ2V0LCB0aGlzLnBhdGgsIHsgaXRlcmFibGVzOiB0aGlzLml0ZXJhYmxlcywgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWRqdXN0KSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHRoaXMuYWRqdXN0KHJlc29sdmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVkID0gdGhpcy5tYXAuZ2V0KHJlc29sdmVkKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gbWFwcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLm1haW5zdGF5KSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIucmVzb2x2ZShzdGF0ZSwgdGhpcywgcmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXk7XG4gICAgfVxuXG4gICAgYWJzb2x1dGUoc3RhdGUpIHtcblxuICAgICAgICByZXR1cm4gWy4uLnN0YXRlLnBhdGguc2xpY2UoMCwgLXRoaXMuYW5jZXN0b3IpLCAuLi50aGlzLnBhdGhdO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJlZih0aGlzKTtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCByZWYgPSB7IHBhdGg6IHRoaXMucGF0aCB9O1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHJlZi50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgIHJlZi5zZXBhcmF0b3IgPSB0aGlzLnNlcGFyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHRoaXMuYW5jZXN0b3IgIT09IDEpIHtcblxuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gdGhpcy5hbmNlc3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgcmVmLm1hcCA9IFsuLi50aGlzLm1hcF07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ2FkanVzdCcsICdpdGVyYWJsZXMnLCAncmVuZGVyJ10pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgcmVmW2tleV0gPSB0aGlzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlZi5pbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyByZWYgfTtcbiAgICB9XG5cbiAgICB1cGRhdGVEaXNwbGF5KCkge1xuXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5ICE9PSBudWxsID8gdGhpcy5rZXkgOiAnJztcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke3RoaXMudHlwZX06JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hbmNlc3Rvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke3RoaXMuc2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOnJvb3Q6JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7a2V5IHx8ICcuLid9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlYWQgPSBuZXcgQXJyYXkodGhpcy5hbmNlc3RvciArIDEpLmZpbGwodGhpcy5zZXBhcmF0b3IpLmpvaW4oJycpO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7bGVhZH0ke2tleSB8fCAnJ31gO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlJlZi5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMucmVmXSA9IHRydWU7XG5cblxuZXhwb3J0cy5idWlsZCA9IGZ1bmN0aW9uIChkZXNjKSB7XG5cbiAgICBkZXNjID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxzLmRlZmF1bHRzLCBkZXNjKTtcbiAgICBpZiAoZGVzYy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgIGRlc2MuYW5jZXN0b3IgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGRlc2MuYW5jZXN0b3IgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJlZihkZXNjKTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnRleHQgPSBmdW5jdGlvbiAoa2V5LCBzZXBhcmF0b3IsIHByZWZpeCA9IHt9KSB7XG5cbiAgICBrZXkgPSBrZXkudHJpbSgpO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICBjb25zdCBnbG9iYWxwID0gcHJlZml4Lmdsb2JhbCA9PT0gdW5kZWZpbmVkID8gJyQnIDogcHJlZml4Lmdsb2JhbDtcbiAgICAgICAgaWYgKGdsb2JhbHAgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgoZ2xvYmFscCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2UoZ2xvYmFscC5sZW5ndGgpLCB0eXBlOiAnZ2xvYmFsJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jYWwgPSBwcmVmaXgubG9jYWwgPT09IHVuZGVmaW5lZCA/ICcjJyA6IHByZWZpeC5sb2NhbDtcbiAgICAgICAgaWYgKGxvY2FsICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGxvY2FsKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShsb2NhbC5sZW5ndGgpLCB0eXBlOiAnbG9jYWwnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb290ID0gcHJlZml4LnJvb3QgPT09IHVuZGVmaW5lZCA/ICcvJyA6IHByZWZpeC5yb290O1xuICAgICAgICBpZiAocm9vdCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChyb290KSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShyb290Lmxlbmd0aCksIHR5cGU6ICd2YWx1ZScsIHJvb3Q6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGtleSwgdHlwZTogJ3ZhbHVlJyB9O1xufTtcblxuXG5pbnRlcm5hbHMuYW5jZXN0b3IgPSBmdW5jdGlvbiAoa2V5LCBzZXBhcmF0b3IpIHtcblxuICAgIGlmICghc2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBbMSwgMF07ICAgICAgICAgICAgICAvLyAnYV9iJyAtPiAxIChwYXJlbnQpXG4gICAgfVxuXG4gICAgaWYgKGtleVswXSAhPT0gc2VwYXJhdG9yKSB7ICAgICAvLyAnYS5iJyAtPiAxIChwYXJlbnQpXG4gICAgICAgIHJldHVybiBbMSwgMF07XG4gICAgfVxuXG4gICAgaWYgKGtleVsxXSAhPT0gc2VwYXJhdG9yKSB7ICAgICAvLyAnLmEuYicgLT4gMCAoc2VsZilcbiAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDI7XG4gICAgd2hpbGUgKGtleVtpXSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICsraTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2kgLSAxLCBpXTsgICAgICAgICAgICAgIC8vICcuLi5hLmIuJyAtPiAyIChncmFuZHBhcmVudClcbn07XG5cblxuZXhwb3J0cy50b1NpYmxpbmcgPSAwO1xuXG5leHBvcnRzLnRvUGFyZW50ID0gMTtcblxuXG5leHBvcnRzLk1hbmFnZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnJlZnMgPSBbXTsgICAgICAgICAgICAgICAgICAgICAvLyAwOiBbc2VsZiByZWZzXSwgMTogW3BhcmVudCByZWZzXSwgMjogW2dyYW5kcGFyZW50IHJlZnNdLCAuLi5cbiAgICB9XG5cbiAgICByZWdpc3Rlcihzb3VyY2UsIHRhcmdldCkge1xuXG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMudG9QYXJlbnQgOiB0YXJnZXQ7XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHJlZiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NoZW1hXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlLl9yZWZzLnJlZnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IGl0ZW0uYW5jZXN0b3IgLSB0YXJnZXQsIHJvb3Q6IGl0ZW0ucm9vdCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChleHBvcnRzLmlzUmVmKHNvdXJjZSkgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICBzb3VyY2UuYW5jZXN0b3IgLSB0YXJnZXQgPj0gMCkge1xuXG4gICAgICAgICAgICB0aGlzLnJlZnMucHVzaCh7IGFuY2VzdG9yOiBzb3VyY2UuYW5jZXN0b3IgLSB0YXJnZXQsIHJvb3Q6IHNvdXJjZS5yb290IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVtcGxhdGVcblxuICAgICAgICBUZW1wbGF0ZSA9IFRlbXBsYXRlIHx8IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuICAgICAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHNvdXJjZS5yZWZzKCksIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgZXhwb3J0cy5NYW5hZ2VyKCk7XG4gICAgICAgIGNvcHkucmVmcyA9IENsb25lKHRoaXMucmVmcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdO1xuICAgIH1cblxuICAgIHJvb3RzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMuZmlsdGVyKChyZWYpID0+ICFyZWYuYW5jZXN0b3IpLm1hcCgocmVmKSA9PiByZWYucm9vdCk7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRXNjYXBlSHRtbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZUh0bWwnKTtcbmNvbnN0IEZvcm11bGEgPSByZXF1aXJlKCdAc2lkZXdheS9mb3JtdWxhJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3ltYm9sOiBTeW1ib2woJ3RlbXBsYXRlJyksXG5cbiAgICBvcGVuczogbmV3IEFycmF5KDEwMDApLmpvaW4oJ1xcdTAwMDAnKSxcbiAgICBjbG9zZXM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAxJyksXG5cbiAgICBkYXRlRm9ybWF0OiB7XG4gICAgICAgIGRhdGU6IERhdGUucHJvdG90eXBlLnRvRGF0ZVN0cmluZyxcbiAgICAgICAgaXNvOiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyxcbiAgICAgICAgc3RyaW5nOiBEYXRlLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgdGltZTogRGF0ZS5wcm90b3R5cGUudG9UaW1lU3RyaW5nLFxuICAgICAgICB1dGM6IERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nXG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBpbnRlcm5hbHMuVGVtcGxhdGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycsICdUZW1wbGF0ZSBzb3VyY2UgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5pbmNsdWRlcygnXFx1MDAwMCcpICYmICFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDEnKSwgJ1RlbXBsYXRlIHNvdXJjZSBjYW5ub3QgY29udGFpbiByZXNlcnZlZCBjb250cm9sIGNoYXJhY3RlcnMnKTtcblxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHNvdXJjZTtcblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnVuY3Rpb25zLCAuLi5vcHRzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPyBDbG9uZShvcHRzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoT2JqZWN0LmtleXModGhpcy5fZnVuY3Rpb25zKS5ldmVyeSgoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyksICdGdW5jdGlvbnMga2V5cyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoT2JqZWN0LnZhbHVlcyh0aGlzLl9mdW5jdGlvbnMpLmV2ZXJ5KChrZXkpID0+IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpLCAnRnVuY3Rpb25zIHZhbHVlcyBtdXN0IGJlIGZ1bmN0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXJzZSgpO1xuICAgIH1cblxuICAgIF9wYXJzZSgpIHtcblxuICAgICAgICAvLyAndGV4dCB7cmF3fSB7e3JlZn19IFxcXFx7e2lnbm9yZX19IHt7aWdub3JlXFxcXH19IHt7aWdub3JlIHt7aWdub3JlfSdcblxuICAgICAgICBpZiAoIXRoaXMuc291cmNlLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuY29kZSBlc2NhcGVkIFxcXFx7e3t7e1xuXG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBpbnRlcm5hbHMuZW5jb2RlKHRoaXMuc291cmNlKTtcblxuICAgICAgICAvLyBTcGxpdCBvbiBmaXJzdCB7IGluIGVhY2ggc2V0XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSBpbnRlcm5hbHMuc3BsaXQoZW5jb2RlZCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIGxldCByZWZzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICBjb25zdCBoZWFkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBwYXJ0WzBdICE9PSAneyc7XG4gICAgICAgICAgICBjb25zdCBlbmRlciA9IHJhdyA/ICd9JyA6ICd9fSc7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwYXJ0LmluZGV4T2YoZW5kZXIpO1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEgfHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG5vbi1tYXRjaGluZyBjbG9zaW5nXG4gICAgICAgICAgICAgICAgcGFydFsxXSA9PT0gJ3snKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbW9yZSB0aGFuIHR3byB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChgeyR7aW50ZXJuYWxzLmRlY29kZShwYXJ0KX1gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhcmlhYmxlID0gcGFydC5zbGljZShyYXcgPyAwIDogMSwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSB2YXJpYWJsZVswXSA9PT0gJzonO1xuICAgICAgICAgICAgaWYgKHdyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljID0gdGhpcy5fcmVmKGludGVybmFscy5kZWNvZGUodmFyaWFibGUpLCB7IHJhdywgd3JhcHBlZCB9KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGR5bmFtaWMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkeW5hbWljICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gcGFydC5zbGljZShlbmQgKyBlbmRlci5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChpbnRlcm5hbHMuZGVjb2RlKHJlc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHByb2Nlc3NlZC5qb2luKCcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gcHJvY2Vzc2VkO1xuICAgIH1cblxuICAgIHN0YXRpYyBkYXRlKGRhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlRm9ybWF0W3ByZWZzLmRhdGVGb3JtYXRdLmNhbGwoZGF0ZSk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb21wYWN0KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB7IHRlbXBsYXRlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHRoaXMuX3NldHRpbmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgZGVzYy5mdW5jdGlvbnMgPSB0aGlzLl9mdW5jdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG5cbiAgICBzdGF0aWMgYnVpbGQoZGVzYykge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlRlbXBsYXRlKGRlc2MudGVtcGxhdGUsIGRlc2Mub3B0aW9ucyB8fCBkZXNjLmZ1bmN0aW9ucyA/IHsgLi4uZGVzYy5vcHRpb25zLCBmdW5jdGlvbnM6IGRlc2MuZnVuY3Rpb25zIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGlzRHluYW1pYygpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSA/ICEhdGVtcGxhdGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmVmcygpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCguLi5wYXJ0LnJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCkge1xuXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0KHRoaXMuX3RlbXBsYXRlWzBdLCAvKiBjb250ZXh0IC0+IFsqLyB2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwge30gLypdICovKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCk7XG4gICAgfVxuXG4gICAgX3BhcnQocGFydCwgLi4uYXJncykge1xuXG4gICAgICAgIGlmIChwYXJ0LnJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQucmVmLnJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydC5mb3JtdWxhLmV2YWx1YXRlKGFyZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZCA9IHRoaXMuX3BhcnQocGFydCwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgLypdICovKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KHJlbmRlcmVkLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnQucmF3IHx8IChvcHRpb25zLmVycm9ycyAmJiBvcHRpb25zLmVycm9ycy5lc2NhcGVIdG1sKSA9PT0gZmFsc2UgPyBzdHJpbmcgOiBFc2NhcGVIdG1sKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goaW50ZXJuYWxzLndyYXAocmVzdWx0LCBwYXJ0LndyYXBwZWQgJiYgcHJlZnMuZXJyb3JzLndyYXAubGFiZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgX3JlZihjb250ZW50LCB7IHJhdywgd3JhcHBlZCB9KSB7XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSAodmFyaWFibGUpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVmID0gUmVmLmNyZWF0ZSh2YXJpYWJsZSwgdGhpcy5fc2V0dGluZ3MpO1xuICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVmLnJlc29sdmUoLi4uY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkICE9PSB1bmRlZmluZWQgPyByZXNvbHZlZCA6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSB0aGlzLl9mdW5jdGlvbnMgPyB7IC4uLmludGVybmFscy5mdW5jdGlvbnMsIC4uLnRoaXMuX2Z1bmN0aW9ucyB9IDogaW50ZXJuYWxzLmZ1bmN0aW9ucztcbiAgICAgICAgICAgIHZhciBmb3JtdWxhID0gbmV3IEZvcm11bGEuUGFyc2VyKGNvbnRlbnQsIHsgcmVmZXJlbmNlLCBmdW5jdGlvbnMsIGNvbnN0YW50czogaW50ZXJuYWxzLmNvbnN0YW50cyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBJbnZhbGlkIHRlbXBsYXRlIHZhcmlhYmxlIFwiJHtjb250ZW50fVwiIGZhaWxzIGR1ZSB0bzogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlKSB7XG4gICAgICAgICAgICBpZiAoZm9ybXVsYS5zaW5nbGUudHlwZSA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSByZWZzWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlZiwgcmF3LCByZWZzLCB3cmFwcGVkOiB3cmFwcGVkIHx8IHJlZi50eXBlID09PSAnbG9jYWwnICYmIHJlZi5rZXkgPT09ICdsYWJlbCcgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zdHJpbmdpZnkoZm9ybXVsYS5zaW5nbGUudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZm9ybXVsYSwgcmF3LCByZWZzIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlRlbXBsYXRlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy50ZW1wbGF0ZV0gPSB0cnVlO1xuaW50ZXJuYWxzLlRlbXBsYXRlLnByb3RvdHlwZS5pc0ltbXV0YWJsZSA9IHRydWU7ICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIEhvZWsgZnJvbSBkZWVwIGNsb25pbmcgc2NoZW1hIG9iamVjdHNcblxuXG5pbnRlcm5hbHMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAucmVwbGFjZSgvXFxcXChcXHsrKS9nLCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMub3BlbnMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx9KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb3Nlcy5zbGljZSgwLCAkMS5sZW5ndGgpO1xuICAgICAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDAvZywgJ3snKVxuICAgICAgICAucmVwbGFjZSgvXFx1MDAwMS9nLCAnfScpO1xufTtcblxuXG5pbnRlcm5hbHMuc3BsaXQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyaW5nW2ldO1xuXG4gICAgICAgIGlmIChjaGFyID09PSAneycpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBzdHJpbmcubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgc3RyaW5nW2kgKyAxXSA9PT0gJ3snKSB7XG5cbiAgICAgICAgICAgICAgICBuZXh0ICs9ICd7JztcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRzLnB1c2goY3VycmVudCk7XG4gICAgcmV0dXJuIHBhcnRzO1xufTtcblxuXG5pbnRlcm5hbHMud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kcykge1xuXG4gICAgaWYgKCFlbmRzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGAke2VuZHN9JHt2YWx1ZX0ke2VuZHN9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7ZW5kc1swXX0ke3ZhbHVlfSR7ZW5kc1sxXX1gO1xufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCBvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNvbnN0IHdyYXAgPSBwcmVmcyAmJiBwcmVmcy5lcnJvcnMgJiYgcHJlZnMuZXJyb3JzLndyYXAgfHwge307XG5cbiAgICBsZXQgc2tpcFdyYXAgPSBmYWxzZTtcbiAgICBpZiAoUmVmLmlzUmVmKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5yZW5kZXIpIHtcblxuICAgICAgICBza2lwV3JhcCA9IHZhbHVlLmluO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlc29sdmUob3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHsgaW46IHZhbHVlLmluLCAuLi5vcHRpb25zIH0pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAodmFsdWUsIG9wdGlvbnMuYXJyYXlJdGVtcyAmJiB3cmFwLnN0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHN5bV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKGAke2tleS50b1N0cmluZygpfSAtPiAke3N5bS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBwYWlycztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChpbnRlcm5hbHMuc3RyaW5naWZ5KGl0ZW0sIG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCB7IGFycmF5SXRlbXM6IHRydWUsIC4uLm9wdGlvbnMgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMud3JhcCh2YWx1ZXMuam9pbignLCAnKSwgIXNraXBXcmFwICYmIHdyYXAuYXJyYXkpO1xufTtcblxuXG5pbnRlcm5hbHMuY29uc3RhbnRzID0ge1xuXG4gICAgdHJ1ZTogdHJ1ZSxcbiAgICBmYWxzZTogZmFsc2UsXG4gICAgbnVsbDogbnVsbCxcblxuICAgIHNlY29uZDogMTAwMCxcbiAgICBtaW51dGU6IDYwICogMTAwMCxcbiAgICBob3VyOiA2MCAqIDYwICogMTAwMCxcbiAgICBkYXk6IDI0ICogNjAgKiA2MCAqIDEwMDBcbn07XG5cblxuaW50ZXJuYWxzLmZ1bmN0aW9ucyA9IHtcblxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbiwgb3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRoZW4gOiBvdGhlcndpc2U7XG4gICAgfSxcblxuICAgIGxlbmd0aChpdGVtKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpdGVtIHx8IHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW0pLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgbXNnKGNvZGUpIHtcblxuICAgICAgICBjb25zdCBbdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnNdID0gdGhpcztcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBvcHRpb25zLm1lc3NhZ2VzO1xuICAgICAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMF0sIGNvZGUsIHN0YXRlLCBwcmVmcykgfHwgRXJyb3JzLnRlbXBsYXRlKHZhbHVlLCBtZXNzYWdlc1sxXSwgY29kZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIG51bWJlcih2YWx1ZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgdGFyZ2V0KSB7XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nICgncGxhaW4gZXJyb3IgbWVzc2FnZScsICd0ZW1wbGF0ZSB7ZXJyb3J9IG1lc3NhZ2UnKVxuXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHN0cmluZycpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKG1lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2VzKSkge1xuICAgICAgICBBc3NlcnQoIXRhcmdldCwgJ0Nhbm5vdCBzZXQgc2luZ2xlIG1lc3NhZ2UgdGVtcGxhdGUnKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cblxuICAgIC8vIEJ5IGVycm9yIGNvZGUgeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZXMpLCAnSW52YWxpZCBtZXNzYWdlIG9wdGlvbnMnKTtcblxuICAgIHRhcmdldCA9IHRhcmdldCA/IENsb25lKHRhcmdldCkgOiB7fTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMuZGVjb21waWxlID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAobGV0IGNvZGUgaW4gbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5yb290ID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2UuZGVzY3JpYmUoeyBjb21wYWN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXS5yb290ID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYmFzZSwgZXh0ZW5kZWQpIHtcblxuICAgIGlmICghYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21waWxlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmdcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoZXh0ZW5kZWQpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoZXh0ZW5kZWQpKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IENsb25lKGJhc2UpO1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBleHRlbmRlZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXh0ZW5kZWRbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXJyb3InKTtcblxuY29uc3QgUGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmxldCBNZXNzYWdlcztcbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBpc29EYXRlOiAvXig/OlstK11cXGR7Mn0pPyg/OlxcZHs0fSg/IVxcZHsyfVxcYikpKD86KC0/KSg/Oig/OjBbMS05XXwxWzAtMl0pKD86XFwxKD86WzEyXVxcZHwwWzEtOV18M1swMV0pKT98Vyg/OlswLTRdXFxkfDVbMC0yXSkoPzotP1sxLTddKT98KD86MDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKD86WzAtNV1cXGR8NlsxLTZdKSkpKD8hW1RdJHxbVF1bXFxkXStaJCkoPzpbVFxcc10oPzooPzooPzpbMDFdXFxkfDJbMC0zXSkoPzooOj8pWzAtNV1cXGQpP3wyNFxcOj8wMCkoPzpbLixdXFxkKyg/ITopKT8pKD86XFwyWzAtNV1cXGQoPzpbLixdXFxkKyk/KT8oPzpbWl18KD86WystXSkoPzpbMDFdXFxkfDJbMC0zXSkoPzo6P1swLTVdXFxkKT8pPyk/KT8kL1xufTtcblxuXG5leHBvcnRzLnZlcnNpb24gPSBQa2cudmVyc2lvbjtcblxuXG5leHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgYWxsb3dVbmtub3duOiBmYWxzZSxcbiAgICBhcnRpZmFjdHM6IGZhbHNlLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgY29udmVydDogdHJ1ZSxcbiAgICBkYXRlRm9ybWF0OiAnaXNvJyxcbiAgICBlcnJvcnM6IHtcbiAgICAgICAgZXNjYXBlSHRtbDogZmFsc2UsXG4gICAgICAgIGxhYmVsOiAncGF0aCcsXG4gICAgICAgIGxhbmd1YWdlOiBudWxsLFxuICAgICAgICByZW5kZXI6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgICAgd3JhcDoge1xuICAgICAgICAgICAgbGFiZWw6ICdcIicsXG4gICAgICAgICAgICBhcnJheTogJ1tdJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBleHRlcm5hbHM6IHRydWUsXG4gICAgbWVzc2FnZXM6IHt9LFxuICAgIG5vbkVudW1lcmFibGVzOiBmYWxzZSxcbiAgICBub0RlZmF1bHRzOiBmYWxzZSxcbiAgICBwcmVzZW5jZTogJ29wdGlvbmFsJyxcbiAgICBza2lwRnVuY3Rpb25zOiBmYWxzZSxcbiAgICBzdHJpcFVua25vd246IGZhbHNlLFxuICAgIHdhcm5pbmdzOiBmYWxzZVxufTtcblxuXG5leHBvcnRzLnN5bWJvbHMgPSB7XG4gICAgYW55OiBTeW1ib2wuZm9yKCdAaGFwaS9qb2kvc2NoZW1hJyksICAgICAgICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IGFueS1iYXNlZCB0eXBlcyAoc2hhcmVkIHdpdGggb3RoZXIgam9pIHZlcnNpb25zKVxuICAgIGFycmF5U2luZ2xlOiBTeW1ib2woJ2FycmF5U2luZ2xlJyksXG4gICAgZGVlcERlZmF1bHQ6IFN5bWJvbCgnZGVlcERlZmF1bHQnKSxcbiAgICBlcnJvcnM6IFN5bWJvbCgnZXJyb3JzJyksXG4gICAgbGl0ZXJhbDogU3ltYm9sKCdsaXRlcmFsJyksXG4gICAgb3ZlcnJpZGU6IFN5bWJvbCgnb3ZlcnJpZGUnKSxcbiAgICBwYXJlbnQ6IFN5bWJvbCgncGFyZW50JyksXG4gICAgcHJlZnM6IFN5bWJvbCgncHJlZnMnKSxcbiAgICByZWY6IFN5bWJvbCgncmVmJyksXG4gICAgdGVtcGxhdGU6IFN5bWJvbCgndGVtcGxhdGUnKSxcbiAgICB2YWx1ZXM6IFN5bWJvbCgndmFsdWVzJylcbn07XG5cblxuZXhwb3J0cy5hc3NlcnRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGtleXMsIG5hbWUgPSAnT3B0aW9ucycpIHtcblxuICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSwgJ09wdGlvbnMgbXVzdCBiZSBvZiB0eXBlIG9iamVjdCcpO1xuICAgIGNvbnN0IHVua25vd25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAha2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgQXNzZXJ0KHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCwgYCR7bmFtZX0gY29udGFpbiB1bmtub3duIGtleXM6ICR7dW5rbm93bktleXN9YCk7XG59O1xuXG5cbmV4cG9ydHMuY2hlY2tQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChwcmVmcykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBTY2hlbWFzLnByZWZlcmVuY2VzLnZhbGlkYXRlKHByZWZzKTtcblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKFtyZXN1bHQuZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlXSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYiwgb3BlcmF0b3IpIHtcblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPSc6IHJldHVybiBhID09PSBiO1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGEgPiBiO1xuICAgICAgICBjYXNlICc8JzogcmV0dXJuIGEgPCBiO1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBhID49IGI7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGEgPD0gYjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufTtcblxuXG5leHBvcnRzLmlzSXNvRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlzb0RhdGUudGVzdChkYXRlKTtcbn07XG5cblxuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy5pc1Jlc29sdmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMucmVmXSB8fCBvYmpbZXhwb3J0cy5zeW1ib2xzLnRlbXBsYXRlXTtcbn07XG5cblxuZXhwb3J0cy5pc1NjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtleHBvcnRzLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoIWFueSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBleHBvcnRzLnZlcnNpb24sICdDYW5ub3QgbWl4IGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBqb2kgc2NoZW1hcycpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5leHBvcnRzLmlzVmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMudmFsdWVzXTtcbn07XG5cblxuZXhwb3J0cy5saW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xufTtcblxuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBNZXNzYWdlcyA9IE1lc3NhZ2VzIHx8IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICBzb3VyY2UgPSBzb3VyY2UgfHwge307XG5cbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZS5lcnJvcnMgJiZcbiAgICAgICAgdGFyZ2V0LmVycm9ycykge1xuXG4gICAgICAgIG1lcmdlZC5lcnJvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZXJyb3JzLCBzb3VyY2UuZXJyb3JzKTtcbiAgICAgICAgbWVyZ2VkLmVycm9ycy53cmFwID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LmVycm9ycy53cmFwLCBzb3VyY2UuZXJyb3JzLndyYXApO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UubWVzc2FnZXMpIHtcbiAgICAgICAgbWVyZ2VkLm1lc3NhZ2VzID0gTWVzc2FnZXMuY29tcGlsZShzb3VyY2UubWVzc2FnZXMsIHRhcmdldC5tZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG1lcmdlZFtleHBvcnRzLnN5bWJvbHMucHJlZnNdO1xuICAgIHJldHVybiBtZXJnZWQ7XG59O1xuXG5cbmV4cG9ydHMudHJ5V2l0aFBhdGggPSBmdW5jdGlvbiAoZm4sIGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLnBhdGggPSBrZXkgKyAnLicgKyBlcnIucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGVBcmcgPSBmdW5jdGlvbiAodmFsdWUsIGxhYmVsLCB7IGFzc2VydCwgbWVzc2FnZSB9KSB7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1NjaGVtYShhc3NlcnQpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzc2VydC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhc3NlcnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbCA/IGAke2xhYmVsfSAke21lc3NhZ2V9YCA6IG1lc3NhZ2U7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZlcmlmeUZsYXQgPSBmdW5jdGlvbiAoYXJncywgbWV0aG9kKSB7XG5cbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgIEFzc2VydCghQXJyYXkuaXNBcnJheShhcmcpLCAnTWV0aG9kIG5vIGxvbmdlciBhY2NlcHRzIGFycmF5IGFyZ3VtZW50czonLCBtZXRob2QpO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWF4OiAxMDAwLFxuICAgIHN1cHBvcnRlZDogbmV3IFNldChbJ3VuZGVmaW5lZCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXSlcbn07XG5cblxuZXhwb3J0cy5wcm92aWRlciA9IHtcblxuICAgIHByb3Zpc2lvbihvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQ2FjaGUob3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG4vLyBMZWFzdCBSZWNlbnRseSBVc2VkIChMUlUpIENhY2hlXG5cbmludGVybmFscy5DYWNoZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbWF4J10pO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5tYXggPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heCAmJiBvcHRpb25zLm1heCA+IDAgJiYgaXNGaW5pdGUob3B0aW9ucy5tYXgpLCAnSW52YWxpZCBtYXggY2FjaGUgc2l6ZScpO1xuXG4gICAgICAgIHRoaXMuX21heCA9IG9wdGlvbnMubWF4IHx8IGludGVybmFscy5tYXg7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIG9mIG5vZGVzIGJ5IGtleVxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IGludGVybmFscy5MaXN0KCk7ICAgICAgICAgICAgICAvLyBMaXN0IG9mIG5vZGVzIChtb3N0IHJlY2VudGx5IHVzZWQgaW4gaGVhZClcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChrZXkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMuc3VwcG9ydGVkLmhhcyh0eXBlb2Yga2V5KSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gdGhpcy5fbGlzdC51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5vZGUpO1xuICAgICAgICB0aGlzLl9jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbXBhY3QoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcC5zaXplID4gdGhpcy5fbWF4KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbGlzdC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuTGlzdCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdW5zaGlmdChub2RlKSB7XG5cbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbm9kZS5wcmV2ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZC5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBmaXJzdChub2RlKSB7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xuICAgICAgICB0aGlzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuXG4gICAgcG9wKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodGhpcy50YWlsKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlKG5vZGUpIHtcblxuICAgICAgICBjb25zdCB7IG5leHQsIHByZXYgfSA9IG5vZGU7XG5cbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhcHBlbmRQYXRoJywgJ292ZXJyaWRlJ10pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zY2hlbWEoSm9pLCBjb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZFBhdGggJiZcbiAgICAgICAgICAgIGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnLCBvcHRpb25zKSB7XG5cbiAgICBBc3NlcnQoY29uZmlnICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIHVuZGVmaW5lZCBzY2hlbWEnKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgQXNzZXJ0KGNvbmZpZy5sZW5ndGgsICdJbnZhbGlkIGVtcHR5IGFycmF5IHNjaGVtYScpO1xuXG4gICAgICAgIGlmIChjb25maWcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWdbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IChiYXNlLCAuLi52YWx1ZXMpID0+IHtcblxuICAgICAgICBpZiAob3B0aW9ucy5vdmVycmlkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnZhbGlkKEpvaS5vdmVycmlkZSwgLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlLnZhbGlkKC4uLnZhbHVlcyk7XG4gICAgfTtcblxuICAgIGlmIChpbnRlcm5hbHMuc2ltcGxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gSm9pLmN1c3RvbShjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc2NoZW1hIGNvbnRlbnQ6JywgdHlwZW9mIGNvbmZpZyk7XG5cbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5zaW1wbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9pLmFsdGVybmF0aXZlcygpLnRyeSguLi5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgLi4uY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBKb2kuc3RyaW5nKCkucmVnZXgoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLmRhdGUoKSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbmZpZykgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICByZXR1cm4gSm9pLm9iamVjdCgpLmtleXMoY29uZmlnKTtcbn07XG5cblxuZXhwb3J0cy5yZWYgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBSZWYuaXNSZWYoaWQpID8gaWQgOiBSZWYuY3JlYXRlKGlkLCBvcHRpb25zKTtcbn07XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHJvb3QsIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2xlZ2FjeSddKTtcblxuICAgIC8vIENvbXBpbGVkIGJ5IGFueSBzdXBwb3J0ZWQgdmVyc2lvblxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBDb21tb24udmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzOicsIGFueS52ZXJzaW9uLCBDb21tb24udmVyc2lvbik7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgLy8gVW5jb21waWxlZCByb290XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgIW9wdGlvbnMubGVnYWN5KSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pOyAgICAgICAgICAvLyBXaWxsIGVycm9yIGlmIHNjaGVtYSBjb250YWlucyBvdGhlciB2ZXJzaW9uc1xuICAgIH1cblxuICAgIC8vIFNjYW4gc2NoZW1hIGZvciBjb21waWxlZCBwYXJ0c1xuXG4gICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWEpO1xuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21waWxlci5jb21waWxlKGNvbXBpbGVyLnJvb3QsIHNjaGVtYSk7XG59O1xuXG5cbmludGVybmFscy53YWxrID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgcmV0dXJuIHsgcm9vdDogc2NoZW1hW2FueS5yb290XSwgY29tcGlsZTogYW55LmNvbXBpbGUgfTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNjaGVtYSkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWFba2V5XSk7XG4gICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5zaW1wbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCBbJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMud2hlbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBBc3NlcnQoY29uZGl0aW9uICYmIHR5cGVvZiBjb25kaXRpb24gPT09ICdvYmplY3QnLCAnTWlzc2luZyBvcHRpb25zJyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IGNvbmRpdGlvbjtcbiAgICAgICAgY29uZGl0aW9uID0gUmVmLmNyZWF0ZSgnLicpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHN3aXRjaDogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaXMnLCAnbm90JywgJ3RoZW4nLCAnb3RoZXJ3aXNlJywgJ3N3aXRjaCcsICdicmVhayddKTtcblxuICAgIC8vIFNjaGVtYSBjb25kaXRpb25cblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoY29uZGl0aW9uKSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnXCJpc1wiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ1wibm90XCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkLCAnXCJzd2l0Y2hcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgaXM6IGNvbmRpdGlvbiwgdGhlbjogb3B0aW9ucy50aGVuLCBvdGhlcndpc2U6IG9wdGlvbnMub3RoZXJ3aXNlLCBicmVhazogb3B0aW9ucy5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgY29uZGl0aW9uXG5cbiAgICBBc3NlcnQoUmVmLmlzUmVmKGNvbmRpdGlvbikgfHwgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGNvbmRpdGlvbjonLCBjb25kaXRpb24pO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwiaXNcIiB3aXRoIFwibm90XCInKTtcblxuICAgIGlmIChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBydWxlID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMubm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bGUgPSB7IGlzOiBvcHRpb25zLm5vdCwgdGhlbjogb3B0aW9ucy5vdGhlcndpc2UsIG90aGVyd2lzZTogb3B0aW9ucy50aGVuLCBicmVhazogb3B0aW9ucy5icmVhayB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzID0gcnVsZS5pcyAhPT0gdW5kZWZpbmVkID8gc2NoZW1hLiRfY29tcGlsZShydWxlLmlzKSA6IHNjaGVtYS4kX3Jvb3QuaW52YWxpZChudWxsLCBmYWxzZSwgMCwgJycpLnJlcXVpcmVkKCk7XG4gICAgICAgIEFzc2VydChydWxlLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkLCAnb3B0aW9ucyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIFwidGhlblwiLCBcIm90aGVyd2lzZVwiLCBvciBcInN3aXRjaFwiJyk7XG4gICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQgfHwgcnVsZS50aGVuID09PSB1bmRlZmluZWQgfHwgcnVsZS5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IHRoZW4sIG90aGVyd2lzZSwgYW5kIGJyZWFrIGFsbCB0b2dldGhlcicpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFSZWYuaXNSZWYob3B0aW9ucy5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEob3B0aW9ucy5pcykpIHtcblxuICAgICAgICAgICAgaXMgPSBpcy5yZXF1aXJlZCgpOyAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jb25kaXRpb24oc2NoZW1hLCB7IHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSwgaXMsIHRoZW46IHJ1bGUudGhlbiwgb3RoZXJ3aXNlOiBydWxlLm90aGVyd2lzZSwgYnJlYWs6IHJ1bGUuYnJlYWsgfSk7XG4gICAgfVxuXG4gICAgLy8gU3dpdGNoIHN0YXRlbWVudFxuXG4gICAgQXNzZXJ0KEFycmF5LmlzQXJyYXkob3B0aW9ucy5zd2l0Y2gpLCAnXCJzd2l0Y2hcIiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcImlzXCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcIm5vdFwiJyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMudGhlbiA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwidGhlblwiJyk7XG5cbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICByZWY6IGV4cG9ydHMucmVmKGNvbmRpdGlvbiksXG4gICAgICAgIHN3aXRjaDogW10sXG4gICAgICAgIGJyZWFrOiBvcHRpb25zLmJyZWFrXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5zd2l0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9IG9wdGlvbnMuc3dpdGNoW2ldO1xuICAgICAgICBjb25zdCBsYXN0ID0gaSA9PT0gb3B0aW9ucy5zd2l0Y2gubGVuZ3RoIC0gMTtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyh0ZXN0LCBsYXN0ID8gWydpcycsICd0aGVuJywgJ290aGVyd2lzZSddIDogWydpcycsICd0aGVuJ10pO1xuXG4gICAgICAgIEFzc2VydCh0ZXN0LmlzICE9PSB1bmRlZmluZWQsICdTd2l0Y2ggc3RhdGVtZW50IG1pc3NpbmcgXCJpc1wiJyk7XG4gICAgICAgIEFzc2VydCh0ZXN0LnRoZW4gIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcInRoZW5cIicpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICBpczogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LmlzKSxcbiAgICAgICAgICAgIHRoZW46IHNjaGVtYS4kX2NvbXBpbGUodGVzdC50aGVuKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghUmVmLmlzUmVmKHRlc3QuaXMpICYmXG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHRlc3QuaXMpKSB7XG5cbiAgICAgICAgICAgIGl0ZW0uaXMgPSBpdGVtLmlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWZcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCB8fCB0ZXN0Lm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgXCJvdGhlcndpc2VcIiBpbnNpZGUgYW5kIG91dHNpZGUgYSBcInN3aXRjaFwiJyk7XG4gICAgICAgICAgICBjb25zdCBvdGhlcndpc2UgPSBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdGhlcndpc2UgOiB0ZXN0Lm90aGVyd2lzZTtcbiAgICAgICAgICAgIGlmIChvdGhlcndpc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBib3RoIG90aGVyd2lzZSBhbmQgYnJlYWsnKTtcbiAgICAgICAgICAgICAgICBpdGVtLm90aGVyd2lzZSA9IHNjaGVtYS4kX2NvbXBpbGUob3RoZXJ3aXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGUuc3dpdGNoLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGU7XG59O1xuXG5cbmludGVybmFscy5jb25kaXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hLCBjb25kaXRpb24pIHtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsndGhlbicsICdvdGhlcndpc2UnXSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmRpdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZGl0aW9uW2tleV0gPSBzY2hlbWEuJF9jb21waWxlKGNvbmRpdGlvbltrZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25kaXRpb247XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoZnJvbSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgYmFzZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmcm9tKTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBDbG9uZShiYXNlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBmcm9tLl9hc3NpZ24oT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKTtcbiAgICBjb25zdCBkZWYgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgIGRlbGV0ZSBkZWYuYmFzZTtcblxuICAgIHByb3RvdHlwZS5fZGVmaW5pdGlvbiA9IGRlZjtcblxuICAgIGNvbnN0IHBhcmVudCA9IGJhc2UuX2RlZmluaXRpb24gfHwge307XG4gICAgZGVmLm1lc3NhZ2VzID0gTWVzc2FnZXMubWVyZ2UocGFyZW50Lm1lc3NhZ2VzLCBkZWYubWVzc2FnZXMpO1xuICAgIGRlZi5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnByb3BlcnRpZXMsIGRlZi5wcm9wZXJ0aWVzKTtcblxuICAgIC8vIFR5cGVcblxuICAgIHNjaGVtYS50eXBlID0gZGVmLnR5cGU7XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZGVmLmZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmZsYWdzLCBkZWYuZmxhZ3MpO1xuXG4gICAgLy8gVGVybXNcblxuICAgIGNvbnN0IHRlcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnRlcm1zKTtcbiAgICBpZiAoZGVmLnRlcm1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYudGVybXMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSBvd24gdGVybXNcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBkZWYudGVybXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXNbbmFtZV0gPT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdGVybSBvdmVycmlkZSBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtc1tuYW1lXSA9IHRlcm0uaW5pdDtcbiAgICAgICAgICAgIHRlcm1zW25hbWVdID0gdGVybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi50ZXJtcyA9IHRlcm1zO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgYXJndW1lbnRzXG5cbiAgICBpZiAoIWRlZi5hcmdzKSB7XG4gICAgICAgIGRlZi5hcmdzID0gcGFyZW50LmFyZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZVxuXG4gICAgZGVmLnByZXBhcmUgPSBpbnRlcm5hbHMucHJlcGFyZShkZWYucHJlcGFyZSwgcGFyZW50LnByZXBhcmUpO1xuXG4gICAgLy8gQ29lcmNlXG5cbiAgICBpZiAoZGVmLmNvZXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZi5jb2VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZi5jb2VyY2UuZnJvbSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGVmLmNvZXJjZS5mcm9tKSkge1xuXG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UubWV0aG9kLCBmcm9tOiBbXS5jb25jYXQoZGVmLmNvZXJjZS5mcm9tKSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLmNvZXJjZSA9IGludGVybmFscy5jb2VyY2UoZGVmLmNvZXJjZSwgcGFyZW50LmNvZXJjZSk7XG5cbiAgICAvLyBWYWxpZGF0ZVxuXG4gICAgZGVmLnZhbGlkYXRlID0gaW50ZXJuYWxzLnZhbGlkYXRlKGRlZi52YWxpZGF0ZSwgcGFyZW50LnZhbGlkYXRlKTtcblxuICAgIC8vIFJ1bGVzXG5cbiAgICBjb25zdCBydWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5ydWxlcyk7XG4gICAgaWYgKGRlZi5ydWxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gZGVmLnJ1bGVzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBydWxlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KCFydWxlc1tuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBydWxlc1tuYW1lXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdLmNvbmNhdChydWxlLmFsaWFzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2FsaWFzXSA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3MgPSBydWxlLmFyZ3MubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHsgbmFtZTogYXJnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXJ1bGUuYXJnc0J5TmFtZS5oYXMoYXJnLm5hbWUpLCAnRHVwbGljYXRlZCBhcmd1bWVudCBuYW1lJywgYXJnLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoYXJnLmFzc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5hc3NlcnQgPSBhcmcuYXNzZXJ0LnN0cmljdCgpLmxhYmVsKGFyZy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZS5zZXQoYXJnLm5hbWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYucnVsZXMgPSBydWxlcztcblxuICAgIC8vIE1vZGlmaWVyc1xuXG4gICAgY29uc3QgbW9kaWZpZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50Lm1vZGlmaWVycyk7XG4gICAgaWYgKGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBkZWYubW9kaWZpZXJzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RpZmllciA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgbW9kaWZpZXIgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGUoeyBbbmFtZV06IGFyZyB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIG1vZGlmaWVyc1tuYW1lXSA9IG1vZGlmaWVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIC8vIE92ZXJyaWRlc1xuXG4gICAgaWYgKGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgcHJvdG90eXBlLl9zdXBlciA9IGJhc2U7XG4gICAgICAgIHNjaGVtYS4kX3N1cGVyID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiBkZWYub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQoYmFzZVtvdmVycmlkZV0sICdDYW5ub3Qgb3ZlcnJpZGUgbWlzc2luZycsIG92ZXJyaWRlKTtcbiAgICAgICAgICAgIGRlZi5vdmVycmlkZXNbb3ZlcnJpZGVdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0gPSBiYXNlW292ZXJyaWRlXTtcbiAgICAgICAgICAgIHNjaGVtYS4kX3N1cGVyW292ZXJyaWRlXSA9IGJhc2Vbb3ZlcnJpZGVdLmJpbmQoc2NoZW1hKTsgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUsIGRlZi5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIC8vIENhc3RzXG5cbiAgICBkZWYuY2FzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5jYXN0LCBkZWYuY2FzdCk7XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgY29uc3QgbWFuaWZlc3QgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubWFuaWZlc3QsIGRlZi5tYW5pZmVzdCk7XG4gICAgbWFuaWZlc3QuYnVpbGQgPSBpbnRlcm5hbHMuYnVpbGQoZGVmLm1hbmlmZXN0ICYmIGRlZi5tYW5pZmVzdC5idWlsZCwgcGFyZW50Lm1hbmlmZXN0ICYmIHBhcmVudC5tYW5pZmVzdC5idWlsZCk7XG4gICAgZGVmLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAvLyBSZWJ1aWxkXG5cbiAgICBkZWYucmVidWlsZCA9IGludGVybmFscy5yZWJ1aWxkKGRlZi5yZWJ1aWxkLCBwYXJlbnQucmVidWlsZCk7XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5idWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudChjaGlsZChvYmosIGRlc2MpLCBkZXNjKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuY29lcmNlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogY2hpbGQuZnJvbSAmJiBwYXJlbnQuZnJvbSA/IFsuLi5uZXcgU2V0KFsuLi5jaGlsZC5mcm9tLCAuLi5wYXJlbnQuZnJvbV0pXSA6IG51bGwsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICBsZXQgY29lcmNlZDtcbiAgICAgICAgICAgIGlmICghcGFyZW50LmZyb20gfHxcbiAgICAgICAgICAgICAgICBwYXJlbnQuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICBjb2VyY2VkID0gcGFyZW50Lm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmZyb20gfHxcbiAgICAgICAgICAgICAgICBjaGlsZC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG93biA9IGNoaWxkLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucHJlcGFyZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGNoaWxkKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHByZXBhcmVkKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgcHJlcGFyZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudCh2YWx1ZSwgaGVscGVycykgfHwgcHJlcGFyZWQ7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYnVpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgICAgIHBhcmVudChzY2hlbWEpO1xuICAgICAgICBjaGlsZChzY2hlbWEpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJlbnQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycyAmJlxuICAgICAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSB8fCByZXN1bHQuZXJyb3JzLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkKHZhbHVlLCBoZWxwZXJzKSB8fCByZXN1bHQ7XG4gICAgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmRlc2NyaWJlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnR5cGUsXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgcnVsZXM6IFtdXG4gICAgfTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBmb3IgKGNvbnN0IGZsYWcgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAoZmxhZ1swXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBkZXNjLmZsYWdzW2ZsYWddID0gaW50ZXJuYWxzLmRlc2NyaWJlKHNjaGVtYS5fZmxhZ3NbZmxhZ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3Qua2V5cyhkZXNjLmZsYWdzKS5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MuZmxhZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyZW5jZXNcblxuICAgIGlmIChzY2hlbWEuX3ByZWZlcmVuY2VzKSB7XG4gICAgICAgIGRlc2MucHJlZmVyZW5jZXMgPSBDbG9uZShzY2hlbWEuX3ByZWZlcmVuY2VzLCB7IHNoYWxsb3c6IFsnbWVzc2FnZXMnXSB9KTtcbiAgICAgICAgZGVsZXRlIGRlc2MucHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdO1xuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcykge1xuICAgICAgICAgICAgZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyA9IE1lc3NhZ2VzLmRlY29tcGlsZShkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgaWYgKHNjaGVtYS5fdmFsaWRzKSB7XG4gICAgICAgIGRlc2MuYWxsb3cgPSBzY2hlbWEuX3ZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuX2ludmFsaWRzKSB7XG4gICAgICAgIGRlc2MuaW52YWxpZCA9IHNjaGVtYS5faW52YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNjaGVtYS5fcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZURlZiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdO1xuICAgICAgICBpZiAocnVsZURlZi5tYW5pZmVzdCA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7IG5hbWU6IHJ1bGUubmFtZSB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bY3VzdG9tXSA9IGludGVybmFscy5kZXNjcmliZShydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgaXRlbS5hcmdzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBydWxlLmFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnb3B0aW9ucycgJiZcbiAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5rZXlzKGFyZykubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5hcmdzW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUoYXJnLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGl0ZW0uYXJncykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0uYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MucnVsZXMucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2MucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnJ1bGVzO1xuICAgIH1cblxuICAgIC8vIFRlcm1zIChtdXN0IGJlIGxhc3QgdG8gdmVyaWZ5IG5vIG5hbWUgY29uZmxpY3RzKVxuXG4gICAgZm9yIChjb25zdCB0ZXJtIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmICh0ZXJtWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KCFkZXNjW3Rlcm1dLCAnQ2Fubm90IGRlc2NyaWJlIHNjaGVtYSBkdWUgdG8gaW50ZXJuYWwgbmFtZSBjb25mbGljdCB3aXRoJywgdGVybSk7XG5cbiAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuJF90ZXJtc1t0ZXJtXTtcbiAgICAgICAgaWYgKCFpdGVtcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IFsuLi5pdGVtcy5lbnRyaWVzKCldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21tb24uaXNWYWx1ZXMoaXRlbXMpKSB7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gaXRlbXMuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1t0ZXJtXSwgJ1Rlcm0nLCB0ZXJtLCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW3Rlcm1dLm1hbmlmZXN0O1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnO1xuICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgIW1hcHBlZCkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaW50ZXJuYWxzLmRlc2NyaWJlKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcHBlZFxuXG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IG1hbmlmZXN0Lm1hcHBlZDtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXVtpdGVtW3RvXV0gPSBpdGVtW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZVxuXG4gICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIEFzc2VydChub3JtYWxpemVkLmxlbmd0aCA9PT0gMSwgJ1Rlcm0nLCB0ZXJtLCAnY29udGFpbnMgbW9yZSB0aGFuIG9uZSBpdGVtJyk7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZDtcbiAgICB9XG5cbiAgICBpbnRlcm5hbHMudmFsaWRhdGUoc2NoZW1hLiRfcm9vdCwgZGVzYyk7XG4gICAgcmV0dXJuIGRlc2M7XG59O1xuXG5cbmludGVybmFscy5kZXNjcmliZSA9IGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1hcChpbnRlcm5hbHMuZGVzY3JpYmUpO1xuICAgIH1cblxuICAgIGlmIChpdGVtID09PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4geyBzcGVjaWFsOiAnZGVlcCcgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGl0ZW0gPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdvcHRpb25zJykge1xuICAgICAgICByZXR1cm4gQ2xvbmUoaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIoaXRlbSkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICByZXR1cm4geyBidWZmZXI6IGl0ZW0udG9TdHJpbmcoJ2JpbmFyeScpIH07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyByZWdleDogaXRlbS50b1N0cmluZygpIH07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1bQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF0pIHtcbiAgICAgICAgcmV0dXJuIHsgZnVuY3Rpb246IGl0ZW0ubGl0ZXJhbCB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlbS5kZXNjcmliZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWYnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpLnJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGludGVybmFscy5kZXNjcmliZSh2YWx1ZSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5cblxuZXhwb3J0cy5idWlsZCA9IGZ1bmN0aW9uIChqb2ksIGRlc2MpIHtcblxuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaW50ZXJuYWxzLkJ1aWxkZXIoam9pKTtcbiAgICByZXR1cm4gYnVpbGRlci5wYXJzZShkZXNjKTtcbn07XG5cblxuaW50ZXJuYWxzLkJ1aWxkZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihqb2kpIHtcblxuICAgICAgICB0aGlzLmpvaSA9IGpvaTtcbiAgICB9XG5cbiAgICBwYXJzZShkZXNjKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlKHRoaXMuam9pLCBkZXNjKTtcblxuICAgICAgICAvLyBUeXBlXG5cbiAgICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuam9pW2Rlc2MudHlwZV0oKS5fYmFyZSgpO1xuICAgICAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAoZGVzYy5mbGFncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0ZXIgPSBkZWYuZmxhZ3NbZmxhZ10gJiYgZGVmLmZsYWdzW2ZsYWddLnNldHRlciB8fCBmbGFnO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3NldHRlcl0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIGZsYWcnLCBmbGFnLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtzZXR0ZXJdKHRoaXMuYnVpbGQoZGVzYy5mbGFnc1tmbGFnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnByZWZlcmVuY2VzKHRoaXMuYnVpbGQoZGVzYy5wcmVmZXJlbmNlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICAgICAgaWYgKGRlc2MuYWxsb3cpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5hbGxvdyguLi50aGlzLmJ1aWxkKGRlc2MuYWxsb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLmludmFsaWQpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5pbnZhbGlkKC4uLnRoaXMuYnVpbGQoZGVzYy5pbnZhbGlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlc1xuXG4gICAgICAgIGlmIChkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3J1bGUubmFtZV0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHJ1bGUnLCBydWxlLm5hbWUsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWlsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWx0W2tleV0gPSB0aGlzLmJ1aWxkKHJ1bGUuYXJnc1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGJ1aWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPD0gZGVmaW5pdGlvbi5sZW5ndGgsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8nLCBkZWZpbml0aW9uLmxlbmd0aCwgJywgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBuYW1lIH0gb2YgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPT09IDEsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8gMSwgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtrZXlzWzBdXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseVxuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3J1bGUubmFtZV0oLi4uYXJncyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSdWxlc2V0XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbY3VzdG9tXSA9IHRoaXMuYnVpbGQocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnJ1bGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBjb25zdCB0ZXJtcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBpZiAoWydhbGxvdycsICdmbGFncycsICdpbnZhbGlkJywgJ3doZW5zJywgJ3ByZWZlcmVuY2VzJywgJ3J1bGVzJywgJ3R5cGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydChkZWYudGVybXNba2V5XSwgJ1Rlcm0nLCBrZXksICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW2tleV0ubWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NjaGVtYScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5wYXJzZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3ZhbHVlcycpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVzY1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVzY1trZXldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtc1trZXldW25hbWVdID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy53aGVucykge1xuICAgICAgICAgICAgdGVybXMud2hlbnMgPSBkZXNjLndoZW5zLm1hcCgod2hlbikgPT4gdGhpcy5idWlsZCh3aGVuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEgPSBkZWYubWFuaWZlc3QuYnVpbGQoc2NoZW1hLCB0ZXJtcyk7XG4gICAgICAgIHNjaGVtYS4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIGJ1aWxkKGRlc2MsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmIChkZXNjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdvcHRpb25zJykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlc2MpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGRlc2MuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KEJ1ZmZlciwgJ0J1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKGRlc2MuYnVmZmVyLCAnYmluYXJ5Jyk7ICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsIGxpdGVyYWw6IGRlc2MuZnVuY3Rpb24gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Mub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYy5yZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWdleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYy5yZWdleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoWydkZWVwJ10uaW5jbHVkZXMoZGVzYy5zcGVjaWFsKSwgJ1Vua25vd24gc3BlY2lhbCB2YWx1ZScsIGRlc2Muc3BlY2lhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5yZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIGNvbnN0IGVuZCA9IHN0cmluZy5sYXN0SW5kZXhPZignLycpO1xuICAgIGNvbnN0IGV4cCA9IHN0cmluZy5zbGljZSgxLCBlbmQpO1xuICAgIGNvbnN0IGZsYWdzID0gc3RyaW5nLnNsaWNlKGVuZCArIDEpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGV4cCwgZmxhZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGpvaS5hc3NlcnQoZGVzYywgU2NoZW1hcy5kZXNjcmlwdGlvbik7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1pc21hdGNoZWQ6IG51bGxcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgcHJvdG90eXBlOiB0cnVlIH0sIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuICEhaW50ZXJuYWxzLmlzRGVlcEVxdWFsKG9iaiwgcmVmLCBvcHRpb25zLCBbXSk7XG59O1xuXG5cbmludGVybmFscy5pc0RlZXBFcXVhbCA9IGZ1bmN0aW9uIChvYmosIHJlZiwgb3B0aW9ucywgc2Vlbikge1xuXG4gICAgaWYgKG9iaiA9PT0gcmVmKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29waWVkIGZyb20gRGVlcC1lcWwsIGNvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciwgamFrZUBhbG9naWNhbHBhcmFkb3guY29tLCBNSVQgTGljZW5zZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWxcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gMCB8fCAxIC8gb2JqID09PSAxIC8gcmVmO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb2JqO1xuXG4gICAgaWYgKHR5cGUgIT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwgfHxcbiAgICAgICAgcmVmID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5kZWVwRnVuY3Rpb24gfHxcbiAgICAgICAgICAgIG9iai50b1N0cmluZygpICE9PSByZWYudG9TdHJpbmcoKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250aW51ZSBhcyBvYmplY3RcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqICYmIHJlZiAhPT0gcmVmOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOYU5cbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZVR5cGUgPSBpbnRlcm5hbHMuZ2V0U2hhcmVkVHlwZShvYmosIHJlZiwgISFvcHRpb25zLnByb3RvdHlwZSk7XG4gICAgc3dpdGNoIChpbnN0YW5jZVR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlcy5idWZmZXI6XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzLmNhbGwob2JqLCByZWYpOyAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIGNhc2UgVHlwZXMucHJvbWlzZTpcbiAgICAgICAgICAgIHJldHVybiBvYmogPT09IHJlZjtcbiAgICAgICAgY2FzZSBUeXBlcy5yZWdleDpcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKSA9PT0gcmVmLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgaW50ZXJuYWxzLm1pc21hdGNoZWQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IHNlZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHNlZW5baV0uaXNTYW1lKG9iaiwgcmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIGNvbXBhcmlzb24gZmFpbGVkLCBpdCB3b3VsZCBoYXZlIHN0b3BwZWQgZXhlY3V0aW9uXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2gobmV3IGludGVybmFscy5TZWVuRW50cnkob2JqLCByZWYpKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbE9iaihpbnN0YW5jZVR5cGUsIG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHNlZW4ucG9wKCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZ2V0U2hhcmVkVHlwZSA9IGZ1bmN0aW9uIChvYmosIHJlZiwgY2hlY2tQcm90b3R5cGUpIHtcblxuICAgIGlmIChjaGVja1Byb3RvdHlwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm1pc21hdGNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgaWYgKHR5cGUgIT09IFR5cGVzLmdldEludGVybmFsUHJvdG8ocmVmKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm1pc21hdGNoZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG5cbmludGVybmFscy52YWx1ZU9mID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgY29uc3Qgb2JqVmFsdWVPZiA9IG9iai52YWx1ZU9mO1xuICAgIGlmIChvYmpWYWx1ZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb2JqVmFsdWVPZi5jYWxsKG9iaik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5oYXNPd25FbnVtZXJhYmxlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpO1xufTtcblxuXG5pbnRlcm5hbHMuaXNTZXRTaW1wbGVFcXVhbCA9IGZ1bmN0aW9uIChvYmosIHJlZikge1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBTZXQucHJvdG90eXBlLnZhbHVlcy5jYWxsKG9iaikpIHtcbiAgICAgICAgaWYgKCFTZXQucHJvdG90eXBlLmhhcy5jYWxsKHJlZiwgZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLmlzRGVlcEVxdWFsT2JqID0gZnVuY3Rpb24gKGluc3RhbmNlVHlwZSwgb2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGNvbnN0IHsgaXNEZWVwRXF1YWwsIHZhbHVlT2YsIGhhc093bkVudW1lcmFibGVQcm9wZXJ0eSB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IHsga2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzIH0gPSBPYmplY3Q7XG5cbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5hcnJheSkge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJ0KSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBpbmRleCBtYXRjaCBhbnkgb3RoZXIgaW5kZXhcblxuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpWYWx1ZSBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZlZhbHVlIG9mIHJlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqVmFsdWUsIHJlZlZhbHVlLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCAhPT0gcmVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtpXSwgcmVmW2ldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLnNldCkge1xuICAgICAgICBpZiAob2JqLnNpemUgIT09IHJlZi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludGVybmFscy5pc1NldFNpbXBsZUVxdWFsKG9iaiwgcmVmKSkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZGVlcCBlcXVhbGl0eVxuXG4gICAgICAgICAgICBjb25zdCByZWYyID0gbmV3IFNldChTZXQucHJvdG90eXBlLnZhbHVlcy5jYWxsKHJlZikpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpFbnRyeSBvZiBTZXQucHJvdG90eXBlLnZhbHVlcy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmMi5kZWxldGUob2JqRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmRW50cnkgb2YgcmVmMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqRW50cnksIHJlZkVudHJ5LCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmMi5kZWxldGUocmVmRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzLmNhbGwob2JqKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIU1hcC5wcm90b3R5cGUuaGFzLmNhbGwocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKHZhbHVlLCBNYXAucHJvdG90eXBlLmdldC5jYWxsKHJlZiwga2V5KSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5lcnJvcikge1xuXG4gICAgICAgIC8vIEFsd2F5cyBjaGVjayBuYW1lIGFuZCBtZXNzYWdlXG5cbiAgICAgICAgaWYgKG9iai5uYW1lICE9PSByZWYubmFtZSB8fFxuICAgICAgICAgICAgb2JqLm1lc3NhZ2UgIT09IHJlZi5tZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIC52YWx1ZU9mKClcblxuICAgIGNvbnN0IHZhbHVlT2ZPYmogPSB2YWx1ZU9mKG9iaik7XG4gICAgY29uc3QgdmFsdWVPZlJlZiA9IHZhbHVlT2YocmVmKTtcbiAgICBpZiAoKG9iaiAhPT0gdmFsdWVPZk9iaiB8fCByZWYgIT09IHZhbHVlT2ZSZWYpICYmXG4gICAgICAgICFpc0RlZXBFcXVhbCh2YWx1ZU9mT2JqLCB2YWx1ZU9mUmVmLCBvcHRpb25zLCBzZWVuKSkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBwcm9wZXJ0aWVzXG5cbiAgICBjb25zdCBvYmpLZXlzID0ga2V5cyhvYmopO1xuICAgIGlmICghb3B0aW9ucy5wYXJ0ICYmXG4gICAgICAgIG9iaktleXMubGVuZ3RoICE9PSBrZXlzKHJlZikubGVuZ3RoICYmXG4gICAgICAgICFvcHRpb25zLnNraXApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHNraXBwZWQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG9iaktleXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcCAmJlxuICAgICAgICAgICAgb3B0aW9ucy5za2lwLmluY2x1ZGVzKGtleSkpIHtcblxuICAgICAgICAgICAgaWYgKHJlZltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICArK3NraXBwZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5wYXJ0ICYmXG4gICAgICAgIG9iaktleXMubGVuZ3RoIC0gc2tpcHBlZCAhPT0ga2V5cyhyZWYpLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzeW1ib2xzXG5cbiAgICBpZiAob3B0aW9ucy5zeW1ib2xzICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICBjb25zdCBvYmpTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG4gICAgICAgIGNvbnN0IHJlZlN5bWJvbHMgPSBuZXcgU2V0KGdldE93blByb3BlcnR5U3ltYm9scyhyZWYpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmpTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcCB8fFxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNraXAuaW5jbHVkZXMoa2V5KSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZlN5bWJvbHMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZWZTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuU2VlbkVudHJ5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob2JqLCByZWYpIHtcblxuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgaXNTYW1lKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub2JqID09PSBvYmogJiYgdGhpcy5yZWYgPT09IHJlZjtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5sb2NhdGlvbiA9IGZ1bmN0aW9uIChkZXB0aCA9IDApIHtcblxuICAgIGNvbnN0IG9yaWcgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IChpZ25vcmUsIHN0YWNrKSA9PiBzdGFjaztcblxuICAgIGNvbnN0IGNhcHR1cmUgPSB7fTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShjYXB0dXJlLCB0aGlzKTtcbiAgICBjb25zdCBsaW5lID0gY2FwdHVyZS5zdGFja1tkZXB0aCArIDFdO1xuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvcmlnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZW5hbWU6IGxpbmUuZ2V0RmlsZU5hbWUoKSxcbiAgICAgICAgbGluZTogbGluZS5nZXRMaW5lTnVtYmVyKClcbiAgICB9O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAc2lkZXdheS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JywgJ0ludmFsaWQgdGFyZ2V0IHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IG51bGxPdmVycmlkZTogdHJ1ZSwgbWVyZ2VBcnJheXM6IHRydWUgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIEFzc2VydChBcnJheS5pc0FycmF5KHRhcmdldCksICdDYW5ub3QgbWVyZ2UgYXJyYXkgb250byBhbiBvYmplY3QnKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1lcmdlQXJyYXlzKSB7XG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBub3QgY2hhbmdlIHRhcmdldCBhc3NpZ25tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goQ2xvbmUoc291cmNlW2ldLCB7IHN5bWJvbHM6IG9wdGlvbnMuc3ltYm9scyB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBVdGlscy5rZXlzKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbiBvY2N1ciBmb3Igc2hhbGxvdyBtZXJnZXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkgIT09IEFycmF5LmlzQXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgICAgIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgfHwgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBDbG9uZSh2YWx1ZSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHMubWVyZ2UodGFyZ2V0W2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCB0byBwcmVzZXJ2ZSBlbXB0eSBzdHJpbmdzXG5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5udWxsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuXG5leHBvcnRzLklkcyA9IGludGVybmFscy5JZHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBpbnRlcm5hbHMuSWRzKCk7XG4gICAgICAgIGNsb25lLl9ieUlkID0gbmV3IE1hcCh0aGlzLl9ieUlkKTtcbiAgICAgICAgY2xvbmUuX2J5S2V5ID0gbmV3IE1hcCh0aGlzLl9ieUtleSk7XG4gICAgICAgIGNsb25lLl9zY2hlbWFDaGFpbiA9IHRoaXMuX3NjaGVtYUNoYWluO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGlmIChzb3VyY2UuX3NjaGVtYUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgdmFsdWVdIG9mIHNvdXJjZS5fYnlJZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNvdXJjZS5fYnlLZXkuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JrKHBhdGgsIGFkanVzdGVyLCByb290KSB7XG5cbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9jb2xsZWN0KHBhdGgpO1xuICAgICAgICBjaGFpbi5wdXNoKHsgc2NoZW1hOiByb290IH0pO1xuICAgICAgICBjb25zdCB0YWlsID0gY2hhaW4uc2hpZnQoKTtcbiAgICAgICAgbGV0IGFkanVzdGVkID0geyBpZDogdGFpbC5pZCwgc2NoZW1hOiBhZGp1c3Rlcih0YWlsLnNjaGVtYSkgfTtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKGFkanVzdGVkLnNjaGVtYSksICdhZGp1c3RlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmV0dXJuIGEgam9pIHNjaGVtYSB0eXBlJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNoYWluKSB7XG4gICAgICAgICAgICBhZGp1c3RlZCA9IHsgaWQ6IG5vZGUuaWQsIHNjaGVtYTogaW50ZXJuYWxzLmZvcmsobm9kZS5zY2hlbWEsIGFkanVzdGVkLmlkLCBhZGp1c3RlZC5zY2hlbWEpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQuc2NoZW1hO1xuICAgIH1cblxuICAgIGxhYmVscyhwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgYmVoaW5kID0gWy4uLmJlaGluZCwgbm9kZS5zY2hlbWEuX2ZsYWdzLmxhYmVsIHx8IGN1cnJlbnRdO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVoaW5kLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLmxhYmVscyhmb3J3YXJkLCBiZWhpbmQpO1xuICAgIH1cblxuICAgIHJlYWNoKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnNjaGVtYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLnJlYWNoKGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdKTtcbiAgICB9XG5cbiAgICByZWdpc3RlcihzY2hlbWEsIHsga2V5IH0gPSB7fSkge1xuXG4gICAgICAgIGlmICghc2NoZW1hIHx8XG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Byb3BlcnR5KCdzY2hlbWFDaGFpbicpIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4pIHtcblxuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYnlJZC5nZXQoaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCFleGlzdGluZyB8fCBleGlzdGluZy5zY2hlbWEgPT09IHNjaGVtYSwgJ0Nhbm5vdCBhZGQgZGlmZmVyZW50IHNjaGVtYXMgd2l0aCB0aGUgc2FtZSBpZDonLCBpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcblxuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHsgc2NoZW1hLCBpZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGtleSksICdTY2hlbWEgYWxyZWFkeSBjb250YWlucyBrZXk6Jywga2V5KTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcblxuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgeyBzY2hlbWEsIGlkOiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfY29sbGVjdChwYXRoLCBiZWhpbmQgPSBbXSwgbm9kZXMgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIG5vZGVzID0gW25vZGUsIC4uLm5vZGVzXTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMuX2NvbGxlY3QoZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0sIG5vZGVzKTtcbiAgICB9XG5cbiAgICBfZ2V0KGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWQuZ2V0KGlkKSB8fCB0aGlzLl9ieUtleS5nZXQoaWQpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZvcmsgPSBmdW5jdGlvbiAoc2NoZW1hLCBpZCwgcmVwbGFjZW1lbnQpIHtcblxuICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBrZXkgfSkgPT4ge1xuXG4gICAgICAgIGlmIChpZCA9PT0gKGl0ZW0uX2ZsYWdzLmlkIHx8IGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvYmogPSBleHBvcnRzLnNjaGVtYShzY2hlbWEsIHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gb2JqID8gb2JqLiRfbXV0YXRlUmVidWlsZCgpIDogc2NoZW1hO1xufTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgIGxldCBvYmo7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS5fZmxhZ3NbbmFtZV0sIHsgc291cmNlOiAnZmxhZ3MnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai5fZmxhZ3NbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS5fcnVsZXNbaV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHJ1bGUuYXJncywgeyBzb3VyY2U6ICdydWxlcycsIG5hbWU6IHJ1bGUubmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIHJ1bGUpO1xuICAgICAgICAgICAgY2xvbmUuYXJncyA9IHJlc3VsdDtcbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBjbG9uZTtcblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVbmlxdWUgPSBvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVW5pcXVlID09PSBydWxlKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuJF90ZXJtc1tuYW1lXSwgeyBzb3VyY2U6ICd0ZXJtcycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLiRfdGVybXNbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMuc2NhbiA9IGZ1bmN0aW9uIChpdGVtLCBzb3VyY2UsIG9wdGlvbnMsIF9wYXRoLCBfa2V5KSB7XG5cbiAgICBjb25zdCBwYXRoID0gX3BhdGggfHwgW107XG5cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNsb25lO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzb3VyY2Uuc291cmNlID09PSAndGVybXMnICYmIHNvdXJjZS5uYW1lID09PSAna2V5cycgJiYgaXRlbVtpXS5rZXk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2ldLCBzb3VyY2UsIG9wdGlvbnMsIFtpLCAuLi5wYXRoXSwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgaXRlbS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNsb25lW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNjaGVtYSAhPT0gZmFsc2UgJiYgQ29tbW9uLmlzU2NoZW1hKGl0ZW0pIHx8XG4gICAgICAgIG9wdGlvbnMucmVmICE9PSBmYWxzZSAmJiBSZWYuaXNSZWYoaXRlbSkpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb25zLmVhY2goaXRlbSwgeyAuLi5zb3VyY2UsIHBhdGgsIGtleTogX2tleSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2tleV0sIHNvdXJjZSwgb3B0aW9ucywgW2tleSwgLi4ucGF0aF0sIF9rZXkpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyB9O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB2YWx1ZTogU3ltYm9sKCd2YWx1ZScpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlN0YXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocGF0aCwgYW5jZXN0b3JzLCBzdGF0ZSkge1xuXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzOyAgICAgICAgICAgICAgICAgLy8gW3BhcmVudCwgLi4uLCByb290XVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkgPSBzdGF0ZS5tYWluc3RheTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc3RhdGUuc2NoZW1hczsgICAgICAgICAgICAgICAvLyBbY3VycmVudCwgLi4uLCByb290XVxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMgPSBudWxsLCBzY2hlbWEgPSBudWxsKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHBhdGgsIGFuY2VzdG9ycywgdGhpcyk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcykge1xuXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzID0gW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIG5lc3Qoc2NoZW1hLCBkZWJ1Zykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZSh0aGlzLnBhdGgsIHRoaXMuYW5jZXN0b3JzLCB0aGlzKTtcbiAgICAgICAgc3RhdGUuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXMgJiYgW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICBzdGF0ZS5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc2hhZG93KHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdyA9IHRoaXMubWFpbnN0YXkuc2hhZG93IHx8IG5ldyBpbnRlcm5hbHMuU2hhZG93KCk7XG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93LnNldCh0aGlzLnBhdGgsIHZhbHVlLCByZWFzb24pO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSBDbG9uZSh0aGlzLm1haW5zdGF5LnNoYWRvdy5ub2RlKHRoaXMucGF0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5zbmFwc2hvdCgpO1xuICAgIH1cblxuICAgIHJlc3RvcmUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbnN0YXkuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdy5vdmVycmlkZSh0aGlzLnBhdGgsIHRoaXMuX3NuYXBzaG90KTtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgY29tbWl0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cub3ZlcnJpZGUodGhpcy5wYXRoLCB0aGlzLl9zbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuY29tbWl0KCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hcyA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4geyBzY2hlbWEgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuXG5pbnRlcm5hbHMuU2hhZG93ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJlYXNvbikge1xuXG4gICAgICAgIGlmICghcGF0aC5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBzdG9yZSByb290IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhc29uID09PSAnc3RyaXAnICYmXG4gICAgICAgICAgICB0eXBlb2YgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykgeyAgICAgICAgLy8gQ2Fubm90IHN0b3JlIHN0cmlwcGVkIGFycmF5IHZhbHVlcyAoZHVlIHRvIHNoaWZ0KVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLl92YWx1ZXMgfHwgbmV3IE1hcCgpO1xuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fdmFsdWVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoW2ldO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLmdldChzZWdtZW50KTtcbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXQoc2VnbWVudCwgbmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVtpbnRlcm5hbHMudmFsdWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0KHBhdGgpIHtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlKHBhdGgpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxzLnZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUocGF0aCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY2godGhpcy5fdmFsdWVzLCBwYXRoLCB7IGl0ZXJhYmxlczogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBvdmVycmlkZShwYXRoLCBub2RlKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgY29uc3Qgb3duID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhcmVudHMsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBwYXJlbnQuc2V0KG93biwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuZGVsZXRlKG93bik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBJZ25vcmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9pZ25vcmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBTdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmVzdWx0OiBTeW1ib2woJ3Jlc3VsdCcpXG59O1xuXG5cbmV4cG9ydHMuZW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MgcHJlZmVyZW5jZSBpbiBzeW5jaHJvbm91cyB2YWxpZGF0aW9uJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5hcnRpZmFjdHMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBhcnRpZmFjdHMgcHJlZmVyZW5jZSBpbiBzeW5jaHJvbm91cyB2YWxpZGF0aW9uJyk7XG4gICAgICAgIHNldHRpbmdzID0gQ29tbW9uLnByZWZlcmVuY2VzKENvbW1vbi5kZWZhdWx0cywgcHJlZnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5lbnRyeSh2YWx1ZSwgc2NoZW1hLCBzZXR0aW5ncyk7XG4gICAgQXNzZXJ0KCFyZXN1bHQubWFpbnN0YXkuZXh0ZXJuYWxzLmxlbmd0aCwgJ1NjaGVtYSB3aXRoIGV4dGVybmFsIHJ1bGVzIG11c3QgdXNlIHZhbGlkYXRlQXN5bmMoKScpO1xuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgb3V0Y29tZS5lcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzLmxlbmd0aCkge1xuICAgICAgICBvdXRjb21lLndhcm5pbmcgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQubWFpbnN0YXkud2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IHJlc3VsdC5tYWluc3RheS5kZWJ1ZztcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmFydGlmYWN0cykge1xuICAgICAgICBvdXRjb21lLmFydGlmYWN0cyA9IHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmV4cG9ydHMuZW50cnlBc3luYyA9IGFzeW5jIGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBwcmVmcykge1xuXG4gICAgbGV0IHNldHRpbmdzID0gQ29tbW9uLmRlZmF1bHRzO1xuICAgIGlmIChwcmVmcykge1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IG1haW5zdGF5ID0gcmVzdWx0Lm1haW5zdGF5O1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgaWYgKG1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IuZGVidWcgPSBtYWluc3RheS5kZWJ1ZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZXh0ZXJuYWxzLmxlbmd0aCkge1xuICAgICAgICBsZXQgcm9vdCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXh0ZXJuYWwgb2YgbWFpbnN0YXkuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZXh0ZXJuYWwuc3RhdGUucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlZCA9IGV4dGVybmFsLnNjaGVtYS50eXBlID09PSAnbGluaycgPyBtYWluc3RheS5saW5rcy5nZXQoZXh0ZXJuYWwuc2NoZW1hKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcblxuICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gcGF0aC5sZW5ndGggPyBbcm9vdF0gOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gcGF0aC5sZW5ndGggPyBSZWFjaCh2YWx1ZSwgcGF0aCkgOiB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtzZWdtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JzLnVuc2hpZnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gYW5jZXN0b3JzWzBdO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCkgPT4gKGxpbmtlZCB8fCBleHRlcm5hbC5zY2hlbWEpLiRfY3JlYXRlRXJyb3IoY29kZSwgbm9kZSwgbG9jYWwsIGV4dGVybmFsLnN0YXRlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgZXh0ZXJuYWwubWV0aG9kKG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBleHRlcm5hbC5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGV4dGVybmFsLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmcyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzQXJyYXk6IGludGVybmFscy5lcnJvcnNBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgd2FybjogKGNvZGUsIGxvY2FsKSA9PiBtYWluc3RheS53YXJuaW5ncy5wdXNoKChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKGNvZGUsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MpKSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gKGxpbmtlZCB8fCBleHRlcm5hbC5zY2hlbWEpLiRfY3JlYXRlRXJyb3IoJ2V4dGVybmFsJywgbm9kZSwgbG9jYWwsIGV4dGVybmFsLnN0YXRlLCBzZXR0aW5ncywgeyBtZXNzYWdlcyB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9PT0gbm9kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5zdGF5LnRyYWNlci5sb2coZXh0ZXJuYWwuc2NoZW1hLCBleHRlcm5hbC5zdGF0ZSwgJ3J1bGUnLCAnZXh0ZXJuYWwnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gob3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpICYmXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5zdGF5LnRyYWNlci5sb2coZXh0ZXJuYWwuc2NoZW1hLCBleHRlcm5hbC5zdGF0ZSwgJ3J1bGUnLCAnZXh0ZXJuYWwnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ub3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5zdGF5LnRyYWNlci52YWx1ZShleHRlcm5hbC5zdGF0ZSwgJ3J1bGUnLCBub2RlLCBvdXRwdXQsICdleHRlcm5hbCcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRba2V5XSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5zdGF5LnRyYWNlci52YWx1ZShleHRlcm5hbC5zdGF0ZSwgJ3J1bGUnLCByb290LCBvdXRwdXQsICdleHRlcm5hbCcpO1xuICAgICAgICAgICAgICAgICAgICByb290ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICs9IGAgKCR7KGV4dGVybmFsLmxhYmVsKX0pYDsgICAgICAgLy8gQ2hhbmdlIG1lc3NhZ2UgdG8gaW5jbHVkZSBwYXRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnZhbHVlID0gcm9vdDtcblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gRXJyb3JzLnByb2Nlc3MoZXJyb3JzLCB2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IuZGVidWcgPSBtYWluc3RheS5kZWJ1ZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncy53YXJuaW5ncyAmJlxuICAgICAgICAhc2V0dGluZ3MuZGVidWcgJiZcbiAgICAgICAgIXNldHRpbmdzLmFydGlmYWN0cykge1xuXG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0Y29tZSA9IHsgdmFsdWU6IHJlc3VsdC52YWx1ZSB9O1xuICAgIGlmIChtYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMobWFpbnN0YXkud2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICBvdXRjb21lLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmFydGlmYWN0cykge1xuICAgICAgICBvdXRjb21lLmFydGlmYWN0cyA9IG1haW5zdGF5LmFydGlmYWN0cztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbn07XG5cblxuaW50ZXJuYWxzLk1haW5zdGF5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodHJhY2VyLCBkZWJ1ZywgbGlua3MpIHtcblxuICAgICAgICB0aGlzLmV4dGVybmFscyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgICAgIHRoaXMudHJhY2VyID0gdHJhY2VyO1xuICAgICAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gICAgICAgIHRoaXMubGlua3MgPSBsaW5rcztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xuICAgICAgICB0aGlzLmFydGlmYWN0cyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzID0gW107XG4gICAgfVxuXG4gICAgc25hcHNob3QoKSB7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzLnB1c2goe1xuICAgICAgICAgICAgZXh0ZXJuYWxzOiB0aGlzLmV4dGVybmFscy5zbGljZSgpLFxuICAgICAgICAgICAgd2FybmluZ3M6IHRoaXMud2FybmluZ3Muc2xpY2UoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuXG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgICAgICB0aGlzLmV4dGVybmFscyA9IHNuYXBzaG90LmV4dGVybmFscztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHNuYXBzaG90Lndhcm5pbmdzO1xuICAgIH1cblxuICAgIGNvbW1pdCgpIHtcblxuICAgICAgICB0aGlzLl9zbmFwc2hvdHMucG9wKCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIC8vIFByZXBhcmUgc3RhdGVcblxuICAgIGNvbnN0IHsgdHJhY2VyLCBjbGVhbnVwIH0gPSBpbnRlcm5hbHMudHJhY2VyKHNjaGVtYSwgcHJlZnMpO1xuICAgIGNvbnN0IGRlYnVnID0gcHJlZnMuZGVidWcgPyBbXSA6IG51bGw7XG4gICAgY29uc3QgbGlua3MgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBuZXcgTWFwKCkgOiBudWxsO1xuICAgIGNvbnN0IG1haW5zdGF5ID0gbmV3IGludGVybmFscy5NYWluc3RheSh0cmFjZXIsIGRlYnVnLCBsaW5rcyk7XG4gICAgY29uc3Qgc2NoZW1hcyA9IHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbiA/IFt7IHNjaGVtYSB9XSA6IG51bGw7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoW10sIFtdLCB7IG1haW5zdGF5LCBzY2hlbWFzIH0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdmFsdWVcblxuICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydHMudmFsaWRhdGUodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIC8vIFByb2Nlc3MgdmFsdWUgYW5kIGVycm9yc1xuXG4gICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgc2NoZW1hLiRfcm9vdC51bnRyYWNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSBFcnJvcnMucHJvY2VzcyhyZXN1bHQuZXJyb3JzLCB2YWx1ZSwgcHJlZnMpO1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIGVycm9yLCBtYWluc3RheSB9O1xufTtcblxuXG5pbnRlcm5hbHMudHJhY2VyID0gZnVuY3Rpb24gKHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGlmIChzY2hlbWEuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgdHJhY2VyOiBzY2hlbWEuJF9yb290Ll90cmFjZXIuX3JlZ2lzdGVyKHNjaGVtYSkgfTtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuZGVidWcpIHtcbiAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Jvb3QudHJhY2UsICdEZWJ1ZyBtb2RlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHsgdHJhY2VyOiBzY2hlbWEuJF9yb290LnRyYWNlKCkuX3JlZ2lzdGVyKHNjaGVtYSksIGNsZWFudXA6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmFjZXI6IGludGVybmFscy5pZ25vcmUgfTtcbn07XG5cblxuZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcyA9IHt9KSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgc3RhdGUgYW5kIHNldHRpbmdzXG5cbiAgICBpZiAoc2NoZW1hLl9wcmVmZXJlbmNlcykge1xuICAgICAgICBwcmVmcyA9IGludGVybmFscy5wcmVmcyhzY2hlbWEsIHByZWZzKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZVxuXG4gICAgaWYgKHNjaGVtYS5fY2FjaGUgJiZcbiAgICAgICAgcHJlZnMuY2FjaGUpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX2NhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3ZhbGlkYXRlJywgJ2NhY2hlZCcsICEhcmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNvbnN0IGNyZWF0ZUVycm9yID0gKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSA9PiBzY2hlbWEuJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIGxvY2FsU3RhdGUgfHwgc3RhdGUsIHByZWZzKTtcbiAgICBjb25zdCBoZWxwZXJzID0ge1xuICAgICAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgICAgIHByZWZzLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgIGVycm9yc0FycmF5OiBpbnRlcm5hbHMuZXJyb3JzQXJyYXksXG4gICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc3RhdGUubWFpbnN0YXkud2FybmluZ3MucHVzaChjcmVhdGVFcnJvcihjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkpLFxuICAgICAgICBtZXNzYWdlOiAobWVzc2FnZXMsIGxvY2FsKSA9PiBzY2hlbWEuJF9jcmVhdGVFcnJvcignY3VzdG9tJywgdmFsdWUsIGxvY2FsLCBzdGF0ZSwgcHJlZnMsIHsgbWVzc2FnZXMgfSlcbiAgICB9O1xuXG4gICAgLy8gUHJlcGFyZVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmVudHJ5KHNjaGVtYSwgc3RhdGUpO1xuXG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuICAgIGlmIChkZWYucHJlcGFyZSAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHByZWZzLmNvbnZlcnQpIHtcblxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGRlZi5wcmVwYXJlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHByZXBhcmVkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdwcmVwYXJlJywgdmFsdWUsIHByZXBhcmVkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHByZXBhcmVkLnZhbHVlLCBbXS5jb25jYXQocHJlcGFyZWQuZXJyb3JzKSwgaGVscGVycyk7ICAgICAgICAgLy8gUHJlcGFyZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGNvZXJjaW9uXG5cbiAgICBpZiAoZGVmLmNvZXJjZSAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHByZWZzLmNvbnZlcnQgJiZcbiAgICAgICAgKCFkZWYuY29lcmNlLmZyb20gfHwgZGVmLmNvZXJjZS5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpKSB7XG5cbiAgICAgICAgY29uc3QgY29lcmNlZCA9IGRlZi5jb2VyY2UubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGNvZXJjZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2NvZXJjZWQnLCB2YWx1ZSwgY29lcmNlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKGNvZXJjZWQudmFsdWUsIFtdLmNvbmNhdChjb2VyY2VkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgICAgLy8gQ29lcmNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1wdHkgdmFsdWVcblxuICAgIGNvbnN0IGVtcHR5ID0gc2NoZW1hLl9mbGFncy5lbXB0eTtcbiAgICBpZiAoZW1wdHkgJiZcbiAgICAgICAgZW1wdHkuJF9tYXRjaChpbnRlcm5hbHMudHJpbSh2YWx1ZSwgc2NoZW1hKSwgc3RhdGUubmVzdChlbXB0eSksIENvbW1vbi5kZWZhdWx0cykpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdlbXB0eScsIHZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBQcmVzZW5jZSByZXF1aXJlbWVudHMgKHJlcXVpcmVkLCBvcHRpb25hbCwgZm9yYmlkZGVuKVxuXG4gICAgY29uc3QgcHJlc2VuY2UgPSBvdmVycmlkZXMucHJlc2VuY2UgfHwgc2NoZW1hLl9mbGFncy5wcmVzZW5jZSB8fCAoc2NoZW1hLl9mbGFncy5fZW5kZWRTd2l0Y2ggPyBudWxsIDogcHJlZnMucHJlc2VuY2UpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZXF1aXJlZCcsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpXSwgaGVscGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdvcHRpb25hbCcpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLmRlZmF1bHQgIT09IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgbnVsbCwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwge30pO1xuICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkudW5rbm93bicsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpXSwgaGVscGVycyk7XG4gICAgfVxuXG4gICAgLy8gQWxsb3dlZCB2YWx1ZXNcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgaWYgKHNjaGVtYS5fdmFsaWRzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc2NoZW1hLl92YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAndmFsaWRzJywgdmFsdWUsIG1hdGNoLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZmlsdGVyKHNjaGVtYSwgc3RhdGUsICd2YWxpZCcsIG1hdGNoKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3Mub25seSkge1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5vbmx5JywgdmFsdWUsIHsgdmFsaWRzOiBzY2hlbWEuX3ZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbmllZCB2YWx1ZXNcblxuICAgIGlmIChzY2hlbWEuX2ludmFsaWRzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc2NoZW1hLl9pbnZhbGlkcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgc2NoZW1hLl9mbGFncy5pbnNlbnNpdGl2ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAnaW52YWxpZCcsIG1hdGNoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkuaW52YWxpZCcsIHZhbHVlLCB7IGludmFsaWRzOiBzY2hlbWEuX2ludmFsaWRzLnZhbHVlcyh7IGRpc3BsYXk6IHRydWUgfSkgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3JlcG9ydF0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFzZSB0eXBlXG5cbiAgICBpZiAoZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBkZWYudmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnYmFzZScsIHZhbHVlLCBiYXNlLnZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZS52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGJhc2UuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJhc2UuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChiYXNlLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIGVycm9ycywgaGVscGVycyk7ICAgICAgICAgIC8vIEJhc2UgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4uYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0ZXN0c1xuXG4gICAgaWYgKCFzY2hlbWEuX3J1bGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMucnVsZXModmFsdWUsIGVycm9ycywgaGVscGVycyk7XG59O1xuXG5cbmludGVybmFscy5ydWxlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNjaGVtYS5fcnVsZXMpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHNjaGVtYS5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm1ldGhvZF07XG5cbiAgICAgICAgLy8gU2tpcCBydWxlcyB0aGF0IGFyZSBhbHNvIGFwcGxpZWQgaW4gY29lcmNlIHN0ZXBcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5jb252ZXJ0ICYmXG4gICAgICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdmdWxsJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgcmVmZXJlbmNlc1xuXG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGxldCBhcmdzID0gcnVsZS5hcmdzO1xuICAgICAgICBpZiAocnVsZS5fcmVzb2x2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBhcmdzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjb3B5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBydWxlLl9yZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IGFyZ3Nba2V5XS5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSByZXNvbHZlci5ub3JtYWxpemUgPyByZXNvbHZlci5ub3JtYWxpemUocmVzb2x2ZWQpIDogcmVzb2x2ZWQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkID0gQ29tbW9uLnZhbGlkYXRlQXJnKG5vcm1hbGl6ZWQsIG51bGwsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnJlZicsIHJlc29sdmVkLCB7IGFyZzoga2V5LCByZWY6IGFyZ3Nba2V5XSwgcmVhc29uOiBpbnZhbGlkIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IHJ1bGVcblxuICAgICAgICByZXQgPSByZXQgfHwgZGVmaW5pdGlvbi52YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgcnVsZSk7ICAgICAgICAgICAvLyBVc2UgcmV0IGlmIGFscmVhZHkgc2V0IHRvIHJlZmVyZW5jZSBlcnJvclxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5ydWxlKHJldCwgcnVsZSk7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZXJyb3InKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUud2Fybikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgcmVzdWx0LmVycm9ycywgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ3Bhc3MnKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3J1bGUnLCB2YWx1ZSwgcmVzdWx0LnZhbHVlLCBydWxlLm5hbWUpO1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZSA9IGZ1bmN0aW9uIChyZXQsIHJ1bGUpIHtcblxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0KSB7XG4gICAgICAgIGludGVybmFscy5lcnJvcihyZXQsIHJ1bGUpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IFtyZXRdLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJldCkgJiZcbiAgICAgICAgcmV0W0NvbW1vbi5zeW1ib2xzLmVycm9yc10pIHtcblxuICAgICAgICByZXQuZm9yRWFjaCgocmVwb3J0KSA9PiBpbnRlcm5hbHMuZXJyb3IocmVwb3J0LCBydWxlKSk7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogcmV0LCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yczogbnVsbCwgdmFsdWU6IHJldCB9O1xufTtcblxuXG5pbnRlcm5hbHMuZXJyb3IgPSBmdW5jdGlvbiAocmVwb3J0LCBydWxlKSB7XG5cbiAgICBpZiAocnVsZS5tZXNzYWdlKSB7XG4gICAgICAgIHJlcG9ydC5fc2V0VGVtcGxhdGUocnVsZS5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwb3J0O1xufTtcblxuXG5pbnRlcm5hbHMuZmluYWxpemUgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgIGNvbnN0IHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAvLyBGYWlsb3ZlciB2YWx1ZVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmFpbG92ZXIgPSBpbnRlcm5hbHMuZGVmYXVsdCgnZmFpbG92ZXInLCB1bmRlZmluZWQsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIGlmIChmYWlsb3ZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdmYWlsb3ZlcicsIHZhbHVlLCBmYWlsb3Zlcik7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhaWxvdmVyO1xuICAgICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFcnJvciBvdmVycmlkZVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5lcnJvcikge1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLl9mbGFncy5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JzID0gc2NoZW1hLl9mbGFncy5lcnJvcihlcnJvcnMpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBbZXJyb3JzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBlcnJvciBvZiBlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9ycy5SZXBvcnQsICdlcnJvcigpIG11c3QgcmV0dXJuIGFuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzID0gW3NjaGVtYS5fZmxhZ3MuZXJyb3JdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdFxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdGVkID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2RlZmF1bHQnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZGVmYXVsdCcsIHZhbHVlLCBkZWZhdWx0ZWQpO1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRlZDtcbiAgICB9XG5cbiAgICAvLyBDYXN0XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5jYXN0ICYmXG4gICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBjb25zdCBjYXN0ZXIgPSBzY2hlbWEuX2RlZmluaXRpb24uY2FzdFtzY2hlbWEuX2ZsYWdzLmNhc3RdO1xuICAgICAgICBpZiAoY2FzdGVyLmZyb20odmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjYXN0ZWQgPSBjYXN0ZXIudG8odmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnY2FzdCcsIHZhbHVlLCBjYXN0ZWQsIHNjaGVtYS5fZmxhZ3MuY2FzdCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNhc3RlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVybmFsc1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscyAmJlxuICAgICAgICBwcmVmcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGZvciBtYXRjaGluZ1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBtZXRob2QgfSBvZiBzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LmV4dGVybmFscy5wdXNoKHsgbWV0aG9kLCBzY2hlbWEsIHN0YXRlLCBsYWJlbDogRXJyb3JzLmxhYmVsKHNjaGVtYS5fZmxhZ3MsIHN0YXRlLCBwcmVmcykgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXN1bHRcblxuICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWUsIGVycm9yczogZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IG51bGwgfTtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLnJlc3VsdCkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSBzY2hlbWEuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJyA/IHVuZGVmaW5lZCA6IC8qIHJhdyAqLyBoZWxwZXJzLm9yaWdpbmFsO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsIHNjaGVtYS5fZmxhZ3MucmVzdWx0LCB2YWx1ZSwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgc3RhdGUuc2hhZG93KHZhbHVlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlICE9PSBmYWxzZSAmJlxuICAgICAgICAhc2NoZW1hLl9yZWZzLmxlbmd0aCkge1xuXG4gICAgICAgIHNjaGVtYS5fY2FjaGUuc2V0KGhlbHBlcnMub3JpZ2luYWwsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLy8gQXJ0aWZhY3RzXG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhcmVzdWx0LmVycm9ycyAmJlxuICAgICAgICBzY2hlbWEuX2ZsYWdzLmFydGlmYWN0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMgPSBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMgfHwgbmV3IE1hcCgpO1xuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5oYXMoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5zZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzLmdldChzY2hlbWEuX2ZsYWdzLmFydGlmYWN0KS5wdXNoKHN0YXRlLnBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbmludGVybmFscy5wcmVmcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBjb25zdCBpc0RlZmF1bHRPcHRpb25zID0gcHJlZnMgPT09IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAoaXNEZWZhdWx0T3B0aW9ucyAmJlxuICAgICAgICBzY2hlbWEuX3ByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXSkge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEuX3ByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXTtcbiAgICB9XG5cbiAgICBwcmVmcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhwcmVmcywgc2NoZW1hLl9wcmVmZXJlbmNlcyk7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10gPSBwcmVmcztcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZnM7XG59O1xuXG5cbmludGVybmFscy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZsYWcsIHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGNvbnN0IHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG4gICAgY29uc3Qgc291cmNlID0gc2NoZW1hLl9mbGFnc1tmbGFnXTtcbiAgICBpZiAocHJlZnMubm9EZWZhdWx0cyB8fFxuICAgICAgICBzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgZmxhZywgJ2Z1bGwnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHNvdXJjZS5sZW5ndGggPyBbQ2xvbmUoc3RhdGUuYW5jZXN0b3JzWzBdKSwgaGVscGVyc10gOiBbXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcihgYW55LiR7ZmxhZ31gLCBudWxsLCB7IGVycm9yOiBlcnIgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGl0ZXJhbDtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2xvbmUoc291cmNlKTtcbn07XG5cblxuaW50ZXJuYWxzLnRyaW0gPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSkge1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgaWYgKCF0cmltIHx8XG4gICAgICAgICF0cmltLmFyZ3MuZW5hYmxlZCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xufTtcblxuXG5pbnRlcm5hbHMuaWdub3JlID0ge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGVidWc6IElnbm9yZSxcbiAgICBlbnRyeTogSWdub3JlLFxuICAgIGZpbHRlcjogSWdub3JlLFxuICAgIGxvZzogSWdub3JlLFxuICAgIHJlc29sdmU6IElnbm9yZSxcbiAgICB2YWx1ZTogSWdub3JlXG59O1xuXG5cbmludGVybmFscy5lcnJvcnNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGVycm9yc1tDb21tb24uc3ltYm9scy5lcnJvcnNdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuVmFsdWVzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodmFsdWVzLCByZWZzKSB7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFNldCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFNldChyZWZzKTtcbiAgICAgICAgdGhpcy5fbG93ZXJjYXNlID0gaW50ZXJuYWxzLmxvd2VyY2FzZXModmFsdWVzKTtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5zaXplICsgdGhpcy5fcmVmcy5zaXplO1xuICAgIH1cblxuICAgIGFkZCh2YWx1ZSwgcmVmcykge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWZzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmcykgeyAgICAgICAgICAgICAgICAgICAgIC8vIFNraXBwZWQgaW4gYSBtZXJnZVxuICAgICAgICAgICAgICAgICAgICByZWZzLnJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbHVlXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2Uuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgcmVtb3ZlKSB7XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBpbnRlcm5hbHMuVmFsdWVzKCk7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4uc291cmNlLl92YWx1ZXMsIC4uLnNvdXJjZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi5yZW1vdmUuX3ZhbHVlcywgLi4ucmVtb3ZlLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCA/IHRhcmdldCA6IG51bGw7XG4gICAgfVxuXG4gICAgcmVtb3ZlKHZhbHVlKSB7XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcy5kZWxldGUodmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2UuZGVsZXRlKHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXBsZSBtYXRjaFxuXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIG1hdGNoXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX2xvd2VyY2FzZS5nZXQodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZm91bmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVmcy5zaXplICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdHNcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpcy5fcmVmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBpbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9ICFyZWYuaW4gfHwgdHlwZW9mIHJlc29sdmVkICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IFtyZXNvbHZlZF1cbiAgICAgICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KHJlc29sdmVkKSA/IHJlc29sdmVkIDogT2JqZWN0LmtleXMocmVzb2x2ZWQpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlbnNpdGl2ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIHJlZiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKCkge1xuXG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZXMob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmXG4gICAgICAgICAgICBvcHRpb25zLmRpc3BsYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4udGhpcy5fdmFsdWVzLCAuLi50aGlzLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKHRoaXMuX3ZhbHVlcywgdGhpcy5fcmVmcyk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuX292ZXJyaWRlLCAnQ2Fubm90IGNvbmNhdCBvdmVycmlkZSBzZXQgb2YgdmFsdWVzJyk7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IGludGVybmFscy5WYWx1ZXMoWy4uLnRoaXMuX3ZhbHVlcywgLi4uc291cmNlLl92YWx1ZXNdLCBbLi4udGhpcy5fcmVmcywgLi4uc291cmNlLl9yZWZzXSk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goeyBvdmVycmlkZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fdmFsdWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2godmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHsgdmFsdWUgfSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fcmVmcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlLmRlc2NyaWJlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy52YWx1ZXNdID0gdHJ1ZTtcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLnNsaWNlID0gaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGUuY2xvbmU7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMubG93ZXJjYXNlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XG5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoZnJvbSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IE1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQmFzZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcblxuICAgICAgICAvLyBOYW1pbmc6IHB1YmxpYywgX3ByaXZhdGUsICRfZXh0ZW5zaW9uLCAkX211dGF0ZXthY3Rpb259XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLiRfcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9XG5cbiAgICBfcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5faWRzID0gbmV3IE1vZGlmeS5JZHMoKTtcbiAgICAgICAgdGhpcy5fcHJlZmVyZW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFJlZi5NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl92YWxpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2luZ2xlUnVsZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAvLyBUaGUgcnVsZSBvcHRpb25zIHBhc3NlZCBmb3Igbm9uLW11bHRpIHJ1bGVzXG5cbiAgICAgICAgdGhpcy4kX3Rlcm1zID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXNoIG9mIGFycmF5cyBvZiBpbW11dGFibGUgb2JqZWN0cyAoZXh0ZW5kZWQgYnkgb3RoZXIgdHlwZXMpXG5cbiAgICAgICAgdGhpcy4kX3RlbXAgPSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIHN0YXRlIChub3QgY2xvbmVkKVxuICAgICAgICAgICAgcnVsZXNldDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGw6IHVzZSBsYXN0LCBmYWxzZTogZXJyb3IsIG51bWJlcjogc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIHdoZW5zOiB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIGNhY2hlIG9mIGdlbmVyYXRlZCB3aGVuc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmRlc2NyaWJlID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuZGVzY3JpYmUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGFsbG93KC4uLnZhbHVlcykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ2FsbG93Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX3ZhbGlkcycpO1xuICAgIH1cblxuICAgIGFsdGVyKHRhcmdldHMpIHtcblxuICAgICAgICBBc3NlcnQodGFyZ2V0cyAmJiB0eXBlb2YgdGFyZ2V0cyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0cyksICdJbnZhbGlkIHRhcmdldHMgYXJndW1lbnQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgYWx0ZXJhdGlvbnMgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgPSBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gdGFyZ2V0cykge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZXIgPSB0YXJnZXRzW3RhcmdldF07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGFkanVzdGVyID09PSAnZnVuY3Rpb24nLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zLnB1c2goeyB0YXJnZXQsIGFkanVzdGVyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXJ0aWZhY3QoaWQpIHtcblxuICAgICAgICBBc3NlcnQoaWQgIT09IHVuZGVmaW5lZCwgJ0FydGlmYWN0IGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9jYWNoZSwgJ0Nhbm5vdCBzZXQgYW4gYXJ0aWZhY3Qgd2l0aCBhIHJ1bGUgY2FjaGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2FydGlmYWN0JywgaWQpO1xuICAgIH1cblxuICAgIGNhc3QodG8pIHtcblxuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHR5cGVvZiB0byA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHRvIHZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdGhpcy5fZGVmaW5pdGlvbi5jYXN0W3RvXSwgJ1R5cGUnLCB0aGlzLnR5cGUsICdkb2VzIG5vdCBzdXBwb3J0IGNhc3RpbmcgdG8nLCB0byk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdjYXN0JywgdG8gPT09IGZhbHNlID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH1cblxuICAgIGRlZmF1bHQodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KGRlc2MgJiYgdHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Rlc2NyaXB0aW9uJywgZGVzYyk7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gb2JqLiRfY29tcGlsZShzY2hlbWEsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ2VtcHR5Jywgc2NoZW1hLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBlcnJvcihlcnIpIHtcblxuICAgICAgICBBc3NlcnQoZXJyLCAnTWlzc2luZyBlcnJvcicpO1xuICAgICAgICBBc3NlcnQoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJywgJ011c3QgcHJvdmlkZSBhIHZhbGlkIEVycm9yIG9iamVjdCBvciBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlcnJvcicsIGVycik7XG4gICAgfVxuXG4gICAgZXhhbXBsZShleGFtcGxlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoZXhhbXBsZSAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZyBleGFtcGxlJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnb3ZlcnJpZGUnXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleGFtcGxlcycsIGV4YW1wbGUsIHsgc2luZ2xlOiB0cnVlLCBvdmVycmlkZTogb3B0aW9ucy5vdmVycmlkZSB9KTtcbiAgICB9XG5cbiAgICBleHRlcm5hbChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBBc3NlcnQoIWRlc2NyaXB0aW9uLCAnQ2Fubm90IGNvbWJpbmUgb3B0aW9ucyB3aXRoIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IG1ldGhvZC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC5tZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleHRlcm5hbHMnLCB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZmFpbG92ZXIodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZmFpbG92ZXInLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZm9yYmlkZGVuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdmb3JiaWRkZW4nKTtcbiAgICB9XG5cbiAgICBpZChpZCkge1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBpZCA9PT0gJ3N0cmluZycsICdpZCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoL15bXlxcLl0rJC8udGVzdChpZCksICdpZCBjYW5ub3QgY29udGFpbiBwZXJpb2QgY2hhcmFjdGVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIGlkKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX2ludmFsaWRzJyk7XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0xhYmVsIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2xhYmVsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgbWV0YShtZXRhKSB7XG5cbiAgICAgICAgQXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbWV0YXMnLCBtZXRhLCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBub3RlKC4uLm5vdGVzKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5vdGVzLmxlbmd0aCwgJ01pc3Npbmcgbm90ZXMnKTtcbiAgICAgICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQobm90ZSAmJiB0eXBlb2Ygbm90ZSA9PT0gJ3N0cmluZycsICdOb3RlcyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ25vdGVzJywgbm90ZXMpO1xuICAgIH1cblxuICAgIG9ubHkobW9kZSA9IHRydWUpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGUgPT09ICdib29sZWFuJywgJ0ludmFsaWQgbW9kZTonLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ29ubHknLCBtb2RlKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBwcmVmcyhwcmVmcykge1xuXG4gICAgICAgIEFzc2VydChwcmVmcywgJ01pc3NpbmcgcHJlZmVyZW5jZXMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmNvbnRleHQgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBjb250ZXh0Jyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5leHRlcm5hbHMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBleHRlcm5hbHMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmRlYnVnID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZGVidWcnKTtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHByZWZzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwcmVzZW5jZShtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHByZXNlbmNlIG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3ByZXNlbmNlJywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmF3KGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3JhdycgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlc3VsdChtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsncmF3JywgJ3N0cmlwJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHJlc3VsdCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBzdHJpY3QoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZW5hYmxlZDtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCB7IGNvbnZlcnQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RyaXAoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAnc3RyaXAnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICB0YWcoLi4udGFncykge1xuXG4gICAgICAgIEFzc2VydCh0YWdzLmxlbmd0aCwgJ01pc3NpbmcgdGFncycpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBBc3NlcnQodGFnICYmIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnLCAnVGFncyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ3RhZ3MnLCB0YWdzKTtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdVbml0IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3VuaXQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd2YWxpZCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuYWxsb3coLi4udmFsdWVzKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnb25seScsICEhb2JqLl92YWxpZHMsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aGVuID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFbJ2FueScsICdsaW5rJ10uaW5jbHVkZXMob2JqLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0udGhlbiB8fCBpdGVtLnRoZW4udHlwZSA9PT0gJ2FueScgfHwgaXRlbS50aGVuLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLnRoZW4gJiYgaXRlbS50aGVuLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS5vdGhlcndpc2UgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gJ2FueScgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0ub3RoZXJ3aXNlICYmIGl0ZW0ub3RoZXJ3aXNlLnR5cGUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHdoZW4pO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNhY2hlKGNhY2hlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgY2FjaGluZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgb3ZlcnJpZGUgc2NoZW1hIGNhY2hlJyk7XG4gICAgICAgIEFzc2VydCh0aGlzLl9mbGFncy5hcnRpZmFjdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhY2hlIGEgcnVsZSB3aXRoIGFuIGFydGlmYWN0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2NhY2hlID0gY2FjaGUgfHwgQ2FjaGUucHJvdmlkZXIucHJvdmlzaW9uKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvYmopO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSB0aGlzLnR5cGUsICdDYW5ub3QgbWVyZ2UgdHlwZScsIHRoaXMudHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNvdXJjZS50eXBlKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBvbnRvIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2FueScgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugb2JqIHRvIG1hdGNoIHNvdXJjZSB0eXBlXG5cbiAgICAgICAgICAgIGNvbnN0IHRtcE9iaiA9IHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0bXBPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqID0gdG1wT2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pZHMuY29uY2F0KHNvdXJjZS5faWRzKTtcbiAgICAgICAgb2JqLl9yZWZzLnJlZ2lzdGVyKHNvdXJjZSwgUmVmLnRvU2libGluZyk7XG5cbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IG9iai5fcHJlZmVyZW5jZXMgPyBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgc291cmNlLl9wcmVmZXJlbmNlcykgOiBzb3VyY2UuX3ByZWZlcmVuY2VzO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX3ZhbGlkcywgc291cmNlLl92YWxpZHMsIHNvdXJjZS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5faW52YWxpZHMsIHNvdXJjZS5faW52YWxpZHMsIHNvdXJjZS5fdmFsaWRzKTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5pcXVlIHJ1bGVzIHByZXNlbnQgaW4gc291cmNlXG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHNvdXJjZS5fc2luZ2xlUnVsZXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3J1bGVzID0gb2JqLl9ydWxlcy5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmtlZXAgfHwgdGFyZ2V0Lm5hbWUgIT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2Ygc291cmNlLl9ydWxlcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX2RlZmluaXRpb24ucnVsZXNbdGVzdC5tZXRob2RdLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQodGVzdC5uYW1lLCB0ZXN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgc291cmNlLl9mbGFncy5lbXB0eSkge1xuXG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc291cmNlLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBzb3VyY2UuX2ZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UuJF90ZXJtcykge1xuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBzb3VyY2UuJF90ZXJtc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtcykge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gb2JqLiRfdGVybXNba2V5XS5jb25jYXQodGVybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIHNvdXJjZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVidWlsZFxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZXh0ZW5kKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYmFzZSwgJ0Nhbm5vdCBleHRlbmQgdHlwZSB3aXRoIGFub3RoZXIgYmFzZScpO1xuXG4gICAgICAgIHJldHVybiBFeHRlbmQudHlwZSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBleHRyYWN0KHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMucmVhY2gocGF0aCk7XG4gICAgfVxuXG4gICAgZm9yayhwYXRocywgYWRqdXN0ZXIpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGZvcmsgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgW10uY29uY2F0KHBhdGhzKSkge1xuICAgICAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgb2JqID0gb2JqLl9pZHMuZm9yayhwYXRoLCBhZGp1c3Rlciwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKGRlZi5tb2RpZmllcnMpKTtcblxuICAgICAgICBBc3NlcnQodGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2UsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCBvciB0aGUgbGFzdCBydWxlIGFkZGVkIGRvZXMgbm90IHN1cHBvcnQgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4kX3RlbXAucnVsZXNldCA9PT0gbnVsbCA/IHRoaXMuX3J1bGVzLmxlbmd0aCAtIDEgOiB0aGlzLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICBBc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuX3J1bGVzLmxlbmd0aCwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gb2JqLl9ydWxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBDbG9uZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVmLm1vZGlmaWVyc1tuYW1lXShydWxlLCBvcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5uYW1lID09PSBvcmlnaW5hbC5uYW1lLCAnQ2Fubm90IGNoYW5nZSBydWxlIG5hbWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpID09PSBvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBnZXQgcnVsZXNldCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHN0YXJ0IGEgbmV3IHJ1bGVzZXQgd2l0aG91dCBjbG9zaW5nIHRoZSBwcmV2aW91cyBvbmUnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG9iai5fcnVsZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGdldCAkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzZXQ7XG4gICAgfVxuXG4gICAgdGFpbG9yKHRhcmdldHMpIHtcblxuICAgICAgICB0YXJnZXRzID0gW10uY29uY2F0KHRhcmdldHMpO1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgdGFpbG9yIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG5cbiAgICAgICAgaWYgKHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGFkanVzdGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEob2JqKSwgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnZmFpbGVkIHRvIHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmouJF9tb2RpZnkoeyBlYWNoOiAoaXRlbSkgPT4gaXRlbS50YWlsb3IodGFyZ2V0cyksIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIHRyYWNlcigpIHtcblxuICAgICAgICByZXR1cm4gVHJhY2UubG9jYXRpb24gPyBUcmFjZS5sb2NhdGlvbih0aGlzKSA6IHRoaXM7ICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVBc3luYyh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnlBc3luYyh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uc1xuXG4gICAgJF9hZGRSdWxlKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBOb3JtYWxpemUgcnVsZVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucycpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5uYW1lICYmIHR5cGVvZiBvcHRpb25zLm5hbWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBydWxlIG5hbWUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBBc3NlcnQoa2V5WzBdICE9PSAnXycsICdDYW5ub3Qgc2V0IHByaXZhdGUgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBydWxlID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBydWxlLl9yZXNvbHZlID0gW107XG4gICAgICAgIHJ1bGUubWV0aG9kID0gcnVsZS5tZXRob2QgfHwgcnVsZS5uYW1lO1xuXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubWV0aG9kXTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJ1bGUuYXJncztcblxuICAgICAgICBBc3NlcnQoZGVmaW5pdGlvbiwgJ1Vua25vd24gcnVsZScsIHJ1bGUubWV0aG9kKTtcblxuICAgICAgICAvLyBBcmdzXG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBBc3NlcnQoT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSAxIHx8IE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm5hbWVdLmFyZ3MubGVuZ3RoLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgdGhpcy50eXBlLCBydWxlLm5hbWUpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFyZ3NCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLnJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmlzUmVzb2x2YWJsZShhcmcpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuX3Jlc29sdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSByZXNvbHZlci5ub3JtYWxpemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5hc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IENvbW1vbi52YWxpZGF0ZUFyZyhhcmcsIGtleSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghZXJyb3IsIGVycm9yLCAnb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5pcXVlIHJ1bGVzXG5cbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLm11bHRpKSB7XG4gICAgICAgICAgICBvYmouX3J1bGVSZW1vdmUocnVsZS5uYW1lLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLiRfdGVtcC5ydWxlc2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnVuc2hpZnQocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5zY2hlbWEodGhpcy4kX3Jvb3QsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLmZsYWdzICE9PSBmYWxzZSA/IHRoaXMuX2ZsYWdzIDoge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcyA/IE1lc3NhZ2VzLm1lcmdlKHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMpIDogdGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcztcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcnMuUmVwb3J0KGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgICRfZ2V0RmxhZyhuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzW25hbWVdO1xuICAgIH1cblxuICAgICRfZ2V0UnVsZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZVJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAkX21hcExhYmVscyhwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLmxhYmVscyhwYXRoKTtcbiAgICB9XG5cbiAgICAkX21hdGNoKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykge1xuXG4gICAgICAgIHByZWZzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlZnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBwcmVmcy5hYm9ydEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKS5lcnJvcnM7XG4gICAgICAgIHN0YXRlLnJlc3RvcmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICRfbW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2VhY2gnLCAnb25jZScsICdyZWYnLCAnc2NoZW1hJ10pO1xuICAgICAgICByZXR1cm4gTW9kaWZ5LnNjaGVtYSh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVidWlsZCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGFkZCB0aGlzIHJ1bGUgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faWRzLnJlc2V0KCk7XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmFtaWx5ID0gdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdICYmIHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXS5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChmYW1pbHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kX211dGF0ZVJlZ2lzdGVyKGl0ZW0sIHsgZmFtaWx5LCBrZXkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kX21vZGlmeSh7IGVhY2ggfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSwgeyBmYW1pbHksIGtleSB9ID0ge30pIHtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlZ2lzdGVyKHNjaGVtYSwgZmFtaWx5KTtcbiAgICAgICAgdGhpcy5faWRzLnJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSk7XG4gICAgfVxuXG4gICAgJF9wcm9wZXJ0eShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24ucHJvcGVydGllc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX3JlYWNoKHBhdGgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgICRfcm9vdFJlZmVyZW5jZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnMucm9vdHMoKTtcbiAgICB9XG5cbiAgICAkX3NldEZsYWcobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lWzBdID09PSAnXycgfHwgIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBmbGFnIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5fZGVmaW5pdGlvbi5mbGFnc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgZmxhZy5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCB0aGlzLl9mbGFnc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFnc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX3BhcmVudChtZXRob2QsIC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAkX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICB0YXJnZXQuJF9yb290ID0gdGhpcy4kX3Jvb3Q7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVtcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF90ZW1wKTtcbiAgICAgICAgdGFyZ2V0LiRfdGVtcC53aGVucyA9IHt9O1xuXG4gICAgICAgIHRhcmdldC5faWRzID0gdGhpcy5faWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcHJlZmVyZW5jZXMgPSB0aGlzLl9wcmVmZXJlbmNlcztcbiAgICAgICAgdGFyZ2V0Ll92YWxpZHMgPSB0aGlzLl92YWxpZHMgJiYgdGhpcy5fdmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5faW52YWxpZHMgPSB0aGlzLl9pbnZhbGlkcyAmJiB0aGlzLl9pbnZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3J1bGVzID0gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICAgICAgdGFyZ2V0Ll9zaW5nbGVSdWxlcyA9IENsb25lKHRoaXMuX3NpbmdsZVJ1bGVzLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5fcmVmcyA9IHRoaXMuX3JlZnMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgdGFyZ2V0Ll9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kX3Rlcm1zKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF90ZXJtc1trZXldID0gdGhpcy4kX3Rlcm1zW2tleV0gPyB0aGlzLiRfdGVybXNba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9iYXJlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0gb2JqLl9kZWZpbml0aW9uLnRlcm1zO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdChmbGFnLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgJ2xpdGVyYWwnKTtcblxuICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcnLCBmbGFnLCAndmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhb3B0aW9ucy5saXRlcmFsLCAnT25seSBmdW5jdGlvbiB2YWx1ZSBzdXBwb3J0cyBsaXRlcmFsIG9wdGlvbicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMubGl0ZXJhbCkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc2V0RmxhZyhmbGFnLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IG1hdGNoaW5nIHdoZW5zXG5cbiAgICAgICAgY29uc3Qgd2hlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kX3Rlcm1zLndoZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB3aGVuID0gdGhpcy4kX3Rlcm1zLndoZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAod2hlbi5jb25jYXQpIHtcbiAgICAgICAgICAgICAgICB3aGVucy5wdXNoKHdoZW4uY29uY2F0KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtpfS5jb25jYXRgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB3aGVuLnJlZiA/IHdoZW4ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gaWRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdHNbal07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSWQgPSBgJHtpfSR7d2hlbi5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7YmFzZUlkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS50aGVuYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gdGhlbi5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0udGhlbiR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0ub3RoZXJ3aXNlYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSBvdGhlcndpc2UuX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS5vdGhlcndpc2Uke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdoZW4uYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID4gYmVmb3JlKSB7ICAgICAgICAgIC8vIFNvbWV0aGluZyBtYXRjaGVkXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNhY2hlXG5cbiAgICAgICAgY29uc3QgaWQgPSBpZHMuam9pbignLCAnKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsICd3aGVuJywgaWQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS50cmFjZXIuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzLiRfdGVtcC53aGVuc1tpZF0sIGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkeW5hbWljIHNjaGVtYVxuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKHRoaXMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgd2hlbnNcblxuICAgICAgICBmb3IgKGNvbnN0IHdoZW4gb2Ygd2hlbnMpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQod2hlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgLi4ud2hlbnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBvYmosIGlkIH07XG4gICAgfVxuXG4gICAgX2lubmVyKHR5cGUsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgYENhbm5vdCBzZXQgJHt0eXBlfSBpbnNpZGUgYSBydWxlc2V0YCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW3R5cGVdIHx8XG4gICAgICAgICAgICBvcHRpb25zLm92ZXJyaWRlKSB7XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGUpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2godmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pblJ1bGVzZXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IG51bGwgJiYgdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3J1bGVSZW1vdmUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAodGVzdC5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRlc3Qua2VlcCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai5faW5SdWxlc2V0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8IG9iai4kX3RlbXAucnVsZXNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb2JqLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9ydWxlcyA9IGZpbHRlcmVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF92YWx1ZXModmFsdWVzLCBrZXkpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsIGtleS5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZSA9IHZhbHVlc1swXSA9PT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSAmJlxuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXMubGVuZ3RoID8gbmV3IFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldLm92ZXJyaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLCAnT3ZlcnJpZGUgbXVzdCBiZSB0aGUgZmlyc3QgdmFsdWUnKTtcblxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrZXkgPT09ICdfaW52YWxpZHMnID8gJ192YWxpZHMnIDogJ19pbnZhbGlkcyc7XG4gICAgICAgICAgICBpZiAob2JqW290aGVyXSkge1xuICAgICAgICAgICAgICAgIG9ialtvdGhlcl0ucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ialtvdGhlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXkgPT09ICdfdmFsaWRzJyB8fCAhb2JqLl9mbGFncy5vbmx5LCAnU2V0dGluZyBpbnZhbGlkIHZhbHVlJywgdmFsdWUsICdsZWF2ZXMgc2NoZW1hIHJlamVjdGluZyBhbGwgdmFsdWVzIGR1ZSB0byBwcmV2aW91cyB2YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIG9ialtvdGhlcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0uYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5hbnldID0ge1xuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENvbXBpbGUuY29tcGlsZSxcbiAgICByb290OiAnJF9yb290J1xufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzIChtdXN0IGJlIG9uIHByb3RvdHlwZSlcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kZW55ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGlzYWxsb3cgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5lcXVhbCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5yZXF1aXJlZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5ub3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5vcHRpb25zID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZlcmVuY2VzID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CYXNlKCk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FueScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG9ubHk6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGFsdGVyYXRpb25zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXhhbXBsZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleHRlcm5hbHM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBtZXRhczogeyBpbml0OiBbXSB9LFxuICAgICAgICBub3RlczogeyBpbml0OiBbXSB9LFxuICAgICAgICBzaGFyZWQ6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICB0YWdzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHdoZW5zOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgbWV0aG9kKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2N1c3RvbScsIGFyZ3M6IHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG1ldGhvZCB9KSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYW55LmN1c3RvbScsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydtZXRob2QnLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZnMoeyBtZXNzYWdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaGFyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSAmJiBzY2hlbWEuX2ZsYWdzLmlkLCAnU2NoZW1hIG11c3QgYmUgYSBzY2hlbWEgd2l0aCBhbiBpZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZCA9IG9iai4kX3Rlcm1zLnNoYXJlZCB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQucHVzaChzY2hlbWEpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoY29kZSwgbG9jYWwpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChjb2RlICYmIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJywgJ0ludmFsaWQgd2FybmluZyBjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnd2FybmluZycsIGFyZ3M6IHsgY29kZSwgbG9jYWwgfSwgd2FybjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBjb2RlLCBsb2NhbCB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihjb2RlLCBsb2NhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb2RlJywgJ2xvY2FsJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vZGlmaWVyczoge1xuXG4gICAgICAgIGtlZXAocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS5rZWVwID0gZW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlKHJ1bGUsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgcnVsZS5tZXNzYWdlID0gTWVzc2FnZXMuY29tcGlsZShtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUud2FybiA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlc2Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2V4YW1wbGVzJywgJ2V4dGVybmFscycsICdtZXRhcycsICdub3RlcycsICd0YWdzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleS5zbGljZSgwLCAtMSldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbHRlcmF0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVyW3RhcmdldF0gPSBhZGp1c3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5hbHRlcihhbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd3aGVucycpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIGNvbmNhdCB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdChjb25jYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4ocmVmLCB7IGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgc3dpdGNoOiB2YWx1ZS5zd2l0Y2gsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKGlzLCB7IHRoZW4sIG90aGVyd2lzZSwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5zaGFyZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbnkuY3VzdG9tJzogJ3t7I2xhYmVsfX0gZmFpbGVkIGN1c3RvbSB2YWxpZGF0aW9uIGJlY2F1c2Uge3sjZXJyb3IubWVzc2FnZX19JyxcbiAgICAgICAgJ2FueS5kZWZhdWx0JzogJ3t7I2xhYmVsfX0gdGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGRlZmF1bHQgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5mYWlsb3Zlcic6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBmYWlsb3ZlciBtZXRob2QnLFxuICAgICAgICAnYW55LmludmFsaWQnOiAne3sjbGFiZWx9fSBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgJ2FueS5vbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7aWYoI3ZhbGlkcy5sZW5ndGggPT0gMSwgXCJcIiwgXCJvbmUgb2YgXCIpfXt7I3ZhbGlkc319JyxcbiAgICAgICAgJ2FueS5yZWYnOiAne3sjbGFiZWx9fSB7eyNhcmd9fSByZWZlcmVuY2VzIHt7OiNyZWZ9fSB3aGljaCB7eyNyZWFzb259fScsXG4gICAgICAgICdhbnkucmVxdWlyZWQnOiAne3sjbGFiZWx9fSBpcyByZXF1aXJlZCcsXG4gICAgICAgICdhbnkudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJ1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYWx0ZXJuYXRpdmVzJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgbWF0Y2g6IHsgZGVmYXVsdDogJ2FueScgfSAgICAgICAgICAgICAgICAgLy8gJ2FueScsICdvbmUnLCAnYWxsJ1xuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hdGNoZXM6IHsgaW5pdDogW10sIHJlZ2lzdGVyOiBSZWYudG9TaWJsaW5nIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZW1hLnRyeSguLi5zY2hlbWFzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgICAgICAvLyBNYXRjaCBhbGwgb3Igb25lXG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2gocmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaCBvbmVcblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2ggPT09ICdvbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoID09PSAxID8geyB2YWx1ZTogbWF0Y2hlZFswXSB9IDogeyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMub25lJykgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggYWxsXG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCAhPT0gc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBmYWlsZWQubWFwKChmKSA9PiBFcnJvcnMuZGV0YWlscyhmLCB7IG92ZXJyaWRlOiBmYWxzZSB9KSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFsbCcsIGNvbnRleHQpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzQW55T2JqID0gKGFsdGVybmF0aXZlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRpdmUuJF90ZXJtcy5tYXRjaGVzLnNvbWUoKHYpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5zY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2LnNjaGVtYS50eXBlID09PSAnYWx0ZXJuYXRpdmVzJyAmJiBpc0FueU9iaih2LnNjaGVtYSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzQW55T2JqKHNjaGVtYSkgPyB7IHZhbHVlOiBtYXRjaGVkLnJlZHVjZSgoYWNjLCB2KSA9PiBNZXJnZShhY2MsIHYsIHsgbWVyZ2VBcnJheXM6IGZhbHNlIH0pKSB9IDogeyB2YWx1ZTogbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXRjaCBhbnlcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcblxuICAgICAgICAgICAgLy8gVHJ5XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5uZXN0KGl0ZW0uc2NoZW1hLCBgbWF0Y2guJHtpfWApO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLiRfdmFsaWRhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHNjaGVtYTogaXRlbS5zY2hlbWEsIHJlcG9ydHM6IHJlc3VsdC5lcnJvcnMgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbmRpdGlvbmFsXG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5yZWYgPyBpdGVtLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IGl0ZW0uaXMgPyBbaXRlbV0gOiBpdGVtLnN3aXRjaDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3Q7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGBtYXRjaC4ke2l9JHtpdGVtLnN3aXRjaCA/ICcuJyArIGogOiAnJ31gO1xuICAgICAgICAgICAgICAgIGlmICghaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7aWR9LmlzYCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJ3aXNlLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3Qob3RoZXJ3aXNlLCBgJHtpZH0ub3RoZXJ3aXNlYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVuLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QodGhlbiwgYCR7aWR9LnRoZW5gKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3JzKGVycm9ycywgaGVscGVycyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29uZGl0aW9uYWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5tYXRjaCwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCB0aGlzLl9mbGFncy5tYXRjaCwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZScpO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3QgdXNlIGJyZWFrIG9wdGlvbiB3aXRoIGFsdGVybmF0aXZlcyBjb25kaXRpb25hbCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBtYXRjaC5pcyA/IFttYXRjaF0gOiBtYXRjaC5zd2l0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGhlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2VuZGVkU3dpdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgbWV0aG9kKG1vZGUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2FueScsICdvbmUnLCAnYWxsJ10uaW5jbHVkZXMobW9kZSksICdJbnZhbGlkIGFsdGVybmF0aXZlcyBtYXRjaCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0aGlzLiRfdGVybXMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KG1hdGNoLnNjaGVtYSwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCBtb2RlLCAnd2l0aCBjb25kaXRpb25hbCBydWxlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdtYXRjaCcsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ01pc3NpbmcgYWx0ZXJuYXRpdmUgc2NoZW1hcycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICd0cnknKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9iai4kX2NvbXBpbGUoc2NoZW1hKSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3BhcmVudCgnbGFiZWwnLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgc291cmNlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnBhdGhbMF0gIT09ICdpcycgJiYgdHlwZW9mIGl0ZW0uX2ZsYWdzLmxhYmVsICE9PSAnc3RyaW5nJyA/IGl0ZW0ubGFiZWwobmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHJlcXVpcmVkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbnknOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAne3sjbGFiZWx9fSBtYXRjaGVzIG1vcmUgdGhhbiBvbmUgYWxsb3dlZCB0eXBlJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy50eXBlcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZHMuYWRkKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCBlcnJvcnMgYXJlIGJhc2UgdHlwZXMgb3IgdmFsaWRzXG5cbiAgICBpZiAoIWNvbXBsZXgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy50eXBlcycsIHsgdHlwZXM6IFsuLi52YWxpZHNdIH0pIH07XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbXBsZXggZXJyb3JcblxuICAgIGlmIChjb21wbGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGNvbXBsZXhbMF0ucmVwb3J0IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbn07XG5cblxuaW50ZXJuYWxzLnVubWF0Y2hlZCA9IGZ1bmN0aW9uIChmYWlsdXJlcywgZXJyb3IpIHtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICBlcnJvcnMucHVzaCguLi5mYWlsdXJlLnJlcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5tYXRjaCcsIEVycm9ycy5kZXRhaWxzKGVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSkpIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FycmF5JyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2luZ2xlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHNwYXJzZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgaXRlbXM6IHsgaW5pdDogW10sIG1hbmlmZXN0OiAnc2NoZW1hJyB9LFxuICAgICAgICBvcmRlcmVkOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcblxuICAgICAgICBfZXhjbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfaW5jbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfcmVxdWlyZWRzOiB7IGluaXQ6IFtdIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdvYmplY3QnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ID0gc2NoZW1hLiRfZ2V0UnVsZSgnc29ydCcpO1xuICAgICAgICAgICAgaWYgKCFzb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgc29ydC5hcmdzLm9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3Muc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBzaW5nbGVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc2luZ2xlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FycmF5LmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF9nZXRSdWxlKCdpdGVtcycpICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZS5zbGljZSgpIH07ICAgICAgICAvLyBDbG9uZSB0aGUgYXJyYXkgc28gdGhhdCB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgaGFzOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoYXMnLCBhcmdzOiB7IHNjaGVtYSB9IH0pO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgcHJlZnMsIGVycm9yIH0sIHsgc2NoZW1hOiBoYXMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgYW5jZXN0b3JzLCBoYXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzLiRfbWF0Y2godmFsdWVbaV0sIGxvY2FsU3RhdGUsIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybkxhYmVsID0gaGFzLl9mbGFncy5sYWJlbDtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuaGFzS25vd24nLCB7IHBhdHRlcm5MYWJlbCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc1Vua25vd24nLCBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuaXRlbXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcywgZXJyb3JzQXJyYXkgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRzID0gc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWRzID0gc2NoZW1hLiRfdGVybXMub3JkZXJlZC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvbnMgPSBbLi4uc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMsIC4uLnJlcXVpcmVkc107XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3YXNBcnJheSA9ICF2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGVycm9yc0FycmF5KCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaWwgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHdhc0FycmF5ID8gaSA6IG5ldyBOdW1iZXIoaSk7ICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTcGFyc2VcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVzaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4Y2x1c2lvbiBvZiBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGNsdXNpb24uJF9tYXRjaChpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGV4Y2x1c2lvbiksIHByZWZzLCB7IHByZXNlbmNlOiAnaWdub3JlJyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuZXhjbHVkZXMnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPcmRlcmVkXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gb3JkZXJlZC4kX3ZhbGlkYXRlKGl0ZW0sIHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgb3JkZXJlZCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWQuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiYgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS4kX3Rlcm1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5vcmRlcmVkTGVuZ3RoJywgeyBwb3M6IGksIGxpbWl0OiBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBObyByZWFzb24gdG8gY29udGludWUgc2luY2UgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHZhbGlkYXRlIG90aGVyIHRoYW4gYXJyYXkub3JkZXJlZExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWRzXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRDaGVja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpsID0gcmVxdWlyZWRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCByZXF1aXJlZHNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSByZXF1aXJlZHNbal0uJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENoZWNrc1tqXSA9IHJlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShyZXF1aXJlZHMsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWpsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVzaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biAmJiAhIXByZWZzLnN0cmlwVW5rbm93bi5hcnJheXMgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgamwgPSBpbmNsdXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmNsdXNpb24gb2YgaW5jbHVzaW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCByZS1ydW5uaW5nIHJlcXVpcmVkcyB0aGF0IGFscmVhZHkgZGlkbid0IG1hdGNoIGluIHRoZSBwcmV2aW91cyBsb29wXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NoZWNrID0gcmVxdWlyZWRzLmluZGV4T2YoaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NoZWNrICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcXVpcmVkQ2hlY2tzW3ByZXZpb3VzQ2hlY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpbmNsdXNpb24uJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb24uX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBlcnJvciBpZiBvbmx5IG9uZSBpbmNsdXNpb24gZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoamwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMubGVuZ3RoIHx8IHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzVmFsaWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmluY2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsT3JkZXJlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgb3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxEZWZhdWx0KG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgIG1hbmlmZXN0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FycmF5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkZXJlZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdvcmRlcmVkJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIG9iaik7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm9yZGVyZWQucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXZhbHVlIHx8ICF0aGlzLl9mbGFncy5fYXJyYXlJdGVtcywgJ0Nhbm5vdCBzcGVjaWZ5IHNpbmdsZSBydWxlIHdoZW4gYXJyYXkgaGFzIGFycmF5IGl0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NpbmdsZScsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5JywgJ29yZGVyJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zLm9yZGVyIHx8ICdhc2NlbmRpbmcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJ5ID0gQ29tcGlsZS5yZWYob3B0aW9ucy5ieSwgeyBhbmNlc3RvcjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXR0aW5ncy5ieS5hbmNlc3RvciwgJ0Nhbm5vdCBzb3J0IGJ5IGFuY2VzdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NvcnQnLCBhcmdzOiB7IG9wdGlvbnM6IHNldHRpbmdzIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHN0YXRlLCBwcmVmcywgc2NoZW1hIH0sIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBzb3J0ZWQsIGVycm9ycyB9ID0gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgb3B0aW9ucywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gIT09IHNvcnRlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5zb3J0JywgeyBvcmRlcjogb3B0aW9ucy5vcmRlciwgYnk6IG9wdGlvbnMuYnkgPyBvcHRpb25zLmJ5LmtleSA6ICd2YWx1ZScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNwYXJzZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5zcGFyc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHZhbHVlID8gdGhpcy5jbG9uZSgpIDogdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ3NwYXJzZScsIHZhbHVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmlxdWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb21wYXJhdG9yLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghY29tcGFyYXRvciB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycsICdjb21wYXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaWdub3JlVW5kZWZpbmVkJywgJ3NlcGFyYXRvciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7IG5hbWU6ICd1bmlxdWUnLCBhcmdzOiB7IG9wdGlvbnMsIGNvbXBhcmF0b3IgfSB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnBhdGggPSBzZXBhcmF0b3IgPyBjb21wYXJhdG9yLnNwbGl0KHNlcGFyYXRvcikgOiBbY29tcGFyYXRvcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHJ1bGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHN0YXRlLCBlcnJvciwgc2NoZW1hIH0sIHsgY29tcGFyYXRvcjogcmF3LCBvcHRpb25zIH0sIHsgY29tcGFyYXRvciwgcGF0aCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBjb21wYXJhdG9yIHx8IERlZXBFcXVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhdGggPyBSZWFjaCh2YWx1ZVtpXSwgcGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZWNvcmRzLCAnRmFpbGVkIHRvIGZpbmQgdW5pcXVlIG1hcCBjb250YWluZXIgZm9yIHR5cGUnLCB0eXBlb2YgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbXBhcmF0b3InLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHNldDoge1xuICAgICAgICAgICAgZnJvbTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLml0ZW1zKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMub3JkZXJlZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouaXRlbXMoLi4uZGVzYy5pdGVtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoub3JkZXJlZCguLi5kZXNjLm9yZGVyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhcnJheS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICAgICdhcnJheS5leGNsdWRlcyc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgJ2FycmF5Lmhhc0tub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgezojcGF0dGVybkxhYmVsfScsXG4gICAgICAgICdhcnJheS5oYXNVbmtub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2gnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0gYW5kIHt7I3Vua25vd25NaXNzZXN9fSBvdGhlciByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319JyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sjdW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5vcmRlcmVkTGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IG1vc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5zb3J0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBzb3J0ZWQgaW4geyNvcmRlcn0gb3JkZXIgYnkge3sjYnl9fScsXG4gICAgICAgICdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gbWlzbWF0Y2hpbmcgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuc29ydC51bnN1cHBvcnRlZCc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIHVuc3VwcG9ydGVkIHR5cGUgeyN0eXBlfScsXG4gICAgICAgICdhcnJheS5zcGFyc2UnOiAne3sjbGFiZWx9fSBtdXN0IG5vdCBiZSBhIHNwYXJzZSBhcnJheSBpdGVtJyxcbiAgICAgICAgJ2FycmF5LnVuaXF1ZSc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCByZXF1aXJlZCBvZiByZXF1aXJlZHMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZC5fZmxhZ3MubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgdmFsdWUsIHsga25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB2YWx1ZSwgeyB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcmVkIG9mIG9yZGVyZWRzKSB7XG4gICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsRGVmYXVsdCA9IGZ1bmN0aW9uIChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gICAgbGV0IHRyYWlsaW5nVW5kZWZpbmVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSBvcmRlcmVkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHNbaV07XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvcmRlcmVkLiRfdmFsaWRhdGUodW5kZWZpbmVkLCBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcykudmFsdWU7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFpbGluZ1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3ZlcnJpZGVzLnVuc2hpZnQob3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIGlmIChvdmVycmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlLnB1c2goLi4ub3ZlcnJpZGVzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ2FycmF5JyB8fFxuICAgICAgICB0eXBlLl9mbGFncy5fYXJyYXlJdGVtcykge1xuXG4gICAgICAgIEFzc2VydCghb2JqLl9mbGFncy5zaW5nbGUsICdDYW5ub3Qgc3BlY2lmeSBhcnJheSBpdGVtIHdpdGggc2luZ2xlIHJ1bGUgZW5hYmxlZCcpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc2V0dGluZ3MsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3JkZXIgPSBzZXR0aW5ncy5vcmRlciA9PT0gJ2FzY2VuZGluZycgPyAxIDogLTE7XG4gICAgY29uc3QgYUZpcnN0ID0gLTEgKiBvcmRlcjtcbiAgICBjb25zdCBiRmlyc3QgPSBvcmRlcjtcblxuICAgIGNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgICAgIGxldCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnkpIHtcbiAgICAgICAgICAgIGEgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGEsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBiID0gc2V0dGluZ3MuYnkucmVzb2x2ZShiLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJywgdmFsdWUsIHsgdHlwZSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgLSBiKSAqIG9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKS5zb3J0KHNvcnQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnIgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIGFGaXJzdCwgYkZpcnN0KSB7XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgIH1cblxuICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0Jvb2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdib29sZWFuJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRydXRoeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZSh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplZCA9PT0gJ3RydWUnID8gdHJ1ZSA6IChub3JtYWxpemVkID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2NoZW1hLiRfdGVybXMudHJ1dGh5ICYmIHNjaGVtYS4kX3Rlcm1zLnRydXRoeS5oYXModmFsdWUsIG51bGwsIG51bGwsICFzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICAoc2NoZW1hLiRfdGVybXMuZmFsc3kgJiYgc2NoZW1hLiRfdGVybXMuZmFsc3kuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYm9vbGVhbi5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi52YWx1ZXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ3RydXRoeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnRydXRoeSA9IG9iai4kX3Rlcm1zLnRydXRoeSB8fCBuZXcgVmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIHRydXRoeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZhbHN5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICdmYWxzeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmZhbHN5ID0gb2JqLiRfdGVybXMuZmFsc3kgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBmYWxzeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnc2Vuc2l0aXZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzQm9vbCxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnRydXRoeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnV0aHkoLi4uZGVzYy50cnV0aHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mYWxzeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5mYWxzeSguLi5kZXNjLmZhbHN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYm9vbGVhbi5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZGF0ZScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydudW1iZXInLCAnc3RyaW5nJ10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaW50ZXJuYWxzLnBhcnNlKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmZvcm1hdCkgfHwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLl9mbGFncy5mb3JtYXQ7XG5cbiAgICAgICAgaWYgKCFwcmVmcy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAhZm9ybWF0IHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2RhdGUuZm9ybWF0JywgeyBmb3JtYXQgfSkgfTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGF0ZSB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gZGF0ZSA9PT0gJ25vdycgPyBEYXRlLm5vdygpIDogZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmdldFRpbWUoKSwgdG8sIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2RhdGUuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MuZGF0ZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZTogKGRhdGUpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPT09ICdub3cnID8gZGF0ZSA6IGludGVybmFscy5wYXJzZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiAoZGF0ZSkgPT4gZGF0ZSAhPT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgaGF2ZSBhIHZhbGlkIGRhdGUgZm9ybWF0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtYXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpLCAnVW5rbm93biBkYXRlIGZvcm1hdCcsIGZvcm1hdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Zvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzbzoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KCdpc28nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdqYXZhc2NyaXB0Jykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXModHlwZSksICdcInR5cGVcIiBtdXN0IGJlIG9uZSBvZiBcImphdmFzY3JpcHQsIHVuaXhcIicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNEYXRlLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCB7IHByZWZzIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2RhdGUuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiB7bXNnKFwiZGF0ZS5mb3JtYXQuXCIgKyAjZm9ybWF0KSB8fCAjZm9ybWF0fSBmb3JtYXQnLFxuICAgICAgICAnZGF0ZS5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5sZXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG4gICAgICAgICdkYXRlLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7OiNsaW1pdH19JyxcblxuICAgICAgICAvLyBNZXNzYWdlcyB1c2VkIGluIGRhdGUuZm9ybWF0XG5cbiAgICAgICAgJ2RhdGUuZm9ybWF0Lmlzbyc6ICdJU08gODYwMSBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LmphdmFzY3JpcHQnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQudW5peCc6ICd0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIHNlY29uZHMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJU09cblxuICAgIGlmIChmb3JtYXQgPT09ICdpc28nKSB7XG4gICAgICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBudW1iZXIgc3RyaW5nXG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaW1lc3RhbXBcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMSAqIHZhbHVlKTsgICAgICAgIC8vIENhc3RpbmcgdG8gbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAndW5peCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSgxMDAwICogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhaW5cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KCFzb3VyY2UgfHwgc291cmNlID09PSB0cnVlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgdHJ1ZSwgZmFsc3kgb3IgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9uczogbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBzb3VyY2UsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyhkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMpO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBNZXJnZShjb3B5LCBzb3VyY2UsIHsgbnVsbE92ZXJyaWRlLCBtZXJnZUFycmF5czogZmFsc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5zaGFsbG93O1xuICAgIEFzc2VydChBcnJheS5pc0FycmF5KGtleXMpLCAnSW52YWxpZCBrZXlzJyk7XG5cbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1lcmdlID0gc291cmNlID09PSB0cnVlID8gbnVsbCA6IG5ldyBTZXQoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGtleSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpOyAgICAgICAgICAgIC8vIFByZS1zcGxpdCBvcHRpbWl6YXRpb25cblxuICAgICAgICBjb25zdCByZWYgPSBSZWFjaChkZWZhdWx0cywga2V5KTtcbiAgICAgICAgaWYgKHJlZiAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlZiA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgc2Vlbi5zZXQocmVmLCBtZXJnZSAmJiBSZWFjaChzb3VyY2UsIGtleSkgfHwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgbWVyZ2UuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMsIHt9LCBzZWVuKTtcblxuICAgIGlmICghbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgbWVyZ2UpIHtcbiAgICAgICAgaW50ZXJuYWxzLnJlYWNoQ29weShjb3B5LCBzb3VyY2UsIGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVsbE92ZXJyaWRlID0gb3B0aW9ucy5udWxsT3ZlcnJpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVsbE92ZXJyaWRlIDogZmFsc2U7XG4gICAgcmV0dXJuIE1lcmdlKGNvcHksIHNvdXJjZSwgeyBudWxsT3ZlcnJpZGUsIG1lcmdlQXJyYXlzOiBmYWxzZSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYWNoQ29weSA9IGZ1bmN0aW9uIChkc3QsIHNyYywgcGF0aCkge1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKCEoc2VnbWVudCBpbiBzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWwgPSBzcmNbc2VnbWVudF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3JjID0gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gc3JjO1xuICAgIGxldCByZWYgPSBkc3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZbc2VnbWVudF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZWZbc2VnbWVudF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHJlZltzZWdtZW50XTtcbiAgICB9XG5cbiAgICByZWZbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuU29ydGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIGFkZChub2Rlcywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHJ1bGVzXG5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gW10uY29uY2F0KG9wdGlvbnMuYmVmb3JlIHx8IFtdKTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBbXS5jb25jYXQob3B0aW9ucy5hZnRlciB8fCBbXSk7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gb3B0aW9ucy5ncm91cCB8fCAnPyc7XG4gICAgICAgIGNvbnN0IHNvcnQgPSBvcHRpb25zLnNvcnQgfHwgMDsgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBmb3IgbWVyZ2luZyBvbmx5XG5cbiAgICAgICAgQXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgaXRzZWxmOiAke2dyb3VwfWApO1xuICAgICAgICBBc3NlcnQoIWJlZm9yZS5pbmNsdWRlcygnPycpLCAnSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBhZnRlciBpdHNlbGY6ICR7Z3JvdXB9YCk7XG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgIHNlcTogdGhpcy5faXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgZXZlbnRcblxuICAgICAgICBpZiAoIW9wdGlvbnMubWFudWFsKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgICAgIEFzc2VydCh2YWxpZCwgJ2l0ZW0nLCBncm91cCAhPT0gJz8nID8gYGFkZGVkIGludG8gZ3JvdXAgJHtncm91cH1gIDogJycsICdjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBtZXJnZShvdGhlcnMpIHtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3RoZXJzKSkge1xuICAgICAgICAgICAgb3RoZXJzID0gW290aGVyc107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG90aGVyLl9pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKTsgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgaXRlbXNcblxuICAgICAgICB0aGlzLl9pdGVtcy5zb3J0KGludGVybmFscy5tZXJnZVNvcnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tpXS5zZXEgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zb3J0KCk7XG4gICAgICAgIEFzc2VydCh2YWxpZCwgJ21lcmdlIGNyZWF0ZWQgYSBkZXBlbmRlbmNpZXMgZXJyb3InKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBzb3J0KCkge1xuXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc29ydCgpO1xuICAgICAgICBBc3NlcnQodmFsaWQsICdzb3J0IGNyZWF0ZWQgYSBkZXBlbmRlbmNpZXMgZXJyb3InKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBfc29ydCgpIHtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgZ3JhcGhcblxuICAgICAgICBjb25zdCBncmFwaCA9IHt9O1xuICAgICAgICBjb25zdCBncmFwaEFmdGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ICAgICAgICAgICAgLy8gQSBwcm90b3R5cGUgY2FuIGJ1bmdsZSBsb29rdXBzIHcvIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgICBjb25zdCBncm91cHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgY29uc3Qgc2VxID0gaXRlbS5zZXE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pcXVlIGFjcm9zcyBhbGwgaXRlbXNcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gaXRlbS5ncm91cDtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIEdyb3Vwc1xuXG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChzZXEpO1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBpbnRlcm1lZGlhcnkgZ3JhcGggdXNpbmcgJ2JlZm9yZSdcblxuICAgICAgICAgICAgZ3JhcGhbc2VxXSA9IGl0ZW0uYmVmb3JlO1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBzZWNvbmQgaW50ZXJtZWRpYXJ5IGdyYXBoIHdpdGggJ2FmdGVyJ1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFmdGVyIG9mIGl0ZW0uYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcl0gPSBncmFwaEFmdGVyc1thZnRlcl0gfHwgW107XG4gICAgICAgICAgICAgICAgZ3JhcGhBZnRlcnNbYWZ0ZXJdLnB1c2goc2VxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGFuZCBpbnRlcm1lZGlhcnkgZ3JhcGhcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ3JhcGhOb2RlSXRlbSBpbiBncmFwaFtub2RlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JhcGhbbm9kZV1bZ3JhcGhOb2RlSXRlbV07XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRHcm91cHMucHVzaCguLi5ncm91cHNbZ3JvdXBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JhcGhbbm9kZV0gPSBleHBhbmRlZEdyb3VwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lcmdlIGludGVybWVkaWFyeSBncmFwaCB1c2luZyBncmFwaEFmdGVycyBpbnRvIGZpbmFsIGdyYXBoXG5cbiAgICAgICAgZm9yIChjb25zdCBncm91cCBpbiBncmFwaEFmdGVycykge1xuICAgICAgICAgICAgaWYgKGdyb3Vwc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JvdXBzW2dyb3VwXSkge1xuICAgICAgICAgICAgICAgICAgICBncmFwaFtub2RlXS5wdXNoKC4uLmdyYXBoQWZ0ZXJzW2dyb3VwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmNlc3RvcnNcblxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIGluIGdyYXBoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoW25vZGVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0gPSBhbmNlc3RvcnNbY2hpbGRdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvcG8gc29ydFxuXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgY29uc3Qgc29ydGVkID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraSkgeyAgICAgICAgICAvLyBMb29waW5nIHRocm91Z2ggaXRlbS5zZXEgdmFsdWVzIG91dCBvZiBvcmRlclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraikgeyAgLy8gQXMgYWJvdmUsIHRoZXNlIGFyZSBpdGVtLnNlcSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbal0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNlc3RvcnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tqXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2VlQ291bnQgPSBhbmNlc3RvcnNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaG91bGRTZWVDb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFthbmNlc3RvcnNbal1ba11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzZWVuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbkNvdW50ID09PSBzaG91bGRTZWVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW25leHRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoICE9PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlcUluZGV4ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgc2VxSW5kZXhbaXRlbS5zZXFdID0gaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNvcnRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkSXRlbSA9IHNlcUluZGV4W3ZhbHVlXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChzb3J0ZWRJdGVtLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChzb3J0ZWRJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm1lcmdlU29ydCA9IChhLCBiKSA9PiB7XG5cbiAgICByZXR1cm4gYS5zb3J0ID09PSBiLnNvcnQgPyAwIDogKGEuc29ydCA8IGIuc29ydCA/IC0xIDogMSk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXBwbHlUb0RlZmF1bHRzID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzJyk7XG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFRvcG8gPSByZXF1aXJlKCdAaGFwaS90b3BvJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZW5hbWVEZWZhdWx0czoge1xuICAgICAgICBhbGlhczogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb2xkIHZhbHVlIGluIHBsYWNlXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSwgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVuYW1pbmcgbXVsdGlwbGUga2V5cyBpbnRvIHRoZSBzYW1lIHRhcmdldFxuICAgICAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnX2tleXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIHR5cGVvZjogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bmtub3duOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBrZXlzOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiB7IG1hcHBlZDogeyBmcm9tOiAnc2NoZW1hJywgdG86ICdrZXknIH0gfSB9LFxuICAgICAgICBwYXR0ZXJuczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIHJlbmFtZXM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCBrZXlzKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5rZXlzKGtleXMpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignb2JqZWN0LmJhc2UnLCB7IHR5cGU6IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB9KSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdGVzdFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhbGxvdyBjbG9uZSB2YWx1ZVxuXG4gICAgICAgIHZhbHVlID0gaW50ZXJuYWxzLmNsb25lKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIFJlbmFtZSBrZXlzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMucmVuYW1lKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcywgZXJyb3JzKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbnl0aGluZyBhbGxvd2VkXG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZWQga2V5c1xuXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBrZXldLCBhbmNlc3RvcnMsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGlsZC5zY2hlbWEuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnNjaGVtYS5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVua25vd24ga2V5c1xuXG4gICAgICAgIGlmICh1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2ZsYWdzLl9oYXNQYXR0ZXJuTWF0Y2gpIHtcblxuICAgICAgICAgICAgY29uc3QgZWFybHkgPSBpbnRlcm5hbHMudW5rbm93bihzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKGVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhcmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGVwZW5kZW5jaWVzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkZXAua2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpKGRlcC5rZXkucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IGludGVybmFscy5kZXBlbmRlbmNpZXNbZGVwLnJlbF0oc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoZmFpbGVkLmNvZGUsIHZhbHVlLCBmYWlsZWQuY29udGV4dCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICdhbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NlcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgICAgIGlmICghVGVtcGxhdGUuaXNUZW1wbGF0ZShzdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gQ29tcGlsZS5yZWYoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsICdNZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXNzZXJ0JywgYXJnczogeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHByZWZzLCBzdGF0ZSB9LCB7IHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhYm91dCA9IHN1YmplY3QucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gUmVmLmlzUmVmKHN1YmplY3QpID8gc3ViamVjdC5hYnNvbHV0ZShzdGF0ZSkgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfbWF0Y2goYWJvdXQsIHN0YXRlLmxvY2FsaXplKHBhdGgsIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSwgc2NoZW1hKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ29iamVjdC5hc3NlcnQnLCB7IHN1YmplY3QsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydzdWJqZWN0JywgJ3NjaGVtYScsICdtZXNzYWdlJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uc3RydWN0b3IsIG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicsICdjb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaW5zdGFuY2UnLCBhcmdzOiB7IGNvbnN0cnVjdG9yLCBuYW1lIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29uc3RydWN0b3IsIG5hbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuaW5zdGFuY2UnLCB7IHR5cGU6IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29uc3RydWN0b3InLCAnbmFtZSddXG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCAnT2JqZWN0IHNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFsbFxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoKSB7ICAgICAgICAgICAgIC8vIEFsbG93IG5vbmVcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG9iai4kX3Rlcm1zLmtleXMgPyBvYmouJF90ZXJtcy5rZXlzLmZpbHRlcigoY2hpbGQpID0+ICFzY2hlbWEuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkgOiBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gb2JqLiRfdGVybXMua2V5cy5wdXNoKHsga2V5LCBzY2hlbWE6IHRoaXMuJF9jb21waWxlKHNjaGVtYVtrZXldKSB9KSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ25hbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnb3InKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3hvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVnRXhwID0gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLiRfY29tcGlsZShwYXR0ZXJuLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydmYWxsdGhyb3VnaCcsICdtYXRjaGVzJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnBhdHRlcm5zID0gb2JqLiRfdGVybXMucGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0geyBbaXNSZWdFeHAgPyAncmVnZXgnIDogJ3NjaGVtYSddOiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gdGhpcy4kX2NvbXBpbGUob3B0aW9ucy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXRjaGVzLnR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gY29uZmlnLm1hdGNoZXMuJF9yb290LmFycmF5KCkuaXRlbXMoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9zZXRGbGFnKCdfaGFzUGF0dGVybk1hdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZhbGx0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdyZWYnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QucmVmVHlwZScsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVnZXgnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZ2V4JywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5hbWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmcm9tLCB0bywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnIHx8IGZyb20gaW5zdGFuY2VvZiBSZWdFeHAsICdSZW5hbWUgbWlzc2luZyB0aGUgZnJvbSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8IHRvIGluc3RhbmNlb2YgVGVtcGxhdGUsICdJbnZhbGlkIHJlbmFtZSB0byBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0byAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUga2V5IHRvIHNhbWUgbmFtZTonLCBmcm9tKTtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxpYXMnLCAnaWdub3JlVW5kZWZpbmVkJywgJ292ZXJyaWRlJywgJ211bHRpcGxlJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcyA9IG9iai4kX3Rlcm1zLnJlbmFtZXMgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZW5hbWUgb2Ygb2JqLiRfdGVybXMucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVuYW1lLmZyb20gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIHRoZSBzYW1lIGtleSBtdWx0aXBsZSB0aW1lcycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHRvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZW5hbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogQXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5yZW5hbWVEZWZhdWx0cywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdhbnknKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2NoZW1hJywgYXJnczogeyB0eXBlIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgdHlwZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ2FueScgfHwgdmFsdWUudHlwZSA9PT0gdHlwZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5zY2hlbWEnLCB7IHR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5rbm93bjoge1xuICAgICAgICAgICAgbWV0aG9kKGFsbG93KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Vua25vd24nLCBhbGxvdyAhPT0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGhvdXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aG91dCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHhvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAneG9yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBkZWZhdWx0KHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9wYXJlbnQoJ2RlZmF1bHQnLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvLlNvcnRlcigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRvcG8uYWRkKGNoaWxkLCB7IGFmdGVyOiBjaGlsZC5zY2hlbWEuJF9yb290UmVmZXJlbmNlcygpLCBncm91cDogY2hpbGQua2V5IH0pLCBjaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5rZXlzID0gbmV3IGludGVybmFscy5LZXlzKC4uLnRvcG8ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmtleXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoua2V5cyhkZXNjLmtleXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVsLCBrZXkgPSBudWxsLCBwZWVycywgb3B0aW9ucyB9IG9mIGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGludGVybmFscy5kZXBlbmRlbmN5KG9iaiwgcmVsLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZ2V4LCBzY2hlbWEsIHJ1bGUsIGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0gb2YgZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucGF0dGVybihyZWdleCB8fCBzY2hlbWEsIHJ1bGUsIHsgZmFsbHRocm91Z2gsIG1hdGNoZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGZyb20sIHRvLCBvcHRpb25zIH0gb2YgZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZW5hbWUoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnb2JqZWN0LmFuZCc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIHt7I3ByZXNlbnRXaXRoTGFiZWxzfX0gd2l0aG91dCBpdHMgcmVxdWlyZWQgcGVlcnMge3sjbWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QuYXNzZXJ0JzogJ3t7I2xhYmVsfX0gaXMgaW52YWxpZCBiZWNhdXNlIHtpZigjc3ViamVjdC5rZXksIGBcImAgKyAjc3ViamVjdC5rZXkgKyBgXCIgZmFpbGVkIHRvIGAgKyAoI21lc3NhZ2UgfHwgXCJwYXNzIHRoZSBhc3NlcnRpb24gdGVzdFwiKSwgI21lc3NhZ2UgfHwgXCJ0aGUgYXNzZXJ0aW9uIGZhaWxlZFwiKX0nLFxuICAgICAgICAnb2JqZWN0LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9mIHR5cGUge3sjdHlwZX19JyxcbiAgICAgICAgJ29iamVjdC5pbnN0YW5jZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge3s6I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYXQgbGVhc3Qge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1pc3NpbmcnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5uYW5kJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbXVzdCBub3QgZXhpc3Qgc2ltdWx0YW5lb3VzbHkgd2l0aCB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3Qub3hvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBvcHRpb25hbCBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LnBhdHRlcm4ubWF0Y2gnOiAne3sjbGFiZWx9fSBrZXlzIGZhaWxlZCB0byBtYXRjaCBwYXR0ZXJuIHJlcXVpcmVtZW50cycsXG4gICAgICAgICdvYmplY3QucmVmVHlwZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgcmVmZXJlbmNlJyxcbiAgICAgICAgJ29iamVjdC5yZWdleCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBSZWdFeHAgb2JqZWN0JyxcbiAgICAgICAgJ29iamVjdC5yZW5hbWUubXVsdGlwbGUnOiAne3sjbGFiZWx9fSBjYW5ub3QgcmVuYW1lIHt7OiNmcm9tfX0gYmVjYXVzZSBtdWx0aXBsZSByZW5hbWVzIGFyZSBkaXNhYmxlZCBhbmQgYW5vdGhlciBrZXkgd2FzIGFscmVhZHkgcmVuYW1lZCB0byB7ezojdG99fScsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm92ZXJyaWRlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCB7ezojdG99fSBleGlzdHMnLFxuICAgICAgICAnb2JqZWN0LnNjaGVtYSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgc2NoZW1hIG9mIHt7I3R5cGV9fSB0eXBlJyxcbiAgICAgICAgJ29iamVjdC51bmtub3duJzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICAnb2JqZWN0LndpdGgnOiAne3s6I21haW5XaXRoTGFiZWx9fSBtaXNzaW5nIHJlcXVpcmVkIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3Qud2l0aG91dCc6ICd7ezojbWFpbldpdGhMYWJlbH19IGNvbmZsaWN0IHdpdGggZm9yYmlkZGVuIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3QueG9yJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIGV4Y2x1c2l2ZSBwZWVycyB7eyNwZWVyc1dpdGhMYWJlbHN9fSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZnMpIHtcblxuICAgIC8vIE9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZWZzLm5vbkVudW1lcmFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUodmFsdWUsIHsgc2hhbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25cblxuICAgIGNvbnN0IGNsb25lID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIGNsb25lLnByb3RvdHlwZSA9IENsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbmFtZScsIHsgdmFsdWU6IHZhbHVlLm5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsICdsZW5ndGgnLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuYXNzaWduKGNsb25lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuXG5pbnRlcm5hbHMuZGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChzY2hlbWEsIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGtleSA9PT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgcmVsLCAna2V5IG11c3QgYmUgYSBzdHJpbmdzJyk7XG5cbiAgICAvLyBFeHRyYWN0IG9wdGlvbnMgZnJvbSBwZWVycyBhcnJheVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwZWVycy5sZW5ndGggPiAxICYmIHR5cGVvZiBwZWVyc1twZWVycy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcgPyBwZWVycy5wb3AoKSA6IHt9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnc2VwYXJhdG9yJywgJ2lzUHJlc2VudCddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwLCBwcmVmaXg6IGZhbHNlIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoICE9PSBjb3VudCAmJlxuICAgICAgICAgICAgcHJlc2VudC5sZW5ndGggIT09IGNvdW50KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC5hbmQnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudFdpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtaXNzaW5nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6ICdvYmplY3QubWlzc2luZycsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgcGVlcnM6IGRlcC5wYXRocyxcbiAgICAgICAgICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG94b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlc2VudC5sZW5ndGggfHxcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICAgICAgY29udGV4dC5wcmVzZW50V2l0aExhYmVscyA9IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KTtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogJ29iamVjdC5veG9yJywgY29udGV4dCB9O1xuICAgIH0sXG5cbiAgICB3aXRoKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC53aXRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZGVwLmtleS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLmtleS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcjogcGVlci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcGVlci5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdpdGhvdXQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3Qud2l0aG91dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGRlcC5rZXkua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5rZXkua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXI6IHBlZXIua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHBlZXIua2V5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB4b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzUHJlc2VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMuaXNQcmVzZW50ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pc1ByZXNlbnQgOiAocmVzb2x2ZWQpID0+IHJlc29sdmVkICE9PSB1bmRlZmluZWQ7XG59O1xuXG5cbmludGVybmFscy5yZW5hbWUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpIHtcblxuICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlbmFtZSBvZiBzY2hlbWEuJF90ZXJtcy5yZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiByZW5hbWUuZnJvbSAhPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZW5hbWUuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAodmFsdWVbcmVuYW1lLmZyb21dICE9PSB1bmRlZmluZWQgfHwgIXJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChyZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcm9tIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHJlbmFtZS50bykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlbmFtZS5mcm9tLmV4ZWMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBmcm9tLCB0bzogcmVuYW1lLnRvLCBtYXRjaCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IG1hdGNoLmZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBtYXRjaC50bztcbiAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSB0by5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbWF0Y2gubWF0Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgIHJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHRvKSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWUub3B0aW9ucy5vdmVycmlkZSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVt0b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0b10gPSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuYW1lZFt0b10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy51bmtub3duID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7XG4gICAgICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4ucmVnZXgudGVzdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICdydWxlJywgYHBhdHRlcm4uJHtpfWAsIG1hdGNoID8gJ3Bhc3MnIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uc2NoZW1hLiRfbWF0Y2goa2V5LCBzdGF0ZS5uZXN0KHBhdHRlcm4uc2NoZW1hLCBgcGF0dGVybi4ke2l9YCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHsgc2NoZW1hOiBwYXR0ZXJuLnJ1bGUsIGtleSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXR0ZXJuLnJ1bGUuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tpXS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF0dGVybiBtYXRjaGVzIHJ1bGVzXG5cbiAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cG0gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXS5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIHN0cG0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cG0uJF92YWxpZGF0ZShtYXRjaCwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQuZXJyb3JzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucGF0dGVybi5tYXRjaCcsIHZhbHVlLCBkZXRhaWxzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHsgICAgIC8vIElmIG5vIGtleXMgb3IgcGF0dGVybnMgc3BlY2lmaWVkLCB1bmtub3duIGtleXMgYWxsb3dlZFxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuc3RyaXBVbmtub3duICYmICFzY2hlbWEuX2ZsYWdzLnVua25vd24gfHxcbiAgICAgICAgcHJlZnMuc2tpcEZ1bmN0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biA/IChwcmVmcy5zdHJpcFVua25vd24gPT09IHRydWUgPyB0cnVlIDogISFwcmVmcy5zdHJpcFVua25vd24ub2JqZWN0cykgOiBmYWxzZTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvcmJpZFVua25vd24gPSAhQ29tbW9uLmRlZmF1bHQoc2NoZW1hLl9mbGFncy51bmtub3duLCBwcmVmcy5hbGxvd1Vua25vd24pO1xuICAgIGlmIChmb3JiaWRVbmtub3duKSB7XG4gICAgICAgIGZvciAoY29uc3QgdW5wcm9jZXNzZWRLZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgdW5wcm9jZXNzZWRLZXldLCBbXSk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnVua25vd24nLCB2YWx1ZVt1bnByb2Nlc3NlZEtleV0sIHsgY2hpbGQ6IHVucHJvY2Vzc2VkS2V5IH0sIGxvY2FsU3RhdGUsIHByZWZzLCB7IGZsYWdzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EZXBlbmRlbmN5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocmVsLCBrZXksIHBlZXJzLCBwYXRocywgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVsID0gcmVsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wZWVycyA9IHBlZXJzO1xuICAgICAgICB0aGlzLnBhdGhzID0gcGF0aHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgICAgIHJlbDogdGhpcy5yZWwsXG4gICAgICAgICAgICBwZWVyczogdGhpcy5wYXRoc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVzYy5rZXkgPSB0aGlzLmtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgZGVzYy5vcHRpb25zID0geyAuLi5kZXNjLm9wdGlvbnMsIHNlcGFyYXRvcjogdGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IC4uLmRlc2Mub3B0aW9ucywgaXNQcmVzZW50OiB0aGlzLm9wdGlvbnMuaXNQcmVzZW50IH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5LZXlzID0gY2xhc3MgZXh0ZW5kcyBBcnJheSB7XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zbGljZSgpO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXlzLnNldChyZXN1bHRbaV0ua2V5LCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcG9zID0ga2V5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0geyBrZXksIHNjaGVtYTogcmVzdWx0W3Bvc10uc2NoZW1hLmNvbmNhdChpdGVtLnNjaGVtYSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVvZjogJ2Z1bmN0aW9uJ1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBhcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW5Bcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluQXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXhBcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Z1bmN0aW9uLmFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IG9mIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5jbGFzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjbGFzcycsXG4gICAgICAgICdmdW5jdGlvbi5tYXhBcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBsZXNzZXIgb3IgZXF1YWwgdG8ge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1pbkFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IGdyZWF0ZXIgb3IgZXF1YWwgdG8ge3sjbn19J1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2xpbmsnLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBzY2hlbWFDaGFpbjogdHJ1ZVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGxpbms6IHsgaW5pdDogbnVsbCwgbWFuaWZlc3Q6ICdzaW5nbGUnLCByZWdpc3RlcjogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBhcmdzKHNjaGVtYSwgcmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZWYocmVmKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgIEFzc2VydChzY2hlbWEuJF90ZXJtcy5saW5rLCAnVW5pbml0aWFsaXplZCBsaW5rIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IGxpbmtlZCA9IGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICAgICAgcmV0dXJuIGxpbmtlZC4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KGxpbmtlZCwgYGxpbms6JHtyZWYuZGlzcGxheX06JHtsaW5rZWQudHlwZX1gKSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICBtZXRob2QocmVmKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuJF90ZXJtcy5saW5rLCAnQ2Fubm90IHJlaW5pdGlhbGl6ZSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIHJlZiA9IENvbXBpbGUucmVmKHJlZik7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocmVmLnR5cGUgPT09ICd2YWx1ZScgfHwgcmVmLnR5cGUgPT09ICdsb2NhbCcsICdJbnZhbGlkIHJlZmVyZW5jZSB0eXBlOicsIHJlZi50eXBlKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocmVmLnR5cGUgPT09ICdsb2NhbCcgfHwgcmVmLmFuY2VzdG9yID09PSAncm9vdCcgfHwgcmVmLmFuY2VzdG9yID4gMCwgJ0xpbmsgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5saW5rID0gW3sgcmVmIH1dO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZWxhdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KHRoaXMuJF90ZXJtcy5saW5rLCAnVW5pbml0aWFsaXplZCBsaW5rIHNjaGVtYScpO1xuICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzb3VyY2UpLCAnSW52YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgICAgICBBc3NlcnQoc291cmNlLnR5cGUgIT09ICdsaW5rJywgJ0Nhbm5vdCBtZXJnZSB0eXBlIGxpbmsgd2l0aCBhbm90aGVyIGxpbmsnKTtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMucHVzaCh7IGNvbmNhdDogc291cmNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBBc3NlcnQoZGVzYy5saW5rLCAnSW52YWxpZCBsaW5rIGRlc2NyaXB0aW9uIG1pc3NpbmcgbGluaycpO1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWYoZGVzYy5saW5rKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgbGV0IGxpbmtlZCA9IHN0YXRlLm1haW5zdGF5LmxpbmtzLmdldChzY2hlbWEpO1xuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtlZC5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZiA9IHNjaGVtYS4kX3Rlcm1zLmxpbmtbMF0ucmVmO1xuICAgIGNvbnN0IHsgcGVyc3BlY3RpdmUsIHBhdGggfSA9IGludGVybmFscy5wZXJzcGVjdGl2ZShyZWYsIHN0YXRlKTtcbiAgICBpbnRlcm5hbHMuYXNzZXJ0KHBlcnNwZWN0aXZlLCAnd2hpY2ggaXMgb3V0c2lkZSBvZiBzY2hlbWEgYm91bmRhcmllcycsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbGlua2VkID0gcGF0aC5sZW5ndGggPyBwZXJzcGVjdGl2ZS4kX3JlYWNoKHBhdGgpIDogcGVyc3BlY3RpdmU7XG4gICAgfVxuICAgIGNhdGNoIChpZ25vcmVFcnIpIHtcbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydChmYWxzZSwgJ3RvIG5vbi1leGlzdGluZyBzY2hlbWEnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbHMuYXNzZXJ0KGxpbmtlZC50eXBlICE9PSAnbGluaycsICd3aGljaCBpcyBhbm90aGVyIGxpbmsnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIGlmICghc2NoZW1hLl9mbGFncy5yZWxhdGl2ZSkge1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5saW5rcy5zZXQoc2NoZW1hLCBsaW5rZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbn07XG5cblxuaW50ZXJuYWxzLnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKHJlZiwgc3RhdGUpIHtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICBmb3IgKGNvbnN0IHsgc2NoZW1hLCBrZXkgfSBvZiBzdGF0ZS5zY2hlbWFzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnJvbSBwYXJlbnQgdG8gcm9vdFxuICAgICAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuX2ZsYWdzLmlkIHx8IGtleTtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc2NoZW1hLCBwYXRoOiByZWYucGF0aC5zbGljZSgxKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMuc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzaGFyZWQgb2Ygc2NoZW1hLiRfdGVybXMuc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuX2ZsYWdzLmlkID09PSByZWYucGF0aFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNoYXJlZCwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBudWxsLCBwYXRoOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzdGF0ZS5zY2hlbWFzW3N0YXRlLnNjaGVtYXMubGVuZ3RoIC0gMV0uc2NoZW1hLCBwYXRoOiByZWYucGF0aCB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzdGF0ZS5zY2hlbWFzW3JlZi5hbmNlc3Rvcl0gJiYgc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbn07XG5cblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmIChjb25kaXRpb24pIHsgICAgICAgICAgICAgICAgLy8gTWFudWFsIGNoZWNrIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXJyb3IgbWVzc2FnZSBvbiBzdWNjZXNzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBBc3NlcnQoZmFsc2UsIGBcIiR7RXJyb3JzLmxhYmVsKHNjaGVtYS5fZmxhZ3MsIHN0YXRlLCBwcmVmcyl9XCIgY29udGFpbnMgbGluayByZWZlcmVuY2UgXCIke3JlZi5kaXNwbGF5fVwiICR7bWVzc2FnZX1gKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBudW1iZXJSeDogL15cXHMqWystXT8oPzooPzpcXGQrKD86XFwuXFxkKik/KXwoPzpcXC5cXGQrKSkoPzplKFsrLV0/XFxkKykpP1xccyokL2ksXG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8sXG4gICAgZXhwb25lbnRpYWxQYXJ0UmVnZXg6IC9bZUVdWystXT9cXGQrJC8sXG4gICAgbGVhZGluZ1NpZ25BbmRaZXJvc1JlZ2V4OiAvXlsrLV0/KDAqKT8vLFxuICAgIGRvdFJlZ2V4OiAvXFwuLyxcbiAgICB0cmFpbGluZ1plcm9zUmVnZXg6IC8wKyQvLFxuICAgIGRlY2ltYWxQbGFjZXModmFsdWUpIHtcblxuICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBkaW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBjb25zdCBlaW5kZXggPSBzdHIuaW5kZXhPZignZScpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGRpbmRleCA8IDAgPyAwIDogKGVpbmRleCA8IDAgPyBzdHIubGVuZ3RoIDogZWluZGV4KSAtIGRpbmRleCAtIDEpICtcbiAgICAgICAgICAgIChlaW5kZXggPCAwID8gMCA6IE1hdGgubWF4KDAsIC1wYXJzZUludChzdHIuc2xpY2UoZWluZGV4ICsgMSkpKSlcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbnVtYmVyJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgdW5zYWZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpIH07XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSkgIT09IGludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoU3RyaW5nKHJlc3VsdC52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHJlc3VsdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5pbmZpbml0eScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvbW1vbi5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlIH07XG5cbiAgICAgICAgaWYgKHByZWZzLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuJF9nZXRSdWxlKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHJ1bGUuYXJncy5saW1pdCk7ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNvbmNlcHR1YWxseSBlcXVpdmFsZW50IHRvIHVzaW5nIHRvRml4ZWQgYnV0IGl0IHNob3VsZCBiZSBtdWNoIGZhc3RlclxuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmVzdWx0LnZhbHVlICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IDA7ICAgICAgICAgICAvLyAtMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgdmFsdWUgPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcblxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbXBhcmU6IHtcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZSwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5pc051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBudW1iZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2dyZWF0ZXInLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVnZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaW50ZWdlcicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC50cnVuYyh2YWx1ZSkgLSB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5pbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVzcycsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICBtZXRob2QoYmFzZSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZURlY2ltYWxQbGFjZSA9IHR5cGVvZiBiYXNlID09PSAnbnVtYmVyJyA/IGludGVybmFscy5kZWNpbWFsUGxhY2VzKGJhc2UpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwZmFjdG9yID0gTWF0aC5wb3coMTAsIGJhc2VEZWNpbWFsUGxhY2UpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ211bHRpcGxlJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VEZWNpbWFsUGxhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZmFjdG9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBiYXNlLCBiYXNlRGVjaW1hbFBsYWNlLCBwZmFjdG9yIH0sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGVjaW1hbFBsYWNlID0gaW50ZXJuYWxzLmRlY2ltYWxQbGFjZXModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRGVjaW1hbFBsYWNlID4gYmFzZURlY2ltYWxQbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZSB3aXRoIGhpZ2hlciBwcmVjaXNpb24gdGhhbiBiYXNlIGNhbiBuZXZlciBiZSBhIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGZhY3RvciAqIHZhbHVlKSAlIE1hdGgucm91bmQocGZhY3RvciAqIGJhc2UpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Jhc2VEZWNpbWFsUGxhY2UnLFxuICAgICAgICAgICAgICAgICdwZmFjdG9yJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbmVnYXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ25lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9ydDoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdwb3J0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA8PSA2NTUzNSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLnBvcnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb3NpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbigncG9zaXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcmVjaXNpb246IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSwgJ2xpbWl0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3ByZWNpc2lvbicsIGFyZ3M6IHsgbGltaXQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZXMgPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKGludGVybmFscy5wcmVjaXNpb25SeCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBNYXRoLm1heCgocGxhY2VzWzFdID8gcGxhY2VzWzFdLmxlbmd0aCA6IDApIC0gKHBsYWNlc1syXSA/IHBhcnNlSW50KHBsYWNlc1syXSwgMTApIDogMCksIDApO1xuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFscyA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wcmVjaXNpb24nLCB7IGxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2lnbjoge1xuICAgICAgICAgICAgbWV0aG9kKHNpZ24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ25lZ2F0aXZlJywgJ3Bvc2l0aXZlJ10uaW5jbHVkZXMoc2lnbiksICdJbnZhbGlkIHNpZ24nLCBzaWduKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzaWduJywgYXJnczogeyBzaWduIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgc2lnbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2lnbiA9PT0gJ25lZ2F0aXZlJyAmJiB2YWx1ZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9PT0gJ3Bvc2l0aXZlJyAmJiB2YWx1ZSA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYG51bWJlci4ke3NpZ259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zYWZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bnNhZmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdudW1iZXIuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLmdyZWF0ZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5pbmZpbml0eSc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBpbmZpbml0eScsXG4gICAgICAgICdudW1iZXIuaW50ZWdlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICAgICdudW1iZXIubGVzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm1heCc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIG11bHRpcGxlIG9mIHt7I211bHRpcGxlfX0nLFxuICAgICAgICAnbnVtYmVyLm5lZ2F0aXZlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgICdudW1iZXIucG9ydCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBwb3J0JyxcbiAgICAgICAgJ251bWJlci5wb3NpdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnByZWNpc2lvbic6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBubyBtb3JlIHRoYW4ge3sjbGltaXR9fSBkZWNpbWFsIHBsYWNlcycsXG4gICAgICAgICdudW1iZXIudW5zYWZlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHNhZmUgbnVtYmVyJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy5leHBvbmVudGlhbFBhcnRSZWdleCwgJycpXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy5kb3RSZWdleCwgJycpXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy50cmFpbGluZ1plcm9zUmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMubGVhZGluZ1NpZ25BbmRaZXJvc1JlZ2V4LCAnJyk7XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemVEZWNpbWFsID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgc3RyID0gc3RyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHBsdXMgc2lnbnNcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zIGlmIHRoZXJlIGlzIGEgZGVjaW1hbCBwb2ludCBhbmQgdW5lY2Vzc2FyeSBkZWNpbWFsIHBvaW50c1xuICAgICAgICAucmVwbGFjZSgvXFwuMCokLywgJycpXG4gICAgICAgIC8vIEFkZCBhIGludGVnZXIgMCBpZiB0aGUgbnVtYmVycyBzdGFydHMgd2l0aCBhIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pXFwuKFteXFwuXSopJC8sICckMTAuJDInKVxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvc1xuICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMC05XSkvLCAnJDEkMicpO1xuXG4gICAgaWYgKHN0ci5pbmNsdWRlcygnLicpICYmXG4gICAgICAgIHN0ci5lbmRzV2l0aCgnMCcpKSB7XG5cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSAnLTAnKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnb2JqZWN0JyxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXModmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jb2RlcyA9IHtcbiAgICBFTVBUWV9TVFJJTkc6ICdBZGRyZXNzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyxcbiAgICBGT1JCSURERU5fVU5JQ09ERTogJ0FkZHJlc3MgY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycsXG4gICAgTVVMVElQTEVfQVRfQ0hBUjogJ0FkZHJlc3MgY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBAIGNoYXJhY3RlcicsXG4gICAgTUlTU0lOR19BVF9DSEFSOiAnQWRkcmVzcyBtdXN0IGNvbnRhaW4gb25lIEAgY2hhcmFjdGVyJyxcbiAgICBFTVBUWV9MT0NBTDogJ0FkZHJlc3MgbG9jYWwgcGFydCBjYW5ub3QgYmUgZW1wdHknLFxuICAgIEFERFJFU1NfVE9PX0xPTkc6ICdBZGRyZXNzIHRvbyBsb25nJyxcbiAgICBMT0NBTF9UT09fTE9ORzogJ0FkZHJlc3MgbG9jYWwgcGFydCB0b28gbG9uZycsXG4gICAgRU1QVFlfTE9DQUxfU0VHTUVOVDogJ0FkZHJlc3MgbG9jYWwgcGFydCBjb250YWlucyBlbXB0eSBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQnLFxuICAgIElOVkFMSURfTE9DQUxfQ0hBUlM6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInLFxuICAgIERPTUFJTl9OT05fRU1QVFlfU1RSSU5HOiAnRG9tYWluIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyxcbiAgICBET01BSU5fVE9PX0xPTkc6ICdEb21haW4gdG9vIGxvbmcnLFxuICAgIERPTUFJTl9JTlZBTElEX1VOSUNPREVfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycsXG4gICAgRE9NQUlOX0lOVkFMSURfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInLFxuICAgIERPTUFJTl9JTlZBTElEX1RMRFNfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCB0bGQgY2hhcmFjdGVyJyxcbiAgICBET01BSU5fU0VHTUVOVFNfQ09VTlQ6ICdEb21haW4gbGFja3MgdGhlIG1pbmltdW0gcmVxdWlyZWQgbnVtYmVyIG9mIHNlZ21lbnRzJyxcbiAgICBET01BSU5fU0VHTUVOVFNfQ09VTlRfTUFYOiAnRG9tYWluIGNvbnRhaW5zIHRvbyBtYW55IHNlZ21lbnRzJyxcbiAgICBET01BSU5fRk9SQklEREVOX1RMRFM6ICdEb21haW4gdXNlcyBmb3JiaWRkZW4gVExEJyxcbiAgICBET01BSU5fRU1QVFlfU0VHTUVOVDogJ0RvbWFpbiBjb250YWlucyBlbXB0eSBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQnLFxuICAgIERPTUFJTl9MT05HX1NFR01FTlQ6ICdEb21haW4gY29udGFpbnMgZG90LXNlcGFyYXRlZCBzZWdtZW50IHRoYXQgaXMgdG9vIGxvbmcnXG59O1xuXG5cbmV4cG9ydHMuY29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG5cbiAgICByZXR1cm4geyBjb2RlLCBlcnJvcjogZXhwb3J0cy5jb2Rlc1tjb2RlXSB9O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaW5Eb21haW5TZWdtZW50czogMixcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGRvbWFpbkNvbnRyb2xSeDogL1tcXHgwMC1cXHgyMEBcXDpcXC9cXFxcIyFcXCQmXFwnXFwoXFwpXFwqXFwrLDs9XFw/XS8sICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sICsgc3BhY2UgKyBzZXBhcmF0b3JzXG4gICAgdGxkU2VnbWVudFJ4OiAvXlthLXpBLVpdKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvLFxuICAgIGRvbWFpblNlZ21lbnRSeDogL15bYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKT8kLyxcbiAgICBVUkw6IFVybC5VUkwgfHwgVVJMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbn07XG5cblxuZXhwb3J0cy5hbmFseXplID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoIWRvbWFpbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBudWxsIC8gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX05PTl9FTVBUWV9TVFJJTkcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBkb21haW4gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChkb21haW4ubGVuZ3RoID4gMjU2KSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1RPT19MT05HJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChkb21haW4pO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX1VOSUNPREVfQ0hBUlMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5ub3JtYWxpemUoJ05GQycpO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbHMuZG9tYWluQ29udHJvbFJ4LnRlc3QoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX0NIQVJTJyk7XG4gICAgfVxuXG4gICAgZG9tYWluID0gaW50ZXJuYWxzLnB1bnljb2RlKGRvbWFpbik7XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNSBzZWN0aW9uIDIuMy4xXG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0Z1bGx5UXVhbGlmaWVkICYmXG4gICAgICAgIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWluRG9tYWluU2VnbWVudHMgPSBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzIHx8IGludGVybmFscy5taW5Eb21haW5TZWdtZW50cztcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA8IG1pbkRvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UX01BWCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGxkcyA9IG9wdGlvbnMudGxkcztcbiAgICBpZiAodGxkcykge1xuICAgICAgICBjb25zdCB0bGQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGxkcy5kZW55ICYmIHRsZHMuZGVueS5oYXModGxkKSB8fFxuICAgICAgICAgICAgdGxkcy5hbGxvdyAmJiAhdGxkcy5hbGxvdy5oYXModGxkKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9GT1JCSURERU5fVExEUycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fRU1QVFlfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0xPTkdfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5kb21haW5TZWdtZW50UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0lOVkFMSURfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnRsZFNlZ21lbnRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fSU5WQUxJRF9UTERTX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFleHBvcnRzLmFuYWx5emUoZG9tYWluLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLnB1bnljb2RlID0gZnVuY3Rpb24gKGRvbWFpbikge1xuXG4gICAgaWYgKGRvbWFpbi5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKC8lL2csICclMjUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5VUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IERvbWFpbiA9IHJlcXVpcmUoJy4vZG9tYWluJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGVuY29kZXI6IG5ldyAoVXRpbC5UZXh0RW5jb2RlciB8fCBUZXh0RW5jb2RlcikoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuXG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5lbWFpbChlbWFpbCwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuZW1haWwgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBlbWFpbCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbWFpbCkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0VNUFRZX1NUUklORycpO1xuICAgIH1cblxuICAgIC8vIFVuaWNvZGVcblxuICAgIGNvbnN0IGFzY2lpID0gIWludGVybmFscy5ub25Bc2NpaVJ4LnRlc3QoZW1haWwpO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRk9SQklEREVOX1VOSUNPREUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtYWlsID0gZW1haWwubm9ybWFsaXplKCdORkMnKTtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBzdHJ1Y3R1cmVcblxuICAgIGNvbnN0IHBhcnRzID0gZW1haWwuc3BsaXQoJ0AnKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAyID8gRXJyb3JzLmNvZGUoJ01VTFRJUExFX0FUX0NIQVInKSA6IEVycm9ycy5jb2RlKCdNSVNTSU5HX0FUX0NIQVInKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbG9jYWwsIGRvbWFpbl0gPSBwYXJ0cztcblxuICAgIGlmICghbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdFTVBUWV9MT0NBTCcpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pZ25vcmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4zXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0FERFJFU1NfVE9PX0xPTkcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuZW5jb2Rlci5lbmNvZGUobG9jYWwpLmxlbmd0aCA+IDY0KSB7ICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuMVxuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdMT0NBTF9UT09fTE9ORycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGFydHNcblxuICAgIHJldHVybiBpbnRlcm5hbHMubG9jYWwobG9jYWwsIGFzY2lpKSB8fCBEb21haW4uYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMubG9jYWwgPSBmdW5jdGlvbiAobG9jYWwsIGFzY2lpKSB7XG5cbiAgICBjb25zdCBzZWdtZW50cyA9IGxvY2FsLnNwbGl0KCcuJyk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRU1QVFlfTE9DQUxfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzY2lpKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5hdGV4dFJ4LnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0lOVkFMSURfTE9DQUxfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5hdGV4dFJ4LnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gaW50ZXJuYWxzLmJpbmFyeShjaGFyKTtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmF0b21SeC50ZXN0KGJpbmFyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0lOVkFMSURfTE9DQUxfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmJpbmFyeSA9IGZ1bmN0aW9uIChjaGFyKSB7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbnRlcm5hbHMuZW5jb2Rlci5lbmNvZGUoY2hhcikpLm1hcCgodikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2KSkuam9pbignJyk7XG59O1xuXG5cbi8qXG4gICAgRnJvbSBSRkMgNTMyMTpcblxuICAgICAgICBNYWlsYm94ICAgICAgICAgPSAgIExvY2FsLXBhcnQgXCJAXCIgKCBEb21haW4gLyBhZGRyZXNzLWxpdGVyYWwgKVxuXG4gICAgICAgIExvY2FsLXBhcnQgICAgICA9ICAgRG90LXN0cmluZyAvIFF1b3RlZC1zdHJpbmdcbiAgICAgICAgRG90LXN0cmluZyAgICAgID0gICBBdG9tICooXCIuXCIgIEF0b20pXG4gICAgICAgIEF0b20gICAgICAgICAgICA9ICAgMSphdGV4dFxuICAgICAgICBhdGV4dCAgICAgICAgICAgPSAgIEFMUEhBIC8gRElHSVQgLyBcIiFcIiAvIFwiI1wiIC8gXCIkXCIgLyBcIiVcIiAvIFwiJlwiIC8gXCInXCIgLyBcIipcIiAvIFwiK1wiIC8gXCItXCIgLyBcIi9cIiAvIFwiPVwiIC8gXCI/XCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcIntcIiAvIFwifFwiIC8gXCJ9XCIgLyBcIn5cIlxuXG4gICAgICAgIERvbWFpbiAgICAgICAgICA9ICAgc3ViLWRvbWFpbiAqKFwiLlwiIHN1Yi1kb21haW4pXG4gICAgICAgIHN1Yi1kb21haW4gICAgICA9ICAgTGV0LWRpZyBbTGRoLXN0cl1cbiAgICAgICAgTGV0LWRpZyAgICAgICAgID0gICBBTFBIQSAvIERJR0lUXG4gICAgICAgIExkaC1zdHIgICAgICAgICA9ICAgKiggQUxQSEEgLyBESUdJVCAvIFwiLVwiICkgTGV0LWRpZ1xuXG4gICAgICAgIEFMUEhBICAgICAgICAgICA9ICAgJXg0MS01QSAvICV4NjEtN0EgICAgICAgIDsgYS16LCBBLVpcbiAgICAgICAgRElHSVQgICAgICAgICAgID0gICAleDMwLTM5ICAgICAgICAgICAgICAgICAgOyAwLTlcblxuICAgIEZyb20gUkZDIDY1MzE6XG5cbiAgICAgICAgc3ViLWRvbWFpbiAgICAgID0vICBVLWxhYmVsXG4gICAgICAgIGF0ZXh0ICAgICAgICAgICA9LyAgVVRGOC1ub24tYXNjaWlcblxuICAgICAgICBVVEY4LW5vbi1hc2NpaSAgPSAgIFVURjgtMiAvIFVURjgtMyAvIFVURjgtNFxuXG4gICAgICAgIFVURjgtMiAgICAgICAgICA9ICAgJXhDMi1ERiBVVEY4LXRhaWxcbiAgICAgICAgVVRGOC0zICAgICAgICAgID0gICAleEUwICV4QTAtQkYgVVRGOC10YWlsIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEUxLUVDIDIoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEVEICV4ODAtOUYgVVRGOC10YWlsIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEVFLUVGIDIoIFVURjgtdGFpbCApXG4gICAgICAgIFVURjgtNCAgICAgICAgICA9ICAgJXhGMCAleDkwLUJGIDIoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEYxLUYzIDMoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEY0ICV4ODAtOEYgMiggVVRGOC10YWlsIClcblxuICAgICAgICBVVEY4LXRhaWwgICAgICAgPSAgICV4ODAtQkZcblxuICAgIE5vdGU6IFRoZSBmb2xsb3dpbmcgYXJlIG5vdCBzdXBwb3J0ZWQ6XG5cbiAgICAgICAgUkZDIDUzMjE6IGFkZHJlc3MtbGl0ZXJhbCwgUXVvdGVkLXN0cmluZ1xuICAgICAgICBSRkMgNTMyMjogb2JzLSosIENGV1NcbiovXG5cblxuaW50ZXJuYWxzLmF0ZXh0UnggPSAvXltcXHchI1xcJCUmJ1xcKlxcK1xcLS89XFw/XFxeYFxce1xcfFxcfX5dKyQvOyAgICAgICAgICAgICAgIC8vIF8gaW5jbHVkZWQgaW4gXFx3XG5cblxuaW50ZXJuYWxzLmF0b21SeCA9IG5ldyBSZWdFeHAoW1xuXG4gICAgLy8gICV4QzItREYgVVRGOC10YWlsXG4gICAgJyg/OltcXFxceGMyLVxcXFx4ZGZdW1xcXFx4ODAtXFxcXHhiZl0pJyxcblxuICAgIC8vICAleEUwICV4QTAtQkYgVVRGOC10YWlsICAgICAgICAgICAgICAleEUxLUVDIDIoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhFRCAleDgwLTlGIFVURjgtdGFpbCAgICAgICAgICAgICAgJXhFRS1FRiAyKCBVVEY4LXRhaWwgKVxuICAgICcoPzpcXFxceGUwW1xcXFx4YTAtXFxcXHhiZl1bXFxcXHg4MC1cXFxceGJmXSl8KD86W1xcXFx4ZTEtXFxcXHhlY11bXFxcXHg4MC1cXFxceGJmXXsyfSl8KD86XFxcXHhlZFtcXFxceDgwLVxcXFx4OWZdW1xcXFx4ODAtXFxcXHhiZl0pfCg/OltcXFxceGVlLVxcXFx4ZWZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pJyxcblxuICAgIC8vICAleEYwICV4OTAtQkYgMiggVVRGOC10YWlsICkgICAgICAgICAgICAleEYxLUYzIDMoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhGNCAleDgwLThGIDIoIFVURjgtdGFpbCApXG4gICAgJyg/OlxcXFx4ZjBbXFxcXHg5MC1cXFxceGJmXVtcXFxceDgwLVxcXFx4YmZdezJ9KXwoPzpbXFxcXHhmMS1cXFxceGYzXVtcXFxceDgwLVxcXFx4YmZdezN9KXwoPzpcXFxceGY0W1xcXFx4ODAtXFxcXHg4Zl1bXFxcXHg4MC1cXFxceGJmXXsyfSknXG5cbl0uam9pbignfCcpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgLy8gRXNjYXBlIF4kLiorLT89ITp8XFwvKClbXXt9LFxuXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxeXFwkXFwuXFwqXFwrXFwtXFw/XFw9XFwhXFw6XFx8XFxcXFxcL1xcKFxcKVxcW1xcXVxce1xcfVxcLF0vZywgJ1xcXFwkJicpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRXNjYXBlUmVnZXggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJmYzM5ODYgPSB7fTtcblxuICAgIGNvbnN0IGhleERpZ2l0ID0gJ1xcXFxkQS1GYS1mJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhFWERJRyA9IERJR0lUIC8gXCJBXCIgLyBcIkJcIiAvIFwiQ1wiIC8gXCJEXCIgLyBcIkVcIiAvIFwiRlwiXG4gICAgY29uc3QgaGV4RGlnaXRPbmx5ID0gJ1snICsgaGV4RGlnaXQgKyAnXSc7XG5cbiAgICBjb25zdCB1bnJlc2VydmVkID0gJ1xcXFx3LVxcXFwufic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVucmVzZXJ2ZWQgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAgICBjb25zdCBzdWJEZWxpbXMgPSAnIVxcXFwkJlxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWItZGVsaW1zID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICAgIGNvbnN0IHBjdEVuY29kZWQgPSAnJScgKyBoZXhEaWdpdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwY3QtZW5jb2RlZCA9IFwiJVwiIEhFWERJRyBIRVhESUdcbiAgICBjb25zdCBwY2hhciA9IHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpAJzsgICAgICAgICAgICAgICAgICAgLy8gcGNoYXIgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxuICAgIGNvbnN0IHBjaGFyT25seSA9ICdbJyArIHBjaGFyICsgJ10nO1xuICAgIGNvbnN0IGRlY09jdGVjdCA9ICcoPzowezAsMn1cXFxcZHwwP1sxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSknOyAgICAgLy8gZGVjLW9jdGV0ID0gRElHSVQgLyAleDMxLTM5IERJR0lUIC8gXCIxXCIgMkRJR0lUIC8gXCIyXCIgJXgzMC0zNCBESUdJVCAvIFwiMjVcIiAleDMwLTM1ICA7IDAtOSAvIDEwLTk5IC8gMTAwLTE5OSAvIDIwMC0yNDkgLyAyNTAtMjU1XG5cbiAgICByZmMzOTg2LmlwdjRhZGRyZXNzID0gJyg/OicgKyBkZWNPY3RlY3QgKyAnXFxcXC4pezN9JyArIGRlY09jdGVjdDsgICAgICAgICAgICAvLyBJUHY0YWRkcmVzcyA9IGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldFxuXG4gICAgLypcbiAgICAgICAgaDE2ID0gMSo0SEVYRElHIDsgMTYgYml0cyBvZiBhZGRyZXNzIHJlcHJlc2VudGVkIGluIGhleGFkZWNpbWFsXG4gICAgICAgIGxzMzIgPSAoIGgxNiBcIjpcIiBoMTYgKSAvIElQdjRhZGRyZXNzIDsgbGVhc3Qtc2lnbmlmaWNhbnQgMzIgYml0cyBvZiBhZGRyZXNzXG4gICAgICAgIElQdjZhZGRyZXNzID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgICAgICAgICAgICAgICAgIC8gWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgKi9cblxuICAgIGNvbnN0IGgxNiA9IGhleERpZ2l0T25seSArICd7MSw0fSc7XG4gICAgY29uc3QgbHMzMiA9ICcoPzonICsgaDE2ICsgJzonICsgaDE2ICsgJ3wnICsgcmZjMzk4Ni5pcHY0YWRkcmVzcyArICcpJztcbiAgICBjb25zdCBJUHY2U2l4SGV4ID0gJyg/OicgKyBoMTYgKyAnOil7Nn0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Rml2ZUhleCA9ICc6Oig/OicgKyBoMTYgKyAnOil7NX0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Rm91ckhleCA9ICcoPzonICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezR9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlRocmVlSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwxfScgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7M30nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2VHdvSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwyfScgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7Mn0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2T25lSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwzfScgKyBoMTYgKyAnKT86OicgKyBoMTYgKyAnOicgKyBsczMyO1xuICAgIGNvbnN0IElQdjZOb25lSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw0fScgKyBoMTYgKyAnKT86OicgKyBsczMyO1xuICAgIGNvbnN0IElQdjZOb25lSGV4MiA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNX0nICsgaDE2ICsgJyk/OjonICsgaDE2O1xuICAgIGNvbnN0IElQdjZOb25lSGV4MyA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNn0nICsgaDE2ICsgJyk/OjonO1xuXG4gICAgcmZjMzk4Ni5pcHY0Q2lkciA9ICcoPzpcXFxcZHxbMS0yXVxcXFxkfDNbMC0yXSknOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJUHY0IGNpZHIgPSBESUdJVCAvICV4MzEtMzIgRElHSVQgLyBcIjNcIiAleDMwLTMyICA7IDAtOSAvIDEwLTI5IC8gMzAtMzJcbiAgICByZmMzOTg2LmlwdjZDaWRyID0gJyg/OjB7MCwyfVxcXFxkfDA/WzEtOV1cXFxcZHwxWzAxXVxcXFxkfDEyWzAtOF0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVB2NiBjaWRyID0gRElHSVQgLyAleDMxLTM5IERJR0lUIC8gXCIxXCIgJXgwLTEgRElHSVQgLyBcIjEyXCIgJXgwLTg7ICAgMC05IC8gMTAtOTkgLyAxMDAtMTE5IC8gMTIwLTEyOFxuICAgIHJmYzM5ODYuaXB2NmFkZHJlc3MgPSAnKD86JyArIElQdjZTaXhIZXggKyAnfCcgKyBJUHY2Rml2ZUhleCArICd8JyArIElQdjZGb3VySGV4ICsgJ3wnICsgSVB2NlRocmVlSGV4ICsgJ3wnICsgSVB2NlR3b0hleCArICd8JyArIElQdjZPbmVIZXggKyAnfCcgKyBJUHY2Tm9uZUhleCArICd8JyArIElQdjZOb25lSGV4MiArICd8JyArIElQdjZOb25lSGV4MyArICcpJztcbiAgICByZmMzOTg2LmlwdkZ1dHVyZSA9ICd2JyArIGhleERpZ2l0T25seSArICcrXFxcXC5bJyArIHVucmVzZXJ2ZWQgKyBzdWJEZWxpbXMgKyAnOl0rJzsgICAgICAvLyBJUHZGdXR1cmUgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG5cbiAgICByZmMzOTg2LnNjaGVtZSA9ICdbYS16QS1aXVthLXpBLVpcXFxcZCstXFxcXC5dKic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjaGVtZSA9IEFMUEhBICooIEFMUEhBIC8gRElHSVQgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgKVxuICAgIHJmYzM5ODYuc2NoZW1lUmVnZXggPSBuZXcgUmVnRXhwKHJmYzM5ODYuc2NoZW1lKTtcblxuICAgIGNvbnN0IHVzZXJpbmZvID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOl0qJzsgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyaW5mbyA9ICooIHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgY29uc3QgSVBMaXRlcmFsID0gJ1xcXFxbKD86JyArIHJmYzM5ODYuaXB2NmFkZHJlc3MgKyAnfCcgKyByZmMzOTg2LmlwdkZ1dHVyZSArICcpXFxcXF0nOyAgICAvLyBJUC1saXRlcmFsID0gXCJbXCIgKCBJUHY2YWRkcmVzcyAvIElQdkZ1dHVyZSAgKSBcIl1cIlxuICAgIGNvbnN0IHJlZ05hbWUgPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICddezEsMjU1fSc7ICAgICAgICAgICAgICAgICAvLyByZWctbmFtZSA9ICooIHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgKVxuICAgIGNvbnN0IGhvc3QgPSAnKD86JyArIElQTGl0ZXJhbCArICd8JyArIHJmYzM5ODYuaXB2NGFkZHJlc3MgKyAnfCcgKyByZWdOYW1lICsgJyknOyAgICAgICAvLyBob3N0ID0gSVAtbGl0ZXJhbCAvIElQdjRhZGRyZXNzIC8gcmVnLW5hbWVcbiAgICBjb25zdCBwb3J0ID0gJ1xcXFxkKic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3J0ID0gKkRJR0lUXG4gICAgY29uc3QgYXV0aG9yaXR5ID0gJyg/OicgKyB1c2VyaW5mbyArICdAKT8nICsgaG9zdCArICcoPzo6JyArIHBvcnQgKyAnKT8nOyAgICAgICAgICAgICAgIC8vIGF1dGhvcml0eSAgID0gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF1cbiAgICBjb25zdCBhdXRob3JpdHlDYXB0dXJlID0gJyg/OicgKyB1c2VyaW5mbyArICdAKT8oJyArIGhvc3QgKyAnKSg/OjonICsgcG9ydCArICcpPyc7XG5cbiAgICAvKlxuICAgICAgICBzZWdtZW50ICAgICAgID0gKnBjaGFyXG4gICAgICAgIHNlZ21lbnQtbnogICAgPSAxKnBjaGFyXG4gICAgICAgIHBhdGggICAgICAgICAgPSBwYXRoLWFiZW1wdHkgICAgOyBiZWdpbnMgd2l0aCBcIi9cIiAnfCcgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLWFic29sdXRlICAgOyBiZWdpbnMgd2l0aCBcIi9cIiBidXQgbm90IFwiLy9cIlxuICAgICAgICAgICAgICAgICAgICAvIHBhdGgtbm9zY2hlbWUgICA7IGJlZ2lucyB3aXRoIGEgbm9uLWNvbG9uIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLXJvb3RsZXNzICAgOyBiZWdpbnMgd2l0aCBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLWVtcHR5ICAgICAgOyB6ZXJvIGNoYXJhY3RlcnNcbiAgICAgICAgcGF0aC1hYmVtcHR5ICA9ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICAgICBwYXRoLWFic29sdXRlID0gXCIvXCIgWyBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKSBdXG4gICAgICAgIHBhdGgtcm9vdGxlc3MgPSBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICovXG5cbiAgICBjb25zdCBzZWdtZW50ID0gcGNoYXJPbmx5ICsgJyonO1xuICAgIGNvbnN0IHNlZ21lbnROeiA9IHBjaGFyT25seSArICcrJztcbiAgICBjb25zdCBzZWdtZW50TnpOYyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ0AnICsgJ10rJztcbiAgICBjb25zdCBwYXRoRW1wdHkgPSAnJztcbiAgICBjb25zdCBwYXRoQWJFbXB0eSA9ICcoPzpcXFxcLycgKyBzZWdtZW50ICsgJykqJztcbiAgICBjb25zdCBwYXRoQWJzb2x1dGUgPSAnXFxcXC8oPzonICsgc2VnbWVudE56ICsgcGF0aEFiRW1wdHkgKyAnKT8nO1xuICAgIGNvbnN0IHBhdGhSb290bGVzcyA9IHNlZ21lbnROeiArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhOb1NjaGVtZSA9IHNlZ21lbnROek5jICsgcGF0aEFiRW1wdHk7XG4gICAgY29uc3QgcGF0aEFiTm9BdXRob3JpdHkgPSAnKD86XFxcXC9cXFxcL1xcXFwvJyArIHNlZ21lbnQgKyBwYXRoQWJFbXB0eSArICcpJzsgICAgIC8vIFVzZWQgYnkgZmlsZTovLy9cblxuICAgIC8vIGhpZXItcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aFxuXG4gICAgcmZjMzk4Ni5oaWVyUGFydCA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoUm9vdGxlc3MgKyAnfCcgKyBwYXRoQWJOb0F1dGhvcml0eSArICcpJztcbiAgICByZmMzOTg2LmhpZXJQYXJ0Q2FwdHVyZSA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5Q2FwdHVyZSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aFJvb3RsZXNzICsgJyknO1xuXG4gICAgLy8gcmVsYXRpdmUtcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5IC8gcGF0aC1hYnNvbHV0ZSAvIHBhdGgtbm9zY2hlbWUgLyBwYXRoLWVtcHR5XG5cbiAgICByZmMzOTg2LnJlbGF0aXZlUmVmID0gJyg/OicgKyAnKD86XFxcXC9cXFxcLycgKyBhdXRob3JpdHkgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhOb1NjaGVtZSArICd8JyArIHBhdGhFbXB0eSArICcpJztcbiAgICByZmMzOTg2LnJlbGF0aXZlUmVmQ2FwdHVyZSA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5Q2FwdHVyZSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aE5vU2NoZW1lICsgJ3wnICsgcGF0aEVtcHR5ICsgJyknO1xuXG4gICAgLy8gcXVlcnkgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuICAgIC8vIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIltcIiAvIFwiXVwiIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LnF1ZXJ5ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCAnfCcgZW5kIG9mIHRoZSBsaW5lLlxuICAgIHJmYzM5ODYucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgPSAnWycgKyBwY2hhciArICdcXFxcW1xcXFxdXFxcXC9cXFxcP10qKD89I3wkKSc7XG5cbiAgICAvLyBmcmFnbWVudCA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LmZyYWdtZW50ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qJztcblxuICAgIHJldHVybiByZmMzOTg2O1xufTtcblxuaW50ZXJuYWxzLnJmYzM5ODYgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoKTtcblxuXG5leHBvcnRzLmlwID0ge1xuICAgIHY0Q2lkcjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NENpZHIsXG4gICAgdjZDaWRyOiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY2Q2lkcixcbiAgICBpcHY0OiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY0YWRkcmVzcyxcbiAgICBpcHY2OiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY2YWRkcmVzcyxcbiAgICBpcHZmdXR1cmU6IGludGVybmFscy5yZmMzOTg2LmlwdkZ1dHVyZVxufTtcblxuXG5pbnRlcm5hbHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgY29uc3QgcmZjID0gaW50ZXJuYWxzLnJmYzM5ODY7XG5cbiAgICAvLyBDb25zdHJ1Y3QgZXhwcmVzc2lvblxuXG4gICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyA/IHJmYy5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA6IHJmYy5xdWVyeTtcbiAgICBjb25zdCBzdWZmaXggPSAnKD86XFxcXD8nICsgcXVlcnkgKyAnKT8nICsgJyg/OiMnICsgcmZjLmZyYWdtZW50ICsgJyk/JztcblxuICAgIC8vIHJlbGF0aXZlLXJlZiA9IHJlbGF0aXZlLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgY29uc3QgcmVsYXRpdmUgPSBvcHRpb25zLmRvbWFpbiA/IHJmYy5yZWxhdGl2ZVJlZkNhcHR1cmUgOiByZmMucmVsYXRpdmVSZWY7XG5cbiAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHJlbGF0aXZlICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gc2NoZW1lc1xuXG4gICAgbGV0IGN1c3RvbVNjaGVtZSA9ICcnO1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5zY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIG9wdGlvbnMuc2NoZW1lID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1lKSwgJ3NjaGVtZSBtdXN0IGJlIGEgUmVnRXhwLCBTdHJpbmcsIG9yIEFycmF5Jyk7XG5cbiAgICAgICAgY29uc3Qgc2NoZW1lcyA9IFtdLmNvbmNhdChvcHRpb25zLnNjaGVtZSk7XG4gICAgICAgIEFzc2VydChzY2hlbWVzLmxlbmd0aCA+PSAxLCAnc2NoZW1lIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHNjaGVtZSBzcGVjaWZpZWQnKTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHRvIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNjaGVtZXNcblxuICAgICAgICBjb25zdCBzZWxlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gc2NoZW1lc1tpXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycsICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBSZWdFeHAgb3IgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2goc2NoZW1lLnNvdXJjZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEFzc2VydChyZmMuc2NoZW1lUmVnZXgudGVzdChzY2hlbWUpLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgdmFsaWQgc2NoZW1lJyk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKEVzY2FwZVJlZ2V4KHNjaGVtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VzdG9tU2NoZW1lID0gc2VsZWN0aW9ucy5qb2luKCd8Jyk7XG4gICAgfVxuXG4gICAgLy8gVVJJID0gc2NoZW1lIFwiOlwiIGhpZXItcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG5cbiAgICBjb25zdCBzY2hlbWUgPSBjdXN0b21TY2hlbWUgPyAnKD86JyArIGN1c3RvbVNjaGVtZSArICcpJyA6IHJmYy5zY2hlbWU7XG4gICAgY29uc3QgYWJzb2x1dGUgPSAnKD86JyArIHNjaGVtZSArICc6JyArIChvcHRpb25zLmRvbWFpbiA/IHJmYy5oaWVyUGFydENhcHR1cmUgOiByZmMuaGllclBhcnQpICsgJyknO1xuICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSA/ICcoPzonICsgYWJzb2x1dGUgKyAnfCcgKyByZWxhdGl2ZSArICcpJyA6IGFic29sdXRlO1xuICAgIHJldHVybiBpbnRlcm5hbHMud3JhcChwcmVmaXggKyBzdWZmaXgsIGN1c3RvbVNjaGVtZSk7XG59O1xuXG5cbmludGVybmFscy53cmFwID0gZnVuY3Rpb24gKHJhdywgc2NoZW1lKSB7XG5cbiAgICByYXcgPSBgKD89LikoPyFodHRwcz9cXDovKD86JHxbXi9dKSkoPyFodHRwcz9cXDovLy8pKD8haHR0cHM/XFw6W14vXSkke3Jhd31gOyAgICAgLy8gUmVxdWlyZSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFuZCBleHBsaWNpdGx5IGZvcmJpZCAnaHR0cDovJyBvciBIVFRQIHdpdGggZW1wdHkgZG9tYWluXG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYXcsXG4gICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGBeJHtyYXd9JGApLFxuICAgICAgICBzY2hlbWVcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMudXJpUmVnZXggPSBpbnRlcm5hbHMuY3JlYXRlUmVnZXgoe30pO1xuXG5cbmV4cG9ydHMucmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWUgfHxcbiAgICAgICAgb3B0aW9ucy5hbGxvd1JlbGF0aXZlIHx8XG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmVPbmx5IHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzIHx8XG4gICAgICAgIG9wdGlvbnMuZG9tYWluKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVSZWdleChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnVyaVJlZ2V4O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBVcmkgPSByZXF1aXJlKCcuL3VyaScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMucmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAvLyBDSURSXG5cbiAgICBBc3NlcnQob3B0aW9ucy5jaWRyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMuY2lkciA9PT0gJ3N0cmluZycsICdvcHRpb25zLmNpZHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGNvbnN0IGNpZHIgPSBvcHRpb25zLmNpZHIgPyBvcHRpb25zLmNpZHIudG9Mb3dlckNhc2UoKSA6ICdvcHRpb25hbCc7XG4gICAgQXNzZXJ0KFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMoY2lkciksICdvcHRpb25zLmNpZHIgbXVzdCBiZSBvbmUgb2YgcmVxdWlyZWQsIG9wdGlvbmFsLCBmb3JiaWRkZW4nKTtcblxuICAgIC8vIFZlcnNpb25zXG5cbiAgICBBc3NlcnQob3B0aW9ucy52ZXJzaW9uID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMudmVyc2lvbiA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnZlcnNpb24pLCAnb3B0aW9ucy52ZXJzaW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nJyk7XG4gICAgbGV0IHZlcnNpb25zID0gb3B0aW9ucy52ZXJzaW9uIHx8IFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHtcbiAgICAgICAgdmVyc2lvbnMgPSBbdmVyc2lvbnNdO1xuICAgIH1cblxuICAgIEFzc2VydCh2ZXJzaW9ucy5sZW5ndGggPj0gMSwgJ29wdGlvbnMudmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb25zW2ldID09PSAnc3RyaW5nJywgJ29wdGlvbnMudmVyc2lvbiBtdXN0IG9ubHkgY29udGFpbiBzdHJpbmdzJyk7XG4gICAgICAgIHZlcnNpb25zW2ldID0gdmVyc2lvbnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgQXNzZXJ0KFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddLmluY2x1ZGVzKHZlcnNpb25zW2ldKSwgJ29wdGlvbnMudmVyc2lvbiBjb250YWlucyB1bmtub3duIHZlcnNpb24gJyArIHZlcnNpb25zW2ldICsgJyAtIG11c3QgYmUgb25lIG9mIGlwdjQsIGlwdjYsIGlwdmZ1dHVyZScpO1xuICAgIH1cblxuICAgIHZlcnNpb25zID0gQXJyYXkuZnJvbShuZXcgU2V0KHZlcnNpb25zKSk7XG5cbiAgICAvLyBSZWdleFxuXG4gICAgY29uc3QgcGFydHMgPSB2ZXJzaW9ucy5tYXAoKHZlcnNpb24pID0+IHtcblxuICAgICAgICAvLyBGb3JiaWRkZW5cblxuICAgICAgICBpZiAoY2lkciA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiBVcmkuaXBbdmVyc2lvbl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXF1aXJlZFxuXG4gICAgICAgIGNvbnN0IGNpZHJwYXJ0ID0gYFxcXFwvJHt2ZXJzaW9uID09PSAnaXB2NCcgPyBVcmkuaXAudjRDaWRyIDogVXJpLmlwLnY2Q2lkcn1gO1xuXG4gICAgICAgIGlmIChjaWRyID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7VXJpLmlwW3ZlcnNpb25dfSR7Y2lkcnBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsXG5cbiAgICAgICAgcmV0dXJuIGAke1VyaS5pcFt2ZXJzaW9uXX0oPzoke2NpZHJwYXJ0fSk/YDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJhdyA9IGAoPzoke3BhcnRzLmpvaW4oJ3wnKX0pYDtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke3Jhd30kYCk7XG4gICAgcmV0dXJuIHsgY2lkciwgdmVyc2lvbnMsIHJlZ2V4LCByYXcgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBodHRwOi8vZGF0YS5pYW5hLm9yZy9UTEQvdGxkcy1hbHBoYS1ieS1kb21haW4udHh0XG4vLyAjIFZlcnNpb24gMjAyMjAzMjEwMiwgTGFzdCBVcGRhdGVkIFR1ZSBNYXIgMjIgMDc6MDc6MDEgMjAyMiBVVENcblxuXG5pbnRlcm5hbHMudGxkcyA9IFtcbiAgICAnQUFBJyxcbiAgICAnQUFSUCcsXG4gICAgJ0FCQVJUSCcsXG4gICAgJ0FCQicsXG4gICAgJ0FCQk9UVCcsXG4gICAgJ0FCQlZJRScsXG4gICAgJ0FCQycsXG4gICAgJ0FCTEUnLFxuICAgICdBQk9HQURPJyxcbiAgICAnQUJVREhBQkknLFxuICAgICdBQycsXG4gICAgJ0FDQURFTVknLFxuICAgICdBQ0NFTlRVUkUnLFxuICAgICdBQ0NPVU5UQU5UJyxcbiAgICAnQUNDT1VOVEFOVFMnLFxuICAgICdBQ08nLFxuICAgICdBQ1RPUicsXG4gICAgJ0FEJyxcbiAgICAnQURBQycsXG4gICAgJ0FEUycsXG4gICAgJ0FEVUxUJyxcbiAgICAnQUUnLFxuICAgICdBRUcnLFxuICAgICdBRVJPJyxcbiAgICAnQUVUTkEnLFxuICAgICdBRicsXG4gICAgJ0FGTCcsXG4gICAgJ0FGUklDQScsXG4gICAgJ0FHJyxcbiAgICAnQUdBS0hBTicsXG4gICAgJ0FHRU5DWScsXG4gICAgJ0FJJyxcbiAgICAnQUlHJyxcbiAgICAnQUlSQlVTJyxcbiAgICAnQUlSRk9SQ0UnLFxuICAgICdBSVJURUwnLFxuICAgICdBS0ROJyxcbiAgICAnQUwnLFxuICAgICdBTEZBUk9NRU8nLFxuICAgICdBTElCQUJBJyxcbiAgICAnQUxJUEFZJyxcbiAgICAnQUxMRklOQU5aJyxcbiAgICAnQUxMU1RBVEUnLFxuICAgICdBTExZJyxcbiAgICAnQUxTQUNFJyxcbiAgICAnQUxTVE9NJyxcbiAgICAnQU0nLFxuICAgICdBTUFaT04nLFxuICAgICdBTUVSSUNBTkVYUFJFU1MnLFxuICAgICdBTUVSSUNBTkZBTUlMWScsXG4gICAgJ0FNRVgnLFxuICAgICdBTUZBTScsXG4gICAgJ0FNSUNBJyxcbiAgICAnQU1TVEVSREFNJyxcbiAgICAnQU5BTFlUSUNTJyxcbiAgICAnQU5EUk9JRCcsXG4gICAgJ0FOUVVBTicsXG4gICAgJ0FOWicsXG4gICAgJ0FPJyxcbiAgICAnQU9MJyxcbiAgICAnQVBBUlRNRU5UUycsXG4gICAgJ0FQUCcsXG4gICAgJ0FQUExFJyxcbiAgICAnQVEnLFxuICAgICdBUVVBUkVMTEUnLFxuICAgICdBUicsXG4gICAgJ0FSQUInLFxuICAgICdBUkFNQ08nLFxuICAgICdBUkNISScsXG4gICAgJ0FSTVknLFxuICAgICdBUlBBJyxcbiAgICAnQVJUJyxcbiAgICAnQVJURScsXG4gICAgJ0FTJyxcbiAgICAnQVNEQScsXG4gICAgJ0FTSUEnLFxuICAgICdBU1NPQ0lBVEVTJyxcbiAgICAnQVQnLFxuICAgICdBVEhMRVRBJyxcbiAgICAnQVRUT1JORVknLFxuICAgICdBVScsXG4gICAgJ0FVQ1RJT04nLFxuICAgICdBVURJJyxcbiAgICAnQVVESUJMRScsXG4gICAgJ0FVRElPJyxcbiAgICAnQVVTUE9TVCcsXG4gICAgJ0FVVEhPUicsXG4gICAgJ0FVVE8nLFxuICAgICdBVVRPUycsXG4gICAgJ0FWSUFOQ0EnLFxuICAgICdBVycsXG4gICAgJ0FXUycsXG4gICAgJ0FYJyxcbiAgICAnQVhBJyxcbiAgICAnQVonLFxuICAgICdBWlVSRScsXG4gICAgJ0JBJyxcbiAgICAnQkFCWScsXG4gICAgJ0JBSURVJyxcbiAgICAnQkFOQU1FWCcsXG4gICAgJ0JBTkFOQVJFUFVCTElDJyxcbiAgICAnQkFORCcsXG4gICAgJ0JBTksnLFxuICAgICdCQVInLFxuICAgICdCQVJDRUxPTkEnLFxuICAgICdCQVJDTEFZQ0FSRCcsXG4gICAgJ0JBUkNMQVlTJyxcbiAgICAnQkFSRUZPT1QnLFxuICAgICdCQVJHQUlOUycsXG4gICAgJ0JBU0VCQUxMJyxcbiAgICAnQkFTS0VUQkFMTCcsXG4gICAgJ0JBVUhBVVMnLFxuICAgICdCQVlFUk4nLFxuICAgICdCQicsXG4gICAgJ0JCQycsXG4gICAgJ0JCVCcsXG4gICAgJ0JCVkEnLFxuICAgICdCQ0cnLFxuICAgICdCQ04nLFxuICAgICdCRCcsXG4gICAgJ0JFJyxcbiAgICAnQkVBVFMnLFxuICAgICdCRUFVVFknLFxuICAgICdCRUVSJyxcbiAgICAnQkVOVExFWScsXG4gICAgJ0JFUkxJTicsXG4gICAgJ0JFU1QnLFxuICAgICdCRVNUQlVZJyxcbiAgICAnQkVUJyxcbiAgICAnQkYnLFxuICAgICdCRycsXG4gICAgJ0JIJyxcbiAgICAnQkhBUlRJJyxcbiAgICAnQkknLFxuICAgICdCSUJMRScsXG4gICAgJ0JJRCcsXG4gICAgJ0JJS0UnLFxuICAgICdCSU5HJyxcbiAgICAnQklOR08nLFxuICAgICdCSU8nLFxuICAgICdCSVonLFxuICAgICdCSicsXG4gICAgJ0JMQUNLJyxcbiAgICAnQkxBQ0tGUklEQVknLFxuICAgICdCTE9DS0JVU1RFUicsXG4gICAgJ0JMT0cnLFxuICAgICdCTE9PTUJFUkcnLFxuICAgICdCTFVFJyxcbiAgICAnQk0nLFxuICAgICdCTVMnLFxuICAgICdCTVcnLFxuICAgICdCTicsXG4gICAgJ0JOUFBBUklCQVMnLFxuICAgICdCTycsXG4gICAgJ0JPQVRTJyxcbiAgICAnQk9FSFJJTkdFUicsXG4gICAgJ0JPRkEnLFxuICAgICdCT00nLFxuICAgICdCT05EJyxcbiAgICAnQk9PJyxcbiAgICAnQk9PSycsXG4gICAgJ0JPT0tJTkcnLFxuICAgICdCT1NDSCcsXG4gICAgJ0JPU1RJSycsXG4gICAgJ0JPU1RPTicsXG4gICAgJ0JPVCcsXG4gICAgJ0JPVVRJUVVFJyxcbiAgICAnQk9YJyxcbiAgICAnQlInLFxuICAgICdCUkFERVNDTycsXG4gICAgJ0JSSURHRVNUT05FJyxcbiAgICAnQlJPQURXQVknLFxuICAgICdCUk9LRVInLFxuICAgICdCUk9USEVSJyxcbiAgICAnQlJVU1NFTFMnLFxuICAgICdCUycsXG4gICAgJ0JUJyxcbiAgICAnQlVHQVRUSScsXG4gICAgJ0JVSUxEJyxcbiAgICAnQlVJTERFUlMnLFxuICAgICdCVVNJTkVTUycsXG4gICAgJ0JVWScsXG4gICAgJ0JVWlonLFxuICAgICdCVicsXG4gICAgJ0JXJyxcbiAgICAnQlknLFxuICAgICdCWicsXG4gICAgJ0JaSCcsXG4gICAgJ0NBJyxcbiAgICAnQ0FCJyxcbiAgICAnQ0FGRScsXG4gICAgJ0NBTCcsXG4gICAgJ0NBTEwnLFxuICAgICdDQUxWSU5LTEVJTicsXG4gICAgJ0NBTScsXG4gICAgJ0NBTUVSQScsXG4gICAgJ0NBTVAnLFxuICAgICdDQU5DRVJSRVNFQVJDSCcsXG4gICAgJ0NBTk9OJyxcbiAgICAnQ0FQRVRPV04nLFxuICAgICdDQVBJVEFMJyxcbiAgICAnQ0FQSVRBTE9ORScsXG4gICAgJ0NBUicsXG4gICAgJ0NBUkFWQU4nLFxuICAgICdDQVJEUycsXG4gICAgJ0NBUkUnLFxuICAgICdDQVJFRVInLFxuICAgICdDQVJFRVJTJyxcbiAgICAnQ0FSUycsXG4gICAgJ0NBU0EnLFxuICAgICdDQVNFJyxcbiAgICAnQ0FTSCcsXG4gICAgJ0NBU0lOTycsXG4gICAgJ0NBVCcsXG4gICAgJ0NBVEVSSU5HJyxcbiAgICAnQ0FUSE9MSUMnLFxuICAgICdDQkEnLFxuICAgICdDQk4nLFxuICAgICdDQlJFJyxcbiAgICAnQ0JTJyxcbiAgICAnQ0MnLFxuICAgICdDRCcsXG4gICAgJ0NFTlRFUicsXG4gICAgJ0NFTycsXG4gICAgJ0NFUk4nLFxuICAgICdDRicsXG4gICAgJ0NGQScsXG4gICAgJ0NGRCcsXG4gICAgJ0NHJyxcbiAgICAnQ0gnLFxuICAgICdDSEFORUwnLFxuICAgICdDSEFOTkVMJyxcbiAgICAnQ0hBUklUWScsXG4gICAgJ0NIQVNFJyxcbiAgICAnQ0hBVCcsXG4gICAgJ0NIRUFQJyxcbiAgICAnQ0hJTlRBSScsXG4gICAgJ0NIUklTVE1BUycsXG4gICAgJ0NIUk9NRScsXG4gICAgJ0NIVVJDSCcsXG4gICAgJ0NJJyxcbiAgICAnQ0lQUklBTkknLFxuICAgICdDSVJDTEUnLFxuICAgICdDSVNDTycsXG4gICAgJ0NJVEFERUwnLFxuICAgICdDSVRJJyxcbiAgICAnQ0lUSUMnLFxuICAgICdDSVRZJyxcbiAgICAnQ0lUWUVBVFMnLFxuICAgICdDSycsXG4gICAgJ0NMJyxcbiAgICAnQ0xBSU1TJyxcbiAgICAnQ0xFQU5JTkcnLFxuICAgICdDTElDSycsXG4gICAgJ0NMSU5JQycsXG4gICAgJ0NMSU5JUVVFJyxcbiAgICAnQ0xPVEhJTkcnLFxuICAgICdDTE9VRCcsXG4gICAgJ0NMVUInLFxuICAgICdDTFVCTUVEJyxcbiAgICAnQ00nLFxuICAgICdDTicsXG4gICAgJ0NPJyxcbiAgICAnQ09BQ0gnLFxuICAgICdDT0RFUycsXG4gICAgJ0NPRkZFRScsXG4gICAgJ0NPTExFR0UnLFxuICAgICdDT0xPR05FJyxcbiAgICAnQ09NJyxcbiAgICAnQ09NQ0FTVCcsXG4gICAgJ0NPTU1CQU5LJyxcbiAgICAnQ09NTVVOSVRZJyxcbiAgICAnQ09NUEFOWScsXG4gICAgJ0NPTVBBUkUnLFxuICAgICdDT01QVVRFUicsXG4gICAgJ0NPTVNFQycsXG4gICAgJ0NPTkRPUycsXG4gICAgJ0NPTlNUUlVDVElPTicsXG4gICAgJ0NPTlNVTFRJTkcnLFxuICAgICdDT05UQUNUJyxcbiAgICAnQ09OVFJBQ1RPUlMnLFxuICAgICdDT09LSU5HJyxcbiAgICAnQ09PS0lOR0NIQU5ORUwnLFxuICAgICdDT09MJyxcbiAgICAnQ09PUCcsXG4gICAgJ0NPUlNJQ0EnLFxuICAgICdDT1VOVFJZJyxcbiAgICAnQ09VUE9OJyxcbiAgICAnQ09VUE9OUycsXG4gICAgJ0NPVVJTRVMnLFxuICAgICdDUEEnLFxuICAgICdDUicsXG4gICAgJ0NSRURJVCcsXG4gICAgJ0NSRURJVENBUkQnLFxuICAgICdDUkVESVRVTklPTicsXG4gICAgJ0NSSUNLRVQnLFxuICAgICdDUk9XTicsXG4gICAgJ0NSUycsXG4gICAgJ0NSVUlTRScsXG4gICAgJ0NSVUlTRVMnLFxuICAgICdDVScsXG4gICAgJ0NVSVNJTkVMTEEnLFxuICAgICdDVicsXG4gICAgJ0NXJyxcbiAgICAnQ1gnLFxuICAgICdDWScsXG4gICAgJ0NZTVJVJyxcbiAgICAnQ1lPVScsXG4gICAgJ0NaJyxcbiAgICAnREFCVVInLFxuICAgICdEQUQnLFxuICAgICdEQU5DRScsXG4gICAgJ0RBVEEnLFxuICAgICdEQVRFJyxcbiAgICAnREFUSU5HJyxcbiAgICAnREFUU1VOJyxcbiAgICAnREFZJyxcbiAgICAnRENMSycsXG4gICAgJ0REUycsXG4gICAgJ0RFJyxcbiAgICAnREVBTCcsXG4gICAgJ0RFQUxFUicsXG4gICAgJ0RFQUxTJyxcbiAgICAnREVHUkVFJyxcbiAgICAnREVMSVZFUlknLFxuICAgICdERUxMJyxcbiAgICAnREVMT0lUVEUnLFxuICAgICdERUxUQScsXG4gICAgJ0RFTU9DUkFUJyxcbiAgICAnREVOVEFMJyxcbiAgICAnREVOVElTVCcsXG4gICAgJ0RFU0knLFxuICAgICdERVNJR04nLFxuICAgICdERVYnLFxuICAgICdESEwnLFxuICAgICdESUFNT05EUycsXG4gICAgJ0RJRVQnLFxuICAgICdESUdJVEFMJyxcbiAgICAnRElSRUNUJyxcbiAgICAnRElSRUNUT1JZJyxcbiAgICAnRElTQ09VTlQnLFxuICAgICdESVNDT1ZFUicsXG4gICAgJ0RJU0gnLFxuICAgICdESVknLFxuICAgICdESicsXG4gICAgJ0RLJyxcbiAgICAnRE0nLFxuICAgICdETlAnLFxuICAgICdETycsXG4gICAgJ0RPQ1MnLFxuICAgICdET0NUT1InLFxuICAgICdET0cnLFxuICAgICdET01BSU5TJyxcbiAgICAnRE9UJyxcbiAgICAnRE9XTkxPQUQnLFxuICAgICdEUklWRScsXG4gICAgJ0RUVicsXG4gICAgJ0RVQkFJJyxcbiAgICAnRFVOTE9QJyxcbiAgICAnRFVQT05UJyxcbiAgICAnRFVSQkFOJyxcbiAgICAnRFZBRycsXG4gICAgJ0RWUicsXG4gICAgJ0RaJyxcbiAgICAnRUFSVEgnLFxuICAgICdFQVQnLFxuICAgICdFQycsXG4gICAgJ0VDTycsXG4gICAgJ0VERUtBJyxcbiAgICAnRURVJyxcbiAgICAnRURVQ0FUSU9OJyxcbiAgICAnRUUnLFxuICAgICdFRycsXG4gICAgJ0VNQUlMJyxcbiAgICAnRU1FUkNLJyxcbiAgICAnRU5FUkdZJyxcbiAgICAnRU5HSU5FRVInLFxuICAgICdFTkdJTkVFUklORycsXG4gICAgJ0VOVEVSUFJJU0VTJyxcbiAgICAnRVBTT04nLFxuICAgICdFUVVJUE1FTlQnLFxuICAgICdFUicsXG4gICAgJ0VSSUNTU09OJyxcbiAgICAnRVJOSScsXG4gICAgJ0VTJyxcbiAgICAnRVNRJyxcbiAgICAnRVNUQVRFJyxcbiAgICAnRVQnLFxuICAgICdFVElTQUxBVCcsXG4gICAgJ0VVJyxcbiAgICAnRVVST1ZJU0lPTicsXG4gICAgJ0VVUycsXG4gICAgJ0VWRU5UUycsXG4gICAgJ0VYQ0hBTkdFJyxcbiAgICAnRVhQRVJUJyxcbiAgICAnRVhQT1NFRCcsXG4gICAgJ0VYUFJFU1MnLFxuICAgICdFWFRSQVNQQUNFJyxcbiAgICAnRkFHRScsXG4gICAgJ0ZBSUwnLFxuICAgICdGQUlSV0lORFMnLFxuICAgICdGQUlUSCcsXG4gICAgJ0ZBTUlMWScsXG4gICAgJ0ZBTicsXG4gICAgJ0ZBTlMnLFxuICAgICdGQVJNJyxcbiAgICAnRkFSTUVSUycsXG4gICAgJ0ZBU0hJT04nLFxuICAgICdGQVNUJyxcbiAgICAnRkVERVgnLFxuICAgICdGRUVEQkFDSycsXG4gICAgJ0ZFUlJBUkknLFxuICAgICdGRVJSRVJPJyxcbiAgICAnRkknLFxuICAgICdGSUFUJyxcbiAgICAnRklERUxJVFknLFxuICAgICdGSURPJyxcbiAgICAnRklMTScsXG4gICAgJ0ZJTkFMJyxcbiAgICAnRklOQU5DRScsXG4gICAgJ0ZJTkFOQ0lBTCcsXG4gICAgJ0ZJUkUnLFxuICAgICdGSVJFU1RPTkUnLFxuICAgICdGSVJNREFMRScsXG4gICAgJ0ZJU0gnLFxuICAgICdGSVNISU5HJyxcbiAgICAnRklUJyxcbiAgICAnRklUTkVTUycsXG4gICAgJ0ZKJyxcbiAgICAnRksnLFxuICAgICdGTElDS1InLFxuICAgICdGTElHSFRTJyxcbiAgICAnRkxJUicsXG4gICAgJ0ZMT1JJU1QnLFxuICAgICdGTE9XRVJTJyxcbiAgICAnRkxZJyxcbiAgICAnRk0nLFxuICAgICdGTycsXG4gICAgJ0ZPTycsXG4gICAgJ0ZPT0QnLFxuICAgICdGT09ETkVUV09SSycsXG4gICAgJ0ZPT1RCQUxMJyxcbiAgICAnRk9SRCcsXG4gICAgJ0ZPUkVYJyxcbiAgICAnRk9SU0FMRScsXG4gICAgJ0ZPUlVNJyxcbiAgICAnRk9VTkRBVElPTicsXG4gICAgJ0ZPWCcsXG4gICAgJ0ZSJyxcbiAgICAnRlJFRScsXG4gICAgJ0ZSRVNFTklVUycsXG4gICAgJ0ZSTCcsXG4gICAgJ0ZST0dBTlMnLFxuICAgICdGUk9OVERPT1InLFxuICAgICdGUk9OVElFUicsXG4gICAgJ0ZUUicsXG4gICAgJ0ZVSklUU1UnLFxuICAgICdGVU4nLFxuICAgICdGVU5EJyxcbiAgICAnRlVSTklUVVJFJyxcbiAgICAnRlVUQk9MJyxcbiAgICAnRllJJyxcbiAgICAnR0EnLFxuICAgICdHQUwnLFxuICAgICdHQUxMRVJZJyxcbiAgICAnR0FMTE8nLFxuICAgICdHQUxMVVAnLFxuICAgICdHQU1FJyxcbiAgICAnR0FNRVMnLFxuICAgICdHQVAnLFxuICAgICdHQVJERU4nLFxuICAgICdHQVknLFxuICAgICdHQicsXG4gICAgJ0dCSVonLFxuICAgICdHRCcsXG4gICAgJ0dETicsXG4gICAgJ0dFJyxcbiAgICAnR0VBJyxcbiAgICAnR0VOVCcsXG4gICAgJ0dFTlRJTkcnLFxuICAgICdHRU9SR0UnLFxuICAgICdHRicsXG4gICAgJ0dHJyxcbiAgICAnR0dFRScsXG4gICAgJ0dIJyxcbiAgICAnR0knLFxuICAgICdHSUZUJyxcbiAgICAnR0lGVFMnLFxuICAgICdHSVZFUycsXG4gICAgJ0dJVklORycsXG4gICAgJ0dMJyxcbiAgICAnR0xBU1MnLFxuICAgICdHTEUnLFxuICAgICdHTE9CQUwnLFxuICAgICdHTE9CTycsXG4gICAgJ0dNJyxcbiAgICAnR01BSUwnLFxuICAgICdHTUJIJyxcbiAgICAnR01PJyxcbiAgICAnR01YJyxcbiAgICAnR04nLFxuICAgICdHT0RBRERZJyxcbiAgICAnR09MRCcsXG4gICAgJ0dPTERQT0lOVCcsXG4gICAgJ0dPTEYnLFxuICAgICdHT08nLFxuICAgICdHT09EWUVBUicsXG4gICAgJ0dPT0cnLFxuICAgICdHT09HTEUnLFxuICAgICdHT1AnLFxuICAgICdHT1QnLFxuICAgICdHT1YnLFxuICAgICdHUCcsXG4gICAgJ0dRJyxcbiAgICAnR1InLFxuICAgICdHUkFJTkdFUicsXG4gICAgJ0dSQVBISUNTJyxcbiAgICAnR1JBVElTJyxcbiAgICAnR1JFRU4nLFxuICAgICdHUklQRScsXG4gICAgJ0dST0NFUlknLFxuICAgICdHUk9VUCcsXG4gICAgJ0dTJyxcbiAgICAnR1QnLFxuICAgICdHVScsXG4gICAgJ0dVQVJESUFOJyxcbiAgICAnR1VDQ0knLFxuICAgICdHVUdFJyxcbiAgICAnR1VJREUnLFxuICAgICdHVUlUQVJTJyxcbiAgICAnR1VSVScsXG4gICAgJ0dXJyxcbiAgICAnR1knLFxuICAgICdIQUlSJyxcbiAgICAnSEFNQlVSRycsXG4gICAgJ0hBTkdPVVQnLFxuICAgICdIQVVTJyxcbiAgICAnSEJPJyxcbiAgICAnSERGQycsXG4gICAgJ0hERkNCQU5LJyxcbiAgICAnSEVBTFRIJyxcbiAgICAnSEVBTFRIQ0FSRScsXG4gICAgJ0hFTFAnLFxuICAgICdIRUxTSU5LSScsXG4gICAgJ0hFUkUnLFxuICAgICdIRVJNRVMnLFxuICAgICdIR1RWJyxcbiAgICAnSElQSE9QJyxcbiAgICAnSElTQU1JVFNVJyxcbiAgICAnSElUQUNISScsXG4gICAgJ0hJVicsXG4gICAgJ0hLJyxcbiAgICAnSEtUJyxcbiAgICAnSE0nLFxuICAgICdITicsXG4gICAgJ0hPQ0tFWScsXG4gICAgJ0hPTERJTkdTJyxcbiAgICAnSE9MSURBWScsXG4gICAgJ0hPTUVERVBPVCcsXG4gICAgJ0hPTUVHT09EUycsXG4gICAgJ0hPTUVTJyxcbiAgICAnSE9NRVNFTlNFJyxcbiAgICAnSE9OREEnLFxuICAgICdIT1JTRScsXG4gICAgJ0hPU1BJVEFMJyxcbiAgICAnSE9TVCcsXG4gICAgJ0hPU1RJTkcnLFxuICAgICdIT1QnLFxuICAgICdIT1RFTEVTJyxcbiAgICAnSE9URUxTJyxcbiAgICAnSE9UTUFJTCcsXG4gICAgJ0hPVVNFJyxcbiAgICAnSE9XJyxcbiAgICAnSFInLFxuICAgICdIU0JDJyxcbiAgICAnSFQnLFxuICAgICdIVScsXG4gICAgJ0hVR0hFUycsXG4gICAgJ0hZQVRUJyxcbiAgICAnSFlVTkRBSScsXG4gICAgJ0lCTScsXG4gICAgJ0lDQkMnLFxuICAgICdJQ0UnLFxuICAgICdJQ1UnLFxuICAgICdJRCcsXG4gICAgJ0lFJyxcbiAgICAnSUVFRScsXG4gICAgJ0lGTScsXG4gICAgJ0lLQU5PJyxcbiAgICAnSUwnLFxuICAgICdJTScsXG4gICAgJ0lNQU1BVCcsXG4gICAgJ0lNREInLFxuICAgICdJTU1PJyxcbiAgICAnSU1NT0JJTElFTicsXG4gICAgJ0lOJyxcbiAgICAnSU5DJyxcbiAgICAnSU5EVVNUUklFUycsXG4gICAgJ0lORklOSVRJJyxcbiAgICAnSU5GTycsXG4gICAgJ0lORycsXG4gICAgJ0lOSycsXG4gICAgJ0lOU1RJVFVURScsXG4gICAgJ0lOU1VSQU5DRScsXG4gICAgJ0lOU1VSRScsXG4gICAgJ0lOVCcsXG4gICAgJ0lOVEVSTkFUSU9OQUwnLFxuICAgICdJTlRVSVQnLFxuICAgICdJTlZFU1RNRU5UUycsXG4gICAgJ0lPJyxcbiAgICAnSVBJUkFOR0EnLFxuICAgICdJUScsXG4gICAgJ0lSJyxcbiAgICAnSVJJU0gnLFxuICAgICdJUycsXG4gICAgJ0lTTUFJTEknLFxuICAgICdJU1QnLFxuICAgICdJU1RBTkJVTCcsXG4gICAgJ0lUJyxcbiAgICAnSVRBVScsXG4gICAgJ0lUVicsXG4gICAgJ0pBR1VBUicsXG4gICAgJ0pBVkEnLFxuICAgICdKQ0InLFxuICAgICdKRScsXG4gICAgJ0pFRVAnLFxuICAgICdKRVRaVCcsXG4gICAgJ0pFV0VMUlknLFxuICAgICdKSU8nLFxuICAgICdKTEwnLFxuICAgICdKTScsXG4gICAgJ0pNUCcsXG4gICAgJ0pOSicsXG4gICAgJ0pPJyxcbiAgICAnSk9CUycsXG4gICAgJ0pPQlVSRycsXG4gICAgJ0pPVCcsXG4gICAgJ0pPWScsXG4gICAgJ0pQJyxcbiAgICAnSlBNT1JHQU4nLFxuICAgICdKUFJTJyxcbiAgICAnSlVFR09TJyxcbiAgICAnSlVOSVBFUicsXG4gICAgJ0tBVUZFTicsXG4gICAgJ0tEREknLFxuICAgICdLRScsXG4gICAgJ0tFUlJZSE9URUxTJyxcbiAgICAnS0VSUllMT0dJU1RJQ1MnLFxuICAgICdLRVJSWVBST1BFUlRJRVMnLFxuICAgICdLRkgnLFxuICAgICdLRycsXG4gICAgJ0tIJyxcbiAgICAnS0knLFxuICAgICdLSUEnLFxuICAgICdLSU0nLFxuICAgICdLSU5ERVInLFxuICAgICdLSU5ETEUnLFxuICAgICdLSVRDSEVOJyxcbiAgICAnS0lXSScsXG4gICAgJ0tNJyxcbiAgICAnS04nLFxuICAgICdLT0VMTicsXG4gICAgJ0tPTUFUU1UnLFxuICAgICdLT1NIRVInLFxuICAgICdLUCcsXG4gICAgJ0tQTUcnLFxuICAgICdLUE4nLFxuICAgICdLUicsXG4gICAgJ0tSRCcsXG4gICAgJ0tSRUQnLFxuICAgICdLVU9LR1JPVVAnLFxuICAgICdLVycsXG4gICAgJ0tZJyxcbiAgICAnS1lPVE8nLFxuICAgICdLWicsXG4gICAgJ0xBJyxcbiAgICAnTEFDQUlYQScsXG4gICAgJ0xBTUJPUkdISU5JJyxcbiAgICAnTEFNRVInLFxuICAgICdMQU5DQVNURVInLFxuICAgICdMQU5DSUEnLFxuICAgICdMQU5EJyxcbiAgICAnTEFORFJPVkVSJyxcbiAgICAnTEFOWEVTUycsXG4gICAgJ0xBU0FMTEUnLFxuICAgICdMQVQnLFxuICAgICdMQVRJTk8nLFxuICAgICdMQVRST0JFJyxcbiAgICAnTEFXJyxcbiAgICAnTEFXWUVSJyxcbiAgICAnTEInLFxuICAgICdMQycsXG4gICAgJ0xEUycsXG4gICAgJ0xFQVNFJyxcbiAgICAnTEVDTEVSQycsXG4gICAgJ0xFRlJBSycsXG4gICAgJ0xFR0FMJyxcbiAgICAnTEVHTycsXG4gICAgJ0xFWFVTJyxcbiAgICAnTEdCVCcsXG4gICAgJ0xJJyxcbiAgICAnTElETCcsXG4gICAgJ0xJRkUnLFxuICAgICdMSUZFSU5TVVJBTkNFJyxcbiAgICAnTElGRVNUWUxFJyxcbiAgICAnTElHSFRJTkcnLFxuICAgICdMSUtFJyxcbiAgICAnTElMTFknLFxuICAgICdMSU1JVEVEJyxcbiAgICAnTElNTycsXG4gICAgJ0xJTkNPTE4nLFxuICAgICdMSU5ERScsXG4gICAgJ0xJTksnLFxuICAgICdMSVBTWScsXG4gICAgJ0xJVkUnLFxuICAgICdMSVZJTkcnLFxuICAgICdMSycsXG4gICAgJ0xMQycsXG4gICAgJ0xMUCcsXG4gICAgJ0xPQU4nLFxuICAgICdMT0FOUycsXG4gICAgJ0xPQ0tFUicsXG4gICAgJ0xPQ1VTJyxcbiAgICAnTE9GVCcsXG4gICAgJ0xPTCcsXG4gICAgJ0xPTkRPTicsXG4gICAgJ0xPVFRFJyxcbiAgICAnTE9UVE8nLFxuICAgICdMT1ZFJyxcbiAgICAnTFBMJyxcbiAgICAnTFBMRklOQU5DSUFMJyxcbiAgICAnTFInLFxuICAgICdMUycsXG4gICAgJ0xUJyxcbiAgICAnTFREJyxcbiAgICAnTFREQScsXG4gICAgJ0xVJyxcbiAgICAnTFVOREJFQ0snLFxuICAgICdMVVhFJyxcbiAgICAnTFVYVVJZJyxcbiAgICAnTFYnLFxuICAgICdMWScsXG4gICAgJ01BJyxcbiAgICAnTUFDWVMnLFxuICAgICdNQURSSUQnLFxuICAgICdNQUlGJyxcbiAgICAnTUFJU09OJyxcbiAgICAnTUFLRVVQJyxcbiAgICAnTUFOJyxcbiAgICAnTUFOQUdFTUVOVCcsXG4gICAgJ01BTkdPJyxcbiAgICAnTUFQJyxcbiAgICAnTUFSS0VUJyxcbiAgICAnTUFSS0VUSU5HJyxcbiAgICAnTUFSS0VUUycsXG4gICAgJ01BUlJJT1RUJyxcbiAgICAnTUFSU0hBTExTJyxcbiAgICAnTUFTRVJBVEknLFxuICAgICdNQVRURUwnLFxuICAgICdNQkEnLFxuICAgICdNQycsXG4gICAgJ01DS0lOU0VZJyxcbiAgICAnTUQnLFxuICAgICdNRScsXG4gICAgJ01FRCcsXG4gICAgJ01FRElBJyxcbiAgICAnTUVFVCcsXG4gICAgJ01FTEJPVVJORScsXG4gICAgJ01FTUUnLFxuICAgICdNRU1PUklBTCcsXG4gICAgJ01FTicsXG4gICAgJ01FTlUnLFxuICAgICdNRVJDS01TRCcsXG4gICAgJ01HJyxcbiAgICAnTUgnLFxuICAgICdNSUFNSScsXG4gICAgJ01JQ1JPU09GVCcsXG4gICAgJ01JTCcsXG4gICAgJ01JTkknLFxuICAgICdNSU5UJyxcbiAgICAnTUlUJyxcbiAgICAnTUlUU1VCSVNISScsXG4gICAgJ01LJyxcbiAgICAnTUwnLFxuICAgICdNTEInLFxuICAgICdNTFMnLFxuICAgICdNTScsXG4gICAgJ01NQScsXG4gICAgJ01OJyxcbiAgICAnTU8nLFxuICAgICdNT0JJJyxcbiAgICAnTU9CSUxFJyxcbiAgICAnTU9EQScsXG4gICAgJ01PRScsXG4gICAgJ01PSScsXG4gICAgJ01PTScsXG4gICAgJ01PTkFTSCcsXG4gICAgJ01PTkVZJyxcbiAgICAnTU9OU1RFUicsXG4gICAgJ01PUk1PTicsXG4gICAgJ01PUlRHQUdFJyxcbiAgICAnTU9TQ09XJyxcbiAgICAnTU9UTycsXG4gICAgJ01PVE9SQ1lDTEVTJyxcbiAgICAnTU9WJyxcbiAgICAnTU9WSUUnLFxuICAgICdNUCcsXG4gICAgJ01RJyxcbiAgICAnTVInLFxuICAgICdNUycsXG4gICAgJ01TRCcsXG4gICAgJ01UJyxcbiAgICAnTVROJyxcbiAgICAnTVRSJyxcbiAgICAnTVUnLFxuICAgICdNVVNFVU0nLFxuICAgICdNVVNJQycsXG4gICAgJ01VVFVBTCcsXG4gICAgJ01WJyxcbiAgICAnTVcnLFxuICAgICdNWCcsXG4gICAgJ01ZJyxcbiAgICAnTVonLFxuICAgICdOQScsXG4gICAgJ05BQicsXG4gICAgJ05BR09ZQScsXG4gICAgJ05BTUUnLFxuICAgICdOQVRVUkEnLFxuICAgICdOQVZZJyxcbiAgICAnTkJBJyxcbiAgICAnTkMnLFxuICAgICdORScsXG4gICAgJ05FQycsXG4gICAgJ05FVCcsXG4gICAgJ05FVEJBTksnLFxuICAgICdORVRGTElYJyxcbiAgICAnTkVUV09SSycsXG4gICAgJ05FVVNUQVInLFxuICAgICdORVcnLFxuICAgICdORVdTJyxcbiAgICAnTkVYVCcsXG4gICAgJ05FWFRESVJFQ1QnLFxuICAgICdORVhVUycsXG4gICAgJ05GJyxcbiAgICAnTkZMJyxcbiAgICAnTkcnLFxuICAgICdOR08nLFxuICAgICdOSEsnLFxuICAgICdOSScsXG4gICAgJ05JQ08nLFxuICAgICdOSUtFJyxcbiAgICAnTklLT04nLFxuICAgICdOSU5KQScsXG4gICAgJ05JU1NBTicsXG4gICAgJ05JU1NBWScsXG4gICAgJ05MJyxcbiAgICAnTk8nLFxuICAgICdOT0tJQScsXG4gICAgJ05PUlRIV0VTVEVSTk1VVFVBTCcsXG4gICAgJ05PUlRPTicsXG4gICAgJ05PVycsXG4gICAgJ05PV1JVWicsXG4gICAgJ05PV1RWJyxcbiAgICAnTlAnLFxuICAgICdOUicsXG4gICAgJ05SQScsXG4gICAgJ05SVycsXG4gICAgJ05UVCcsXG4gICAgJ05VJyxcbiAgICAnTllDJyxcbiAgICAnTlonLFxuICAgICdPQkknLFxuICAgICdPQlNFUlZFUicsXG4gICAgJ09GRklDRScsXG4gICAgJ09LSU5BV0EnLFxuICAgICdPTEFZQU4nLFxuICAgICdPTEFZQU5HUk9VUCcsXG4gICAgJ09MRE5BVlknLFxuICAgICdPTExPJyxcbiAgICAnT00nLFxuICAgICdPTUVHQScsXG4gICAgJ09ORScsXG4gICAgJ09ORycsXG4gICAgJ09OTCcsXG4gICAgJ09OTElORScsXG4gICAgJ09PTycsXG4gICAgJ09QRU4nLFxuICAgICdPUkFDTEUnLFxuICAgICdPUkFOR0UnLFxuICAgICdPUkcnLFxuICAgICdPUkdBTklDJyxcbiAgICAnT1JJR0lOUycsXG4gICAgJ09TQUtBJyxcbiAgICAnT1RTVUtBJyxcbiAgICAnT1RUJyxcbiAgICAnT1ZIJyxcbiAgICAnUEEnLFxuICAgICdQQUdFJyxcbiAgICAnUEFOQVNPTklDJyxcbiAgICAnUEFSSVMnLFxuICAgICdQQVJTJyxcbiAgICAnUEFSVE5FUlMnLFxuICAgICdQQVJUUycsXG4gICAgJ1BBUlRZJyxcbiAgICAnUEFTU0FHRU5TJyxcbiAgICAnUEFZJyxcbiAgICAnUENDVycsXG4gICAgJ1BFJyxcbiAgICAnUEVUJyxcbiAgICAnUEYnLFxuICAgICdQRklaRVInLFxuICAgICdQRycsXG4gICAgJ1BIJyxcbiAgICAnUEhBUk1BQ1knLFxuICAgICdQSEQnLFxuICAgICdQSElMSVBTJyxcbiAgICAnUEhPTkUnLFxuICAgICdQSE9UTycsXG4gICAgJ1BIT1RPR1JBUEhZJyxcbiAgICAnUEhPVE9TJyxcbiAgICAnUEhZU0lPJyxcbiAgICAnUElDUycsXG4gICAgJ1BJQ1RFVCcsXG4gICAgJ1BJQ1RVUkVTJyxcbiAgICAnUElEJyxcbiAgICAnUElOJyxcbiAgICAnUElORycsXG4gICAgJ1BJTksnLFxuICAgICdQSU9ORUVSJyxcbiAgICAnUElaWkEnLFxuICAgICdQSycsXG4gICAgJ1BMJyxcbiAgICAnUExBQ0UnLFxuICAgICdQTEFZJyxcbiAgICAnUExBWVNUQVRJT04nLFxuICAgICdQTFVNQklORycsXG4gICAgJ1BMVVMnLFxuICAgICdQTScsXG4gICAgJ1BOJyxcbiAgICAnUE5DJyxcbiAgICAnUE9ITCcsXG4gICAgJ1BPS0VSJyxcbiAgICAnUE9MSVRJRScsXG4gICAgJ1BPUk4nLFxuICAgICdQT1NUJyxcbiAgICAnUFInLFxuICAgICdQUkFNRVJJQ0EnLFxuICAgICdQUkFYSScsXG4gICAgJ1BSRVNTJyxcbiAgICAnUFJJTUUnLFxuICAgICdQUk8nLFxuICAgICdQUk9EJyxcbiAgICAnUFJPRFVDVElPTlMnLFxuICAgICdQUk9GJyxcbiAgICAnUFJPR1JFU1NJVkUnLFxuICAgICdQUk9NTycsXG4gICAgJ1BST1BFUlRJRVMnLFxuICAgICdQUk9QRVJUWScsXG4gICAgJ1BST1RFQ1RJT04nLFxuICAgICdQUlUnLFxuICAgICdQUlVERU5USUFMJyxcbiAgICAnUFMnLFxuICAgICdQVCcsXG4gICAgJ1BVQicsXG4gICAgJ1BXJyxcbiAgICAnUFdDJyxcbiAgICAnUFknLFxuICAgICdRQScsXG4gICAgJ1FQT04nLFxuICAgICdRVUVCRUMnLFxuICAgICdRVUVTVCcsXG4gICAgJ1JBQ0lORycsXG4gICAgJ1JBRElPJyxcbiAgICAnUkUnLFxuICAgICdSRUFEJyxcbiAgICAnUkVBTEVTVEFURScsXG4gICAgJ1JFQUxUT1InLFxuICAgICdSRUFMVFknLFxuICAgICdSRUNJUEVTJyxcbiAgICAnUkVEJyxcbiAgICAnUkVEU1RPTkUnLFxuICAgICdSRURVTUJSRUxMQScsXG4gICAgJ1JFSEFCJyxcbiAgICAnUkVJU0UnLFxuICAgICdSRUlTRU4nLFxuICAgICdSRUlUJyxcbiAgICAnUkVMSUFOQ0UnLFxuICAgICdSRU4nLFxuICAgICdSRU5UJyxcbiAgICAnUkVOVEFMUycsXG4gICAgJ1JFUEFJUicsXG4gICAgJ1JFUE9SVCcsXG4gICAgJ1JFUFVCTElDQU4nLFxuICAgICdSRVNUJyxcbiAgICAnUkVTVEFVUkFOVCcsXG4gICAgJ1JFVklFVycsXG4gICAgJ1JFVklFV1MnLFxuICAgICdSRVhST1RIJyxcbiAgICAnUklDSCcsXG4gICAgJ1JJQ0hBUkRMSScsXG4gICAgJ1JJQ09IJyxcbiAgICAnUklMJyxcbiAgICAnUklPJyxcbiAgICAnUklQJyxcbiAgICAnUk8nLFxuICAgICdST0NIRVInLFxuICAgICdST0NLUycsXG4gICAgJ1JPREVPJyxcbiAgICAnUk9HRVJTJyxcbiAgICAnUk9PTScsXG4gICAgJ1JTJyxcbiAgICAnUlNWUCcsXG4gICAgJ1JVJyxcbiAgICAnUlVHQlknLFxuICAgICdSVUhSJyxcbiAgICAnUlVOJyxcbiAgICAnUlcnLFxuICAgICdSV0UnLFxuICAgICdSWVVLWVUnLFxuICAgICdTQScsXG4gICAgJ1NBQVJMQU5EJyxcbiAgICAnU0FGRScsXG4gICAgJ1NBRkVUWScsXG4gICAgJ1NBS1VSQScsXG4gICAgJ1NBTEUnLFxuICAgICdTQUxPTicsXG4gICAgJ1NBTVNDTFVCJyxcbiAgICAnU0FNU1VORycsXG4gICAgJ1NBTkRWSUsnLFxuICAgICdTQU5EVklLQ09ST01BTlQnLFxuICAgICdTQU5PRkknLFxuICAgICdTQVAnLFxuICAgICdTQVJMJyxcbiAgICAnU0FTJyxcbiAgICAnU0FWRScsXG4gICAgJ1NBWE8nLFxuICAgICdTQicsXG4gICAgJ1NCSScsXG4gICAgJ1NCUycsXG4gICAgJ1NDJyxcbiAgICAnU0NBJyxcbiAgICAnU0NCJyxcbiAgICAnU0NIQUVGRkxFUicsXG4gICAgJ1NDSE1JRFQnLFxuICAgICdTQ0hPTEFSU0hJUFMnLFxuICAgICdTQ0hPT0wnLFxuICAgICdTQ0hVTEUnLFxuICAgICdTQ0hXQVJaJyxcbiAgICAnU0NJRU5DRScsXG4gICAgJ1NDT1QnLFxuICAgICdTRCcsXG4gICAgJ1NFJyxcbiAgICAnU0VBUkNIJyxcbiAgICAnU0VBVCcsXG4gICAgJ1NFQ1VSRScsXG4gICAgJ1NFQ1VSSVRZJyxcbiAgICAnU0VFSycsXG4gICAgJ1NFTEVDVCcsXG4gICAgJ1NFTkVSJyxcbiAgICAnU0VSVklDRVMnLFxuICAgICdTRVMnLFxuICAgICdTRVZFTicsXG4gICAgJ1NFVycsXG4gICAgJ1NFWCcsXG4gICAgJ1NFWFknLFxuICAgICdTRlInLFxuICAgICdTRycsXG4gICAgJ1NIJyxcbiAgICAnU0hBTkdSSUxBJyxcbiAgICAnU0hBUlAnLFxuICAgICdTSEFXJyxcbiAgICAnU0hFTEwnLFxuICAgICdTSElBJyxcbiAgICAnU0hJS1NIQScsXG4gICAgJ1NIT0VTJyxcbiAgICAnU0hPUCcsXG4gICAgJ1NIT1BQSU5HJyxcbiAgICAnU0hPVUpJJyxcbiAgICAnU0hPVycsXG4gICAgJ1NIT1dUSU1FJyxcbiAgICAnU0knLFxuICAgICdTSUxLJyxcbiAgICAnU0lOQScsXG4gICAgJ1NJTkdMRVMnLFxuICAgICdTSVRFJyxcbiAgICAnU0onLFxuICAgICdTSycsXG4gICAgJ1NLSScsXG4gICAgJ1NLSU4nLFxuICAgICdTS1knLFxuICAgICdTS1lQRScsXG4gICAgJ1NMJyxcbiAgICAnU0xJTkcnLFxuICAgICdTTScsXG4gICAgJ1NNQVJUJyxcbiAgICAnU01JTEUnLFxuICAgICdTTicsXG4gICAgJ1NOQ0YnLFxuICAgICdTTycsXG4gICAgJ1NPQ0NFUicsXG4gICAgJ1NPQ0lBTCcsXG4gICAgJ1NPRlRCQU5LJyxcbiAgICAnU09GVFdBUkUnLFxuICAgICdTT0hVJyxcbiAgICAnU09MQVInLFxuICAgICdTT0xVVElPTlMnLFxuICAgICdTT05HJyxcbiAgICAnU09OWScsXG4gICAgJ1NPWScsXG4gICAgJ1NQQScsXG4gICAgJ1NQQUNFJyxcbiAgICAnU1BPUlQnLFxuICAgICdTUE9UJyxcbiAgICAnU1InLFxuICAgICdTUkwnLFxuICAgICdTUycsXG4gICAgJ1NUJyxcbiAgICAnU1RBREEnLFxuICAgICdTVEFQTEVTJyxcbiAgICAnU1RBUicsXG4gICAgJ1NUQVRFQkFOSycsXG4gICAgJ1NUQVRFRkFSTScsXG4gICAgJ1NUQycsXG4gICAgJ1NUQ0dST1VQJyxcbiAgICAnU1RPQ0tIT0xNJyxcbiAgICAnU1RPUkFHRScsXG4gICAgJ1NUT1JFJyxcbiAgICAnU1RSRUFNJyxcbiAgICAnU1RVRElPJyxcbiAgICAnU1RVRFknLFxuICAgICdTVFlMRScsXG4gICAgJ1NVJyxcbiAgICAnU1VDS1MnLFxuICAgICdTVVBQTElFUycsXG4gICAgJ1NVUFBMWScsXG4gICAgJ1NVUFBPUlQnLFxuICAgICdTVVJGJyxcbiAgICAnU1VSR0VSWScsXG4gICAgJ1NVWlVLSScsXG4gICAgJ1NWJyxcbiAgICAnU1dBVENIJyxcbiAgICAnU1dJU1MnLFxuICAgICdTWCcsXG4gICAgJ1NZJyxcbiAgICAnU1lETkVZJyxcbiAgICAnU1lTVEVNUycsXG4gICAgJ1NaJyxcbiAgICAnVEFCJyxcbiAgICAnVEFJUEVJJyxcbiAgICAnVEFMSycsXG4gICAgJ1RBT0JBTycsXG4gICAgJ1RBUkdFVCcsXG4gICAgJ1RBVEFNT1RPUlMnLFxuICAgICdUQVRBUicsXG4gICAgJ1RBVFRPTycsXG4gICAgJ1RBWCcsXG4gICAgJ1RBWEknLFxuICAgICdUQycsXG4gICAgJ1RDSScsXG4gICAgJ1REJyxcbiAgICAnVERLJyxcbiAgICAnVEVBTScsXG4gICAgJ1RFQ0gnLFxuICAgICdURUNITk9MT0dZJyxcbiAgICAnVEVMJyxcbiAgICAnVEVNQVNFSycsXG4gICAgJ1RFTk5JUycsXG4gICAgJ1RFVkEnLFxuICAgICdURicsXG4gICAgJ1RHJyxcbiAgICAnVEgnLFxuICAgICdUSEQnLFxuICAgICdUSEVBVEVSJyxcbiAgICAnVEhFQVRSRScsXG4gICAgJ1RJQUEnLFxuICAgICdUSUNLRVRTJyxcbiAgICAnVElFTkRBJyxcbiAgICAnVElGRkFOWScsXG4gICAgJ1RJUFMnLFxuICAgICdUSVJFUycsXG4gICAgJ1RJUk9MJyxcbiAgICAnVEonLFxuICAgICdUSk1BWFgnLFxuICAgICdUSlgnLFxuICAgICdUSycsXG4gICAgJ1RLTUFYWCcsXG4gICAgJ1RMJyxcbiAgICAnVE0nLFxuICAgICdUTUFMTCcsXG4gICAgJ1ROJyxcbiAgICAnVE8nLFxuICAgICdUT0RBWScsXG4gICAgJ1RPS1lPJyxcbiAgICAnVE9PTFMnLFxuICAgICdUT1AnLFxuICAgICdUT1JBWScsXG4gICAgJ1RPU0hJQkEnLFxuICAgICdUT1RBTCcsXG4gICAgJ1RPVVJTJyxcbiAgICAnVE9XTicsXG4gICAgJ1RPWU9UQScsXG4gICAgJ1RPWVMnLFxuICAgICdUUicsXG4gICAgJ1RSQURFJyxcbiAgICAnVFJBRElORycsXG4gICAgJ1RSQUlOSU5HJyxcbiAgICAnVFJBVkVMJyxcbiAgICAnVFJBVkVMQ0hBTk5FTCcsXG4gICAgJ1RSQVZFTEVSUycsXG4gICAgJ1RSQVZFTEVSU0lOU1VSQU5DRScsXG4gICAgJ1RSVVNUJyxcbiAgICAnVFJWJyxcbiAgICAnVFQnLFxuICAgICdUVUJFJyxcbiAgICAnVFVJJyxcbiAgICAnVFVORVMnLFxuICAgICdUVVNIVScsXG4gICAgJ1RWJyxcbiAgICAnVFZTJyxcbiAgICAnVFcnLFxuICAgICdUWicsXG4gICAgJ1VBJyxcbiAgICAnVUJBTksnLFxuICAgICdVQlMnLFxuICAgICdVRycsXG4gICAgJ1VLJyxcbiAgICAnVU5JQ09NJyxcbiAgICAnVU5JVkVSU0lUWScsXG4gICAgJ1VOTycsXG4gICAgJ1VPTCcsXG4gICAgJ1VQUycsXG4gICAgJ1VTJyxcbiAgICAnVVknLFxuICAgICdVWicsXG4gICAgJ1ZBJyxcbiAgICAnVkFDQVRJT05TJyxcbiAgICAnVkFOQScsXG4gICAgJ1ZBTkdVQVJEJyxcbiAgICAnVkMnLFxuICAgICdWRScsXG4gICAgJ1ZFR0FTJyxcbiAgICAnVkVOVFVSRVMnLFxuICAgICdWRVJJU0lHTicsXG4gICAgJ1ZFUlNJQ0hFUlVORycsXG4gICAgJ1ZFVCcsXG4gICAgJ1ZHJyxcbiAgICAnVkknLFxuICAgICdWSUFKRVMnLFxuICAgICdWSURFTycsXG4gICAgJ1ZJRycsXG4gICAgJ1ZJS0lORycsXG4gICAgJ1ZJTExBUycsXG4gICAgJ1ZJTicsXG4gICAgJ1ZJUCcsXG4gICAgJ1ZJUkdJTicsXG4gICAgJ1ZJU0EnLFxuICAgICdWSVNJT04nLFxuICAgICdWSVZBJyxcbiAgICAnVklWTycsXG4gICAgJ1ZMQUFOREVSRU4nLFxuICAgICdWTicsXG4gICAgJ1ZPREtBJyxcbiAgICAnVk9MS1NXQUdFTicsXG4gICAgJ1ZPTFZPJyxcbiAgICAnVk9URScsXG4gICAgJ1ZPVElORycsXG4gICAgJ1ZPVE8nLFxuICAgICdWT1lBR0UnLFxuICAgICdWVScsXG4gICAgJ1ZVRUxPUycsXG4gICAgJ1dBTEVTJyxcbiAgICAnV0FMTUFSVCcsXG4gICAgJ1dBTFRFUicsXG4gICAgJ1dBTkcnLFxuICAgICdXQU5HR09VJyxcbiAgICAnV0FUQ0gnLFxuICAgICdXQVRDSEVTJyxcbiAgICAnV0VBVEhFUicsXG4gICAgJ1dFQVRIRVJDSEFOTkVMJyxcbiAgICAnV0VCQ0FNJyxcbiAgICAnV0VCRVInLFxuICAgICdXRUJTSVRFJyxcbiAgICAnV0VEJyxcbiAgICAnV0VERElORycsXG4gICAgJ1dFSUJPJyxcbiAgICAnV0VJUicsXG4gICAgJ1dGJyxcbiAgICAnV0hPU1dITycsXG4gICAgJ1dJRU4nLFxuICAgICdXSUtJJyxcbiAgICAnV0lMTElBTUhJTEwnLFxuICAgICdXSU4nLFxuICAgICdXSU5ET1dTJyxcbiAgICAnV0lORScsXG4gICAgJ1dJTk5FUlMnLFxuICAgICdXTUUnLFxuICAgICdXT0xURVJTS0xVV0VSJyxcbiAgICAnV09PRFNJREUnLFxuICAgICdXT1JLJyxcbiAgICAnV09SS1MnLFxuICAgICdXT1JMRCcsXG4gICAgJ1dPVycsXG4gICAgJ1dTJyxcbiAgICAnV1RDJyxcbiAgICAnV1RGJyxcbiAgICAnWEJPWCcsXG4gICAgJ1hFUk9YJyxcbiAgICAnWEZJTklUWScsXG4gICAgJ1hJSFVBTicsXG4gICAgJ1hJTicsXG4gICAgJ1hOLS0xMUI0QzNEJyxcbiAgICAnWE4tLTFDSzJFMUInLFxuICAgICdYTi0tMVFRVzIzQScsXG4gICAgJ1hOLS0yU0NSSjlDJyxcbiAgICAnWE4tLTMwUlI3WScsXG4gICAgJ1hOLS0zQlNUMDBNJyxcbiAgICAnWE4tLTNEUzQ0M0cnLFxuICAgICdYTi0tM0UwQjcwN0UnLFxuICAgICdYTi0tM0hDUko5QycsXG4gICAgJ1hOLS0zUFhVOEsnLFxuICAgICdYTi0tNDJDMkQ5QScsXG4gICAgJ1hOLS00NUJSNUNZTCcsXG4gICAgJ1hOLS00NUJSSjlDJyxcbiAgICAnWE4tLTQ1UTExQycsXG4gICAgJ1hOLS00REJSSzBDRScsXG4gICAgJ1hOLS00R0JSSU0nLFxuICAgICdYTi0tNTRCN0ZUQTBDQycsXG4gICAgJ1hOLS01NVFXNDJHJyxcbiAgICAnWE4tLTU1UVg1RCcsXG4gICAgJ1hOLS01U1UzNEo5MzZCR1NHJyxcbiAgICAnWE4tLTVUWk01RycsXG4gICAgJ1hOLS02RlJaODJHJyxcbiAgICAnWE4tLTZRUTk4NkIzWEwnLFxuICAgICdYTi0tODBBRFhIS1MnLFxuICAgICdYTi0tODBBTzIxQScsXG4gICAgJ1hOLS04MEFRRUNEUjFBJyxcbiAgICAnWE4tLTgwQVNFSERCJyxcbiAgICAnWE4tLTgwQVNXRycsXG4gICAgJ1hOLS04WTBBMDYzQScsXG4gICAgJ1hOLS05MEEzQUMnLFxuICAgICdYTi0tOTBBRScsXG4gICAgJ1hOLS05MEFJUycsXG4gICAgJ1hOLS05REJRMkEnLFxuICAgICdYTi0tOUVUNTJVJyxcbiAgICAnWE4tLTlLUlQwMEEnLFxuICAgICdYTi0tQjRXNjA1RkVSRCcsXG4gICAgJ1hOLS1CQ0sxQjlBNURSRTRDJyxcbiAgICAnWE4tLUMxQVZHJyxcbiAgICAnWE4tLUMyQlI3RycsXG4gICAgJ1hOLS1DQ0syQjNCJyxcbiAgICAnWE4tLUNDS1dDWEVURCcsXG4gICAgJ1hOLS1DRzRCS0knLFxuICAgICdYTi0tQ0xDSEMwRUEwQjJHMkE5R0NEJyxcbiAgICAnWE4tLUNaUjY5NEInLFxuICAgICdYTi0tQ1pSUzBUJyxcbiAgICAnWE4tLUNaUlUyRCcsXG4gICAgJ1hOLS1EMUFDSjNCJyxcbiAgICAnWE4tLUQxQUxGJyxcbiAgICAnWE4tLUUxQTRDJyxcbiAgICAnWE4tLUVDS1ZEVEM5RCcsXG4gICAgJ1hOLS1FRlZZODhIJyxcbiAgICAnWE4tLUZDVDQyOUsnLFxuICAgICdYTi0tRkhCRUknLFxuICAgICdYTi0tRklRMjI4QzVIUycsXG4gICAgJ1hOLS1GSVE2NEInLFxuICAgICdYTi0tRklRUzhTJyxcbiAgICAnWE4tLUZJUVo5UycsXG4gICAgJ1hOLS1GSlE3MjBBJyxcbiAgICAnWE4tLUZMVzM1MUUnLFxuICAgICdYTi0tRlBDUko5QzNEJyxcbiAgICAnWE4tLUZaQzJDOUUyQycsXG4gICAgJ1hOLS1GWllTOEQ2OVVWR00nLFxuICAgICdYTi0tRzJYWDQ4QycsXG4gICAgJ1hOLS1HQ0tSM0YwRicsXG4gICAgJ1hOLS1HRUNSSjlDJyxcbiAgICAnWE4tLUdLM0FUMUUnLFxuICAgICdYTi0tSDJCUkVHM0VWRScsXG4gICAgJ1hOLS1IMkJSSjlDJyxcbiAgICAnWE4tLUgyQlJKOUM4QycsXG4gICAgJ1hOLS1IWFQ4MTRFJyxcbiAgICAnWE4tLUkxQjZCMUE2QTJFJyxcbiAgICAnWE4tLUlNUjUxM04nLFxuICAgICdYTi0tSU8wQTdJJyxcbiAgICAnWE4tLUoxQUVGJyxcbiAgICAnWE4tLUoxQU1IJyxcbiAgICAnWE4tLUo2VzE5M0cnLFxuICAgICdYTi0tSkxRNDgwTjJSRycsXG4gICAgJ1hOLS1KTFE2MVU5VzdCJyxcbiAgICAnWE4tLUpWUjE4OU0nLFxuICAgICdYTi0tS0NSWDc3RDFYNEEnLFxuICAgICdYTi0tS1BSVzEzRCcsXG4gICAgJ1hOLS1LUFJZNTdEJyxcbiAgICAnWE4tLUtQVVQzSScsXG4gICAgJ1hOLS1MMUFDQycsXG4gICAgJ1hOLS1MR0JCQVQxQUQ4SicsXG4gICAgJ1hOLS1NR0I5QVdCRicsXG4gICAgJ1hOLS1NR0JBM0EzRUpUJyxcbiAgICAnWE4tLU1HQkEzQTRGMTZBJyxcbiAgICAnWE4tLU1HQkE3QzBCQk4wQScsXG4gICAgJ1hOLS1NR0JBQUtDN0RWRicsXG4gICAgJ1hOLS1NR0JBQU03QThIJyxcbiAgICAnWE4tLU1HQkFCMkJEJyxcbiAgICAnWE4tLU1HQkFIMUEzSEpLUkQnLFxuICAgICdYTi0tTUdCQUk5QVpHUVA2SicsXG4gICAgJ1hOLS1NR0JBWUg3R1BBJyxcbiAgICAnWE4tLU1HQkJIMUEnLFxuICAgICdYTi0tTUdCQkgxQTcxRScsXG4gICAgJ1hOLS1NR0JDMEE5QVpDRycsXG4gICAgJ1hOLS1NR0JDQTdEWkRPJyxcbiAgICAnWE4tLU1HQkNQUTZHUEExQScsXG4gICAgJ1hOLS1NR0JFUlA0QTVENEFSJyxcbiAgICAnWE4tLU1HQkdVODJBJyxcbiAgICAnWE4tLU1HQkk0RUNFWFAnLFxuICAgICdYTi0tTUdCUEwyRkgnLFxuICAgICdYTi0tTUdCVDNESEQnLFxuICAgICdYTi0tTUdCVFgyQicsXG4gICAgJ1hOLS1NR0JYNENEMEFCJyxcbiAgICAnWE4tLU1JWDg5MUYnLFxuICAgICdYTi0tTUsxQlU0NEMnLFxuICAgICdYTi0tTVhUUTFNJyxcbiAgICAnWE4tLU5HQkM1QVpEJyxcbiAgICAnWE4tLU5HQkU5RTBBJyxcbiAgICAnWE4tLU5HQlJYJyxcbiAgICAnWE4tLU5PREUnLFxuICAgICdYTi0tTlFWN0YnLFxuICAgICdYTi0tTlFWN0ZTMDBFTUEnLFxuICAgICdYTi0tTllRWTI2QScsXG4gICAgJ1hOLS1PM0NXNEgnLFxuICAgICdYTi0tT0dCUEY4RkwnLFxuICAgICdYTi0tT1RVNzk2RCcsXG4gICAgJ1hOLS1QMUFDRicsXG4gICAgJ1hOLS1QMUFJJyxcbiAgICAnWE4tLVBHQlMwREgnLFxuICAgICdYTi0tUFNTWTJVJyxcbiAgICAnWE4tLVE3Q0U2QScsXG4gICAgJ1hOLS1ROUpZQjRDJyxcbiAgICAnWE4tLVFDS0ExUE1DJyxcbiAgICAnWE4tLVFYQTZBJyxcbiAgICAnWE4tLVFYQU0nLFxuICAgICdYTi0tUkhRVjk2RycsXG4gICAgJ1hOLS1ST1ZVODhCJyxcbiAgICAnWE4tLVJWQzFFMEFNM0UnLFxuICAgICdYTi0tUzlCUko5QycsXG4gICAgJ1hOLS1TRVM1NTRHJyxcbiAgICAnWE4tLVQ2MEI1NkEnLFxuICAgICdYTi0tVENLV0UnLFxuICAgICdYTi0tVElRNDlYUVlKJyxcbiAgICAnWE4tLVVOVVA0WScsXG4gICAgJ1hOLS1WRVJNR0VOU0JFUkFURVItQ1RCJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRVTkctUFdCJyxcbiAgICAnWE4tLVZIUVVWJyxcbiAgICAnWE4tLVZVUTg2MUInLFxuICAgICdYTi0tVzRSODVFTDhGSFU1RE5SQScsXG4gICAgJ1hOLS1XNFJTNDBMJyxcbiAgICAnWE4tLVdHQkgxQycsXG4gICAgJ1hOLS1XR0JMNkEnLFxuICAgICdYTi0tWEhRNTIxQicsXG4gICAgJ1hOLS1YS0MyQUwzSFlFMkEnLFxuICAgICdYTi0tWEtDMkRMM0E1RUUwSCcsXG4gICAgJ1hOLS1ZOUEzQVEnLFxuICAgICdYTi0tWUZSTzRJNjdPJyxcbiAgICAnWE4tLVlHQkkyQU1NWCcsXG4gICAgJ1hOLS1aRlIxNjRCJyxcbiAgICAnWFhYJyxcbiAgICAnWFlaJyxcbiAgICAnWUFDSFRTJyxcbiAgICAnWUFIT08nLFxuICAgICdZQU1BWFVOJyxcbiAgICAnWUFOREVYJyxcbiAgICAnWUUnLFxuICAgICdZT0RPQkFTSEknLFxuICAgICdZT0dBJyxcbiAgICAnWU9LT0hBTUEnLFxuICAgICdZT1UnLFxuICAgICdZT1VUVUJFJyxcbiAgICAnWVQnLFxuICAgICdZVU4nLFxuICAgICdaQScsXG4gICAgJ1pBUFBPUycsXG4gICAgJ1pBUkEnLFxuICAgICdaRVJPJyxcbiAgICAnWklQJyxcbiAgICAnWk0nLFxuICAgICdaT05FJyxcbiAgICAnWlVFUklDSCcsXG4gICAgJ1pXJ1xuXTtcblxuXG4vLyBLZWVwIGFzIHVwcGVyLWNhc2UgdG8gbWFrZSB1cGRhdGluZyBmcm9tIHNvdXJjZSBlYXNpZXJcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KGludGVybmFscy50bGRzLm1hcCgodGxkKSA9PiB0bGQudG9Mb3dlckNhc2UoKSkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEb21haW4gPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi9kb21haW4nKTtcbmNvbnN0IEVtYWlsID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwnKTtcbmNvbnN0IElwID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvaXAnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcbmNvbnN0IFRsZHMgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi90bGRzJyk7XG5jb25zdCBVcmkgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi91cmknKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0bGRzOiBUbGRzIGluc3RhbmNlb2YgU2V0ID8geyB0bGRzOiB7IGFsbG93OiBUbGRzLCBkZW55OiBudWxsIH0gfSA6IGZhbHNlLCAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgYmFzZTY0UmVnZXg6IHtcbiAgICAgICAgLy8gcGFkZGluZ1JlcXVpcmVkXG4gICAgICAgIHRydWU6IHtcbiAgICAgICAgICAgIC8vIHVybFNhZmVcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn09PXxbXFx3XFwtXXszfT0pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kL1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZToge1xuICAgICAgICAgICAgdHJ1ZTogL14oPzpbXFx3XFwtXXsyfVtcXHdcXC1dezJ9KSooPzpbXFx3XFwtXXsyfSg9PSk/fFtcXHdcXC1dezN9PT8pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn0oPT0pP3xbQS1aYS16MC05K1xcL117M309Pyk/JC9cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YVVyaVJlZ2V4OiAvXmRhdGE6W1xcdysuLV0rXFwvW1xcdysuLV0rOygoY2hhcnNldD1bXFx3LV0rfGJhc2U2NCksKT8oLiopJC8sXG4gICAgaGV4UmVnZXg6IC9eW2EtZjAtOV0rJC9pLFxuICAgIGlwUmVnZXg6IElwLnJlZ2V4KHsgY2lkcjogJ2ZvcmJpZGRlbicgfSkucmVnZXgsXG4gICAgaXNvRHVyYXRpb25SZWdleDogL15QKD8hJCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtXKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/JC8sXG5cbiAgICBndWlkQnJhY2tldHM6IHtcbiAgICAgICAgJ3snOiAnfScsICdbJzogJ10nLCAnKCc6ICcpJywgJyc6ICcnXG4gICAgfSxcbiAgICBndWlkVmVyc2lvbnM6IHtcbiAgICAgICAgdXVpZHYxOiAnMScsXG4gICAgICAgIHV1aWR2MjogJzInLFxuICAgICAgICB1dWlkdjM6ICczJyxcbiAgICAgICAgdXVpZHY0OiAnNCcsXG4gICAgICAgIHV1aWR2NTogJzUnLFxuICAgICAgICB1dWlkdjY6ICc2JyxcbiAgICAgICAgdXVpZHY3OiAnNycsXG4gICAgICAgIHV1aWR2ODogJzgnXG4gICAgfSxcbiAgICBndWlkU2VwYXJhdG9yczogbmV3IFNldChbdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgJy0nLCAnOiddKSxcblxuICAgIG5vcm1hbGl6YXRpb25Gb3JtczogWydORkMnLCAnTkZEJywgJ05GS0MnLCAnTkZLRCddXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3RyaW5nJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgdHJ1bmNhdGU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIHJlcGxhY2VtZW50czogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemUgPSBzY2hlbWEuJF9nZXRSdWxlKCdub3JtYWxpemUnKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZShub3JtYWxpemUuYXJncy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FzaW5nID0gc2NoZW1hLiRfZ2V0UnVsZSgnY2FzZScpO1xuICAgICAgICAgICAgaWYgKGNhc2luZykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2FzaW5nLmFyZ3MuZGlyZWN0aW9uID09PSAndXBwZXInID8gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSA6IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgICAgICAgICBpZiAodHJpbSAmJlxuICAgICAgICAgICAgICAgIHRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVwbGFjZW1lbnQgb2Ygc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZXBsYWNlbWVudC5wYXR0ZXJuLCByZXBsYWNlbWVudC5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZXggPSBzY2hlbWEuJF9nZXRSdWxlKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChoZXggJiZcbiAgICAgICAgICAgICAgICBoZXguYXJncy5vcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX2dldFJ1bGUoJ2lzb0RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IGludGVybmFscy5pc29EYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWF4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gcnVsZS5hcmdzLmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbGltaXQucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQ29tbW9uLmxpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVmJywgbGltaXQsIHsgcmVmOiBydWxlLmFyZ3MubGltaXQsIGFyZzogJ2xpbWl0JywgcmVhc29uOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInIH0sIHN0YXRlLCBwcmVmcykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N0cmluZy5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHNjaGVtYS4kX2dldFJ1bGUoJ21pbicpO1xuICAgICAgICAgICAgaWYgKG1pbiAmJlxuICAgICAgICAgICAgICAgIG1pbi5hcmdzLmxpbWl0ID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuZW1wdHknKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYWxwaGFudW06IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eW2EtekEtWjAtOV0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiYXNlNjQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsncGFkZGluZ1JlcXVpcmVkJywgJ3VybFNhZmUnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyB1cmxTYWZlOiBmYWxzZSwgcGFkZGluZ1JlcXVpcmVkOiB0cnVlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLCAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy51cmxTYWZlID09PSAnYm9vbGVhbicsICd1cmxTYWZlIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Jhc2U2NCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBpbnRlcm5hbHMuYmFzZTY0UmVnZXhbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdW29wdGlvbnMudXJsU2FmZV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmJhc2U2NCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChkaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2xvd2VyJywgJ3VwcGVyJ10uaW5jbHVkZXMoZGlyZWN0aW9uKSwgJ0ludmFsaWQgY2FzZTonLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Nhc2UnLCBhcmdzOiB7IGRpcmVjdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRpcmVjdGlvbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbG93ZXInICYmIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3VwcGVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihgc3RyaW5nLiR7ZGlyZWN0aW9ufWNhc2VgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlZGl0Q2FyZDoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGxldCBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtdWwgPSAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpICogbXVsO1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAoY2hhciAtIChjaGFyID4gOSkgKiA5KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsID0gbXVsIF4gMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBzdW0gJSAxMCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmNyZWRpdENhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhVXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkYXRhVXJpJywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLmRhdGFVcmlSZWdleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzJdICE9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0cmVnZXggPSBpbnRlcm5hbHMuYmFzZTY0UmVnZXhbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdLmZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZTY0cmVnZXgudGVzdChtYXRjaGVzWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kYXRhVXJpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBpbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2RvbWFpbicsIGFyZ3M6IHsgb3B0aW9ucyB9LCBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCB7IGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKERvbWFpbi5pc1ZhbGlkKHZhbHVlLCBhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kb21haW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdpZ25vcmVMZW5ndGgnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAnbXVsdGlwbGUnLCAnc2VwYXJhdG9yJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMubXVsdGlwbGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5tdWx0aXBsZSA9PT0gJ2Jvb2xlYW4nLCAnbXVsdGlwbGUgb3B0aW9uIG11c3QgYmUgYW4gYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxzKlske29wdGlvbnMuc2VwYXJhdG9yID8gRXNjYXBlUmVnZXgob3B0aW9ucy5zZXBhcmF0b3IpIDogJywnfV1cXFxccypgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdlbWFpbCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWxzID0gb3B0aW9ucy5tdWx0aXBsZSA/IHZhbHVlLnNwbGl0KHJlZ2V4KSA6IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGVtYWlscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUVtYWlsLmlzVmFsaWQoZW1haWwsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcy5wdXNoKGVtYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW52YWxpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmVtYWlsJywgeyB2YWx1ZSwgaW52YWxpZHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgYWxpYXM6ICd1dWlkJyxcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsndmVyc2lvbicsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmVyc2lvbk51bWJlcnMgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBbXS5jb25jYXQob3B0aW9ucy52ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbnMubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhbGlkIHZlcnNpb24gc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk51bWJlciA9IGludGVybmFscy5ndWlkVmVyc2lvbnNbdmVyc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9uTnVtYmVyLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGludGVybmFscy5ndWlkVmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXQuaGFzKHZlcnNpb25OdW1iZXIpLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBub3QgYmUgYSBkdXBsaWNhdGUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbk51bWJlcnMgKz0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5hZGQodmVyc2lvbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLmd1aWRTZXBhcmF0b3JzLmhhcyhvcHRpb25zLnNlcGFyYXRvciksICdzZXBhcmF0b3IgbXVzdCBiZSBvbmUgb2YgdHJ1ZSwgZmFsc2UsIFwiLVwiLCBvciBcIjpcIicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnWzotXT8nIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IHRydWUgPyAnWzotXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IGZhbHNlID8gJ1tdPycgOiBgXFxcXCR7b3B0aW9ucy5zZXBhcmF0b3J9YDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXihbXFxcXFt7XFxcXChdPylbMC05QS1GXXs4fSgke3NlcGFyYXRvcn0pWzAtOUEtRl17NH1cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyB8fCAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyA/ICc4OUFCJyA6ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1swLTlBLUZdezEyfShbXFxcXF19XFxcXCldPykkYCwgJ2knKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdndWlkJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaGluZyBicmFjZXNcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZ3VpZEJyYWNrZXRzW3Jlc3VsdHNbMV1dICE9PSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhleDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieXRlQWxpZ25lZCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGJ5dGVBbGlnbmVkOiBmYWxzZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5ieXRlQWxpZ25lZCA9PT0gJ2Jvb2xlYW4nLCAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGV4JywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5oZXhSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleEFsaWduJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhvc3RuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2hvc3RuYW1lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgeyBtaW5Eb21haW5TZWdtZW50czogMSB9KSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXBSZWdleC50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhvc3RuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaW5zZW5zaXRpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpcDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydjaWRyJywgJ3ZlcnNpb24nXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNpZHIsIHZlcnNpb25zLCByZWdleCB9ID0gSXAucmVnZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/IHZlcnNpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpcCcsIGFyZ3M6IHsgb3B0aW9uczogeyBjaWRyLCB2ZXJzaW9uIH0gfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwVmVyc2lvbicsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXAnLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRGF0ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EYXRlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcuaXNvRGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0R1cmF0aW9uOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRHVyYXRpb25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ2xlbmd0aCcsIGxpbWl0LCAnPScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCwgZW5jb2RpbmcgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlciAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShsZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlLCBlbmNvZGluZyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW5jb2RpbmcnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG93ZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCdsb3dlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21heCcsIGxpbWl0LCAnPD0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWluJywgbGltaXQsICc+PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpemU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtID0gJ05GQycpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmluY2x1ZGVzKGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ25vcm1hbGl6ZScsIGFyZ3M6IHsgZm9ybSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0sIHsgZm9ybSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcubm9ybWFsaXplJywgeyB2YWx1ZSwgZm9ybSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICAgICAgICBtZXRob2QocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwLCAncmVnZXggbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3JlZ2V4IHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpbnZlcnQnLCAnbmFtZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IFsnc3RyaW5nLnBhdHRlcm4nLCBvcHRpb25zLmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBvcHRpb25zLm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3BhdHRlcm4nLCBhcmdzOiB7IHJlZ2V4LCBvcHRpb25zIH0sIGVycm9yQ29kZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyByZWdleCwgb3B0aW9ucyB9LCB7IGVycm9yQ29kZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSByZWdleC50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBvcHRpb25zLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IG9wdGlvbnMubmFtZSwgcmVnZXgsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsncmVnZXgnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoRXNjYXBlUmVnZXgocGF0dGVybiksICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cy5wdXNoKHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCd0b2tlbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3RyaW0nLCBhcmdzOiB7IGVuYWJsZWQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBlbmFibGVkIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudHJpbScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndHJ1bmNhdGUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cHBlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ3VwcGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93UmVsYXRpdmUnLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbicsICdyZWxhdGl2ZU9ubHknLCAnc2NoZW1lJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMuZG9tYWluLCBbJ2FsbG93RnVsbHlRdWFsaWZpZWQnLCAnYWxsb3dVbmljb2RlJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWdleCwgc2NoZW1lIH0gPSBVcmkucmVnZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3B0aW9ucy5kb21haW4gPyBpbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMob3B0aW9ucy5kb21haW4pIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAndXJpJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4LCBkb21haW4sIHNjaGVtZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGRvbWFpbiwgc2NoZW1lIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2h0dHA6LycsICdodHRwczovJ10uaW5jbHVkZXModmFsdWUpKSB7ICAgICAgICAgICAgLy8gc2NoZW1lOi8gaXMgdGVjaG5pY2FsbHkgdmFsaWQgYnV0IG1ha2VzIG5vIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fCBtYXRjaGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIURvbWFpbi5pc1ZhbGlkKG1hdGNoZWQsIGRvbWFpbikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kb21haW4nLCB7IHZhbHVlOiBtYXRjaGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaVJlbGF0aXZlT25seScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaUN1c3RvbVNjaGVtZScsIHsgc2NoZW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCByZXBsYWNlbWVudCB9IG9mIGRlc2MucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N0cmluZy5hbHBoYW51bSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmJhc2U2NCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5jcmVkaXRDYXJkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgJ3N0cmluZy5kYXRhVXJpJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5kb21haW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYSB2YWxpZCBkb21haW4gbmFtZScsXG4gICAgICAgICdzdHJpbmcuZW1haWwnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgICAnc3RyaW5nLmVtcHR5JzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICAnc3RyaW5nLmd1aWQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgR1VJRCcsXG4gICAgICAgICdzdHJpbmcuaGV4JzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuaGV4QWxpZ24nOiAne3sjbGFiZWx9fSBoZXggZGVjb2RlZCByZXByZXNlbnRhdGlvbiBtdXN0IGJlIGJ5dGUgYWxpZ25lZCcsXG4gICAgICAgICdzdHJpbmcuaG9zdG5hbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaG9zdG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmlwJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pcFZlcnNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9ucyB7eyN2ZXJzaW9ufX0gd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pc29EYXRlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiBpc28gZm9ybWF0JyxcbiAgICAgICAgJ3N0cmluZy5pc29EdXJhdGlvbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkdXJhdGlvbicsXG4gICAgICAgICdzdHJpbmcubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLmxvd2VyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5tYXgnOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLm1pbic6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5ub3JtYWxpemUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHVuaWNvZGUgbm9ybWFsaXplZCBpbiB0aGUge3sjZm9ybX19IGZvcm0nLFxuICAgICAgICAnc3RyaW5nLnRva2VuJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBhbmQgdW5kZXJzY29yZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmJhc2UnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5uYW1lJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmludmVydC5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy50cmltJzogJ3t7I2xhYmVsfX0gbXVzdCBub3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UnLFxuICAgICAgICAnc3RyaW5nLnVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmknLFxuICAgICAgICAnc3RyaW5nLnVyaUN1c3RvbVNjaGVtZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmkgd2l0aCBhIHNjaGVtZSBtYXRjaGluZyB0aGUge3sjc2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudXJpUmVsYXRpdmVPbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHJlbGF0aXZlIHVyaScsXG4gICAgICAgICdzdHJpbmcudXBwZXJjYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8vIG1pbkRvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPiAwLCAnbWluRG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIG1heERvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5tYXhEb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPiAwLCAnbWF4RG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIHRsZHNcblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IHRydWUgfHxcbiAgICAgICAgb3B0aW9ucy50bGRzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLnRsZHMsICdCdWlsdC1pbiBUTEQgbGlzdCBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgaW50ZXJuYWxzLnRsZHMpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy50bGRzID09PSAnb2JqZWN0JywgJ3RsZHMgbXVzdCBiZSB0cnVlLCBmYWxzZSwgb3IgYW4gb2JqZWN0Jyk7XG5cbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy50bGRzLmRlbnk7XG4gICAgaWYgKGRlbnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVueSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgZGVueTogbmV3IFNldChkZW55KSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXksIFNldCwgb3IgYm9vbGVhbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMudGxkcy5hbGxvdywgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggdGxkcy5hbGxvdyBhbmQgdGxkcy5kZW55IGxpc3RzJyk7XG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZVRsZHMob3B0aW9ucy50bGRzLmRlbnksICd0bGRzLmRlbnknKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLnRsZHMuYWxsb3c7XG4gICAgaWYgKCFhbGxvdykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3cgPT09IHRydWUpIHtcbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBhbGxvdzogbmV3IFNldChhbGxvdykgfSB9KTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0LCAndGxkcy5hbGxvdyBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5hbGxvdywgJ3RsZHMuYWxsb3cnKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyA9IGZ1bmN0aW9uIChzZXQsIHNvdXJjZSkge1xuXG4gICAgZm9yIChjb25zdCB0bGQgb2Ygc2V0KSB7XG4gICAgICAgIEFzc2VydChEb21haW4uaXNWYWxpZCh0bGQsIHsgbWluRG9tYWluU2VnbWVudHM6IDEsIG1heERvbWFpblNlZ21lbnRzOiAxIH0pLCBgJHtzb3VyY2V9IG11c3QgY29udGFpbiB2YWxpZCB0b3AgbGV2ZWwgZG9tYWluIG5hbWVzYCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaXNvRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgaWYgKCFDb21tb24uaXNJc29EYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoLy4qVC4qWystXVxcZFxcZCQvLnRlc3QodmFsdWUpKSB7ICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIHRyYWlsaW5nIHplcm9zIHRvIHRpbWVzaGlmdFxuICAgICAgICB2YWx1ZSArPSAnMDAnO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufTtcblxuXG5pbnRlcm5hbHMubGVuZ3RoID0gZnVuY3Rpb24gKHNjaGVtYSwgbmFtZSwgbGltaXQsIG9wZXJhdG9yLCBlbmNvZGluZykge1xuXG4gICAgQXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIgJiYgQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG5cbiAgICByZXR1cm4gc2NoZW1hLiRfYWRkUnVsZSh7IG5hbWUsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQsIGVuY29kaW5nIH0sIG9wZXJhdG9yIH0pO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5NYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5NYXAodGhpcyk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ3N5bWJvbCcsXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hcDogeyBpbml0OiBuZXcgaW50ZXJuYWxzLk1hcCgpIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gc2NoZW1hLiRfdGVybXMubWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb29rdXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5vbmx5IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5tYXAnLCB7IG1hcDogc2NoZW1hLiRfdGVybXMubWFwIH0pIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgbWV0aG9kKGl0ZXJhYmxlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0LmVudHJpZXMoaXRlcmFibGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdLCAnSXRlcmFibGUgbXVzdCBiZSBhbiBpdGVyYWJsZSBvciBvYmplY3QnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChlbnRyeSAmJiBlbnRyeVtTeW1ib2wuaXRlcmF0b3JdLCAnRW50cnkgbXVzdCBiZSBhbiBpdGVyYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Yga2V5ICE9PSAnc3ltYm9sJywgJ0tleSBtdXN0IG5vdCBiZSBvZiB0eXBlIG9iamVjdCwgZnVuY3Rpb24sIG9yIFN5bWJvbCcpO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJywgJ1ZhbHVlIG11c3QgYmUgYSBTeW1ib2wnKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmoudmFsaWQoLi4uc3ltYm9scyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWFwKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm1hcChkZXNjLm1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N5bWJvbC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHN5bWJvbCcsXG4gICAgICAgICdzeW1ib2wubWFwJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvbmUgb2Yge3sjbWFwfX0nXG4gICAgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYmluYXJ5JyxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiBbJ3N0cmluZycsICdvYmplY3QnXSxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS50eXBlID09PSAnQnVmZmVyJykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogQnVmZmVyLmZyb20odmFsdWUsIHNjaGVtYS5fZmxhZ3MuZW5jb2RpbmcpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVFcnIpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdiaW5hcnkuYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgZW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlbmNvZGluZycsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdiaW5hcnkuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdiaW5hcnkuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnLFxuICAgICAgICAnYmluYXJ5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgYmUge3sjbGltaXR9fSBieXRlcycsXG4gICAgICAgICdiaW5hcnkubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBieXRlcycsXG4gICAgICAgICdiaW5hcnkubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGJ5dGVzJ1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHR5cGVzOiB7XG4gICAgICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICAgICAgYW55OiByZXF1aXJlKCcuL3R5cGVzL2FueScpLFxuICAgICAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgICAgICBib29sZWFuOiByZXF1aXJlKCcuL3R5cGVzL2Jvb2xlYW4nKSxcbiAgICAgICAgZGF0ZTogcmVxdWlyZSgnLi90eXBlcy9kYXRlJyksXG4gICAgICAgIGZ1bmN0aW9uOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmN0aW9uJyksXG4gICAgICAgIGxpbms6IHJlcXVpcmUoJy4vdHlwZXMvbGluaycpLFxuICAgICAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgICAgIG9iamVjdDogcmVxdWlyZSgnLi90eXBlcy9vYmplY3QnKSxcbiAgICAgICAgc3RyaW5nOiByZXF1aXJlKCcuL3R5cGVzL3N0cmluZycpLFxuICAgICAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbiAgICB9LFxuICAgIGFsaWFzZXM6IHtcbiAgICAgICAgYWx0OiAnYWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgYm9vbDogJ2Jvb2xlYW4nLFxuICAgICAgICBmdW5jOiAnZnVuY3Rpb24nXG4gICAgfVxufTtcblxuXG5pZiAoQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBpbnRlcm5hbHMudHlwZXMuYmluYXJ5ID0gcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKTtcbn1cblxuXG5pbnRlcm5hbHMucm9vdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJvb3QgPSB7XG4gICAgICAgIF90eXBlczogbmV3IFNldChPYmplY3Qua2V5cyhpbnRlcm5hbHMudHlwZXMpKVxuICAgIH07XG5cbiAgICAvLyBUeXBlc1xuXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHJvb3QuX3R5cGVzKSB7XG4gICAgICAgIHJvb3RbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICBBc3NlcnQoIWFyZ3MubGVuZ3RoIHx8IFsnYWx0ZXJuYXRpdmVzJywgJ2xpbmsnLCAnb2JqZWN0J10uaW5jbHVkZXModHlwZSksICdUaGUnLCB0eXBlLCAndHlwZSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgaW50ZXJuYWxzLnR5cGVzW3R5cGVdLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcblxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIFsnYWxsb3cnLCAnY3VzdG9tJywgJ2Rpc2FsbG93JywgJ2VxdWFsJywgJ2V4aXN0JywgJ2ZvcmJpZGRlbicsICdpbnZhbGlkJywgJ25vdCcsICdvbmx5JywgJ29wdGlvbmFsJywgJ29wdGlvbnMnLCAncHJlZnMnLCAncHJlZmVyZW5jZXMnLCAncmVxdWlyZWQnLCAnc3RyaXAnLCAndmFsaWQnLCAnd2hlbiddKSB7XG4gICAgICAgIHJvb3RbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFueSgpW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kc1xuXG4gICAgT2JqZWN0LmFzc2lnbihyb290LCBpbnRlcm5hbHMubWV0aG9kcyk7XG5cbiAgICAvLyBBbGlhc2VzXG5cbiAgICBmb3IgKGNvbnN0IGFsaWFzIGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGludGVybmFscy5hbGlhc2VzW2FsaWFzXTtcbiAgICAgICAgcm9vdFthbGlhc10gPSByb290W3RhcmdldF07XG4gICAgfVxuXG4gICAgcm9vdC54ID0gcm9vdC5leHByZXNzaW9uO1xuXG4gICAgLy8gVHJhY2VcblxuICAgIGlmIChUcmFjZS5zZXR1cCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBUcmFjZS5zZXR1cChyb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cblxuaW50ZXJuYWxzLm1ldGhvZHMgPSB7XG5cbiAgICBWYWxpZGF0aW9uRXJyb3I6IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IsXG4gICAgdmVyc2lvbjogQ29tbW9uLnZlcnNpb24sXG4gICAgY2FjaGU6IENhY2hlLnByb3ZpZGVyLFxuXG4gICAgYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIHRydWUsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBhdHRlbXB0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCBmYWxzZSwgYXJncyk7XG4gICAgfSxcblxuICAgIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmJ1aWxkID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuYnVpbGQodGhpcywgZGVzYyk7XG4gICAgfSxcblxuICAgIGNoZWNrUHJlZmVyZW5jZXMocHJlZnMpIHtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuY29tcGlsZSh0aGlzLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0cyhtb2RpZmllcikge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGpvaS5fdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGlmaWVyKGpvaVt0eXBlXSgpKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ21vZGlmaWVyIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuXG4gICAgICAgICAgICBqb2lbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGV4cHJlc3Npb24oLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIGV4dGVuZCguLi5leHRlbnNpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoZXh0ZW5zaW9ucywgJ2V4dGVuZCcpO1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgICAgIEFzc2VydChleHRlbnNpb25zLmxlbmd0aCwgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIGV4dGVuc2lvbicpO1xuICAgICAgICB0aGlzLmFzc2VydChleHRlbnNpb25zLCBTY2hlbWFzLmV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGNvbnN0IGpvaSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICAgICAgICBqb2kuX3R5cGVzID0gbmV3IFNldChqb2kuX3R5cGVzKTtcblxuICAgICAgICBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCBTY2hlbWFzLmV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gaW50ZXJuYWxzLmV4cGFuZEV4dGVuc2lvbihleHRlbnNpb24sIGpvaSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoam9pW2l0ZW0udHlwZV0gPT09IHVuZGVmaW5lZCB8fCBqb2kuX3R5cGVzLmhhcyhpdGVtLnR5cGUpLCAnQ2Fubm90IG92ZXJyaWRlIG5hbWUnLCBpdGVtLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IGl0ZW0uYmFzZSB8fCB0aGlzLmFueSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IEV4dGVuZC50eXBlKGJhc2UsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgam9pLl90eXBlcy5hZGQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBqb2lbaXRlbS50eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBpc0Vycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IsXG4gICAgaXNFeHByZXNzaW9uOiBUZW1wbGF0ZS5pc1RlbXBsYXRlLFxuICAgIGlzUmVmOiBSZWYuaXNSZWYsXG4gICAgaXNTY2hlbWE6IENvbW1vbi5pc1NjaGVtYSxcblxuICAgIGluKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmluKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBvdmVycmlkZTogQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGUsXG5cbiAgICByZWYoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICB0eXBlcygpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5fdHlwZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gdGhpc1t0eXBlXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gaW50ZXJuYWxzLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3RhcmdldF0gPSB0aGlzW3RhcmdldF0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBhbm5vdGF0ZSwgYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgPyBhcmdzWzBdIDogbnVsbDtcbiAgICBjb25zdCBvcHRpb25zID0gbWVzc2FnZSAhPT0gbnVsbCA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgQ29tbW9uLnByZWZlcmVuY2VzKHsgZXJyb3JzOiB7IHN0YWNrOiB0cnVlIH0gfSwgb3B0aW9ucyB8fCB7fSkpO1xuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGxheSA9IGFubm90YXRlICYmIHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGVycm9yLmFubm90YXRlKCkgOiBlcnJvci5tZXNzYWdlO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3JzLlZhbGlkYXRpb25FcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZXJyb3IgPSBDbG9uZShlcnJvcik7XG4gICAgfVxuXG4gICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2UgPyBgJHttZXNzYWdlfSAke2Rpc3BsYXl9YCA6IGRpc3BsYXk7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChyb290LCBzY2hlbWEsIGFyZ3MpIHtcblxuICAgIEFzc2VydChyb290LCAnTXVzdCBiZSBpbnZva2VkIG9uIGEgSm9pIGluc3RhbmNlLicpO1xuXG4gICAgc2NoZW1hLiRfcm9vdCA9IHJvb3Q7XG5cbiAgICBpZiAoIXNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzIHx8XG4gICAgICAgICFhcmdzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzKHNjaGVtYSwgLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5leHBhbmRFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uLCBqb2kpIHtcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmRlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24udHlwZS50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGl0ZW0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpdGVtLmJhc2UgPSBqb2lbdHlwZV0oKTtcbiAgICAgICAgICAgIGV4dGVuZGVkLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLnJvb3QoKTtcbiIsICIvKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGVycm9yIHJlc3BvbnNlcyBmb3IgYW4gZW5kcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyW119IHN0YXR1c0NvZGVzICAtIGxpc3Qgb2YgZXJyb3IgcmVzcG9uc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hlbiAtIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JSZXNwb25zZXMoc3RhdHVzQ29kZXMsIHdoZW4pIHtcbiAgY29uc3QgcmVzcG9uc2VzID0gW11cbiAgY29uc3QgcG9zdFRleHQgPSAnVGhlIGV4YW1wbGVzIHNob3cgYWxsIHBvc3NpYmxlIGBjb2RlYCBhbmQgYG1lc3NhZ2VgIHZhbHVlcywgbm90IGxpbWl0ZWQgdG8gdGhpcyBlbmRwb2ludC4nXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg0MDApKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQW4gZXJyb3IgbWVzc2FnZSB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdFcnJvclJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg0MDEpKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNDAxLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVW5hdXRob3Jpc2VkIHVzZXIgd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnVW5hdXRob3JpemVkUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwMykpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDMsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBGb3JiaWRkZW4gd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnRm9yYmlkZGVuUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwNCkpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDQsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBSZXNvdXJjZSBub3QgZm91bmQgd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnTm90Rm91bmRSZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RhdHVzQ29kZXMuaW5jbHVkZXMoNDI5KSkge1xuICAgIHJlc3BvbnNlcy5wdXNoKHtcbiAgICAgIHN0YXR1c0NvZGU6IDQyOSxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogYFJhdGUgbGltaXRlZCB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdSYXRlTGltaXRlZFJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg1MDApKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQSBzZXJ2ZXIgZXJyb3Igd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnU2VydmVyRXJyb3JSZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2VzXG59XG5cbmV4cG9ydCB7XG4gIGdlbmVyYXRlRXJyb3JSZXNwb25zZXMsXG59XG4iLCAiaW1wb3J0IEpvaURhdGUgZnJvbSAnQGpvaS9kYXRlJ1xuaW1wb3J0IEpvaUJhc2UgZnJvbSAnam9pJ1xuXG4vKiogQHR5cGUgeyBpbXBvcnQoXCJqb2lcIikuUm9vdCB9ICovXG5jb25zdCBKb2kgPSBKb2lCYXNlLmV4dGVuZChKb2lEYXRlKVxuXG5leHBvcnQgeyBKb2kgfVxuIiwgImltcG9ydCB7IGdlbmVyYXRlRXJyb3JSZXNwb25zZXMgfSBmcm9tICcuLi9zY2hlbWFzL2NvbW1vbi5qcydcbmltcG9ydCB7IEpvaSB9IGZyb20gJy4uL3NjaGVtYXMvdmFsaWRhdG9yLmpzJ1xuXG5jb25zdCBkb2N1bWVudGF0aW9uID0ge1xuICBzdW1tYXJ5OiAnSGVsbG8gMScsXG4gIHRhZ3M6IFsnSGVsbG8gT25lIFNlY3Rpb24nXSxcbiAgZGVzY3JpcHRpb246ICdIZWxsbyAxIHRlbXBsYXRlLicsXG4gIG1ldGhvZFJlc3BvbnNlczogW1xuICAgIHtcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogJ0FuIG9iamVjdCByZXR1cm5pbmcgaGVsbG8xOiB0cnVlLicsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnSGVsbG9PbmVTY2hlbWEnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIC4uLmdlbmVyYXRlRXJyb3JSZXNwb25zZXMoWzQwMCwgNDAxLCA0MDQsIDUwMF0sICdnZXR0aW5nIGhlbGxvIDEnKSxcbiAgXSxcbn1cblxuY29uc3Qgc2NoZW1hID0ge1xuICByZXNwb25zZTogSm9pLm9iamVjdCh7XG4gICAgaGVsbG8xOiBKb2kuYm9vbGVhbigpLnJlcXVpcmVkKCksXG4gIH0pLFxufVxuXG5jb25zdCBoYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBoZWxsbzE6IHRydWUsXG4gICAgfSksXG4gIH1cbn1cblxuZXhwb3J0IHsgZG9jdW1lbnRhdGlvbiwgaGFuZGxlciwgc2NoZW1hIH1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQU1DLEtBQUMsU0FBVSxRQUFRLFNBQVM7QUFDekIsYUFBTyxZQUFZLFlBQVksT0FBTyxXQUFXLGNBQWMsT0FBTyxVQUFVLFFBQVEsSUFDeEYsT0FBTyxXQUFX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LFlBQVksQ0FBQztBQU9uQixjQUFVLE9BQU87QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUtBLFdBQU8sVUFBVSxJQUFJLElBQUksVUFBVSxLQUFLLElBQUksQ0FBQyxRQUFRLElBQUksWUFBWSxDQUFDLENBQUM7QUFBQTtBQUFBOzs7QUM3OUN2RTtBQUFBO0FBQUE7QUFFQSxRQUFNLFNBQVM7QUFDZixRQUFNLFNBQVM7QUFDZixRQUFNLFFBQVE7QUFDZCxRQUFNLEtBQUs7QUFDWCxRQUFNLGNBQWM7QUFDcEIsUUFBTSxPQUFPO0FBQ2IsUUFBTSxNQUFNO0FBRVosUUFBTSxNQUFNO0FBQ1osUUFBTSxTQUFTO0FBR2YsUUFBTSxZQUFZO0FBQUEsTUFDZCxNQUFNLGdCQUFnQixNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sTUFBTSxNQUFNLEtBQUssRUFBRSxJQUFJO0FBQUE7QUFBQSxNQUNwRSxhQUFhO0FBQUE7QUFBQSxRQUVULE1BQU07QUFBQTtBQUFBLFVBRUYsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLE9BQU87QUFBQSxVQUNILE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUFBLE1BQ0EsY0FBYztBQUFBLE1BQ2QsVUFBVTtBQUFBLE1BQ1YsU0FBUyxHQUFHLE1BQU0sRUFBRSxNQUFNLFlBQVksQ0FBQyxFQUFFO0FBQUEsTUFDekMsa0JBQWtCO0FBQUEsTUFFbEIsY0FBYztBQUFBLFFBQ1YsS0FBSztBQUFBLFFBQUssS0FBSztBQUFBLFFBQUssS0FBSztBQUFBLFFBQUssSUFBSTtBQUFBLE1BQ3RDO0FBQUEsTUFDQSxjQUFjO0FBQUEsUUFDVixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixRQUFRO0FBQUEsTUFDWjtBQUFBLE1BQ0EsZ0JBQWdCLG9CQUFJLElBQUksQ0FBQyxRQUFXLE1BQU0sT0FBTyxLQUFLLEdBQUcsQ0FBQztBQUFBLE1BRTFELG9CQUFvQixDQUFDLE9BQU8sT0FBTyxRQUFRLE1BQU07QUFBQSxJQUNyRDtBQUdBLFdBQU8sVUFBVSxJQUFJLE9BQU87QUFBQSxNQUV4QixNQUFNO0FBQUEsTUFFTixPQUFPO0FBQUEsUUFFSCxhQUFhLEVBQUUsU0FBUyxNQUFNO0FBQUEsUUFDOUIsVUFBVSxFQUFFLFNBQVMsTUFBTTtBQUFBLE1BQy9CO0FBQUEsTUFFQSxPQUFPO0FBQUEsUUFFSCxjQUFjLEVBQUUsTUFBTSxLQUFLO0FBQUEsTUFDL0I7QUFBQSxNQUVBLFFBQVE7QUFBQSxRQUNKLE1BQU07QUFBQSxRQUNOLE9BQU8sT0FBTyxFQUFFLFFBQUFDLFNBQVEsT0FBTyxNQUFNLEdBQUc7QUFFcEMsZ0JBQU0sWUFBWUEsUUFBTyxVQUFVLFdBQVc7QUFDOUMsY0FBSSxXQUFXO0FBQ1gsb0JBQVEsTUFBTSxVQUFVLFVBQVUsS0FBSyxJQUFJO0FBQUEsVUFDL0M7QUFFQSxnQkFBTSxTQUFTQSxRQUFPLFVBQVUsTUFBTTtBQUN0QyxjQUFJLFFBQVE7QUFDUixvQkFBUSxPQUFPLEtBQUssY0FBYyxVQUFVLE1BQU0sa0JBQWtCLElBQUksTUFBTSxrQkFBa0I7QUFBQSxVQUNwRztBQUVBLGdCQUFNLE9BQU9BLFFBQU8sVUFBVSxNQUFNO0FBQ3BDLGNBQUksUUFDQSxLQUFLLEtBQUssU0FBUztBQUVuQixvQkFBUSxNQUFNLEtBQUs7QUFBQSxVQUN2QjtBQUVBLGNBQUlBLFFBQU8sUUFBUSxjQUFjO0FBQzdCLHVCQUFXLGVBQWVBLFFBQU8sUUFBUSxjQUFjO0FBQ25ELHNCQUFRLE1BQU0sUUFBUSxZQUFZLFNBQVMsWUFBWSxXQUFXO0FBQUEsWUFDdEU7QUFBQSxVQUNKO0FBRUEsZ0JBQU0sTUFBTUEsUUFBTyxVQUFVLEtBQUs7QUFDbEMsY0FBSSxPQUNBLElBQUksS0FBSyxRQUFRLGVBQ2pCLE1BQU0sU0FBUyxNQUFNLEdBQUc7QUFFeEIsb0JBQVEsSUFBSSxLQUFLO0FBQUEsVUFDckI7QUFFQSxjQUFJQSxRQUFPLFVBQVUsU0FBUyxHQUFHO0FBQzdCLGtCQUFNLE1BQU0sVUFBVSxRQUFRLEtBQUs7QUFDbkMsZ0JBQUksS0FBSztBQUNMLHNCQUFRO0FBQUEsWUFDWjtBQUFBLFVBQ0o7QUFFQSxjQUFJQSxRQUFPLE9BQU8sVUFBVTtBQUN4QixrQkFBTSxPQUFPQSxRQUFPLFVBQVUsS0FBSztBQUNuQyxnQkFBSSxNQUFNO0FBQ04sa0JBQUksUUFBUSxLQUFLLEtBQUs7QUFDdEIsa0JBQUksT0FBTyxhQUFhLEtBQUssR0FBRztBQUM1Qix3QkFBUSxNQUFNLFFBQVEsT0FBTyxPQUFPLEtBQUs7QUFDekMsb0JBQUksQ0FBQyxPQUFPLE1BQU0sS0FBSyxHQUFHO0FBQ3RCLHlCQUFPLEVBQUUsT0FBTyxRQUFRQSxRQUFPLGNBQWMsV0FBVyxPQUFPLEVBQUUsS0FBSyxLQUFLLEtBQUssT0FBTyxLQUFLLFNBQVMsUUFBUSw2QkFBNkIsR0FBRyxPQUFPLEtBQUssRUFBRTtBQUFBLGdCQUMvSjtBQUFBLGNBQ0o7QUFFQSxzQkFBUSxNQUFNLE1BQU0sR0FBRyxLQUFLO0FBQUEsWUFDaEM7QUFBQSxVQUNKO0FBRUEsaUJBQU8sRUFBRSxNQUFNO0FBQUEsUUFDbkI7QUFBQSxNQUNKO0FBQUEsTUFFQSxTQUFTLE9BQU8sRUFBRSxRQUFBQSxTQUFRLE1BQU0sR0FBRztBQUUvQixZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGlCQUFPLEVBQUUsT0FBTyxRQUFRLE1BQU0sYUFBYSxFQUFFO0FBQUEsUUFDakQ7QUFFQSxZQUFJLFVBQVUsSUFBSTtBQUNkLGdCQUFNLE1BQU1BLFFBQU8sVUFBVSxLQUFLO0FBQ2xDLGNBQUksT0FDQSxJQUFJLEtBQUssVUFBVSxHQUFHO0FBRXRCO0FBQUEsVUFDSjtBQUVBLGlCQUFPLEVBQUUsT0FBTyxRQUFRLE1BQU0sY0FBYyxFQUFFO0FBQUEsUUFDbEQ7QUFBQSxNQUNKO0FBQUEsTUFFQSxPQUFPO0FBQUEsUUFFSCxVQUFVO0FBQUEsVUFDTixTQUFTO0FBRUwsbUJBQU8sS0FBSyxVQUFVLFVBQVU7QUFBQSxVQUNwQztBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVM7QUFFckIsZ0JBQUksaUJBQWlCLEtBQUssS0FBSyxHQUFHO0FBQzlCLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxpQkFBaUI7QUFBQSxVQUMxQztBQUFBLFFBQ0o7QUFBQSxRQUVBLFFBQVE7QUFBQSxVQUNKLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFFakIsbUJBQU8sY0FBYyxTQUFTLENBQUMsbUJBQW1CLFNBQVMsQ0FBQztBQUU1RCxzQkFBVSxFQUFFLFNBQVMsT0FBTyxpQkFBaUIsTUFBTSxHQUFHLFFBQVE7QUFDOUQsbUJBQU8sT0FBTyxRQUFRLG9CQUFvQixXQUFXLGlDQUFpQztBQUN0RixtQkFBTyxPQUFPLFFBQVEsWUFBWSxXQUFXLHlCQUF5QjtBQUV0RSxtQkFBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDO0FBQUEsVUFDL0Q7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTLEVBQUUsUUFBUSxHQUFHO0FBRWxDLGtCQUFNLFFBQVEsVUFBVSxZQUFZLFFBQVEsZUFBZSxFQUFFLFFBQVEsT0FBTztBQUM1RSxnQkFBSSxNQUFNLEtBQUssS0FBSyxHQUFHO0FBQ25CLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxlQUFlO0FBQUEsVUFDeEM7QUFBQSxRQUNKO0FBQUEsUUFFQSxNQUFNO0FBQUEsVUFDRixPQUFPLFdBQVc7QUFFZCxtQkFBTyxDQUFDLFNBQVMsT0FBTyxFQUFFLFNBQVMsU0FBUyxHQUFHLGlCQUFpQixTQUFTO0FBRXpFLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxNQUFNLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFBQSxVQUMvRDtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxVQUFVLEdBQUc7QUFFcEMsZ0JBQUksY0FBYyxXQUFXLFVBQVUsTUFBTSxrQkFBa0IsS0FDM0QsY0FBYyxXQUFXLFVBQVUsTUFBTSxrQkFBa0IsR0FBRztBQUU5RCxxQkFBTztBQUFBLFlBQ1g7QUFFQSxtQkFBTyxRQUFRLE1BQU0sVUFBVSxTQUFTLE1BQU07QUFBQSxVQUNsRDtBQUFBLFVBQ0EsU0FBUztBQUFBLFFBQ2I7QUFBQSxRQUVBLFlBQVk7QUFBQSxVQUNSLFNBQVM7QUFFTCxtQkFBTyxLQUFLLFVBQVUsWUFBWTtBQUFBLFVBQ3RDO0FBQUEsVUFDQSxTQUFTLE9BQU8sU0FBUztBQUVyQixnQkFBSSxJQUFJLE1BQU07QUFDZCxnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksTUFBTTtBQUVWLG1CQUFPLEtBQUs7QUFDUixvQkFBTSxPQUFPLE1BQU0sT0FBTyxDQUFDLElBQUk7QUFDL0Isb0JBQU0sT0FBTyxRQUFRLE9BQU8sS0FBSztBQUNqQyxvQkFBTSxNQUFNO0FBQUEsWUFDaEI7QUFFQSxnQkFBSSxNQUFNLEtBQ04sTUFBTSxPQUFPLEdBQUc7QUFFaEIscUJBQU87QUFBQSxZQUNYO0FBRUEsbUJBQU8sUUFBUSxNQUFNLG1CQUFtQjtBQUFBLFVBQzVDO0FBQUEsUUFDSjtBQUFBLFFBRUEsU0FBUztBQUFBLFVBQ0wsT0FBTyxVQUFVLENBQUMsR0FBRztBQUVqQixtQkFBTyxjQUFjLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQztBQUVqRCxzQkFBVSxFQUFFLGlCQUFpQixNQUFNLEdBQUcsUUFBUTtBQUM5QyxtQkFBTyxPQUFPLFFBQVEsb0JBQW9CLFdBQVcsaUNBQWlDO0FBRXRGLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sV0FBVyxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUM7QUFBQSxVQUNoRTtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxRQUFRLEdBQUc7QUFFbEMsa0JBQU0sVUFBVSxNQUFNLE1BQU0sVUFBVSxZQUFZO0FBRWxELGdCQUFJLFNBQVM7QUFDVCxrQkFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHO0FBQ2IsdUJBQU87QUFBQSxjQUNYO0FBRUEsa0JBQUksUUFBUSxDQUFDLE1BQU0sVUFBVTtBQUN6Qix1QkFBTztBQUFBLGNBQ1g7QUFFQSxvQkFBTSxjQUFjLFVBQVUsWUFBWSxRQUFRLGVBQWUsRUFBRTtBQUNuRSxrQkFBSSxZQUFZLEtBQUssUUFBUSxDQUFDLENBQUMsR0FBRztBQUM5Qix1QkFBTztBQUFBLGNBQ1g7QUFBQSxZQUNKO0FBRUEsbUJBQU8sUUFBUSxNQUFNLGdCQUFnQjtBQUFBLFVBQ3pDO0FBQUEsUUFDSjtBQUFBLFFBRUEsUUFBUTtBQUFBLFVBQ0osT0FBTyxTQUFTO0FBRVosZ0JBQUksU0FBUztBQUNULHFCQUFPLGNBQWMsU0FBUyxDQUFDLHVCQUF1QixnQkFBZ0IscUJBQXFCLHFCQUFxQixNQUFNLENBQUM7QUFBQSxZQUMzSDtBQUVBLGtCQUFNLFVBQVUsVUFBVSxlQUFlLE9BQU87QUFDaEQsbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxVQUFVLE1BQU0sRUFBRSxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQUEsVUFDeEU7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTLE1BQU0sRUFBRSxRQUFRLEdBQUc7QUFFeEMsZ0JBQUksT0FBTyxRQUFRLE9BQU8sT0FBTyxHQUFHO0FBQ2hDLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxlQUFlO0FBQUEsVUFDeEM7QUFBQSxRQUNKO0FBQUEsUUFFQSxPQUFPO0FBQUEsVUFDSCxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBRWpCLG1CQUFPLGNBQWMsU0FBUyxDQUFDLHVCQUF1QixnQkFBZ0IsZ0JBQWdCLHFCQUFxQixxQkFBcUIsWUFBWSxhQUFhLE1BQU0sQ0FBQztBQUNoSyxtQkFBTyxRQUFRLGFBQWEsVUFBYSxPQUFPLFFBQVEsYUFBYSxXQUFXLG9DQUFvQztBQUVwSCxrQkFBTSxVQUFVLFVBQVUsZUFBZSxPQUFPO0FBQ2hELGtCQUFNLFFBQVEsSUFBSSxPQUFPLFFBQVEsUUFBUSxZQUFZLFlBQVksUUFBUSxTQUFTLElBQUksR0FBRyxPQUFPO0FBRWhHLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxNQUFNLEVBQUUsUUFBUSxHQUFHLE9BQU8sUUFBUSxDQUFDO0FBQUEsVUFDOUU7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTLEVBQUUsUUFBUSxHQUFHLEVBQUUsT0FBTyxRQUFRLEdBQUc7QUFFdEQsa0JBQU0sU0FBUyxRQUFRLFdBQVcsTUFBTSxNQUFNLEtBQUssSUFBSSxDQUFDLEtBQUs7QUFDN0Qsa0JBQU0sV0FBVyxDQUFDO0FBQ2xCLHVCQUFXLFNBQVMsUUFBUTtBQUN4QixrQkFBSSxDQUFDLE1BQU0sUUFBUSxPQUFPLE9BQU8sR0FBRztBQUNoQyx5QkFBUyxLQUFLLEtBQUs7QUFBQSxjQUN2QjtBQUFBLFlBQ0o7QUFFQSxnQkFBSSxDQUFDLFNBQVMsUUFBUTtBQUNsQixxQkFBTztBQUFBLFlBQ1g7QUFFQSxtQkFBTyxRQUFRLE1BQU0sZ0JBQWdCLEVBQUUsT0FBTyxTQUFTLENBQUM7QUFBQSxVQUM1RDtBQUFBLFFBQ0o7QUFBQSxRQUVBLE1BQU07QUFBQSxVQUNGLE9BQU87QUFBQSxVQUNQLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFFakIsbUJBQU8sY0FBYyxTQUFTLENBQUMsV0FBVyxXQUFXLENBQUM7QUFFdEQsZ0JBQUksaUJBQWlCO0FBRXJCLGdCQUFJLFFBQVEsU0FBUztBQUNqQixvQkFBTSxXQUFXLENBQUMsRUFBRSxPQUFPLFFBQVEsT0FBTztBQUUxQyxxQkFBTyxTQUFTLFVBQVUsR0FBRyxzREFBc0Q7QUFDbkYsb0JBQU0sTUFBTSxvQkFBSSxJQUFJO0FBRXBCLHVCQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxFQUFFLEdBQUc7QUFDdEMsc0JBQU0sVUFBVSxTQUFTLENBQUM7QUFDMUIsdUJBQU8sT0FBTyxZQUFZLFVBQVUseUJBQXlCLElBQUksbUJBQW1CO0FBQ3BGLHNCQUFNLGdCQUFnQixVQUFVLGFBQWEsUUFBUSxZQUFZLENBQUM7QUFDbEUsdUJBQU8sZUFBZSx5QkFBeUIsSUFBSSxxQkFBcUIsT0FBTyxLQUFLLFVBQVUsWUFBWSxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQ3RILHVCQUFPLENBQUMsSUFBSSxJQUFJLGFBQWEsR0FBRyx5QkFBeUIsSUFBSSwwQkFBMEI7QUFFdkYsa0NBQWtCO0FBQ2xCLG9CQUFJLElBQUksYUFBYTtBQUFBLGNBQ3pCO0FBQUEsWUFDSjtBQUVBLG1CQUFPLFVBQVUsZUFBZSxJQUFJLFFBQVEsU0FBUyxHQUFHLG1EQUFtRDtBQUMzRyxrQkFBTSxZQUFZLFFBQVEsY0FBYyxTQUFZLFVBQ2hELFFBQVEsY0FBYyxPQUFPLFNBQ3pCLFFBQVEsY0FBYyxRQUFRLFFBQVEsS0FBSyxRQUFRLFNBQVM7QUFFcEUsa0JBQU0sUUFBUSxJQUFJLE9BQU8sNEJBQTRCLFNBQVMsb0JBQW9CLGtCQUFrQixRQUFRLG9CQUFvQixpQkFBaUIsU0FBUyxRQUFRLDZDQUE2QyxHQUFHO0FBRWxOLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxNQUFNLEVBQUUsUUFBUSxHQUFHLE1BQU0sQ0FBQztBQUFBLFVBQ3BFO0FBQUEsVUFDQSxTQUFTLE9BQU8sU0FBUyxNQUFNLEVBQUUsTUFBTSxHQUFHO0FBRXRDLGtCQUFNLFVBQVUsTUFBTSxLQUFLLEtBQUs7QUFFaEMsZ0JBQUksQ0FBQyxTQUFTO0FBQ1YscUJBQU8sUUFBUSxNQUFNLGFBQWE7QUFBQSxZQUN0QztBQUlBLGdCQUFJLFVBQVUsYUFBYSxRQUFRLENBQUMsQ0FBQyxNQUFNLFFBQVEsUUFBUSxTQUFTLENBQUMsR0FBRztBQUNwRSxxQkFBTyxRQUFRLE1BQU0sYUFBYTtBQUFBLFlBQ3RDO0FBRUEsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUFBLFFBRUEsS0FBSztBQUFBLFVBQ0QsT0FBTyxVQUFVLENBQUMsR0FBRztBQUVqQixtQkFBTyxjQUFjLFNBQVMsQ0FBQyxhQUFhLENBQUM7QUFFN0Msc0JBQVUsRUFBRSxhQUFhLE9BQU8sR0FBRyxRQUFRO0FBQzNDLG1CQUFPLE9BQU8sUUFBUSxnQkFBZ0IsV0FBVyw2QkFBNkI7QUFFOUUsbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxPQUFPLE1BQU0sRUFBRSxRQUFRLEVBQUUsQ0FBQztBQUFBLFVBQzVEO0FBQUEsVUFDQSxTQUFTLE9BQU8sU0FBUyxFQUFFLFFBQVEsR0FBRztBQUVsQyxnQkFBSSxDQUFDLFVBQVUsU0FBUyxLQUFLLEtBQUssR0FBRztBQUNqQyxxQkFBTyxRQUFRLE1BQU0sWUFBWTtBQUFBLFlBQ3JDO0FBRUEsZ0JBQUksUUFBUSxlQUNSLE1BQU0sU0FBUyxNQUFNLEdBQUc7QUFFeEIscUJBQU8sUUFBUSxNQUFNLGlCQUFpQjtBQUFBLFlBQzFDO0FBRUEsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUFBLFFBRUEsVUFBVTtBQUFBLFVBQ04sU0FBUztBQUVMLG1CQUFPLEtBQUssVUFBVSxVQUFVO0FBQUEsVUFDcEM7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTO0FBRXJCLGdCQUFJLE9BQU8sUUFBUSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxLQUM5QyxVQUFVLFFBQVEsS0FBSyxLQUFLLEdBQUc7QUFFL0IscUJBQU87QUFBQSxZQUNYO0FBRUEsbUJBQU8sUUFBUSxNQUFNLGlCQUFpQjtBQUFBLFVBQzFDO0FBQUEsUUFDSjtBQUFBLFFBRUEsYUFBYTtBQUFBLFVBQ1QsU0FBUztBQUVMLG1CQUFPLEtBQUssVUFBVSxlQUFlLElBQUk7QUFBQSxVQUM3QztBQUFBLFFBQ0o7QUFBQSxRQUVBLElBQUk7QUFBQSxVQUNBLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFFakIsbUJBQU8sY0FBYyxTQUFTLENBQUMsUUFBUSxTQUFTLENBQUM7QUFFakQsa0JBQU0sRUFBRSxNQUFNLFVBQVUsTUFBTSxJQUFJLEdBQUcsTUFBTSxPQUFPO0FBQ2xELGtCQUFNLFVBQVUsUUFBUSxVQUFVLFdBQVc7QUFDN0MsbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxNQUFNLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFBQSxVQUNyRjtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxRQUFRLEdBQUcsRUFBRSxNQUFNLEdBQUc7QUFFN0MsZ0JBQUksTUFBTSxLQUFLLEtBQUssR0FBRztBQUNuQixxQkFBTztBQUFBLFlBQ1g7QUFFQSxnQkFBSSxRQUFRLFNBQVM7QUFDakIscUJBQU8sUUFBUSxNQUFNLG9CQUFvQixFQUFFLE9BQU8sTUFBTSxRQUFRLE1BQU0sU0FBUyxRQUFRLFFBQVEsQ0FBQztBQUFBLFlBQ3BHO0FBRUEsbUJBQU8sUUFBUSxNQUFNLGFBQWEsRUFBRSxPQUFPLE1BQU0sUUFBUSxLQUFLLENBQUM7QUFBQSxVQUNuRTtBQUFBLFFBQ0o7QUFBQSxRQUVBLFNBQVM7QUFBQSxVQUNMLFNBQVM7QUFFTCxtQkFBTyxLQUFLLFVBQVUsU0FBUztBQUFBLFVBQ25DO0FBQUEsVUFDQSxTQUFTLE9BQU8sRUFBRSxNQUFNLEdBQUc7QUFFdkIsZ0JBQUksVUFBVSxRQUFRLEtBQUssR0FBRztBQUMxQixxQkFBTztBQUFBLFlBQ1g7QUFFQSxtQkFBTyxNQUFNLGdCQUFnQjtBQUFBLFVBQ2pDO0FBQUEsUUFDSjtBQUFBLFFBRUEsYUFBYTtBQUFBLFVBQ1QsU0FBUztBQUVMLG1CQUFPLEtBQUssVUFBVSxhQUFhO0FBQUEsVUFDdkM7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTO0FBRXJCLGdCQUFJLFVBQVUsaUJBQWlCLEtBQUssS0FBSyxHQUFHO0FBQ3hDLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxvQkFBb0I7QUFBQSxVQUM3QztBQUFBLFFBQ0o7QUFBQSxRQUVBLFFBQVE7QUFBQSxVQUNKLE9BQU8sT0FBTyxVQUFVO0FBRXBCLG1CQUFPLFVBQVUsT0FBTyxNQUFNLFVBQVUsT0FBTyxLQUFLLFFBQVE7QUFBQSxVQUNoRTtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxPQUFPLFNBQVMsR0FBRyxFQUFFLE1BQU0sVUFBVSxLQUFLLEdBQUc7QUFFcEUsa0JBQU0sU0FBUyxXQUFXLFVBQVUsT0FBTyxXQUFXLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDL0UsZ0JBQUksT0FBTyxRQUFRLFFBQVEsT0FBTyxRQUFRLEdBQUc7QUFDekMscUJBQU87QUFBQSxZQUNYO0FBRUEsbUJBQU8sUUFBUSxNQUFNLFlBQVksTUFBTSxFQUFFLE9BQU8sS0FBSyxPQUFPLE9BQU8sU0FBUyxDQUFDO0FBQUEsVUFDakY7QUFBQSxVQUNBLE1BQU07QUFBQSxZQUNGO0FBQUEsY0FDSSxNQUFNO0FBQUEsY0FDTixLQUFLO0FBQUEsY0FDTCxRQUFRLE9BQU87QUFBQSxjQUNmLFNBQVM7QUFBQSxZQUNiO0FBQUEsWUFDQTtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsUUFFQSxXQUFXO0FBQUEsVUFDUCxTQUFTO0FBRUwsbUJBQU8sS0FBSyxLQUFLLE9BQU87QUFBQSxVQUM1QjtBQUFBLFFBQ0o7QUFBQSxRQUVBLEtBQUs7QUFBQSxVQUNELE9BQU8sT0FBTyxVQUFVO0FBRXBCLG1CQUFPLFVBQVUsT0FBTyxNQUFNLE9BQU8sT0FBTyxNQUFNLFFBQVE7QUFBQSxVQUM5RDtBQUFBLFVBQ0EsTUFBTSxDQUFDLFNBQVMsVUFBVTtBQUFBLFFBQzlCO0FBQUEsUUFFQSxLQUFLO0FBQUEsVUFDRCxPQUFPLE9BQU8sVUFBVTtBQUVwQixtQkFBTyxVQUFVLE9BQU8sTUFBTSxPQUFPLE9BQU8sTUFBTSxRQUFRO0FBQUEsVUFDOUQ7QUFBQSxVQUNBLE1BQU0sQ0FBQyxTQUFTLFVBQVU7QUFBQSxRQUM5QjtBQUFBLFFBRUEsV0FBVztBQUFBLFVBQ1AsT0FBTyxPQUFPLE9BQU87QUFFakIsbUJBQU8sVUFBVSxtQkFBbUIsU0FBUyxJQUFJLEdBQUcsdUNBQXVDLFVBQVUsbUJBQW1CLEtBQUssSUFBSSxDQUFDO0FBRWxJLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sYUFBYSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFBQSxVQUMvRDtBQUFBLFVBQ0EsU0FBUyxPQUFPLEVBQUUsTUFBTSxHQUFHLEVBQUUsS0FBSyxHQUFHO0FBRWpDLGdCQUFJLFVBQVUsTUFBTSxVQUFVLElBQUksR0FBRztBQUNqQyxxQkFBTztBQUFBLFlBQ1g7QUFFQSxtQkFBTyxNQUFNLG9CQUFvQixFQUFFLE9BQU8sS0FBSyxDQUFDO0FBQUEsVUFDcEQ7QUFBQSxVQUNBLFNBQVM7QUFBQSxRQUNiO0FBQUEsUUFFQSxTQUFTO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxPQUFPLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFFeEIsbUJBQU8saUJBQWlCLFFBQVEsd0JBQXdCO0FBQ3hELG1CQUFPLENBQUMsTUFBTSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsTUFBTSxNQUFNLFNBQVMsR0FBRyxHQUFHLDRDQUE0QztBQUU3RyxnQkFBSSxPQUFPLFlBQVksVUFBVTtBQUM3Qix3QkFBVSxFQUFFLE1BQU0sUUFBUTtBQUFBLFlBQzlCO0FBRUEsbUJBQU8sY0FBYyxTQUFTLENBQUMsVUFBVSxNQUFNLENBQUM7QUFFaEQsa0JBQU0sWUFBWSxDQUFDLGtCQUFrQixRQUFRLFNBQVMsWUFBWSxJQUFJLFFBQVEsT0FBTyxVQUFVLE9BQU8sRUFBRSxLQUFLLEVBQUU7QUFDL0csbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxXQUFXLE1BQU0sRUFBRSxPQUFPLFFBQVEsR0FBRyxVQUFVLENBQUM7QUFBQSxVQUNsRjtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxPQUFPLFFBQVEsR0FBRyxFQUFFLFVBQVUsR0FBRztBQUV4RCxrQkFBTSxlQUFlLE1BQU0sS0FBSyxLQUFLO0FBRXJDLGdCQUFJLGVBQWUsUUFBUSxRQUFRO0FBQy9CLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxXQUFXLEVBQUUsTUFBTSxRQUFRLE1BQU0sT0FBTyxNQUFNLENBQUM7QUFBQSxVQUN4RTtBQUFBLFVBQ0EsTUFBTSxDQUFDLFNBQVMsU0FBUztBQUFBLFVBQ3pCLE9BQU87QUFBQSxRQUNYO0FBQUEsUUFFQSxTQUFTO0FBQUEsVUFDTCxPQUFPLFNBQVMsYUFBYTtBQUV6QixnQkFBSSxPQUFPLFlBQVksVUFBVTtBQUM3Qix3QkFBVSxJQUFJLE9BQU8sWUFBWSxPQUFPLEdBQUcsR0FBRztBQUFBLFlBQ2xEO0FBRUEsbUJBQU8sbUJBQW1CLFFBQVEsMEJBQTBCO0FBQzVELG1CQUFPLE9BQU8sZ0JBQWdCLFVBQVUsOEJBQThCO0FBRXRFLGtCQUFNLE1BQU0sS0FBSyxNQUFNO0FBRXZCLGdCQUFJLENBQUMsSUFBSSxRQUFRLGNBQWM7QUFDM0Isa0JBQUksUUFBUSxlQUFlLENBQUM7QUFBQSxZQUNoQztBQUVBLGdCQUFJLFFBQVEsYUFBYSxLQUFLLEVBQUUsU0FBUyxZQUFZLENBQUM7QUFDdEQsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUFBLFFBRUEsT0FBTztBQUFBLFVBQ0gsU0FBUztBQUVMLG1CQUFPLEtBQUssVUFBVSxPQUFPO0FBQUEsVUFDakM7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTO0FBRXJCLGdCQUFJLFFBQVEsS0FBSyxLQUFLLEdBQUc7QUFDckIscUJBQU87QUFBQSxZQUNYO0FBRUEsbUJBQU8sUUFBUSxNQUFNLGNBQWM7QUFBQSxVQUN2QztBQUFBLFFBQ0o7QUFBQSxRQUVBLE1BQU07QUFBQSxVQUNGLE9BQU8sVUFBVSxNQUFNO0FBRW5CLG1CQUFPLE9BQU8sWUFBWSxXQUFXLDJCQUEyQjtBQUVoRSxtQkFBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDO0FBQUEsVUFDN0Q7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTLEVBQUUsUUFBUSxHQUFHO0FBRWxDLGdCQUFJLENBQUMsV0FDRCxVQUFVLE1BQU0sS0FBSyxHQUFHO0FBRXhCLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxhQUFhO0FBQUEsVUFDdEM7QUFBQSxVQUNBLFNBQVM7QUFBQSxRQUNiO0FBQUEsUUFFQSxVQUFVO0FBQUEsVUFDTixPQUFPLFVBQVUsTUFBTTtBQUVuQixtQkFBTyxPQUFPLFlBQVksV0FBVywyQkFBMkI7QUFFaEUsbUJBQU8sS0FBSyxVQUFVLFlBQVksT0FBTztBQUFBLFVBQzdDO0FBQUEsUUFDSjtBQUFBLFFBRUEsV0FBVztBQUFBLFVBQ1AsU0FBUztBQUVMLG1CQUFPLEtBQUssS0FBSyxPQUFPO0FBQUEsVUFDNUI7QUFBQSxRQUNKO0FBQUEsUUFFQSxLQUFLO0FBQUEsVUFDRCxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBRWpCLG1CQUFPLGNBQWMsU0FBUyxDQUFDLGlCQUFpQiw0QkFBNEIsVUFBVSxnQkFBZ0IsUUFBUSxDQUFDO0FBRS9HLGdCQUFJLFFBQVEsUUFBUTtBQUNoQixxQkFBTyxjQUFjLFFBQVEsUUFBUSxDQUFDLHVCQUF1QixnQkFBZ0IscUJBQXFCLHFCQUFxQixNQUFNLENBQUM7QUFBQSxZQUNsSTtBQUVBLGtCQUFNLEVBQUUsT0FBTyxPQUFPLElBQUksSUFBSSxNQUFNLE9BQU87QUFDM0Msa0JBQU0sU0FBUyxRQUFRLFNBQVMsVUFBVSxlQUFlLFFBQVEsTUFBTSxJQUFJO0FBQzNFLG1CQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sT0FBTyxNQUFNLEVBQUUsUUFBUSxHQUFHLE9BQU8sUUFBUSxPQUFPLENBQUM7QUFBQSxVQUNuRjtBQUFBLFVBQ0EsU0FBUyxPQUFPLFNBQVMsRUFBRSxRQUFRLEdBQUcsRUFBRSxPQUFPLFFBQVEsT0FBTyxHQUFHO0FBRTdELGdCQUFJLENBQUMsVUFBVSxTQUFTLEVBQUUsU0FBUyxLQUFLLEdBQUc7QUFDdkMscUJBQU8sUUFBUSxNQUFNLFlBQVk7QUFBQSxZQUNyQztBQUVBLGtCQUFNLFFBQVEsTUFBTSxLQUFLLEtBQUs7QUFDOUIsZ0JBQUksT0FBTztBQUNQLG9CQUFNLFVBQVUsTUFBTSxDQUFDLEtBQUssTUFBTSxDQUFDO0FBQ25DLGtCQUFJLFdBQ0MsQ0FBQyxRQUFRLGlCQUFpQixZQUMzQixDQUFDLE9BQU8sUUFBUSxTQUFTLE1BQU0sR0FBRztBQUVsQyx1QkFBTyxRQUFRLE1BQU0saUJBQWlCLEVBQUUsT0FBTyxRQUFRLENBQUM7QUFBQSxjQUM1RDtBQUVBLHFCQUFPO0FBQUEsWUFDWDtBQUVBLGdCQUFJLFFBQVEsY0FBYztBQUN0QixxQkFBTyxRQUFRLE1BQU0sd0JBQXdCO0FBQUEsWUFDakQ7QUFFQSxnQkFBSSxRQUFRLFFBQVE7QUFDaEIscUJBQU8sUUFBUSxNQUFNLDBCQUEwQixFQUFFLFFBQVEsTUFBTSxDQUFDO0FBQUEsWUFDcEU7QUFFQSxtQkFBTyxRQUFRLE1BQU0sWUFBWTtBQUFBLFVBQ3JDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUVBLFVBQVU7QUFBQSxRQUVOLE1BQU0sS0FBSyxNQUFNO0FBRWIsY0FBSSxLQUFLLGNBQWM7QUFDbkIsdUJBQVcsRUFBRSxTQUFTLFlBQVksS0FBSyxLQUFLLGNBQWM7QUFDdEQsb0JBQU0sSUFBSSxRQUFRLFNBQVMsV0FBVztBQUFBLFlBQzFDO0FBQUEsVUFDSjtBQUVBLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQSxNQUVBLFVBQVU7QUFBQSxRQUNOLG1CQUFtQjtBQUFBLFFBQ25CLGVBQWU7QUFBQSxRQUNmLGlCQUFpQjtBQUFBLFFBQ2pCLHFCQUFxQjtBQUFBLFFBQ3JCLGtCQUFrQjtBQUFBLFFBQ2xCLGlCQUFpQjtBQUFBLFFBQ2pCLGdCQUFnQjtBQUFBLFFBQ2hCLGdCQUFnQjtBQUFBLFFBQ2hCLGVBQWU7QUFBQSxRQUNmLGNBQWM7QUFBQSxRQUNkLG1CQUFtQjtBQUFBLFFBQ25CLG1CQUFtQjtBQUFBLFFBQ25CLGFBQWE7QUFBQSxRQUNiLG9CQUFvQjtBQUFBLFFBQ3BCLGtCQUFrQjtBQUFBLFFBQ2xCLHNCQUFzQjtBQUFBLFFBQ3RCLGlCQUFpQjtBQUFBLFFBQ2pCLG9CQUFvQjtBQUFBLFFBQ3BCLGNBQWM7QUFBQSxRQUNkLGNBQWM7QUFBQSxRQUNkLG9CQUFvQjtBQUFBLFFBQ3BCLGdCQUFnQjtBQUFBLFFBQ2hCLHVCQUF1QjtBQUFBLFFBQ3ZCLHVCQUF1QjtBQUFBLFFBQ3ZCLDhCQUE4QjtBQUFBLFFBQzlCLDhCQUE4QjtBQUFBLFFBQzlCLGVBQWU7QUFBQSxRQUNmLGNBQWM7QUFBQSxRQUNkLDBCQUEwQjtBQUFBLFFBQzFCLDBCQUEwQjtBQUFBLFFBQzFCLG9CQUFvQjtBQUFBLE1BQ3hCO0FBQUEsSUFDSixDQUFDO0FBS0QsY0FBVSxpQkFBaUIsU0FBVSxTQUFTO0FBRTFDLFVBQUksQ0FBQyxTQUFTO0FBQ1YsZUFBTztBQUFBLE1BQ1g7QUFJQSxhQUFPLFFBQVEsc0JBQXNCLFVBQ2pDLE9BQU8sY0FBYyxRQUFRLGlCQUFpQixLQUFLLFFBQVEsb0JBQW9CLEdBQUcsOENBQThDO0FBSXBJLGFBQU8sUUFBUSxzQkFBc0IsVUFDakMsT0FBTyxjQUFjLFFBQVEsaUJBQWlCLEtBQUssUUFBUSxvQkFBb0IsR0FBRyw4Q0FBOEM7QUFJcEksVUFBSSxRQUFRLFNBQVMsT0FBTztBQUN4QixlQUFPO0FBQUEsTUFDWDtBQUVBLFVBQUksUUFBUSxTQUFTLFFBQ2pCLFFBQVEsU0FBUyxRQUFXO0FBRTVCLGVBQU8sVUFBVSxNQUFNLDRCQUE0QjtBQUNuRCxlQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsU0FBUyxVQUFVLElBQUk7QUFBQSxNQUNwRDtBQUVBLGFBQU8sT0FBTyxRQUFRLFNBQVMsVUFBVSx3Q0FBd0M7QUFFakYsWUFBTSxPQUFPLFFBQVEsS0FBSztBQUMxQixVQUFJLE1BQU07QUFDTixZQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDckIsb0JBQVUsT0FBTyxPQUFPLENBQUMsR0FBRyxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sSUFBSSxJQUFJLElBQUksRUFBRSxFQUFFLENBQUM7QUFBQSxRQUMxRTtBQUVBLGVBQU8sUUFBUSxLQUFLLGdCQUFnQixLQUFLLDZDQUE2QztBQUN0RixlQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sb0RBQW9EO0FBQ2hGLGtCQUFVLGFBQWEsUUFBUSxLQUFLLE1BQU0sV0FBVztBQUNyRCxlQUFPO0FBQUEsTUFDWDtBQUVBLFlBQU0sUUFBUSxRQUFRLEtBQUs7QUFDM0IsVUFBSSxDQUFDLE9BQU87QUFDUixlQUFPO0FBQUEsTUFDWDtBQUVBLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU8sVUFBVSxNQUFNLDRCQUE0QjtBQUNuRCxlQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsU0FBUyxVQUFVLElBQUk7QUFBQSxNQUNwRDtBQUVBLFVBQUksTUFBTSxRQUFRLEtBQUssR0FBRztBQUN0QixrQkFBVSxPQUFPLE9BQU8sQ0FBQyxHQUFHLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxJQUFJLElBQUksS0FBSyxFQUFFLEVBQUUsQ0FBQztBQUFBLE1BQzVFO0FBRUEsYUFBTyxRQUFRLEtBQUssaUJBQWlCLEtBQUssOENBQThDO0FBQ3hGLGdCQUFVLGFBQWEsUUFBUSxLQUFLLE9BQU8sWUFBWTtBQUN2RCxhQUFPO0FBQUEsSUFDWDtBQUdBLGNBQVUsZUFBZSxTQUFVLEtBQUssUUFBUTtBQUU1QyxpQkFBVyxPQUFPLEtBQUs7QUFDbkIsZUFBTyxPQUFPLFFBQVEsS0FBSyxFQUFFLG1CQUFtQixHQUFHLG1CQUFtQixFQUFFLENBQUMsR0FBRyxHQUFHLE1BQU0sNENBQTRDO0FBQUEsTUFDckk7QUFBQSxJQUNKO0FBR0EsY0FBVSxVQUFVLFNBQVUsT0FBTztBQUVqQyxVQUFJLENBQUMsT0FBTyxVQUFVLEtBQUssR0FBRztBQUMxQixlQUFPO0FBQUEsTUFDWDtBQUVBLFVBQUksaUJBQWlCLEtBQUssS0FBSyxHQUFHO0FBQzlCLGlCQUFTO0FBQUEsTUFDYjtBQUVBLFlBQU0sT0FBTyxJQUFJLEtBQUssS0FBSztBQUMzQixVQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRztBQUN2QixlQUFPO0FBQUEsTUFDWDtBQUVBLGFBQU8sS0FBSyxZQUFZO0FBQUEsSUFDNUI7QUFHQSxjQUFVLFNBQVMsU0FBVUEsU0FBUSxNQUFNLE9BQU8sVUFBVSxVQUFVO0FBRWxFLGFBQU8sQ0FBQyxZQUFZLFVBQVUsT0FBTyxXQUFXLFFBQVEsR0FBRyxxQkFBcUIsUUFBUTtBQUV4RixhQUFPQSxRQUFPLFVBQVUsRUFBRSxNQUFNLFFBQVEsVUFBVSxNQUFNLEVBQUUsT0FBTyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQUEsSUFDM0Y7QUFBQTtBQUFBOzs7QUM5ekJBO0FBQUE7QUFBQTtBQUVBLFFBQU0sU0FBUztBQUVmLFFBQU0sTUFBTTtBQUdaLFFBQU0sWUFBWSxDQUFDO0FBR25CLGNBQVUsTUFBTSxjQUFjLElBQUk7QUFBQSxNQUU5QixRQUFRO0FBRUosZUFBTyxJQUFJLFVBQVUsSUFBSSxJQUFJO0FBQUEsTUFDakM7QUFBQSxJQUNKO0FBR0EsV0FBTyxVQUFVLElBQUksT0FBTztBQUFBLE1BRXhCLE1BQU07QUFBQSxNQUVOLE9BQU87QUFBQSxRQUVILEtBQUssRUFBRSxNQUFNLElBQUksVUFBVSxJQUFJLEVBQUU7QUFBQSxNQUNyQztBQUFBLE1BRUEsUUFBUTtBQUFBLFFBQ0osT0FBTyxPQUFPLEVBQUUsUUFBQUMsU0FBUSxNQUFNLEdBQUc7QUFFN0IsZ0JBQU0sU0FBU0EsUUFBTyxRQUFRLElBQUksSUFBSSxLQUFLO0FBQzNDLGNBQUksUUFBUTtBQUNSLG9CQUFRO0FBQUEsVUFDWjtBQUVBLGNBQUksQ0FBQ0EsUUFBTyxPQUFPLFFBQ2YsT0FBTyxVQUFVLFVBQVU7QUFFM0IsbUJBQU8sRUFBRSxNQUFNO0FBQUEsVUFDbkI7QUFFQSxpQkFBTyxFQUFFLE9BQU8sUUFBUSxNQUFNLGNBQWMsRUFBRSxLQUFLQSxRQUFPLFFBQVEsSUFBSSxDQUFDLEVBQUU7QUFBQSxRQUM3RTtBQUFBLE1BQ0o7QUFBQSxNQUVBLFNBQVMsT0FBTyxFQUFFLE1BQU0sR0FBRztBQUV2QixZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGlCQUFPLEVBQUUsT0FBTyxRQUFRLE1BQU0sYUFBYSxFQUFFO0FBQUEsUUFDakQ7QUFBQSxNQUNKO0FBQUEsTUFFQSxPQUFPO0FBQUEsUUFDSCxLQUFLO0FBQUEsVUFDRCxPQUFPLFVBQVU7QUFFYixnQkFBSSxZQUNBLENBQUMsU0FBUyxPQUFPLFFBQVEsS0FDekIsT0FBTyxhQUFhLFVBQVU7QUFFOUIseUJBQVcsT0FBTyxRQUFRLFFBQVE7QUFBQSxZQUN0QztBQUVBLG1CQUFPLFlBQVksU0FBUyxPQUFPLFFBQVEsR0FBRyx3Q0FBd0M7QUFFdEYsa0JBQU0sTUFBTSxLQUFLLE1BQU07QUFFdkIsa0JBQU0sVUFBVSxDQUFDO0FBQ2pCLHVCQUFXLFNBQVMsVUFBVTtBQUMxQixxQkFBTyxTQUFTLE1BQU0sT0FBTyxRQUFRLEdBQUcsMkJBQTJCO0FBQ25FLG9CQUFNLENBQUMsS0FBSyxLQUFLLElBQUk7QUFFckIscUJBQU8sT0FBTyxRQUFRLFlBQVksT0FBTyxRQUFRLGNBQWMsT0FBTyxRQUFRLFVBQVUscURBQXFEO0FBQzdJLHFCQUFPLE9BQU8sVUFBVSxVQUFVLHdCQUF3QjtBQUUxRCxrQkFBSSxRQUFRLElBQUksSUFBSSxLQUFLLEtBQUs7QUFDOUIsc0JBQVEsS0FBSyxLQUFLO0FBQUEsWUFDdEI7QUFFQSxtQkFBTyxJQUFJLE1BQU0sR0FBRyxPQUFPO0FBQUEsVUFDL0I7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BRUEsVUFBVTtBQUFBLFFBRU4sTUFBTSxLQUFLLE1BQU07QUFFYixjQUFJLEtBQUssS0FBSztBQUNWLGtCQUFNLElBQUksSUFBSSxLQUFLLEdBQUc7QUFBQSxVQUMxQjtBQUVBLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQSxNQUVBLFVBQVU7QUFBQSxRQUNOLGVBQWU7QUFBQSxRQUNmLGNBQWM7QUFBQSxNQUNsQjtBQUFBLElBQ0osQ0FBQztBQUFBO0FBQUE7OztBQ3JHRDtBQUFBO0FBQUE7QUFFQSxRQUFNLFNBQVM7QUFFZixRQUFNLE1BQU07QUFDWixRQUFNLFNBQVM7QUFNZixXQUFPLFVBQVUsSUFBSSxPQUFPO0FBQUEsTUFFeEIsTUFBTTtBQUFBLE1BRU4sUUFBUTtBQUFBLFFBQ0osTUFBTSxDQUFDLFVBQVUsUUFBUTtBQUFBLFFBQ3pCLE9BQU8sT0FBTyxFQUFFLFFBQUFDLFFBQU8sR0FBRztBQUV0QixjQUFJLE9BQU8sVUFBVSxZQUFhLFVBQVUsUUFBUSxNQUFNLFNBQVMsVUFBVztBQUMxRSxnQkFBSTtBQUNBLHFCQUFPLEVBQUUsT0FBTyxPQUFPLEtBQUssT0FBT0EsUUFBTyxPQUFPLFFBQVEsRUFBRTtBQUFBLFlBQy9ELFNBQ08sV0FBVztBQUFBLFlBQUU7QUFBQSxVQUN4QjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFFQSxTQUFTLE9BQU8sRUFBRSxNQUFNLEdBQUc7QUFFdkIsWUFBSSxDQUFDLE9BQU8sU0FBUyxLQUFLLEdBQUc7QUFDekIsaUJBQU8sRUFBRSxPQUFPLFFBQVEsTUFBTSxhQUFhLEVBQUU7QUFBQSxRQUNqRDtBQUFBLE1BQ0o7QUFBQSxNQUVBLE9BQU87QUFBQSxRQUNILFVBQVU7QUFBQSxVQUNOLE9BQU8sVUFBVTtBQUViLG1CQUFPLE9BQU8sV0FBVyxRQUFRLEdBQUcscUJBQXFCLFFBQVE7QUFFakUsbUJBQU8sS0FBSyxVQUFVLFlBQVksUUFBUTtBQUFBLFVBQzlDO0FBQUEsUUFDSjtBQUFBLFFBRUEsUUFBUTtBQUFBLFVBQ0osT0FBTyxPQUFPO0FBRVYsbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxVQUFVLFFBQVEsVUFBVSxNQUFNLEVBQUUsTUFBTSxHQUFHLFVBQVUsSUFBSSxDQUFDO0FBQUEsVUFDOUY7QUFBQSxVQUNBLFNBQVMsT0FBTyxTQUFTLEVBQUUsTUFBTSxHQUFHLEVBQUUsTUFBTSxVQUFVLEtBQUssR0FBRztBQUUxRCxnQkFBSSxPQUFPLFFBQVEsTUFBTSxRQUFRLE9BQU8sUUFBUSxHQUFHO0FBQy9DLHFCQUFPO0FBQUEsWUFDWDtBQUVBLG1CQUFPLFFBQVEsTUFBTSxZQUFZLE1BQU0sRUFBRSxPQUFPLEtBQUssT0FBTyxNQUFNLENBQUM7QUFBQSxVQUN2RTtBQUFBLFVBQ0EsTUFBTTtBQUFBLFlBQ0Y7QUFBQSxjQUNJLE1BQU07QUFBQSxjQUNOLEtBQUs7QUFBQSxjQUNMLFFBQVEsT0FBTztBQUFBLGNBQ2YsU0FBUztBQUFBLFlBQ2I7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLFFBRUEsS0FBSztBQUFBLFVBQ0QsT0FBTyxPQUFPO0FBRVYsbUJBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxPQUFPLFFBQVEsVUFBVSxNQUFNLEVBQUUsTUFBTSxHQUFHLFVBQVUsS0FBSyxDQUFDO0FBQUEsVUFDNUY7QUFBQSxRQUNKO0FBQUEsUUFFQSxLQUFLO0FBQUEsVUFDRCxPQUFPLE9BQU87QUFFVixtQkFBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLE9BQU8sUUFBUSxVQUFVLE1BQU0sRUFBRSxNQUFNLEdBQUcsVUFBVSxLQUFLLENBQUM7QUFBQSxVQUM1RjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFFQSxNQUFNO0FBQUEsUUFDRixRQUFRO0FBQUEsVUFDSixNQUFNLENBQUMsVUFBVSxPQUFPLFNBQVMsS0FBSztBQUFBLFVBQ3RDLEdBQUcsT0FBTyxTQUFTO0FBRWYsbUJBQU8sTUFBTSxTQUFTO0FBQUEsVUFDMUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BRUEsVUFBVTtBQUFBLFFBQ04sZUFBZTtBQUFBLFFBQ2YsaUJBQWlCO0FBQUEsUUFDakIsY0FBYztBQUFBLFFBQ2QsY0FBYztBQUFBLE1BQ2xCO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQTs7O0FDbkdELElBQUFDLGVBQUE7QUFBQTtBQUFBO0FBRUEsUUFBTSxTQUFTO0FBQ2YsUUFBTSxRQUFRO0FBRWQsUUFBTSxRQUFRO0FBQ2QsUUFBTSxTQUFTO0FBQ2YsUUFBTSxVQUFVO0FBQ2hCLFFBQU0sU0FBUztBQUNmLFFBQU0sU0FBUztBQUNmLFFBQU0sV0FBVztBQUNqQixRQUFNLE1BQU07QUFDWixRQUFNLFdBQVc7QUFDakIsUUFBTSxRQUFRO0FBRWQsUUFBSTtBQUdKLFFBQU0sWUFBWTtBQUFBLE1BQ2QsT0FBTztBQUFBLFFBQ0gsY0FBYztBQUFBLFFBQ2QsS0FBSztBQUFBLFFBQ0wsT0FBTztBQUFBLFFBQ1AsU0FBUztBQUFBLFFBQ1QsTUFBTTtBQUFBLFFBQ04sVUFBVTtBQUFBLFFBQ1YsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLFFBQ1IsUUFBUTtBQUFBLFFBQ1IsUUFBUTtBQUFBLFFBQ1IsUUFBUTtBQUFBLE1BQ1o7QUFBQSxNQUNBLFNBQVM7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNWO0FBQUEsSUFDSjtBQUdBLFFBQUksUUFBUTtBQUNSLGdCQUFVLE1BQU0sU0FBUztBQUFBLElBQzdCO0FBR0EsY0FBVSxPQUFPLFdBQVk7QUFFekIsWUFBTSxPQUFPO0FBQUEsUUFDVCxRQUFRLElBQUksSUFBSSxPQUFPLEtBQUssVUFBVSxLQUFLLENBQUM7QUFBQSxNQUNoRDtBQUlBLGlCQUFXLFFBQVEsS0FBSyxRQUFRO0FBQzVCLGFBQUssSUFBSSxJQUFJLFlBQWEsTUFBTTtBQUU1QixpQkFBTyxDQUFDLEtBQUssVUFBVSxDQUFDLGdCQUFnQixRQUFRLFFBQVEsRUFBRSxTQUFTLElBQUksR0FBRyxPQUFPLE1BQU0sK0JBQStCO0FBQ3RILGlCQUFPLFVBQVUsU0FBUyxNQUFNLFVBQVUsTUFBTSxJQUFJLEdBQUcsSUFBSTtBQUFBLFFBQy9EO0FBQUEsTUFDSjtBQUlBLGlCQUFXLFVBQVUsQ0FBQyxTQUFTLFVBQVUsWUFBWSxTQUFTLFNBQVMsYUFBYSxXQUFXLE9BQU8sUUFBUSxZQUFZLFdBQVcsU0FBUyxlQUFlLFlBQVksU0FBUyxTQUFTLE1BQU0sR0FBRztBQUNoTSxhQUFLLE1BQU0sSUFBSSxZQUFhLE1BQU07QUFFOUIsaUJBQU8sS0FBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtBQUFBLFFBQ3JDO0FBQUEsTUFDSjtBQUlBLGFBQU8sT0FBTyxNQUFNLFVBQVUsT0FBTztBQUlyQyxpQkFBVyxTQUFTLFVBQVUsU0FBUztBQUNuQyxjQUFNLFNBQVMsVUFBVSxRQUFRLEtBQUs7QUFDdEMsYUFBSyxLQUFLLElBQUksS0FBSyxNQUFNO0FBQUEsTUFDN0I7QUFFQSxXQUFLLElBQUksS0FBSztBQUlkLFVBQUksTUFBTSxPQUFPO0FBQ2IsY0FBTSxNQUFNLElBQUk7QUFBQSxNQUNwQjtBQUVBLGFBQU87QUFBQSxJQUNYO0FBR0EsY0FBVSxVQUFVO0FBQUEsTUFFaEIsaUJBQWlCLE9BQU87QUFBQSxNQUN4QixTQUFTLE9BQU87QUFBQSxNQUNoQixPQUFPLE1BQU07QUFBQSxNQUViLE9BQU8sT0FBT0MsWUFBVyxNQUFpQztBQUV0RCxrQkFBVSxPQUFPLE9BQU9BLFNBQVEsTUFBTSxJQUFJO0FBQUEsTUFDOUM7QUFBQSxNQUVBLFFBQVEsT0FBT0EsWUFBVyxNQUFpQztBQUV2RCxlQUFPLFVBQVUsT0FBTyxPQUFPQSxTQUFRLE9BQU8sSUFBSTtBQUFBLE1BQ3REO0FBQUEsTUFFQSxNQUFNLE1BQU07QUFFUixlQUFPLE9BQU8sU0FBUyxVQUFVLFlBQVksaUNBQWlDO0FBQzlFLGVBQU8sU0FBUyxNQUFNLE1BQU0sSUFBSTtBQUFBLE1BQ3BDO0FBQUEsTUFFQSxpQkFBaUIsT0FBTztBQUVwQixlQUFPLGlCQUFpQixLQUFLO0FBQUEsTUFDakM7QUFBQSxNQUVBLFFBQVFBLFNBQVEsU0FBUztBQUVyQixlQUFPLFFBQVEsUUFBUSxNQUFNQSxTQUFRLE9BQU87QUFBQSxNQUNoRDtBQUFBLE1BRUEsU0FBUyxVQUFVO0FBRWYsZUFBTyxPQUFPLGFBQWEsWUFBWSw2QkFBNkI7QUFFcEUsY0FBTSxNQUFNLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSTtBQUNsQyxtQkFBVyxRQUFRLElBQUksUUFBUTtBQUMzQixnQkFBTUEsVUFBUyxTQUFTLElBQUksSUFBSSxFQUFFLENBQUM7QUFDbkMsaUJBQU8sT0FBTyxTQUFTQSxPQUFNLEdBQUcsNENBQTRDO0FBRTVFLGNBQUksSUFBSSxJQUFJLFlBQWEsTUFBTTtBQUUzQixtQkFBTyxVQUFVLFNBQVMsTUFBTUEsU0FBUSxJQUFJO0FBQUEsVUFDaEQ7QUFBQSxRQUNKO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUVBLGNBQWMsTUFBTTtBQUVoQixlQUFPLElBQUksU0FBUyxHQUFHLElBQUk7QUFBQSxNQUMvQjtBQUFBLE1BRUEsVUFBVSxZQUFZO0FBRWxCLGVBQU8sV0FBVyxZQUFZLFFBQVE7QUFFdEMsa0JBQVUsV0FBVztBQUVyQixlQUFPLFdBQVcsUUFBUSw0Q0FBNEM7QUFDdEUsYUFBSyxPQUFPLFlBQVksUUFBUSxVQUFVO0FBRTFDLGNBQU0sTUFBTSxPQUFPLE9BQU8sQ0FBQyxHQUFHLElBQUk7QUFDbEMsWUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLE1BQU07QUFFL0IsaUJBQVMsYUFBYSxZQUFZO0FBQzlCLGNBQUksT0FBTyxjQUFjLFlBQVk7QUFDakMsd0JBQVksVUFBVSxHQUFHO0FBQUEsVUFDN0I7QUFFQSxlQUFLLE9BQU8sV0FBVyxRQUFRLFNBQVM7QUFFeEMsZ0JBQU0sV0FBVyxVQUFVLGdCQUFnQixXQUFXLEdBQUc7QUFDekQscUJBQVcsUUFBUSxVQUFVO0FBQ3pCLG1CQUFPLElBQUksS0FBSyxJQUFJLE1BQU0sVUFBYSxJQUFJLE9BQU8sSUFBSSxLQUFLLElBQUksR0FBRyx3QkFBd0IsS0FBSyxJQUFJO0FBRW5HLGtCQUFNLE9BQU8sS0FBSyxRQUFRLEtBQUssSUFBSTtBQUNuQyxrQkFBTUEsVUFBUyxPQUFPLEtBQUssTUFBTSxJQUFJO0FBRXJDLGdCQUFJLE9BQU8sSUFBSSxLQUFLLElBQUk7QUFDeEIsZ0JBQUksS0FBSyxJQUFJLElBQUksWUFBYSxNQUFNO0FBRWhDLHFCQUFPLFVBQVUsU0FBUyxNQUFNQSxTQUFRLElBQUk7QUFBQSxZQUNoRDtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUVBLFNBQVMsT0FBTyxnQkFBZ0I7QUFBQSxNQUNoQyxjQUFjLFNBQVM7QUFBQSxNQUN2QixPQUFPLElBQUk7QUFBQSxNQUNYLFVBQVUsT0FBTztBQUFBLE1BRWpCLE1BQU0sTUFBTTtBQUVSLGVBQU8sSUFBSSxHQUFHLEdBQUcsSUFBSTtBQUFBLE1BQ3pCO0FBQUEsTUFFQSxVQUFVLE9BQU8sUUFBUTtBQUFBLE1BRXpCLE9BQU8sTUFBTTtBQUVULGVBQU8sSUFBSSxPQUFPLEdBQUcsSUFBSTtBQUFBLE1BQzdCO0FBQUEsTUFFQSxRQUFRO0FBRUosY0FBTSxRQUFRLENBQUM7QUFDZixtQkFBVyxRQUFRLEtBQUssUUFBUTtBQUM1QixnQkFBTSxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7QUFBQSxRQUM3QjtBQUVBLG1CQUFXLFVBQVUsVUFBVSxTQUFTO0FBQ3BDLGdCQUFNLE1BQU0sSUFBSSxLQUFLLE1BQU0sRUFBRTtBQUFBLFFBQ2pDO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBS0EsY0FBVSxTQUFTLFNBQVUsT0FBT0EsU0FBUSxVQUFVLE1BQWlDO0FBRW5GLFlBQU0sVUFBVSxLQUFLLENBQUMsYUFBYSxTQUFTLE9BQU8sS0FBSyxDQUFDLE1BQU0sV0FBVyxLQUFLLENBQUMsSUFBSTtBQUNwRixZQUFNLFVBQVUsWUFBWSxPQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQztBQUNuRCxZQUFNLFNBQVNBLFFBQU8sU0FBUyxPQUFPLE9BQU8sWUFBWSxFQUFFLFFBQVEsRUFBRSxPQUFPLEtBQUssRUFBRSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFFcEcsVUFBSSxRQUFRLE9BQU87QUFDbkIsVUFBSSxDQUFDLE9BQU87QUFDUixlQUFPLE9BQU87QUFBQSxNQUNsQjtBQUVBLFVBQUksbUJBQW1CLE9BQU87QUFDMUIsY0FBTTtBQUFBLE1BQ1Y7QUFFQSxZQUFNLFVBQVUsWUFBWSxPQUFPLE1BQU0sYUFBYSxhQUFhLE1BQU0sU0FBUyxJQUFJLE1BQU07QUFFNUYsVUFBSSxpQkFBaUIsT0FBTyxvQkFBb0IsT0FBTztBQUNuRCxnQkFBUSxNQUFNLEtBQUs7QUFBQSxNQUN2QjtBQUVBLFlBQU0sVUFBVSxVQUFVLEdBQUcsT0FBTyxJQUFJLE9BQU8sS0FBSztBQUNwRCxZQUFNO0FBQUEsSUFDVjtBQUdBLGNBQVUsV0FBVyxTQUFVLE1BQU1BLFNBQVEsTUFBTTtBQUUvQyxhQUFPLE1BQU0sb0NBQW9DO0FBRWpELE1BQUFBLFFBQU8sU0FBUztBQUVoQixVQUFJLENBQUNBLFFBQU8sWUFBWSxRQUNwQixDQUFDLEtBQUssUUFBUTtBQUVkLGVBQU9BO0FBQUEsTUFDWDtBQUVBLGFBQU9BLFFBQU8sWUFBWSxLQUFLQSxTQUFRLEdBQUcsSUFBSTtBQUFBLElBQ2xEO0FBR0EsY0FBVSxrQkFBa0IsU0FBVSxXQUFXLEtBQUs7QUFFbEQsVUFBSSxPQUFPLFVBQVUsU0FBUyxVQUFVO0FBQ3BDLGVBQU8sQ0FBQyxTQUFTO0FBQUEsTUFDckI7QUFFQSxZQUFNLFdBQVcsQ0FBQztBQUNsQixpQkFBVyxRQUFRLElBQUksUUFBUTtBQUMzQixZQUFJLFVBQVUsS0FBSyxLQUFLLElBQUksR0FBRztBQUMzQixnQkFBTSxPQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsU0FBUztBQUN4QyxlQUFLLE9BQU87QUFDWixlQUFLLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDdEIsbUJBQVMsS0FBSyxJQUFJO0FBQUEsUUFDdEI7QUFBQSxNQUNKO0FBRUEsYUFBTztBQUFBLElBQ1g7QUFHQSxXQUFPLFVBQVUsVUFBVSxLQUFLO0FBQUE7QUFBQTs7O0FDcFJoQyxTQUFTLHVCQUF1QixhQUFhLE1BQU07QUFDakQsUUFBTSxZQUFZLENBQUM7QUFDbkIsUUFBTSxXQUFXO0FBQ2pCLE1BQUksWUFBWSxTQUFTLEdBQUcsR0FBRztBQUM3QixjQUFVLEtBQUs7QUFBQSxNQUNiLFlBQVk7QUFBQSxNQUNaLGNBQWM7QUFBQSxRQUNaLGFBQWEseUJBQXlCLElBQUksS0FBSyxRQUFRO0FBQUEsTUFDekQ7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLFFBQ2Qsb0JBQW9CO0FBQUEsTUFDdEI7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBRUEsTUFBSSxZQUFZLFNBQVMsR0FBRyxHQUFHO0FBQzdCLGNBQVUsS0FBSztBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osY0FBYztBQUFBLFFBQ1osYUFBYSwwQkFBMEIsSUFBSSxLQUFLLFFBQVE7QUFBQSxNQUMxRDtBQUFBLE1BQ0EsZ0JBQWdCO0FBQUEsUUFDZCxvQkFBb0I7QUFBQSxNQUN0QjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFFQSxNQUFJLFlBQVksU0FBUyxHQUFHLEdBQUc7QUFDN0IsY0FBVSxLQUFLO0FBQUEsTUFDYixZQUFZO0FBQUEsTUFDWixjQUFjO0FBQUEsUUFDWixhQUFhLGtCQUFrQixJQUFJLEtBQUssUUFBUTtBQUFBLE1BQ2xEO0FBQUEsTUFDQSxnQkFBZ0I7QUFBQSxRQUNkLG9CQUFvQjtBQUFBLE1BQ3RCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUVBLE1BQUksWUFBWSxTQUFTLEdBQUcsR0FBRztBQUM3QixjQUFVLEtBQUs7QUFBQSxNQUNiLFlBQVk7QUFBQSxNQUNaLGNBQWM7QUFBQSxRQUNaLGFBQWEsMkJBQTJCLElBQUksS0FBSyxRQUFRO0FBQUEsTUFDM0Q7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLFFBQ2Qsb0JBQW9CO0FBQUEsTUFDdEI7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBRUEsTUFBSSxZQUFZLFNBQVMsR0FBRyxHQUFHO0FBQzdCLGNBQVUsS0FBSztBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osY0FBYztBQUFBLFFBQ1osYUFBYSxxQkFBcUIsSUFBSSxLQUFLLFFBQVE7QUFBQSxNQUNyRDtBQUFBLE1BQ0EsZ0JBQWdCO0FBQUEsUUFDZCxvQkFBb0I7QUFBQSxNQUN0QjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFFQSxNQUFJLFlBQVksU0FBUyxHQUFHLEdBQUc7QUFDN0IsY0FBVSxLQUFLO0FBQUEsTUFDYixZQUFZO0FBQUEsTUFDWixjQUFjO0FBQUEsUUFDWixhQUFhLHVCQUF1QixJQUFJLEtBQUssUUFBUTtBQUFBLE1BQ3ZEO0FBQUEsTUFDQSxnQkFBZ0I7QUFBQSxRQUNkLG9CQUFvQjtBQUFBLE1BQ3RCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUVBLFNBQU87QUFDVDtBQTVFUzs7O0FDTlQsa0JBQW9CO0FBQ3BCLGlCQUFvQjtBQUdwQixJQUFNLE1BQU0sV0FBQUMsUUFBUSxPQUFPLFlBQUFDLE9BQU87OztBQ0RsQyxJQUFNLGdCQUFnQjtBQUFBLEVBQ3BCLFNBQVM7QUFBQSxFQUNULE1BQU0sQ0FBQyxtQkFBbUI7QUFBQSxFQUMxQixhQUFhO0FBQUEsRUFDYixpQkFBaUI7QUFBQSxJQUNmO0FBQUEsTUFDRSxZQUFZO0FBQUEsTUFDWixjQUFjO0FBQUEsUUFDWixhQUFhO0FBQUEsTUFDZjtBQUFBLE1BQ0EsZ0JBQWdCO0FBQUEsUUFDZCxvQkFBb0I7QUFBQSxNQUN0QjtBQUFBLElBQ0Y7QUFBQSxJQUNBLEdBQUcsdUJBQXVCLENBQUMsS0FBSyxLQUFLLEtBQUssR0FBRyxHQUFHLGlCQUFpQjtBQUFBLEVBQ25FO0FBQ0Y7QUFFQSxJQUFNLFNBQVM7QUFBQSxFQUNiLFVBQVUsSUFBSSxPQUFPO0FBQUEsSUFDbkIsUUFBUSxJQUFJLFFBQVEsRUFBRSxTQUFTO0FBQUEsRUFDakMsQ0FBQztBQUNIO0FBRUEsSUFBTSxVQUFVLG1DQUFZO0FBQzFCLFNBQU87QUFBQSxJQUNMLFlBQVk7QUFBQSxJQUNaLE1BQU0sS0FBSyxVQUFVO0FBQUEsTUFDbkIsUUFBUTtBQUFBLElBQ1YsQ0FBQztBQUFBLEVBQ0g7QUFDRixHQVBnQjsiLAogICJuYW1lcyI6IFsiZm9ybWF0IiwgImxvY2FsZSIsICJ0byIsICJmcm9tIiwgIm5vdyIsICJzaWduIiwgInRva2VuIiwgIm9yZGluYWwiLCAiaSIsICJkaWZmIiwgImxvY2FsZURhdGEiLCAiaG91cnMiLCAibWludXRlcyIsICJ0b2tlbnMiLCAibWVyaWRpZW0iLCAieWVhcnMiLCAibW9udGhzIiwgIndlZWtzIiwgImRheXMiLCAic2Vjb25kcyIsICJtaWxsaXNlY29uZHMiLCAib2Zmc2V0IiwgInRocmVzaG9sZHMiLCAic2NoZW1hIiwgIkpvaSIsICJyZXF1aXJlX2xpYiIsICJtZXNzYWdlIiwgInNjaGVtYSIsICJKb2kiLCAic2NoZW1hIiwgInJ1bGUiLCAic2NoZW1hIiwgInNjaGVtYSIsICJyZXF1aXJlX2xpYiIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgImlkIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9saWIiLCAic2NoZW1hIiwgImNsb25lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9lcnJvcnMiLCAic2NoZW1lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInJlcXVpcmVfbGliIiwgInNjaGVtYSIsICJKb2lCYXNlIiwgIkpvaURhdGUiXQp9Cg==
