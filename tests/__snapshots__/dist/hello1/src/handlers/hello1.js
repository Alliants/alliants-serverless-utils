import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../node_modules/source-map/lib/base64.js"(exports) {
    init_register();
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../node_modules/source-map/lib/base64-vlq.js"(exports) {
    init_register();
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    __name(toVLQSigned, "toVLQSigned");
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    __name(fromVLQSigned, "fromVLQSigned");
    exports.encode = /* @__PURE__ */ __name(function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    }, "base64VLQ_encode");
    exports.decode = /* @__PURE__ */ __name(function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    }, "base64VLQ_decode");
  }
});

// ../node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../node_modules/source-map/lib/util.js"(exports) {
    init_register();
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    __name(getArg, "getArg");
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    __name(urlParse, "urlParse");
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    __name(urlGenerate, "urlGenerate");
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    __name(normalize, "normalize");
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    __name(join, "join");
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    __name(relative, "relative");
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    __name(identity, "identity");
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    __name(toSetString, "toSetString");
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    __name(fromSetString, "fromSetString");
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    __name(isProtoString, "isProtoString");
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByOriginalPositions, "compareByOriginalPositions");
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated");
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    __name(strcmp, "strcmp");
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated");
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    __name(parseSourceMapInput, "parseSourceMapInput");
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    __name(computeSourceURL, "computeSourceURL");
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../node_modules/source-map/lib/array-set.js"(exports) {
    init_register();
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    __name(ArraySet, "ArraySet");
    ArraySet.fromArray = /* @__PURE__ */ __name(function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    }, "ArraySet_fromArray");
    ArraySet.prototype.size = /* @__PURE__ */ __name(function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    }, "ArraySet_size");
    ArraySet.prototype.add = /* @__PURE__ */ __name(function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    }, "ArraySet_add");
    ArraySet.prototype.has = /* @__PURE__ */ __name(function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    }, "ArraySet_has");
    ArraySet.prototype.indexOf = /* @__PURE__ */ __name(function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    }, "ArraySet_indexOf");
    ArraySet.prototype.at = /* @__PURE__ */ __name(function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    }, "ArraySet_at");
    ArraySet.prototype.toArray = /* @__PURE__ */ __name(function ArraySet_toArray() {
      return this._array.slice();
    }, "ArraySet_toArray");
    exports.ArraySet = ArraySet;
  }
});

// ../node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../node_modules/source-map/lib/mapping-list.js"(exports) {
    init_register();
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    __name(generatedPositionAfter, "generatedPositionAfter");
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    __name(MappingList, "MappingList");
    MappingList.prototype.unsortedForEach = /* @__PURE__ */ __name(function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    }, "MappingList_forEach");
    MappingList.prototype.add = /* @__PURE__ */ __name(function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    }, "MappingList_add");
    MappingList.prototype.toArray = /* @__PURE__ */ __name(function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    }, "MappingList_toArray");
    exports.MappingList = MappingList;
  }
});

// ../node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../node_modules/source-map/lib/source-map-generator.js"(exports) {
    init_register();
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    __name(SourceMapGenerator, "SourceMapGenerator");
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = /* @__PURE__ */ __name(function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    }, "SourceMapGenerator_fromSourceMap");
    SourceMapGenerator.prototype.addMapping = /* @__PURE__ */ __name(function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    }, "SourceMapGenerator_addMapping");
    SourceMapGenerator.prototype.setSourceContent = /* @__PURE__ */ __name(function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    }, "SourceMapGenerator_setSourceContent");
    SourceMapGenerator.prototype.applySourceMap = /* @__PURE__ */ __name(function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    }, "SourceMapGenerator_applySourceMap");
    SourceMapGenerator.prototype._validateMapping = /* @__PURE__ */ __name(function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    }, "SourceMapGenerator_validateMapping");
    SourceMapGenerator.prototype._serializeMappings = /* @__PURE__ */ __name(function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    }, "SourceMapGenerator_serializeMappings");
    SourceMapGenerator.prototype._generateSourcesContent = /* @__PURE__ */ __name(function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    }, "SourceMapGenerator_generateSourcesContent");
    SourceMapGenerator.prototype.toJSON = /* @__PURE__ */ __name(function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    }, "SourceMapGenerator_toJSON");
    SourceMapGenerator.prototype.toString = /* @__PURE__ */ __name(function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    }, "SourceMapGenerator_toString");
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../node_modules/source-map/lib/binary-search.js"(exports) {
    init_register();
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    __name(recursiveSearch, "recursiveSearch");
    exports.search = /* @__PURE__ */ __name(function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    }, "search");
  }
});

// ../node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../node_modules/source-map/lib/quick-sort.js"(exports) {
    init_register();
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    __name(swap, "swap");
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    __name(randomIntInRange, "randomIntInRange");
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    __name(doQuickSort, "doQuickSort");
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../node_modules/source-map/lib/source-map-consumer.js"(exports) {
    init_register();
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    __name(SourceMapConsumer, "SourceMapConsumer");
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = /* @__PURE__ */ __name(function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    }, "SourceMapConsumer_charIsMappingSeparator");
    SourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    }, "SourceMapConsumer_parseMappings");
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = /* @__PURE__ */ __name(function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    }, "SourceMapConsumer_eachMapping");
    SourceMapConsumer.prototype.allGeneratedPositionsFor = /* @__PURE__ */ __name(function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    }, "SourceMapConsumer_allGeneratedPositionsFor");
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    __name(BasicSourceMapConsumer, "BasicSourceMapConsumer");
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = /* @__PURE__ */ __name(function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    }, "SourceMapConsumer_fromSourceMap");
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    __name(Mapping, "Mapping");
    BasicSourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    }, "SourceMapConsumer_parseMappings");
    BasicSourceMapConsumer.prototype._findMapping = /* @__PURE__ */ __name(function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    }, "SourceMapConsumer_findMapping");
    BasicSourceMapConsumer.prototype.computeColumnSpans = /* @__PURE__ */ __name(function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    }, "SourceMapConsumer_computeColumnSpans");
    BasicSourceMapConsumer.prototype.originalPositionFor = /* @__PURE__ */ __name(function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }, "SourceMapConsumer_originalPositionFor");
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = /* @__PURE__ */ __name(function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    }, "BasicSourceMapConsumer_hasContentsOfAllSources");
    BasicSourceMapConsumer.prototype.sourceContentFor = /* @__PURE__ */ __name(function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    }, "SourceMapConsumer_sourceContentFor");
    BasicSourceMapConsumer.prototype.generatedPositionFor = /* @__PURE__ */ __name(function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }, "SourceMapConsumer_generatedPositionFor");
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    __name(IndexedSourceMapConsumer, "IndexedSourceMapConsumer");
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    }, "IndexedSourceMapConsumer_originalPositionFor");
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    }, "IndexedSourceMapConsumer_hasContentsOfAllSources");
    IndexedSourceMapConsumer.prototype.sourceContentFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    }, "IndexedSourceMapConsumer_sourceContentFor");
    IndexedSourceMapConsumer.prototype.generatedPositionFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    }, "IndexedSourceMapConsumer_generatedPositionFor");
    IndexedSourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    }, "IndexedSourceMapConsumer_parseMappings");
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../node_modules/source-map/lib/source-node.js"(exports) {
    init_register();
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    __name(SourceNode, "SourceNode");
    SourceNode.fromStringWithSourceMap = /* @__PURE__ */ __name(function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = /* @__PURE__ */ __name(function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
        __name(getNextLine, "getNextLine");
      }, "shiftNextLine");
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
      __name(addMappingWithCode, "addMappingWithCode");
    }, "SourceNode_fromStringWithSourceMap");
    SourceNode.prototype.add = /* @__PURE__ */ __name(function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    }, "SourceNode_add");
    SourceNode.prototype.prepend = /* @__PURE__ */ __name(function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    }, "SourceNode_prepend");
    SourceNode.prototype.walk = /* @__PURE__ */ __name(function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    }, "SourceNode_walk");
    SourceNode.prototype.join = /* @__PURE__ */ __name(function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    }, "SourceNode_join");
    SourceNode.prototype.replaceRight = /* @__PURE__ */ __name(function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    }, "SourceNode_replaceRight");
    SourceNode.prototype.setSourceContent = /* @__PURE__ */ __name(function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    }, "SourceNode_setSourceContent");
    SourceNode.prototype.walkSourceContents = /* @__PURE__ */ __name(function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    }, "SourceNode_walkSourceContents");
    SourceNode.prototype.toString = /* @__PURE__ */ __name(function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    }, "SourceNode_toString");
    SourceNode.prototype.toStringWithSourceMap = /* @__PURE__ */ __name(function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    }, "SourceNode_toStringWithSourceMap");
    exports.SourceNode = SourceNode;
  }
});

// ../node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../node_modules/source-map/source-map.js"(exports) {
    init_register();
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// ../node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "../node_modules/buffer-from/index.js"(exports, module) {
    init_register();
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    __name(isArrayBuffer, "isArrayBuffer");
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    __name(fromString, "fromString");
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    __name(bufferFrom, "bufferFrom");
    module.exports = bufferFrom;
  }
});

// ../node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "../node_modules/source-map-support/source-map-support.js"(exports, module) {
    init_register();
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var path = __require("path");
    var fs;
    try {
      fs = __require("fs");
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    __name(dynamicRequire, "dynamicRequire");
    var errorFormatterInstalled = false;
    var uncaughtShimInstalled = false;
    var emptyCacheBetweenOperations = false;
    var environment = "auto";
    var fileContentsCache = {};
    var sourceMapCache = {};
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    var retrieveFileHandlers = [];
    var retrieveMapHandlers = [];
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    __name(isInBrowser, "isInBrowser");
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    __name(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter");
    function globalProcessVersion() {
      if (typeof process === "object" && process !== null) {
        return process.version;
      } else {
        return "";
      }
    }
    __name(globalProcessVersion, "globalProcessVersion");
    function globalProcessStderr() {
      if (typeof process === "object" && process !== null) {
        return process.stderr;
      }
    }
    __name(globalProcessStderr, "globalProcessStderr");
    function globalProcessExit(code) {
      if (typeof process === "object" && process !== null && typeof process.exit === "function") {
        return process.exit(code);
      }
    }
    __name(globalProcessExit, "globalProcessExit");
    function handlerExec(list) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    __name(handlerExec, "handlerExec");
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      path2 = path2.trim();
      if (/^file:/.test(path2)) {
        path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : (
            // file:///C:/dir/file -> C:/dir/file
            "/"
          );
        });
      }
      if (path2 in fileContentsCache) {
        return fileContentsCache[path2];
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            false
          );
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path2)) {
          contents = fs.readFileSync(path2, "utf8");
        }
      } catch (er) {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      var dir = path.dirname(file);
      var match = /^\w+:\/\/[^\/]*/.exec(dir);
      var protocol = match ? match[0] : "";
      var startPath = dir.slice(protocol.length);
      if (protocol && /^\/\w\:/.test(startPath)) {
        protocol += "/";
        return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/");
      }
      return protocol + path.resolve(dir.slice(protocol.length), url);
    }
    __name(supportRelativeURL, "supportRelativeURL");
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(source);
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match;
      while (match = re.exec(fileData))
        lastMatch = match;
      if (!lastMatch)
        return null;
      return lastMatch[1];
    }
    __name(retrieveSourceMapURL, "retrieveSourceMapURL");
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          };
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.sources.forEach(function(source, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                var url = supportRelativeURL(sourceMap.url, source);
                fileContentsCache[url] = contents;
              }
            });
          }
        } else {
          sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
        }
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null) {
          originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          );
          return originalPosition;
        }
      }
      return position;
    }
    __name(mapSourcePosition, "mapSourcePosition");
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match) {
        return "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")";
      }
      return origin;
    }
    __name(mapEvalOrigin, "mapEvalOrigin");
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    __name(CallSiteToString, "CallSiteToString");
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    __name(cloneCallSite, "cloneCallSite");
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    __name(wrapCallSite, "wrapCallSite");
    function prepareStackTrace(error, stack) {
      if (emptyCacheBetweenOperations) {
        fileContentsCache = {};
        sourceMapCache = {};
      }
      var name = error.name || "Error";
      var message = error.message || "";
      var errorString = name + ": " + message;
      var state = { nextPosition: null, curPosition: null };
      var processedStack = [];
      for (var i = stack.length - 1; i >= 0; i--) {
        processedStack.push("\n    at " + wrapCallSite(stack[i], state));
        state.nextPosition = state.curPosition;
      }
      state.curPosition = state.nextPosition = null;
      return errorString + processedStack.reverse().join("");
    }
    __name(prepareStackTrace, "prepareStackTrace");
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1];
        var line = +match[2];
        var column = +match[3];
        var contents = fileContentsCache[source];
        if (!contents && fs && fs.existsSync(source)) {
          try {
            contents = fs.readFileSync(source, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    __name(getErrorSource, "getErrorSource");
    function printErrorAndExit(error) {
      var source = getErrorSource(error);
      var stderr = globalProcessStderr();
      if (stderr && stderr._handle && stderr._handle.setBlocking) {
        stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error();
        console.error(source);
      }
      console.error(error.stack);
      globalProcessExit(1);
    }
    __name(printErrorAndExit, "printErrorAndExit");
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack;
          var hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners) {
            return printErrorAndExit(arguments[1]);
          }
        }
        return origEmit.apply(this, arguments);
      };
    }
    __name(shimEmitUncaughtException, "shimEmitUncaughtException");
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          retrieveFileHandlers.length = 0;
        }
        retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          retrieveMapHandlers.length = 0;
        }
        retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module, "module");
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            fileContentsCache[filename] = content;
            sourceMapCache[filename] = void 0;
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!emptyCacheBetweenOperations) {
        emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!errorFormatterInstalled) {
        errorFormatterInstalled = true;
        Error.prepareStackTrace = prepareStackTrace;
      }
      if (!uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          uncaughtShimInstalled = true;
          shimEmitUncaughtException();
        }
      }
    };
    exports.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0;
      retrieveMapHandlers.length = 0;
      retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
      retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);
      retrieveSourceMap = handlerExec(retrieveMapHandlers);
      retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// ../node_modules/source-map-support/register.js
var init_register = __esm({
  "../node_modules/source-map-support/register.js"() {
    require_source_map_support().install();
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module) {
    init_register();
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      __name(hooks, "hooks");
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      __name(setHookCallback, "setHookCallback");
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      __name(isArray, "isArray");
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      __name(isObject, "isObject");
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      __name(hasOwnProp, "hasOwnProp");
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      __name(isObjectEmpty, "isObjectEmpty");
      function isUndefined(input) {
        return input === void 0;
      }
      __name(isUndefined, "isUndefined");
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      __name(isNumber, "isNumber");
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      __name(isDate, "isDate");
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      __name(map, "map");
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      __name(extend, "extend");
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      __name(createUTC, "createUTC");
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      __name(defaultParsingFlags, "defaultParsingFlags");
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      __name(getParsingFlags, "getParsingFlags");
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = /* @__PURE__ */ __name(function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        }, "some");
      }
      function isValid(m) {
        var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m);
          parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m._isValid;
      }
      __name(isValid, "isValid");
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      __name(createInvalid, "createInvalid");
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      __name(copyConfig, "copyConfig");
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      __name(Moment, "Moment");
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      __name(isMoment, "isMoment");
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      __name(warn, "warn");
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      __name(deprecate, "deprecate");
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      __name(deprecateSimple, "deprecateSimple");
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      __name(isFunction, "isFunction");
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      __name(set, "set");
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      __name(mergeConfigs, "mergeConfigs");
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      __name(Locale, "Locale");
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = /* @__PURE__ */ __name(function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        }, "keys");
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      __name(calendar, "calendar");
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      __name(zeroFill, "zeroFill");
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = /* @__PURE__ */ __name(function() {
            return this[callback]();
          }, "func");
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      __name(addFormatToken, "addFormatToken");
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      __name(removeFormattingTokens, "removeFormattingTokens");
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      __name(makeFormatFunction, "makeFormatFunction");
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      __name(formatMoment, "formatMoment");
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        __name(replaceLongDateFormatTokens, "replaceLongDateFormatTokens");
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      __name(expandFormat, "expandFormat");
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      __name(longDateFormat, "longDateFormat");
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      __name(invalidDate, "invalidDate");
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      __name(ordinal, "ordinal");
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      __name(relativeTime, "relativeTime");
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      __name(pastFuture, "pastFuture");
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      __name(normalizeUnits, "normalizeUnits");
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      __name(normalizeObjectUnits, "normalizeObjectUnits");
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      __name(getPrioritizedUnits, "getPrioritizedUnits");
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      __name(addRegexToken, "addRegexToken");
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      __name(getParseRegexForToken, "getParseRegexForToken");
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      __name(unescapeFormat, "unescapeFormat");
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      __name(regexEscape, "regexEscape");
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      __name(absFloor, "absFloor");
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      __name(toInt, "toInt");
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = /* @__PURE__ */ __name(function(input, array) {
            array[callback] = toInt(input);
          }, "func");
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      __name(addParseToken, "addParseToken");
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      __name(addWeekParseToken, "addWeekParseToken");
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      __name(addTimeToArrayFromToken, "addTimeToArrayFromToken");
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      __name(isLeapYear, "isLeapYear");
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      __name(daysInYear, "daysInYear");
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      __name(getIsLeapYear, "getIsLeapYear");
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      __name(makeGetSet, "makeGetSet");
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case "Seconds":
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case "Minutes":
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case "Hours":
            return isUTC ? d.getUTCHours() : d.getHours();
          case "Date":
            return isUTC ? d.getUTCDate() : d.getDate();
          case "Day":
            return isUTC ? d.getUTCDay() : d.getDay();
          case "Month":
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case "FullYear":
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
        }
      }
      __name(get, "get");
      function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case "Hours":
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case "Date":
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          case "FullYear":
            break;
          default:
            return;
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
      }
      __name(set$1, "set$1");
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      __name(stringGet, "stringGet");
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      __name(stringSet, "stringSet");
      function mod(n, x) {
        return (n % x + x) % x;
      }
      __name(mod, "mod");
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = /* @__PURE__ */ __name(function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        }, "indexOf");
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      __name(daysInMonth, "daysInMonth");
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonths, "localeMonths");
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonthsShort, "localeMonthsShort");
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse, "handleStrictParse");
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      __name(localeMonthsParse, "localeMonthsParse");
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        var month = value, date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      __name(setMonth, "setMonth");
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      __name(getSetMonth, "getSetMonth");
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      __name(getDaysInMonth, "getDaysInMonth");
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      __name(monthsShortRegex, "monthsShortRegex");
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      __name(monthsRegex, "monthsRegex");
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeMonthsParse, "computeMonthsParse");
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      __name(createDate, "createDate");
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      __name(createUTCDate, "createUTCDate");
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      __name(firstWeekOffset, "firstWeekOffset");
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      __name(dayOfYearFromWeeks, "dayOfYearFromWeeks");
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      __name(weekOfYear, "weekOfYear");
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      __name(weeksInYear, "weeksInYear");
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      __name(localeWeek, "localeWeek");
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      __name(localeFirstDayOfWeek, "localeFirstDayOfWeek");
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      __name(localeFirstDayOfYear, "localeFirstDayOfYear");
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetWeek, "getSetWeek");
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetISOWeek, "getSetISOWeek");
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      __name(parseWeekday, "parseWeekday");
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      __name(parseIsoWeekday, "parseIsoWeekday");
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      __name(shiftWeekdays, "shiftWeekdays");
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      __name(localeWeekdays, "localeWeekdays");
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      __name(localeWeekdaysShort, "localeWeekdaysShort");
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      __name(localeWeekdaysMin, "localeWeekdaysMin");
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse$1, "handleStrictParse$1");
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      __name(localeWeekdaysParse, "localeWeekdaysParse");
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      __name(getSetDayOfWeek, "getSetDayOfWeek");
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      __name(getSetLocaleDayOfWeek, "getSetLocaleDayOfWeek");
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      __name(getSetISODayOfWeek, "getSetISODayOfWeek");
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      __name(weekdaysRegex, "weekdaysRegex");
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      __name(weekdaysShortRegex, "weekdaysShortRegex");
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      __name(weekdaysMinRegex, "weekdaysMinRegex");
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeWeekdaysParse, "computeWeekdaysParse");
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      __name(hFormat, "hFormat");
      function kFormat() {
        return this.hours() || 24;
      }
      __name(kFormat, "kFormat");
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      __name(meridiem, "meridiem");
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      __name(matchMeridiem, "matchMeridiem");
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      __name(localeIsPM, "localeIsPM");
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      __name(localeMeridiem, "localeMeridiem");
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      __name(commonPrefix, "commonPrefix");
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      __name(normalizeLocale, "normalizeLocale");
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      __name(chooseLocale, "chooseLocale");
      function isLocaleNameSane(name) {
        return !!(name && name.match("^[^/\\\\]*$"));
      }
      __name(isLocaleNameSane, "isLocaleNameSane");
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = __require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      __name(loadLocale, "loadLocale");
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      __name(getSetGlobalLocale, "getSetGlobalLocale");
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      __name(defineLocale, "defineLocale");
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      __name(updateLocale, "updateLocale");
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      __name(getLocale, "getLocale");
      function listLocales() {
        return keys(locales);
      }
      __name(listLocales, "listLocales");
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      __name(checkOverflow, "checkOverflow");
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      __name(configFromISO, "configFromISO");
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      __name(extractFromRFC2822Strings, "extractFromRFC2822Strings");
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      __name(untruncateYear, "untruncateYear");
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      __name(preprocessRFC2822, "preprocessRFC2822");
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      __name(checkWeekday, "checkWeekday");
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      __name(calculateOffset, "calculateOffset");
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      __name(configFromRFC2822, "configFromRFC2822");
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromString, "configFromString");
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      __name(defaults, "defaults");
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      __name(currentDateArray, "currentDateArray");
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      __name(configFromArray, "configFromArray");
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      __name(dayOfYearFromWeekInfo, "dayOfYearFromWeekInfo");
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      __name(configFromStringAndFormat, "configFromStringAndFormat");
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      __name(meridiemFixWrap, "meridiemFixWrap");
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      __name(configFromStringAndArray, "configFromStringAndArray");
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      __name(configFromObject, "configFromObject");
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      __name(createFromConfig, "createFromConfig");
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      __name(prepareConfig, "prepareConfig");
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromInput, "configFromInput");
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      __name(createLocalOrUTC, "createLocalOrUTC");
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      __name(createLocal, "createLocal");
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      __name(pickBy, "pickBy");
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      __name(min, "min");
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      __name(max, "max");
      var now = /* @__PURE__ */ __name(function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      }, "now");
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      __name(isDurationValid, "isDurationValid");
      function isValid$1() {
        return this._isValid;
      }
      __name(isValid$1, "isValid$1");
      function createInvalid$1() {
        return createDuration(NaN);
      }
      __name(createInvalid$1, "createInvalid$1");
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      __name(Duration, "Duration");
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      __name(isDuration, "isDuration");
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      __name(absRound, "absRound");
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      __name(compareArrays, "compareArrays");
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      __name(offset, "offset");
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      __name(offsetFromString, "offsetFromString");
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      __name(cloneWithOffset, "cloneWithOffset");
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      __name(getDateOffset, "getDateOffset");
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      __name(getSetOffset, "getSetOffset");
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      __name(getSetZone, "getSetZone");
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      __name(setOffsetToUTC, "setOffsetToUTC");
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      __name(setOffsetToLocal, "setOffsetToLocal");
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      __name(setOffsetToParsedOffset, "setOffsetToParsedOffset");
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      __name(hasAlignedHourOffset, "hasAlignedHourOffset");
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      __name(isDaylightSavingTime, "isDaylightSavingTime");
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      __name(isDaylightSavingTimeShifted, "isDaylightSavingTimeShifted");
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      __name(isLocal, "isLocal");
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      __name(isUtcOffset, "isUtcOffset");
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      __name(isUtc, "isUtc");
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      __name(createDuration, "createDuration");
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      __name(parseIso, "parseIso");
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      __name(positiveMomentsDifference, "positiveMomentsDifference");
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      __name(momentsDifference, "momentsDifference");
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      __name(createAdder, "createAdder");
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      __name(addSubtract, "addSubtract");
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      __name(isString, "isString");
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      __name(isMomentInput, "isMomentInput");
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isMomentInputObject, "isMomentInputObject");
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      __name(isNumberOrStringArray, "isNumberOrStringArray");
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isCalendarSpec, "isCalendarSpec");
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      __name(getCalendarFormat, "getCalendarFormat");
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      __name(calendar$1, "calendar$1");
      function clone() {
        return new Moment(this);
      }
      __name(clone, "clone");
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      __name(isAfter, "isAfter");
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      __name(isBefore, "isBefore");
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      __name(isBetween, "isBetween");
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      __name(isSame, "isSame");
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      __name(isSameOrAfter, "isSameOrAfter");
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      __name(isSameOrBefore, "isSameOrBefore");
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      __name(diff, "diff");
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      __name(monthDiff, "monthDiff");
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      __name(toString, "toString");
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      __name(toISOString, "toISOString");
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      __name(inspect, "inspect");
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      __name(format, "format");
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(from, "from");
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      __name(fromNow, "fromNow");
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(to, "to");
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      __name(toNow, "toNow");
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      __name(locale, "locale");
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      __name(localeData, "localeData");
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      __name(mod$1, "mod$1");
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      __name(localStartOfDate, "localStartOfDate");
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      __name(utcStartOfDate, "utcStartOfDate");
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(startOf, "startOf");
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(endOf, "endOf");
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      __name(valueOf, "valueOf");
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      __name(unix, "unix");
      function toDate() {
        return new Date(this.valueOf());
      }
      __name(toDate, "toDate");
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      __name(toArray, "toArray");
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      __name(toObject, "toObject");
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      __name(toJSON, "toJSON");
      function isValid$2() {
        return isValid(this);
      }
      __name(isValid$2, "isValid$2");
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      __name(parsingFlags, "parsingFlags");
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      __name(invalidAt, "invalidAt");
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      __name(creationData, "creationData");
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      __name(localeEras, "localeEras");
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      __name(localeErasParse, "localeErasParse");
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      __name(localeErasConvertYear, "localeErasConvertYear");
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      __name(getEraName, "getEraName");
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      __name(getEraNarrow, "getEraNarrow");
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      __name(getEraAbbr, "getEraAbbr");
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      __name(getEraYear, "getEraYear");
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      __name(erasNameRegex, "erasNameRegex");
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      __name(erasAbbrRegex, "erasAbbrRegex");
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      __name(erasNarrowRegex, "erasNarrowRegex");
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      __name(matchEraAbbr, "matchEraAbbr");
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      __name(matchEraName, "matchEraName");
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      __name(matchEraNarrow, "matchEraNarrow");
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      __name(matchEraYearOrdinal, "matchEraYearOrdinal");
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeErasParse, "computeErasParse");
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      __name(addWeekYearFormatToken, "addWeekYearFormatToken");
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      __name(getSetWeekYear, "getSetWeekYear");
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      __name(getSetISOWeekYear, "getSetISOWeekYear");
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      __name(getISOWeeksInYear, "getISOWeeksInYear");
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      __name(getISOWeeksInISOWeekYear, "getISOWeeksInISOWeekYear");
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInYear, "getWeeksInYear");
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInWeekYear, "getWeeksInWeekYear");
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      __name(getSetWeekYearHelper, "getSetWeekYearHelper");
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      __name(setWeekAll, "setWeekAll");
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      __name(getSetQuarter, "getSetQuarter");
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      __name(getSetDayOfYear, "getSetDayOfYear");
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      __name(parseMs, "parseMs");
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      __name(getZoneAbbr, "getZoneAbbr");
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      __name(getZoneName, "getZoneName");
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      __name(createUnix, "createUnix");
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      __name(createInZone, "createInZone");
      function preParsePostFormat(string) {
        return string;
      }
      __name(preParsePostFormat, "preParsePostFormat");
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      __name(get$1, "get$1");
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      __name(listMonthsImpl, "listMonthsImpl");
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      __name(listWeekdaysImpl, "listWeekdaysImpl");
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      __name(listMonths, "listMonths");
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      __name(listMonthsShort, "listMonthsShort");
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      __name(listWeekdays, "listWeekdays");
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      __name(listWeekdaysShort, "listWeekdaysShort");
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      __name(listWeekdaysMin, "listWeekdaysMin");
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      __name(abs, "abs");
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      __name(addSubtract$1, "addSubtract$1");
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      __name(add$1, "add$1");
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      __name(subtract$1, "subtract$1");
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      __name(absCeil, "absCeil");
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      __name(bubble, "bubble");
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      __name(daysToMonths, "daysToMonths");
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      __name(monthsToDays, "monthsToDays");
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      __name(as, "as");
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      __name(makeAs, "makeAs");
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      __name(clone$1, "clone$1");
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      __name(get$2, "get$2");
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      __name(makeGetter, "makeGetter");
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      __name(weeks, "weeks");
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      __name(substituteTimeAgo, "substituteTimeAgo");
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      __name(relativeTime$1, "relativeTime$1");
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      __name(getSetRelativeTimeRounding, "getSetRelativeTimeRounding");
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      __name(getSetRelativeTimeThreshold, "getSetRelativeTimeThreshold");
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      __name(humanize, "humanize");
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      __name(sign, "sign");
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      __name(toISOString$1, "toISOString$1");
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/@joi/date/lib/index.js
var require_lib = __commonJS({
  "node_modules/@joi/date/lib/index.js"(exports, module) {
    "use strict";
    init_register();
    var Moment = require_moment();
    module.exports = (joi) => {
      const args = {
        format: joi.alternatives([
          joi.string(),
          joi.array().items(joi.string().invalid("iso", "javascript", "unix"))
        ])
      };
      return {
        type: "date",
        base: joi.date(),
        coerce: {
          from: "string",
          method: function(value, { schema: schema2 }) {
            const format = schema2.$_getFlag("format");
            if (!format) {
              return;
            }
            const date = schema2.$_getFlag("utc") ? Moment.utc(value, format, true) : Moment(value, format, true);
            if (date.isValid()) {
              return { value: date.toDate() };
            }
          }
        },
        rules: {
          utc: {
            method: function(enabled = true) {
              return this.$_setFlag("utc", enabled);
            }
          }
        },
        overrides: {
          format: function(format) {
            joi.attempt(format, args.format, "Invalid format");
            if (["iso", "javascript", "unix"].includes(format)) {
              return this.$_super.format(format);
            }
            return this.$_setFlag("format", format);
          }
        }
      };
    };
    module.exports.default = module.exports;
  }
});

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@hapi/hoek/lib/stringify.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/error.js
var require_error = __commonJS({
  "node_modules/@hapi/hoek/lib/error.js"(exports, module) {
    "use strict";
    init_register();
    var Stringify = require_stringify();
    module.exports = class extends Error {
      constructor(args) {
        const msgs = args.filter((arg) => arg !== "").map((arg) => {
          return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });
        super(msgs.join(" ") || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, exports.assert);
        }
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS({
  "node_modules/@hapi/hoek/lib/assert.js"(exports, module) {
    "use strict";
    init_register();
    var AssertError = require_error();
    module.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      throw new AssertError(args);
    };
  }
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS({
  "node_modules/@hapi/hoek/lib/reach.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var internals = {};
    module.exports = function(obj, chain, options) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number = Number(key);
          if (Number.isInteger(number)) {
            key = number < 0 ? ref.length + number : number;
          }
        }
        if (!ref || typeof ref === "function" && options.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS({
  "node_modules/@hapi/hoek/lib/types.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    exports = module.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports.error],
      ["[object Map]", exports.map],
      ["[object Promise]", exports.promise],
      ["[object Set]", exports.set],
      ["[object WeakMap]", exports.weakMap],
      ["[object WeakSet]", exports.weakSet]
    ]);
    exports.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports.buffer;
      }
      if (obj instanceof Date) {
        return exports.date;
      }
      if (obj instanceof RegExp) {
        return exports.regex;
      }
      if (obj instanceof Error) {
        return exports.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports.generic;
    };
  }
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@hapi/hoek/lib/utils.js"(exports) {
    "use strict";
    init_register();
    exports.keys = function(obj, options = {}) {
      return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS({
  "node_modules/@hapi/hoek/lib/clone.js"(exports, module) {
    "use strict";
    init_register();
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
    };
    module.exports = internals.clone = function(obj, options = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone = internals.clone;
      let seen = _seen;
      if (options.shallow) {
        if (options.shallow !== true) {
          return internals.cloneWithShallow(obj, options);
        }
        clone = /* @__PURE__ */ __name((value) => value, "clone");
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);
      }
      if (baseProto === Types.date) {
        return new Date(obj.getTime());
      }
      if (baseProto === Types.regex) {
        return new RegExp(obj);
      }
      const newObj = internals.base(obj, baseProto, options);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone(value, options, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone(value, options, seen));
        }
      }
      const keys = Utils.keys(obj, options);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone(obj[key], options, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone(obj[key], options, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options) {
      const keys = options.shallow;
      options = Object.assign({}, options);
      options.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options, seen);
    };
    internals.base = function(obj, baseProto, options) {
      if (options.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto = Object.getPrototypeOf(obj);
      if (proto && proto.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      return Object.create(proto);
    };
  }
});

// node_modules/joi/package.json
var require_package = __commonJS({
  "node_modules/joi/package.json"(exports, module) {
    module.exports = {
      name: "joi",
      description: "Object schema validation",
      version: "17.12.2",
      repository: "git://github.com/hapijs/joi",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/hoek": "^9.3.0",
        "@hapi/topo": "^5.1.0",
        "@sideway/address": "^4.1.5",
        "@sideway/formula": "^3.0.1",
        "@sideway/pinpoint": "^2.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "2.x.x",
        "@hapi/code": "8.x.x",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
        "@hapi/lab": "^25.1.3",
        "@types/node": "^14.18.63",
        typescript: "4.3.x"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L -Y",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/joi/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/joi/lib/schemas.js"(exports) {
    "use strict";
    init_register();
    var Joi2 = require_lib5();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      artifacts: Joi2.boolean(),
      cache: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      debug: Joi2.boolean(),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap,
          string: internals.wrap
        }
      },
      externals: Joi2.boolean(),
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi2.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi2.object({
      alias: Joi2.array().items(Joi2.string().pattern(internals.nameRx)).single(),
      args: Joi2.array().items(
        Joi2.string(),
        Joi2.object({
          name: Joi2.string().pattern(internals.nameRx).required(),
          ref: Joi2.boolean(),
          assert: Joi2.alternatives([
            Joi2.function(),
            Joi2.object().schema()
          ]).conditional("ref", { is: true, then: Joi2.required() }),
          normalize: Joi2.function(),
          message: Joi2.string().when("assert", { is: Joi2.function(), then: Joi2.required() })
        })
      ),
      convert: Joi2.boolean(),
      manifest: Joi2.boolean(),
      method: Joi2.function().allow(false),
      multi: Joi2.boolean(),
      validate: Joi2.function()
    });
    exports.extension = Joi2.object({
      type: Joi2.alternatives([
        Joi2.string(),
        Joi2.object().regex()
      ]).required(),
      args: Joi2.function(),
      cast: Joi2.object().pattern(internals.nameRx, Joi2.object({
        from: Joi2.function().maxArity(1).required(),
        to: Joi2.function().minArity(1).maxArity(2).required()
      })),
      base: Joi2.object().schema().when("type", { is: Joi2.object().regex(), then: Joi2.forbidden() }),
      coerce: [
        Joi2.function().maxArity(3),
        Joi2.object({ method: Joi2.function().maxArity(3).required(), from: Joi2.array().items(Joi2.string()).single() })
      ],
      flags: Joi2.object().pattern(internals.nameRx, Joi2.object({
        setter: Joi2.string(),
        default: Joi2.any()
      })),
      manifest: {
        build: Joi2.function().arity(2)
      },
      messages: [Joi2.object(), Joi2.string()],
      modifiers: Joi2.object().pattern(internals.nameRx, Joi2.function().minArity(1).maxArity(2)),
      overrides: Joi2.object().pattern(internals.nameRx, Joi2.function()),
      prepare: Joi2.function().maxArity(3),
      rebuild: Joi2.function().arity(1),
      rules: Joi2.object().pattern(internals.nameRx, internals.rule),
      terms: Joi2.object().pattern(internals.nameRx, Joi2.object({
        init: Joi2.array().allow(null).required(),
        manifest: Joi2.object().pattern(/.+/, [
          Joi2.valid("schema", "single"),
          Joi2.object({
            mapped: Joi2.object({
              from: Joi2.string().required(),
              to: Joi2.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi2.function().maxArity(3)
    }).strict();
    exports.extensions = Joi2.array().items(Joi2.object(), Joi2.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi2.object({
        buffer: Joi2.string()
      }),
      func: Joi2.object({
        function: Joi2.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi2.object({
        override: true
      }),
      ref: Joi2.object({
        ref: Joi2.object({
          type: Joi2.valid("value", "global", "local"),
          path: Joi2.array().required(),
          separator: Joi2.string().length(1).allow(false),
          ancestor: Joi2.number().min(0).integer().allow("root"),
          map: Joi2.array().items(Joi2.array().length(2)).min(1),
          adjust: Joi2.function(),
          iterables: Joi2.boolean(),
          in: Joi2.boolean(),
          render: Joi2.boolean()
        }).required()
      }),
      regex: Joi2.object({
        regex: Joi2.string().min(3)
      }),
      special: Joi2.object({
        special: Joi2.valid("deep").required()
      }),
      template: Joi2.object({
        template: Joi2.string().required(),
        options: Joi2.object()
      }),
      value: Joi2.object({
        value: Joi2.alternatives([Joi2.object(), Joi2.array()]).required()
      })
    };
    internals.desc.entity = Joi2.alternatives([
      Joi2.array().items(Joi2.link("...")),
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number(),
      Joi2.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi2.link("/")
    ]);
    internals.desc.values = Joi2.array().items(
      null,
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number().allow(Infinity, -Infinity),
      Joi2.string().allow(""),
      Joi2.symbol(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.override,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.template,
      internals.desc.value
    );
    internals.desc.messages = Joi2.object().pattern(/.+/, [
      Joi2.string(),
      internals.desc.template,
      Joi2.object().pattern(/.+/, [Joi2.string(), internals.desc.template])
    ]);
    exports.description = Joi2.object({
      type: Joi2.string().required(),
      flags: Joi2.object({
        cast: Joi2.string(),
        default: Joi2.any(),
        description: Joi2.string(),
        empty: Joi2.link("/"),
        failover: internals.desc.entity,
        id: Joi2.string(),
        label: Joi2.string(),
        only: true,
        presence: ["optional", "required", "forbidden"],
        result: ["raw", "strip"],
        strip: Joi2.boolean(),
        unit: Joi2.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi2.boolean(),
        abortEarly: Joi2.boolean(),
        artifacts: Joi2.boolean(),
        cache: Joi2.boolean(),
        convert: Joi2.boolean(),
        dateFormat: ["date", "iso", "string", "time", "utc"],
        errors: {
          escapeHtml: Joi2.boolean(),
          label: ["path", "key"],
          language: [
            Joi2.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi2.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi2.boolean(),
        nonEnumerables: Joi2.boolean(),
        presence: ["required", "optional", "forbidden"],
        skipFunctions: Joi2.boolean(),
        stripUnknown: Joi2.object({
          arrays: Joi2.boolean(),
          objects: Joi2.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi2.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi2.array().min(1).items({
        name: Joi2.string().required(),
        args: Joi2.object().min(1),
        keep: Joi2.boolean(),
        message: [
          Joi2.string(),
          internals.desc.messages
        ],
        warn: Joi2.boolean()
      }),
      // Terms
      keys: Joi2.object().pattern(/.*/, Joi2.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi2.any());
  }
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeHtml.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    module.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || // a-z
        i >= 65 && i <= 90 || // A-Z
        i >= 48 && i <= 57 || // 0-9
        i === 32 || // space
        i === 46 || // .
        i === 44 || // ,
        i === 45 || // -
        i === 58 || // :
        i === 95) {
          safe.add(i);
        }
      }
      return safe;
    }();
  }
});

// node_modules/@sideway/formula/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@sideway/formula/lib/index.js"(exports) {
    "use strict";
    init_register();
    var internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports.Parser = class {
      constructor(string, options = {}) {
        if (!options[internals.settings] && options.constants) {
          for (const constant in options.constants) {
            const value = options.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;
        this._parts = null;
        this._parse(string);
      }
      _parse(string) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = /* @__PURE__ */ __name((inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        }, "flush");
        for (const c of string) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i) => {
          if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = /* @__PURE__ */ __name(() => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
            }
            args.push(current);
            current = "";
          }, "flush");
          for (let i = 0; i < string.length; ++i) {
            const c = string[i];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i = parts.length - 2; i >= 0; --i) {
          const part = parts[i];
          if (part && part.type === "operator") {
            const current = parts[i + 1];
            parts.splice(i + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i = 1; i < parts.length - 1; ) {
            if (set.includes(parts[i])) {
              const operator = parts[i];
              const left = internals.evaluate(parts[i - 1], context);
              const right = internals.evaluate(parts[i + 1], context);
              parts.splice(i, 2);
              const result = internals.calculate(operator, left, right);
              parts[i - 1] = result === 0 ? 0 : result;
            } else {
              i += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});

// node_modules/joi/lib/annotate.js
var require_annotate = __commonJS({
  "node_modules/joi/lib/annotate.js"(exports) {
    "use strict";
    init_register();
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = /* @__PURE__ */ __name((key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      }, "cycleReplacer");
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/joi/lib/errors.js
var require_errors = __commonJS({
  "node_modules/joi/lib/errors.js"(exports) {
    "use strict";
    init_register();
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports.Report = class {
      constructor(code, value, local, flags, messages, state, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code) {
        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
      }
    };
    exports.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports.template = function(value, messages, code, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang]) {
        if (messages[lang][code] !== void 0) {
          return messages[lang][code];
        }
        if (messages[lang]["*"] !== void 0) {
          return messages[lang]["*"];
        }
      }
      if (!messages[code]) {
        return messages["*"];
      }
      return messages[code];
    };
    exports.label = function(flags, state, prefs, messages) {
      if (flags.label) {
        return flags.label;
      }
      if (!prefs.errors.label) {
        return "";
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports.path(path);
      if (normalized) {
        return normalized;
      }
      return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
    };
    exports.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports.details = function(errors, options = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports.ValidationError;
      }
    };
    exports.ValidationError.prototype.isJoi = true;
    exports.ValidationError.prototype.name = "ValidationError";
    exports.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/joi/lib/ref.js
var require_ref = __commonJS({
  "node_modules/joi/lib/ref.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports.in = function(key, options = {}) {
      return exports.create(key, { ...options, in: true });
    };
    exports.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
      }
      _resolve(target, state, options) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = { path: this.path };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [...this.map];
        }
        for (const key of ["adjust", "iterables", "render"]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return { ref };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports.toSibling = 0;
    exports.toParent = 1;
    exports.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || require_template();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/joi/lib/template.js
var require_template = __commonJS({
  "node_modules/joi/lib/template.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Formula = require_lib2();
    var Common = require_common();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module.exports = exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options) {
          const { functions, ...opts } = options;
          this._settings = Object.keys(opts).length ? Clone(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date);
      }
      describe(options = {}) {
        if (!this._settings && options.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state, prefs, local);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state,
              prefs,
              local,
              options
              /*] */
            );
            const string = internals.stringify(rendered, value, state, prefs, local, options);
            if (string !== void 0) {
              const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = /* @__PURE__ */ __name((variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => {
            const resolved = ref.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        }, "reference");
        try {
          const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
          var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref = refs[0];
            return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string) {
      return string.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string) {
      return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string.length; ++i) {
        const char = string[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string.length && string[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state, prefs, local, options = {}) {
      const type = typeof value;
      const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
      }
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return internals.wrap(value, options.arrayItems && wrap.string);
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values = [];
      for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
      }
      return internals.wrap(values.join(", "), !skipWrap && wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code) {
        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local, options);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});

// node_modules/joi/lib/messages.js
var require_messages = __commonJS({
  "node_modules/joi/lib/messages.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports.decompile = function(messages) {
      const target = {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code] = message.describe({ compact: true });
          continue;
        }
        const language = code;
        target[language] = {};
        for (code in message) {
          const localized = message[code];
          if (code === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports.merge = function(base, extended) {
      if (!base) {
        return exports.compile(extended);
      }
      if (!extended) {
        return base;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/common.js
var require_common = __commonJS({
  "node_modules/joi/lib/common.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var AssertError = require_error();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports.version = Pkg.version;
    exports.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports.assertOptions = function(options, keys, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports.isIsoDate = function(date) {
      return internals.isoDate.test(date);
    };
    exports.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports.symbols.ref] || obj[exports.symbols.template];
    };
    exports.isSchema = function(schema2, options = {}) {
      const any = schema2 && schema2[exports.symbols.any];
      if (!any) {
        return false;
      }
      Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports.isValues = function(obj) {
      return obj[exports.symbols.values];
    };
    exports.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports.symbols.prefs];
      return merged;
    };
    exports.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports.validateArg = function(value, label, { assert, message }) {
      if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/joi/lib/cache.js
var require_cache = __commonJS({
  "node_modules/joi/lib/cache.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
    };
    exports.provider = {
      provision(options) {
        return new internals.Cache(options);
      }
    };
    internals.Cache = class {
      constructor(options = {}) {
        Common.assertOptions(options, ["max"]);
        Assert(options.max === void 0 || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
        this._max = options.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return Clone(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});

// node_modules/joi/lib/compile.js
var require_compile = __commonJS({
  "node_modules/joi/lib/compile.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.schema = function(Joi2, config, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config, options) {
      Assert(config !== void 0, "Invalid undefined schema");
      if (Array.isArray(config)) {
        Assert(config.length, "Invalid empty array schema");
        if (config.length === 1) {
          config = config[0];
        }
      }
      const valid = /* @__PURE__ */ __name((base, ...values) => {
        if (options.override !== false) {
          return base.valid(Joi2.override, ...values);
        }
        return base.valid(...values);
      }, "valid");
      if (internals.simple(config)) {
        return valid(Joi2, config);
      }
      if (typeof config === "function") {
        return Joi2.custom(config);
      }
      Assert(typeof config === "object", "Invalid schema content:", typeof config);
      if (Common.isResolvable(config)) {
        return valid(Joi2, config);
      }
      if (Common.isSchema(config)) {
        return config;
      }
      if (Array.isArray(config)) {
        for (const item of config) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config);
          }
        }
        return valid(Joi2, ...config);
      }
      if (config instanceof RegExp) {
        return Joi2.string().regex(config);
      }
      if (config instanceof Date) {
        return valid(Joi2.date(), config);
      }
      Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config);
    };
    exports.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports.compile = function(root, schema2, options = {}) {
      Common.assertOptions(options, ["legacy"]);
      const any = schema2 && schema2[Common.symbols.any];
      if (any) {
        Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema2;
      }
      if (typeof schema2 !== "object" || !options.legacy) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      const compiler = internals.walk(schema2);
      if (!compiler) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema2);
    };
    internals.walk = function(schema2) {
      if (typeof schema2 !== "object") {
        return null;
      }
      if (Array.isArray(schema2)) {
        for (const item of schema2) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any = schema2[Common.symbols.any];
      if (any) {
        return { root: schema2[any.root], compile: any.compile };
      }
      Assert(Object.getPrototypeOf(schema2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema2) {
        const compiler = internals.walk(schema2[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports.when = function(schema2, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema2, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema2.$_compile(rule2.is) : schema2.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema2, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema2.$_compile(test.is),
          then: schema2.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema2.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema2, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema2.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/joi/lib/extend.js
var require_extend = __commonJS({
  "node_modules/joi/lib/extend.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var internals = {};
    exports.type = function(from, options) {
      const base = Object.getPrototypeOf(from);
      const prototype = Clone(base);
      const schema2 = from._assign(Object.create(prototype));
      const def = Object.assign({}, options);
      delete def.base;
      prototype._definition = def;
      const parent = base._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema2.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema2.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema2.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = /* @__PURE__ */ __name(function() {
              return this.$_addRule(name);
            }, "method");
          }
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = /* @__PURE__ */ __name(function(arg) {
            return this.rule({ [name]: arg });
          }, "method");
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base;
        schema2.$_super = {};
        for (const override in def.overrides) {
          Assert(base[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base[override];
          schema2.$_super[override] = base[override].bind(schema2);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest = Object.assign({}, parent.manifest, def.manifest);
      manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema2;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema2) {
        parent(schema2);
        child(schema2);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});

// node_modules/joi/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/joi/lib/manifest.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var Ref = require_ref();
    var Template = require_template();
    var Schemas;
    var internals = {};
    exports.describe = function(schema2) {
      const def = schema2._definition;
      const desc = {
        type: schema2.type,
        flags: {},
        rules: []
      };
      for (const flag in schema2._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema2._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema2._preferences) {
        desc.preferences = Clone(schema2._preferences, { shallow: ["messages"] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema2._valids) {
        desc.allow = schema2._valids.describe();
      }
      if (schema2._invalids) {
        desc.invalid = schema2._invalids.describe();
      }
      for (const rule of schema2._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = { name: rule.name };
        for (const custom in def.modifiers) {
          if (rule[custom] !== void 0) {
            item[custom] = internals.describe(rule[custom]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, { assign: key });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema2.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema2.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [...items.entries()];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        Assert(def.terms[term], "Term", term, "missing configuration");
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from, to } = manifest.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from];
          }
          continue;
        }
        if (manifest === "single") {
          Assert(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema2.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return { special: "deep" };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options.assign === "options") {
        return Clone(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return { buffer: item.toString("binary") };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options.assign === "regex") {
          return item.toString();
        }
        return { regex: item.toString() };
      }
      if (item[Common.symbols.literal]) {
        return { function: item.literal };
      }
      if (typeof item.describe === "function") {
        if (options.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, { assign: key });
      }
      return normalized;
    };
    exports.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema2 = this.joi[desc.type]()._bare();
        const def = schema2._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            Assert(typeof schema2[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema2 = schema2[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema2 = schema2.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema2 = schema2.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema2 = schema2.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            Assert(typeof schema2[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], { assign: key });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema2 = schema2[rule.name](...args);
            const options = {};
            for (const custom in def.modifiers) {
              if (rule[custom] !== void 0) {
                options[custom] = this.build(rule[custom]);
              }
            }
            if (Object.keys(options).length) {
              schema2 = schema2.rule(options);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
            continue;
          }
          Assert(def.terms[key], "Term", key, "missing configuration");
          const manifest = def.terms[key].manifest;
          if (manifest === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema2 = def.manifest.build(schema2, terms);
        schema2.$_temp.ruleset = false;
        return schema2;
      }
      build(desc, options = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options.assign === "options") {
          return Clone(desc);
        }
        if (options.assign === "regex") {
          return internals.regex(desc);
        }
        if (options.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            Assert(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return { [Common.symbols.literal]: true, literal: desc.function };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return Clone(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], { assign: key });
        }
        return normalized;
      }
    };
    internals.regex = function(string) {
      const end = string.lastIndexOf("/");
      const exp = string.slice(1, end);
      const flags = string.slice(end + 1);
      return new RegExp(exp, flags);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas();
      joi.assert(desc, Schemas.description);
    };
  }
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS({
  "node_modules/@hapi/hoek/lib/deepEqual.js"(exports, module) {
    "use strict";
    init_register();
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module.exports = function(obj, ref, options) {
      options = Object.assign({ prototype: true }, options);
      return !!internals.isDeepEqual(obj, ref, options, []);
    };
    internals.isDeepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
          return obj === ref;
        case Types.regex:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i = 0; i < obj.length; ++i) {
            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options.skip && options.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      if (!options.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options.skip || !options.skip.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});

// node_modules/@sideway/pinpoint/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@sideway/pinpoint/lib/index.js"(exports) {
    "use strict";
    init_register();
    exports.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});

// node_modules/joi/lib/trace.js
var require_trace = __commonJS({
  "node_modules/joi/lib/trace.js"(exports) {
    "use strict";
    init_register();
    var DeepEqual = require_deepEqual();
    var Pinpoint = require_lib3();
    var Errors = require_errors();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports.setup = function(root) {
      const trace = /* @__PURE__ */ __name(function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      }, "trace");
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports.location = function(schema2) {
      return schema2.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema2) {
        const existing = this._schemas.get(schema2);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema2);
        const { filename, line } = schema2._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema2, { filename, line, store });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file && file !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema2, log] of store._sources.entries()) {
            if (internals.sub(log.paths, skipped)) {
              continue;
            }
            if (!log.entry) {
              missing.push({
                status: "never reached",
                paths: [...log.paths]
              });
              skipped.push(...log.paths);
              continue;
            }
            for (const type of ["valid", "invalid"]) {
              const set = schema2[`_${type}s`];
              if (!set) {
                continue;
              }
              const values = new Set(set._values);
              const refs = new Set(set._refs);
              for (const { value, ref } of log[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [...values, ...[...refs].map((ref) => ref.display)],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema2._rules.map((rule) => rule.name);
            for (const type of ["default", "failover"]) {
              if (schema2._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log.rule[name] || 0];
              if (status) {
                const report = { rule: name, status };
                if (log.paths.size) {
                  report.paths = [...log.paths];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema2) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema2);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
      }
      entry(schema2, state) {
        internals.debug(state, { type: "entry" });
        this._record(schema2, (log) => {
          log.entry = true;
        });
      }
      filter(schema2, state, source, value) {
        internals.debug(state, { type: source, ...value });
        this._record(schema2, (log) => {
          log[source].add(value);
        });
      }
      log(schema2, state, source, name, result) {
        internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
        this._record(schema2, (log) => {
          log[source][name] = log[source][name] || 0;
          log[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log = { type: "resolve", ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
      }
      value(state, by, from, to, name) {
        if (!state.mainstay.debug || DeepEqual(from, to)) {
          return;
        }
        const log = { type: "value", by, from, to, path: state.path };
        if (name) {
          log.name = name;
        }
        state.mainstay.debug.push(log);
      }
      _record(schema2, each) {
        const log = this._sources.get(schema2);
        if (log) {
          each(log);
          return;
        }
        const sources = this._combos.get(schema2);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema2, _path) {
        const path = _path || [];
        let log = this._sources.get(schema2);
        if (!log) {
          log = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema2, log);
        }
        if (path.length) {
          log.paths.add(path);
        }
        const each = /* @__PURE__ */ __name((sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path.concat(subId));
        }, "each");
        schema2.$_modify({ each, ref: false });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema2, { source, name, path, key }) {
      if (schema2._flags.id) {
        return schema2._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [name, path[Math.min(path.length - 1, 1)]];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path of paths) {
        for (const skip of skipped) {
          if (DeepEqual(path.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS({
  "node_modules/@hapi/hoek/lib/merge.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module.exports = internals.merge = function(target, source, options) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options.mergeArrays) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(Clone(source[i], { symbols: options.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options.symbols });
          } else {
            internals.merge(target[key], value, options);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/modify.js
var require_modify = __commonJS({
  "node_modules/joi/lib/modify.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        if (!node) {
          return [...behind, ...path].join(".");
        }
        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema2, { key } = {}) {
        if (!schema2 || !Common.isSchema(schema2)) {
          return;
        }
        if (schema2.$_property("schemaChain") || schema2._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema2._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema2, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema: schema2, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema: schema2, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        nodes = [node, ...nodes];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema2, id, replacement) {
      const each = /* @__PURE__ */ __name((item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      }, "each");
      const obj = exports.schema(schema2, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema2;
    };
    exports.schema = function(schema2, options) {
      let obj;
      for (const name in schema2._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema2._rules.length; ++i) {
        const rule = schema2._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          const clone = Object.assign({}, rule);
          clone.args = result;
          obj._rules[i] = clone;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone);
          }
        }
      }
      for (const name in schema2.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.source === "terms" && source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone = clone || item.slice();
            clone[i] = result;
          }
        }
        return clone;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone = clone || Object.assign({}, item);
          clone[key] = result;
        }
      }
      return clone;
    };
  }
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS({
  "node_modules/@hapi/hoek/lib/ignore.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function() {
    };
  }
});

// node_modules/joi/lib/state.js
var require_state = __commonJS({
  "node_modules/joi/lib/state.js"(exports, module) {
    "use strict";
    init_register();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path, ancestors = null, schema2 = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema2 && state.schemas) {
          state.schemas = [internals.schemas(schema2), ...state.schemas];
        }
        return state;
      }
      nest(schema2, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema2), ...state.schemas];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
        this.mainstay.snapshot();
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.restore();
      }
      commit() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.commit();
      }
    };
    internals.schemas = function(schema2) {
      if (Common.isSchema(schema2)) {
        return { schema: schema2 };
      }
      return schema2;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
          const segment = path[i];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, { iterables: true });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/joi/lib/validator.js
var require_validator = __commonJS({
  "node_modules/joi/lib/validator.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Ignore = require_ignore();
    var Reach = require_reach();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports.entry = function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        Assert(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        Assert(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports.entryAsync = async function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
          const path = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node = root;
          let key;
          let parent;
          const ancestors = path.length ? [root] : [];
          const original = path.length ? Reach(value, path) : value;
          if (path.length) {
            key = path[path.length - 1];
            let current = root;
            for (const segment of path.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node = parent[key];
          }
          try {
            const createError = /* @__PURE__ */ __name((code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings), "createError");
            const output = await external.method(node, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),
              message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages })
            });
            if (output === void 0 || output === node) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors.length) {
          result.error = Errors.process(errors, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema2, prefs) {
      const { tracer, cleanup } = internals.tracer(schema2, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema2._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas = schema2._ids._schemaChain ? [{ schema: schema2 }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports.validate(value, schema2, state, prefs);
      if (cleanup) {
        schema2.$_root.untrace();
      }
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    internals.tracer = function(schema2, prefs) {
      if (schema2.$_root._tracer) {
        return { tracer: schema2.$_root._tracer._register(schema2) };
      }
      if (prefs.debug) {
        Assert(schema2.$_root.trace, "Debug mode not supported");
        return { tracer: schema2.$_root.trace()._register(schema2), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports.validate = function(value, schema2, state, prefs, overrides = {}) {
      if (schema2.$_terms.whens) {
        schema2 = schema2._generate(value, state, prefs).schema;
      }
      if (schema2._preferences) {
        prefs = internals.prefs(schema2, prefs);
      }
      if (schema2._cache && prefs.cache) {
        const result = schema2._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = /* @__PURE__ */ __name((code, local, localState) => schema2.$_createError(code, value, local, localState || state, prefs), "createError");
      const helpers = {
        original: value,
        prefs,
        schema: schema2,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema2.$_createError("custom", value, local, state, prefs, { messages })
      };
      state.mainstay.tracer.entry(schema2, state);
      const def = schema2._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty = schema2._flags.empty;
      if (empty && empty.$_match(internals.trim(value, schema2), state.nest(empty), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema2._flags.presence || (schema2._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema2.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema2._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema2.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema2._valids) {
        const match = schema2._valids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema2, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema2._flags.only) {
          const report = schema2.$_createError("any.only", value, { valids: schema2._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema2._invalids) {
        const match = schema2._invalids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema2, state, "invalid", match);
          const report = schema2.$_createError("any.invalid", value, { invalids: schema2._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
          state.mainstay.tracer.value(state, "base", value, base.value);
          value = base.value;
          if (base.errors) {
            if (!Array.isArray(base.errors)) {
              errors.push(base.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base.errors.length) {
              errors.push(...base.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema2._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      for (const rule of schema2._rules) {
        const definition = schema2._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema2.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema: schema2, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema2._flags.error) {
        if (typeof schema2._flags.error === "function") {
          errors = schema2._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema2._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema2._flags.cast && value !== void 0) {
        const caster = schema2._definition.cast[schema2._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema2._flags.cast);
          value = casted;
        }
      }
      if (schema2.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema2.$_terms.externals) {
          state.mainstay.externals.push({ method, schema: schema2, state, label: Errors.label(schema2._flags, state, prefs) });
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema2._flags.result) {
        result.value = schema2._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.mainstay.tracer.value(state, schema2._flags.result, value, result.value);
        state.shadow(value, schema2._flags.result);
      }
      if (schema2._cache && prefs.cache !== false && !schema2._refs.length) {
        schema2._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema2._flags.artifact !== void 0) {
        state.mainstay.artifacts = state.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state.mainstay.artifacts.has(schema2._flags.artifact)) {
          state.mainstay.artifacts.set(schema2._flags.artifact, []);
        }
        state.mainstay.artifacts.get(schema2._flags.artifact).push(state.path);
      }
      return result;
    };
    internals.prefs = function(schema2, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema2._preferences[Common.symbols.prefs]) {
        return schema2._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema2._preferences);
      if (isDefaultOptions) {
        schema2._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      const source = schema2._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema2, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema2.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema2) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema2.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: Ignore,
      entry: Ignore,
      filter: Ignore,
      log: Ignore,
      resolve: Ignore,
      value: Ignore
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/joi/lib/values.js
var require_values = __commonJS({
  "node_modules/joi/lib/values.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options) {
        if (options && options.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({ override: true });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? { value } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from) {
      const map = /* @__PURE__ */ new Map();
      if (from) {
        for (const value of from) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});

// node_modules/joi/lib/base.js
var require_base = __commonJS({
  "node_modules/joi/lib/base.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Trace = require_trace();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._reset();
      }
      _reset() {
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          // Runtime state (not cloned)
          ruleset: null,
          // null: use last, false: error, number: start position
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Manifest
      describe() {
        Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({ target, adjuster });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      artifact(id) {
        Assert(id !== void 0, "Artifact cannot be undefined");
        Assert(!this._cache, "Cannot set an artifact with a rule cache");
        return this.$_setFlag("artifact", id);
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options) {
        return this._default("default", value, options);
      }
      description(desc) {
        Assert(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema2) {
        const obj = this.clone();
        if (schema2 !== void 0) {
          schema2 = obj.$_compile(schema2, { override: false });
        }
        return obj.$_setFlag("empty", schema2, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options = {}) {
        Assert(example !== void 0, "Missing example");
        Common.assertOptions(options, ["override"]);
        return this._inner("examples", example, { single: true, override: options.override });
      }
      external(method, description) {
        if (typeof method === "object") {
          Assert(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        Assert(typeof method === "function", "Method must be a function");
        Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", { method, description }, { single: true });
      }
      failover(value, options) {
        return this._default("failover", value, options);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        Assert(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        Assert(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, { single: true });
      }
      note(...notes) {
        Assert(notes.length, "Missing notes");
        for (const note of notes) {
          Assert(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Assert(prefs.externals === void 0, "Cannot override externals");
        Assert(prefs.warnings === void 0, "Cannot override warnings");
        Assert(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled = true) {
        return this.$_setFlag("result", enabled ? "raw" : void 0);
      }
      result(mode) {
        Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled) {
        const obj = this.clone();
        const convert = enabled === void 0 ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled = true) {
        return this.$_setFlag("result", enabled ? "strip" : void 0);
      }
      tag(...tags) {
        Assert(tags.length, "Missing tags");
        for (const tag of tags) {
          Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        Assert(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      cache(cache) {
        Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
        Assert(!this._cache, "Cannot override schema cache");
        Assert(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, source]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options) {
        Assert(!options.base, "Cannot extend type with another base");
        return Extend.type(this, options);
      }
      extract(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.reach(path);
      }
      fork(paths, adjuster) {
        Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path of [].concat(paths)) {
          path = Array.isArray(path) ? path : path.split(".");
          obj = obj._ids.fork(path, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      rule(options) {
        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));
        Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i = start; i < obj._rules.length; ++i) {
          const original = obj._rules[i];
          const rule = Clone(original);
          for (const name in options) {
            def.modifiers[name](rule, options[name]);
            Assert(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options) {
        return Validator.entry(value, this, options);
      }
      validateAsync(value, options) {
        return Validator.entryAsync(value, this, options);
      }
      // Extensions
      $_addRule(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        Assert(options && typeof options === "object", "Invalid options");
        Assert(options.name && typeof options.name === "string", "Invalid rule name");
        for (const key in options) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, { clone: false });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema2, options) {
        return Compile.schema(this.$_root, schema2, options);
      }
      $_createError(code, value, local, state, prefs, options = {}) {
        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.labels(path);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options) {
        Common.assertOptions(options, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options) || this;
      }
      $_mutateRebuild() {
        Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = /* @__PURE__ */ __name((item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        }, "each");
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema2, { family, key } = {}) {
        this._refs.register(schema2, family);
        this._ids.register(schema2, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options = {}) {
        Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _bare() {
        const obj = this.clone();
        obj._reset();
        const terms = obj._definition.terms;
        for (const name in terms) {
          const term = terms[name];
          obj.$_terms[name] = term.init;
        }
        return obj.$_mutateRebuild();
      }
      _default(flag, value, options = {}) {
        Common.assertOptions(options, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
        if (typeof value === "function" && options.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
          const when = this.$_terms.whens[i];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return { schema: this };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, ...whens]);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _inner(type, values, options = {}) {
        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options.override) {
          obj.$_terms[type] = [];
        }
        if (options.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
          const test = obj._rules[i];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module.exports = new internals.Base();
  }
});

// node_modules/joi/lib/types/any.js
var require_any = __commonJS({
  "node_modules/joi/lib/types/any.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    var Messages = require_messages();
    module.exports = Base.extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema2) {
            Assert(Common.isSchema(schema2) && schema2._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema2);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        warning: {
          method(code, local) {
            Assert(code && typeof code === "string", "Invalid warning code");
            return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
          },
          validate(value, helpers, { code, local }) {
            return helpers.error(code, local);
          },
          args: ["code", "local"],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled = true) {
          rule.keep = enabled;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled = true) {
          rule.warn = enabled;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat } = value;
                if (concat) {
                  obj = obj.concat(concat);
                } else if (ref) {
                  obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                } else {
                  obj = obj.when(is, { then, otherwise, break: value.break });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/joi/lib/types/alternatives.js
var require_alternatives = __commonJS({
  "node_modules/joi/lib/types/alternatives.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Merge = require_merge();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema2, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema2.try(...schemas[0]);
          }
        }
        return schema2.try(...schemas);
      },
      validate(value, helpers) {
        const { schema: schema2, error, state, prefs } = helpers;
        if (schema2._flags.match) {
          const matched = [];
          const failed = [];
          for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
            const item = schema2.$_terms.matches[i];
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              matched.push(result.value);
              localState.commit();
            } else {
              failed.push(result.errors);
              localState.restore();
            }
          }
          if (matched.length === 0) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.any", context) };
          }
          if (schema2._flags.match === "one") {
            return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
          }
          if (matched.length !== schema2.$_terms.matches.length) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.all", context) };
          }
          const isAnyObj = /* @__PURE__ */ __name((alternative) => {
            return alternative.$_terms.matches.some((v) => {
              return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
            });
          }, "isAnyObj");
          return isAnyObj(schema2) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }
        const errors = [];
        for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
          const item = schema2.$_terms.matches[i];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              localState.commit();
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema2 of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema2) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_parent("label", name);
          const each = /* @__PURE__ */ __name((item, source) => {
            return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
          }, "each");
          return obj.$_modify({ each, ref: false });
        }
      },
      rebuild(schema2) {
        const each = /* @__PURE__ */ __name((item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema2.$_setFlag("_arrayItems", true, { clone: false });
          }
        }, "each");
        schema2.$_modify({ each });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema: schema2, ref, is, not, then, otherwise } = match;
              if (schema2) {
                obj = obj.try(schema2);
              } else if (ref) {
                obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
              } else {
                obj = obj.conditional(is, { then, otherwise });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema: schema2 } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema2.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code] = report.code.split(".");
        if (code !== "base") {
          complex.push({ type: schema2.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});

// node_modules/joi/lib/types/array.js
var require_array = __commonJS({
  "node_modules/joi/lib/types/array.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module.exports = Any.extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [], manifest: "schema" },
        ordered: { init: [], manifest: "schema" },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema: schema2, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema2.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema2, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema: schema2, error }) {
        if (!Array.isArray(value)) {
          if (schema2._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema2.$_getRule("items") && !schema2.$_terms.externals) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema2) {
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema: schema2 } });
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has }) {
            const ancestors = [value, ...state.ancestors];
            for (let i = 0; i < value.length; ++i) {
              const localState = state.localize([...state.path, i], ancestors, has);
              if (has.$_match(value[i], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has._flags.label;
            if (patternLabel) {
              return error("array.hasKnown", { patternLabel });
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema: schema2, error, state, prefs, errorsArray }) {
            const requireds = schema2.$_terms._requireds.slice();
            const ordereds = schema2.$_terms.ordered.slice();
            const inclusions = [...schema2.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i = 0; i < il; ++i) {
              const item = value[i];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i : new Number(i);
              const path = [...state.path, key];
              if (!schema2._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema2.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema2.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema2.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i, limit: schema2.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  localState.commit();
                  value[i] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema2._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    localState.commit();
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if ((schema2.$_terms._inclusions.length || schema2.$_terms._requireds.length) && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema2, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema2, errors, ordereds, value, state, prefs);
              if (!errors.length) {
                internals.fillDefault(ordereds, value, state, prefs);
              }
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options = {}) {
            Common.assertOptions(options, ["by", "order"]);
            const settings = {
              order: options.order || "ascending"
            };
            if (options.by) {
              settings.by = Compile.ref(options.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema: schema2 }, { options }) {
            const { value: sorted, errors } = internals.sort(schema2, value, options, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i = 0; i < value.length; ++i) {
              if (value[i] !== sorted[i]) {
                return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema: schema2 }, { comparator: raw, options }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options.ignoreUndefined;
            for (let i = 0; i < value.length; ++i) {
              const item = path ? Reach(value[i], path) : value[i];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema2) {
        schema2.$_terms._inclusions = [];
        schema2.$_terms._exclusions = [];
        schema2.$_terms._requireds = [];
        for (const type of schema2.$_terms.items) {
          internals.validateSingle(type, schema2);
          if (type._flags.presence === "required") {
            schema2.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema2.$_terms._exclusions.push(type);
          } else {
            schema2.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema2.$_terms.ordered) {
          internals.validateSingle(type, schema2);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema2, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema2.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
        } else {
          errors.push(schema2.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
        }
      } else {
        errors.push(schema2.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema2, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema2, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fillDefault = function(ordereds, value, state, prefs) {
      const overrides = [];
      let trailingUndefined = true;
      for (let i = ordereds.length - 1; i >= 0; --i) {
        const ordered = ordereds[i];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(void 0, state.localize(state.path, ancestors, ordered), prefs).value;
        if (trailingUndefined) {
          if (override === void 0) {
            continue;
          }
          trailingUndefined = false;
        }
        overrides.unshift(override);
      }
      if (overrides.length) {
        value.push(...overrides);
      }
    };
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema2, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = /* @__PURE__ */ __name((a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema2.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema2.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      }, "sort");
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/joi/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/joi/lib/types/boolean.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema: schema2 }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema2._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema2.$_terms.truthy && schema2.$_terms.truthy.has(value, null, null, !schema2._flags.sensitive) || (schema2.$_terms.falsy && schema2.$_terms.falsy.has(value, null, null, !schema2._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled = true) {
            return this.$_setFlag("sensitive", enabled);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/joi/lib/types/date.js
var require_date = __commonJS({
  "node_modules/joi/lib/types/date.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module.exports = Any.extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema: schema2 }) {
          return { value: internals.parse(value, schema2._flags.format) || value };
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format = schema2._flags.format;
        if (!prefs.convert || !format || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date }, { name, operator, args }) {
            const to = date === "now" ? Date.now() : date.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date) => {
                return date === "now" ? date : internals.parse(date);
              },
              assert: (date) => date !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format) {
            Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
            return this.$_setFlag("format", format);
          }
        },
        greater: {
          method(date) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date) {
            return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
          }
        },
        max: {
          method(date) {
            return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
          }
        },
        min: {
          method(date) {
            return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
        // Messages used in date.format
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format) {
        if (format === "javascript") {
          return internals.date(1 * value);
        }
        if (format === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date;
      }
      return null;
    };
  }
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS({
  "node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module.exports = function(defaults, source, options = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
      }
      const copy = Clone(defaults);
      if (source === true) {
        return copy;
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options) {
      const keys = options.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge && Reach(source, key) || ref);
        } else if (merge) {
          merge.add(key);
        }
      }
      const copy = Clone(defaults, {}, seen);
      if (!merge) {
        return copy;
      }
      for (const key of merge) {
        internals.reachCopy(copy, source, key);
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src, path) {
      for (const segment of path) {
        if (!(segment in src)) {
          return;
        }
        const val = src[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src = val;
      }
      const value = src;
      let ref = dst;
      for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path[path.length - 1]] = value;
    };
  }
});

// node_modules/@hapi/topo/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@hapi/topo/lib/index.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var internals = {};
    exports.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options) {
        options = options || {};
        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || "?";
        const sort = options.sort || 0;
        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes("?"), "Item cannot come before unassociated items");
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options.manual) {
          const valid = this._sort();
          Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [others];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
          this._items[i].seq = i;
        }
        const valid = this._sort();
        Assert(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        Assert(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] || [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] || [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] || [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] || [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i = 0; i < this._items.length; ++i) {
          let next = i;
          if (ancestors[i]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// node_modules/joi/lib/types/keys.js
var require_keys = __commonJS({
  "node_modules/joi/lib/types/keys.js"(exports, module) {
    "use strict";
    init_register();
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib4();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var Template = require_template();
    var internals = {
      renameDefaults: {
        alias: false,
        // Keep old value in place
        multiple: false,
        // Allow renaming multiple keys into the same target
        override: false
        // Overrides an existing key
      }
    };
    module.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema2, keys) {
        return schema2.keys(keys);
      },
      validate(value, { schema: schema2, error, state, prefs }) {
        if (!value || typeof value !== schema2.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema2.$_property("typeof") }) };
        }
        if (!schema2.$_terms.renames && !schema2.$_terms.dependencies && !schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema2.$_terms.renames && !internals.rename(schema2, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema2.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema2.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              if (result.value !== void 0) {
                value[key] = result.value;
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema2._flags._hasPatternMatch) {
          const early = internals.unknown(schema2, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema2.$_terms.dependencies) {
          for (const dep of schema2.$_terms.dependencies) {
            if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema2, dep, value, state, prefs);
            if (failed) {
              const report = schema2.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema2) {
            if (schema2 === null || schema2 === void 0 || Object.keys(schema2).length === 0) {
              return this;
            }
            return this.keys(schema2);
          }
        },
        assert: {
          method(subject, schema2, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema: schema2, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema: schema2, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema2.$_match(about, state.localize(path, [value, ...state.ancestors], schema2), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema2) {
            Assert(schema2 === void 0 || typeof schema2 === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema2), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema2) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema2).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema2.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema2) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema2[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema2, options = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema2 !== void 0, "Invalid rule");
            Common.assertOptions(options, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema2 };
            if (options.matches) {
              config.matches = this.$_compile(options.matches);
              if (config.matches.type !== "array") {
                config.matches = config.matches.$_root.array().items(config.matches);
              }
              obj.$_mutateRegister(config.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options.fallthrough) {
              config.fallthrough = true;
            }
            obj.$_terms.patterns.push(config);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from, to, options = {}) {
            Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            Assert(to !== from, "Cannot rename key to same name:", from);
            Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "with", key, peers, options);
          }
        },
        without: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "without", key, peers, options);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options);
        }
      },
      rebuild(schema2) {
        if (schema2.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema2.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema2.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema: schema2, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema2, rule, { fallthrough, matches });
            }
          }
          if (desc.renames) {
            for (const { from, to, options } of desc.renames) {
              obj = obj.rename(from, to, options);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone2 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone2, value);
        return clone2;
      }
      const clone = /* @__PURE__ */ __name(function(...args) {
        return value.apply(this, args);
      }, "clone");
      clone.prototype = Clone(value.prototype);
      Object.defineProperty(clone, "name", { value: value.name, writable: false });
      Object.defineProperty(clone, "length", { value: value.length, writable: false });
      Object.assign(clone, value);
      return clone;
    };
    internals.dependency = function(schema2, rel, key, peers, options) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options, ["separator", "isPresent"]);
      peers = [].concat(peers);
      const separator = Common.default(options.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be strings");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema2.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
      return obj;
    };
    internals.dependencies = {
      and(schema2, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema2, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema2, missing)
            }
          };
        }
      },
      nand(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema2, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema2, values)
          }
        };
      },
      or(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema2, dep.paths)
          }
        };
      },
      oxor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.oxor", context };
      },
      with(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      without(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      xor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.xor", context };
      }
    };
    internals.keysToLabels = function(schema2, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema2.$_mapLabels(key));
      }
      return schema2.$_mapLabels(keys);
    };
    internals.isPresent = function(options) {
      return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== void 0;
    };
    internals.rename = function(schema2, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema2.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from in value) {
            if (value[from] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from === rename.to) {
              continue;
            }
            const match = rename.from.exec(from);
            if (!match) {
              continue;
            }
            matches.push({ from, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema2.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema2.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema2, value, unprocessed, errors, state, prefs) {
      if (schema2.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema2.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [...state.path, key];
          for (let i = 0; i < schema2.$_terms.patterns.length; ++i) {
            const pattern = schema2.$_terms.patterns[i];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i = 0; i < matches.length; ++i) {
            const match = matches[i];
            if (!match) {
              continue;
            }
            const stpm = schema2.$_terms.patterns[i].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema2.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema2.$_terms.keys && !schema2.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema2._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema2._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema2.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths, options) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = { ...desc.options, separator: this.peers[0].separator };
        }
        if (this.options.isPresent) {
          desc.options = { ...desc.options, isPresent: this.options.isPresent };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i = 0; i < result.length; ++i) {
          keys.set(result[i].key, i);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/joi/lib/types/function.js
var require_function = __commonJS({
  "node_modules/joi/lib/types/function.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/joi/lib/types/link.js
var require_link = __commonJS({
  "node_modules/joi/lib/types/link.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, manifest: "single", register: false }
      },
      args(schema2, ref) {
        return schema2.ref(ref);
      },
      validate(value, { schema: schema2, state, prefs }) {
        Assert(schema2.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema2, value, state, prefs);
        const ref = schema2.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema2, value, state, prefs) {
        return internals.generate(schema2, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled = true) {
            return this.$_setFlag("relative", enabled);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          Assert(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema2, value, state, prefs) {
      let linked = state.mainstay.links.get(schema2);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema2.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema2, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema2, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema2, state, prefs);
      if (!schema2._flags.relative) {
        state.mainstay.links.set(schema2, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema: schema2, key } of state.schemas) {
          const id = schema2._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema2, path: ref.path.slice(1) };
          }
          if (schema2.$_terms.shared) {
            for (const shared of schema2.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema2, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema2._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/joi/lib/types/number.js
var require_number = __commonJS({
  "node_modules/joi/lib/types/number.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
      exponentialPartRegex: /[eE][+-]?\d+$/,
      leadingSignAndZerosRegex: /^[+-]?(0*)?/,
      dotRegex: /\./,
      trailingZerosRegex: /0+$/,
      decimalPlaces(value) {
        const str = value.toString();
        const dindex = str.indexOf(".");
        const eindex = str.indexOf("e");
        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
      }
    };
    module.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema2._flags.unsafe) {
            if (value.match(/e/i)) {
              if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string = result.value.toString();
              if (string.match(/e/i)) {
                return result;
              }
              if (string !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema2.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema2._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base) {
            const baseDecimalPlace = typeof base === "number" ? internals.decimalPlaces(base) : null;
            const pfactor = Math.pow(10, baseDecimalPlace);
            return this.$_addRule({
              name: "multiple",
              args: {
                base,
                baseDecimalPlace,
                pfactor
              }
            });
          },
          validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {
            const valueDecimalPlace = internals.decimalPlaces(value);
            if (valueDecimalPlace > baseDecimalPlace) {
              return helpers.error("number.multiple", { multiple: options.args.base, value });
            }
            return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ? value : helpers.error("number.multiple", { multiple: options.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            },
            "baseDecimalPlace",
            "pfactor"
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign) {
            Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
            return this.$_addRule({ name: "sign", args: { sign } });
          },
          validate(value, helpers, { sign }) {
            if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign}`);
          }
        },
        unsafe: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.extractSignificantDigits = function(value) {
      return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/joi/lib/types/object.js
var require_object = __commonJS({
  "node_modules/joi/lib/types/object.js"(exports, module) {
    "use strict";
    init_register();
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/@sideway/address/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/@sideway/address/lib/errors.js"(exports) {
    "use strict";
    init_register();
    exports.codes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    exports.code = function(code) {
      return { code, error: exports.codes[code] };
    };
  }
});

// node_modules/@sideway/address/lib/domain.js
var require_domain = __commonJS({
  "node_modules/@sideway/address/lib/domain.js"(exports) {
    "use strict";
    init_register();
    var Url = __require("url");
    var Errors = require_errors2();
    var internals = {
      minDomainSegments: 2,
      nonAsciiRx: /[^\x00-\x7f]/,
      domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
      // Control + space + separators
      tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      URL: Url.URL || URL
      // $lab:coverage:ignore$
    };
    exports.analyze = function(domain, options = {}) {
      if (!domain) {
        return Errors.code("DOMAIN_NON_EMPTY_STRING");
      }
      if (typeof domain !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (domain.length > 256) {
        return Errors.code("DOMAIN_TOO_LONG");
      }
      const ascii = !internals.nonAsciiRx.test(domain);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain = domain.normalize("NFC");
      }
      if (internals.domainControlRx.test(domain)) {
        return Errors.code("DOMAIN_INVALID_CHARS");
      }
      domain = internals.punycode(domain);
      if (options.allowFullyQualified && domain[domain.length - 1] === ".") {
        domain = domain.slice(0, -1);
      }
      const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
      const segments = domain.split(".");
      if (segments.length < minDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT");
      }
      if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
          return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds = options.tlds;
      if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
          return Errors.code("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return Errors.code("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return Errors.code("DOMAIN_LONG_SEGMENT");
        }
        if (i < segments.length - 1) {
          if (!internals.domainSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_CHARS");
          }
        } else {
          if (!internals.tldSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    };
    exports.isValid = function(domain, options) {
      return !exports.analyze(domain, options);
    };
    internals.punycode = function(domain) {
      if (domain.includes("%")) {
        domain = domain.replace(/%/g, "%25");
      }
      try {
        return new internals.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});

// node_modules/@sideway/address/lib/email.js
var require_email = __commonJS({
  "node_modules/@sideway/address/lib/email.js"(exports) {
    "use strict";
    init_register();
    var Util = __require("util");
    var Domain = require_domain();
    var Errors = require_errors2();
    var internals = {
      nonAsciiRx: /[^\x00-\x7f]/,
      encoder: new (Util.TextEncoder || TextEncoder)()
      // $lab:coverage:ignore$
    };
    exports.analyze = function(email, options) {
      return internals.email(email, options);
    };
    exports.isValid = function(email, options) {
      return !internals.email(email, options);
    };
    internals.email = function(email, options = {}) {
      if (typeof email !== "string") {
        throw new Error("Invalid input: email must be a string");
      }
      if (!email) {
        return Errors.code("EMPTY_STRING");
      }
      const ascii = !internals.nonAsciiRx.test(email);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("FORBIDDEN_UNICODE");
        }
        email = email.normalize("NFC");
      }
      const parts = email.split("@");
      if (parts.length !== 2) {
        return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
      }
      const [local, domain] = parts;
      if (!local) {
        return Errors.code("EMPTY_LOCAL");
      }
      if (!options.ignoreLength) {
        if (email.length > 254) {
          return Errors.code("ADDRESS_TOO_LONG");
        }
        if (internals.encoder.encode(local).length > 64) {
          return Errors.code("LOCAL_TOO_LONG");
        }
      }
      return internals.local(local, ascii) || Domain.analyze(domain, options);
    };
    internals.local = function(local, ascii) {
      const segments = local.split(".");
      for (const segment of segments) {
        if (!segment.length) {
          return Errors.code("EMPTY_LOCAL_SEGMENT");
        }
        if (ascii) {
          if (!internals.atextRx.test(segment)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
          continue;
        }
        for (const char of segment) {
          if (internals.atextRx.test(char)) {
            continue;
          }
          const binary = internals.binary(char);
          if (!internals.atomRx.test(binary)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
        }
      }
    };
    internals.binary = function(char) {
      return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
    };
    internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    internals.atomRx = new RegExp([
      //  %xC2-DF UTF8-tail
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeRegex.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});

// node_modules/@sideway/address/lib/uri.js
var require_uri = __commonJS({
  "node_modules/@sideway/address/lib/uri.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var internals = {};
    internals.generate = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
      rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
      const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
      const port = "\\d*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
      rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
      rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
      rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
      rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      return rfc3986;
    };
    internals.rfc3986 = internals.generate();
    exports.ip = {
      v4Cidr: internals.rfc3986.ipv4Cidr,
      v6Cidr: internals.rfc3986.ipv6Cidr,
      ipv4: internals.rfc3986.ipv4address,
      ipv6: internals.rfc3986.ipv6address,
      ipvfuture: internals.rfc3986.ipvFuture
    };
    internals.createRegex = function(options) {
      const rfc = internals.rfc3986;
      const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
      const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
      const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
      if (options.relativeOnly) {
        return internals.wrap(relative + suffix);
      }
      let customScheme = "";
      if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
          const scheme2 = schemes[i];
          Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
          if (scheme2 instanceof RegExp) {
            selections.push(scheme2.source.toString());
          } else {
            Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
            selections.push(EscapeRegex(scheme2));
          }
        }
        customScheme = selections.join("|");
      }
      const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
      const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
      const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
      return internals.wrap(prefix + suffix, customScheme);
    };
    internals.wrap = function(raw, scheme) {
      raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
      return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
      };
    };
    internals.uriRegex = internals.createRegex({});
    exports.regex = function(options = {}) {
      if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
        return internals.createRegex(options);
      }
      return internals.uriRegex;
    };
  }
});

// node_modules/@sideway/address/lib/ip.js
var require_ip = __commonJS({
  "node_modules/@sideway/address/lib/ip.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Uri = require_uri();
    exports.regex = function(options = {}) {
      Assert(options.cidr === void 0 || typeof options.cidr === "string", "options.cidr must be a string");
      const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
      Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
      Assert(options.version === void 0 || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
      let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      Assert(versions.length >= 1, "options.version must have at least 1 version specified");
      for (let i = 0; i < versions.length; ++i) {
        Assert(typeof versions[i] === "string", "options.version must only contain strings");
        versions[i] = versions[i].toLowerCase();
        Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
      }
      versions = Array.from(new Set(versions));
      const parts = versions.map((version) => {
        if (cidr === "forbidden") {
          return Uri.ip[version];
        }
        const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
        if (cidr === "required") {
          return `${Uri.ip[version]}${cidrpart}`;
        }
        return `${Uri.ip[version]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      const regex = new RegExp(`^${raw}$`);
      return { cidr, versions, regex, raw };
    };
  }
});

// node_modules/@sideway/address/lib/tlds.js
var require_tlds = __commonJS({
  "node_modules/@sideway/address/lib/tlds.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    internals.tlds = [
      "AAA",
      "AARP",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMAZON",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AVIANCA",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BENTLEY",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CASA",
      "CASE",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CC",
      "CD",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMCAST",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CPA",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DABUR",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ET",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUARDIAN",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYLOGISTICS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIDS",
      "KIM",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LAMBORGHINI",
      "LAMER",
      "LANCASTER",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINK",
      "LIPSY",
      "LIVE",
      "LIVING",
      "LK",
      "LLC",
      "LLP",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUSIC",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NAGOYA",
      "NAME",
      "NATURA",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAMERICA",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "RACING",
      "RADIO",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDSTONE",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIL",
      "RIO",
      "RIP",
      "RO",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHAW",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPA",
      "SPACE",
      "SPORT",
      "SPOT",
      "SR",
      "SRL",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XFINITY",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4DBRK0CE",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CCKWCXETD",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ480N2RG",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBCPQ6GPA1A",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q7CE6A",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
    module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
  }
});

// node_modules/joi/lib/types/string.js
var require_string = __commonJS({
  "node_modules/joi/lib/types/string.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Domain = require_domain();
    var Email = require_email();
    var Ip = require_ip();
    var EscapeRegex = require_escapeRegex();
    var Tlds = require_tlds();
    var Uri = require_uri();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
      // $lab:coverage:ignore$
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: {
        withPrefix: /^0x[0-9a-f]+$/i,
        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
        withoutPrefix: /^[0-9a-f]+$/i
      },
      ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5",
        uuidv6: "6",
        uuidv7: "7",
        uuidv8: "8"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    module.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, state, prefs }) {
          const normalize = schema2.$_getRule("normalize");
          if (normalize) {
            value = value.normalize(normalize.args.form);
          }
          const casing = schema2.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema2.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema2.$_terms.replacements) {
            for (const replacement of schema2.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema2.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema2.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema2._flags.truncate) {
            const rule = schema2.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema2.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { schema: schema2, error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          const min = schema2.$_getRule("min");
          if (min && min.args.limit === 0) {
            return;
          }
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
            options = { urlSafe: false, paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options } });
          },
          validate(value, helpers, { options }) {
            const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i = value.length;
            let sum = 0;
            let mul = 1;
            while (i--) {
              const char = value.charAt(i) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired"]);
            options = { paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options } });
          },
          validate(value, helpers, { options }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options) {
            if (options) {
              Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const address = internals.addressOptions(options);
            return this.$_addRule({ name: "domain", args: { options }, address });
          },
          validate(value, helpers, args, { address }) {
            if (Domain.isValid(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options = {}) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
            Assert(options.multiple === void 0 || typeof options.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options);
            const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
            return this.$_addRule({ name: "email", args: { options }, regex, address });
          },
          validate(value, helpers, { options }, { regex, address }) {
            const emails = options.multiple ? value.split(regex) : [value];
            const invalids = [];
            for (const email of emails) {
              if (!Email.isValid(email, address)) {
                invalids.push(email);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", { value, invalids });
          }
        },
        guid: {
          alias: "uuid",
          method(options = {}) {
            Common.assertOptions(options, ["version", "separator"]);
            let versionNumbers = "";
            if (options.version) {
              const versions = [].concat(options.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i = 0; i < versions.length; ++i) {
                const version = versions[i];
                Assert(typeof version === "string", "version at position " + i + " must be a string");
                const versionNumber = internals.guidVersions[version.toLowerCase()];
                Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options.separator === void 0 ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options = {}) {
            Common.assertOptions(options, ["byteAligned", "prefix"]);
            options = { byteAligned: false, prefix: false, ...options };
            Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
            Assert(typeof options.prefix === "boolean" || options.prefix === "optional", 'prefix must be boolean or "optional"');
            return this.$_addRule({ name: "hex", args: { options } });
          },
          validate(value, helpers, { options }) {
            const re = options.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
            if (!re.test(value)) {
              return helpers.error("string.hex");
            }
            if (options.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options = {}) {
            Common.assertOptions(options, ["cidr", "version"]);
            const { cidr, versions, regex } = Ip.regex(options);
            const version = options.version ? versions : void 0;
            return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
          },
          validate(value, helpers, { options }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options.version) {
              return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
            }
            return helpers.error("string.ip", { value, cidr: options.cidr });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options === "string") {
              options = { name: options };
            }
            Common.assertOptions(options, ["invert", "name"]);
            const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
          },
          validate(value, helpers, { regex, options }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled } });
          },
          validate(value, helpers, { enabled }) {
            if (!enabled || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options = {}) {
            Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]);
            if (options.domain) {
              Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const { regex, scheme } = Uri.regex(options);
            const domain = options.domain ? internals.addressOptions(options.domain) : null;
            return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
          },
          validate(value, helpers, { options }, { regex, domain, scheme }) {
            if (["http:/", "https:/"].includes(value)) {
              return helpers.error("string.uri");
            }
            const match = regex.exec(value);
            if (match) {
              const matched = match[1] || match[2];
              if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {
                return helpers.error("string.domain", { value: matched });
              }
              return value;
            }
            if (options.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options.scheme) {
              return helpers.error("string.uriCustomScheme", { scheme, value });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options) {
      if (!options) {
        return internals.tlds || options;
      }
      Assert(options.minDomainSegments === void 0 || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      Assert(options.maxDomainSegments === void 0 || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
      if (options.tlds === false) {
        return options;
      }
      if (options.tlds === true || options.tlds === void 0) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
      const deny = options.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }
        Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        internals.validateTlds(options.tlds.deny, "tlds.deny");
        return options;
      }
      const allow = options.tlds.allow;
      if (!allow) {
        return options;
      }
      if (allow === true) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
      }
      Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      internals.validateTlds(options.tlds.allow, "tlds.allow");
      return options;
    };
    internals.validateTlds = function(set, source) {
      for (const tld of set) {
        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
      }
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      if (/.*T.*[+-]\d\d$/.test(value)) {
        value += "00";
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date.toISOString();
    };
    internals.length = function(schema2, name, limit, operator, encoding) {
      Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema2.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
  }
});

// node_modules/joi/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/joi/lib/types/symbol.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module.exports = Any.extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema: schema2, error }) {
          const lookup = schema2.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema2._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema2.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols.push(value);
            }
            return obj.valid(...symbols);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/joi/lib/types/binary.js
var require_binary = __commonJS({
  "node_modules/joi/lib/types/binary.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module.exports = Any.extend({
      type: "binary",
      coerce: {
        from: ["string", "object"],
        method(value, { schema: schema2 }) {
          if (typeof value === "string" || value !== null && value.type === "Buffer") {
            try {
              return { value: Buffer.from(value, schema2._flags.encoding) };
            } catch (ignoreErr) {
            }
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/joi/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/joi/lib/index.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Ref = require_ref();
    var Template = require_template();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema2, ...args) {
        internals.assert(value, schema2, true, args);
      },
      attempt(value, schema2, ...args) {
        return internals.assert(value, schema2, false, args);
      },
      build(desc) {
        Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema2, options) {
        return Compile.compile(this, schema2, options);
      },
      defaults(modifier) {
        Assert(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema2 = modifier(joi[type]());
          Assert(Common.isSchema(schema2), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema2, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas();
        Assert(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            Assert(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base = item.base || this.any();
            const schema2 = Extend.type(base, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema2, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema2, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options = message !== null ? args[1] : args[0];
      const result = schema2.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema2, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema2.$_root = root;
      if (!schema2._definition.args || !args.length) {
        return schema2;
      }
      return schema2._definition.args(schema2, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [extension];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module.exports = internals.root();
  }
});

// src/handlers/hello1.js
init_register();

// src/schemas/common.js
init_register();
function generateErrorResponses(statusCodes, when) {
  const responses = [];
  const postText = "The examples show all possible `code` and `message` values, not limited to this endpoint.";
  if (statusCodes.includes(400)) {
    responses.push({
      statusCode: 400,
      responseBody: {
        description: `An error message when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ErrorResponse"
      }
    });
  }
  if (statusCodes.includes(401)) {
    responses.push({
      statusCode: 401,
      responseBody: {
        description: `Unauthorised user when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "UnauthorizedResponse"
      }
    });
  }
  if (statusCodes.includes(403)) {
    responses.push({
      statusCode: 403,
      responseBody: {
        description: `Forbidden when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ForbiddenResponse"
      }
    });
  }
  if (statusCodes.includes(404)) {
    responses.push({
      statusCode: 404,
      responseBody: {
        description: `Resource not found when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "NotFoundResponse"
      }
    });
  }
  if (statusCodes.includes(429)) {
    responses.push({
      statusCode: 429,
      responseBody: {
        description: `Rate limited when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "RateLimitedResponse"
      }
    });
  }
  if (statusCodes.includes(500)) {
    responses.push({
      statusCode: 500,
      responseBody: {
        description: `A server error when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ServerErrorResponse"
      }
    });
  }
  return responses;
}
__name(generateErrorResponses, "generateErrorResponses");

// src/schemas/validator.js
init_register();
var import_date = __toESM(require_lib(), 1);
var import_joi = __toESM(require_lib5(), 1);
var Joi = import_joi.default.extend(import_date.default);

// src/handlers/hello1.js
var documentation = {
  summary: "Hello 1",
  tags: ["Hello One Section"],
  description: "Hello 1 template.",
  methodResponses: [
    {
      statusCode: 200,
      responseBody: {
        description: "An object returning hello1: true."
      },
      responseModels: {
        "application/json": "HelloOneSchema"
      }
    },
    ...generateErrorResponses([400, 401, 404, 500], "getting hello 1")
  ]
};
var schema = {
  response: Joi.object({
    hello1: Joi.boolean().required()
  })
};
var handler = /* @__PURE__ */ __name(async () => {
  return {
    statusCode: 200,
    body: JSON.stringify({
      hello1: true
    })
  };
}, "handler");
export {
  documentation,
  handler,
  schema
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3NvdXJjZS1tYXAtc3VwcG9ydC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aam9pL2RhdGUvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9zdHJpbmdpZnkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Vycm9yLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hc3NlcnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3JlYWNoLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi90eXBlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Nsb25lLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvcGFja2FnZS5qc29uIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZUh0bWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2Zvcm11bGEvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Fubm90YXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Vycm9ycy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9yZWYuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdGVtcGxhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWVzc2FnZXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NhY2hlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbXBpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXh0ZW5kLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL21hbmlmZXN0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L3BpbnBvaW50L2xpYi9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90cmFjZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvbWVyZ2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbW9kaWZ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9pZ25vcmUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvc3RhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdmFsaWRhdG9yLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3ZhbHVlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FueS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYXJyYXkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYm9vbGVhbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL3RvcG8vbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2tleXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvbGluay5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9udW1iZXIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvb2JqZWN0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi9lcnJvcnMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2RvbWFpbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi91cmkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2lwLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi90bGRzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N0cmluZy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zeW1ib2wuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYmluYXJ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9oYW5kbGVycy9oZWxsbzEuanMiLCAiLi4vLi4vLi4vLi4vc3JjL3NjaGVtYXMvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9zY2hlbWFzL3ZhbGlkYXRvci5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICBcdTIwMUNzb3VyY2VzXHUyMDFEIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIFx1MjAxQ3NvdXJjZVx1MjAxRCBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAgXHUyMDFDc291cmNlUm9vdFx1MjAxRCwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwgIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgc291cmNlUmVsYXRpdmUgPSBzb3VyY2VGaWxlO1xuICAgICAgaWYgKHNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc291cmNlUmVsYXRpdmUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKSB7XG4gICAgICAgIGdlbmVyYXRvci5fc291cmNlcy5hZGQoc291cmNlUmVsYXRpdmUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIC8vIFdoZW4gYU9yaWdpbmFsIGlzIHRydXRoeSBidXQgaGFzIGVtcHR5IHZhbHVlcyBmb3IgLmxpbmUgYW5kIC5jb2x1bW4sXG4gICAgLy8gaXQgaXMgbW9zdCBsaWtlbHkgYSBwcm9ncmFtbWVyIGVycm9yLiBJbiB0aGlzIGNhc2Ugd2UgdGhyb3cgYSB2ZXJ5XG4gICAgLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyLWJ1bmRsZXIvcHVsbC81MTlcbiAgICBpZiAoYU9yaWdpbmFsICYmIHR5cGVvZiBhT3JpZ2luYWwubGluZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcgK1xuICAgICAgICAgICAgJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnICtcbiAgICAgICAgICAgICdudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuIiwgIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCAiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCAiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsICIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxudmFyIGlzTW9kZXJuID0gKFxuICB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nXG4pXG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKGlucHV0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGlucHV0KS5zbGljZSg4LCAtMSkgPT09ICdBcnJheUJ1ZmZlcidcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBieXRlT2Zmc2V0ID4+Pj0gMFxuXG4gIHZhciBtYXhMZW5ndGggPSBvYmouYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXRcblxuICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID4+Pj0gMFxuXG4gICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpXG4gICAgOiBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KG9iai5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSkpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKVxuICAgIDogbmV3IEJ1ZmZlcihzdHJpbmcsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBidWZmZXJGcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgIDogbmV3IEJ1ZmZlcih2YWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWZmZXJGcm9tXG4iLCAidmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcENvbnN1bWVyO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmcztcbnRyeSB7XG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jIHx8ICFmcy5yZWFkRmlsZVN5bmMpIHtcbiAgICAvLyBmcyBkb2Vzbid0IGhhdmUgYWxsIG1ldGhvZHMgd2UgbmVlZFxuICAgIGZzID0gbnVsbDtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIG5vcCAqL1xufVxuXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJyk7XG5cbi8qKlxuICogUmVxdWlyZXMgYSBtb2R1bGUgd2hpY2ggaXMgcHJvdGVjdGVkIGFnYWluc3QgYnVuZGxlciBtaW5pZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtOb2RlTW9kdWxlfSBtb2RcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWNSZXF1aXJlKG1vZCwgcmVxdWVzdCkge1xuICByZXR1cm4gbW9kLnJlcXVpcmUocmVxdWVzdCk7XG59XG5cbi8vIE9ubHkgaW5zdGFsbCBvbmNlIGlmIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xudmFyIGVycm9yRm9ybWF0dGVySW5zdGFsbGVkID0gZmFsc2U7XG52YXIgdW5jYXVnaHRTaGltSW5zdGFsbGVkID0gZmFsc2U7XG5cbi8vIElmIHRydWUsIHRoZSBjYWNoZXMgYXJlIHJlc2V0IGJlZm9yZSBhIHN0YWNrIHRyYWNlIGZvcm1hdHRpbmcgb3BlcmF0aW9uXG52YXIgZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zID0gZmFsc2U7XG5cbi8vIFN1cHBvcnRzIHticm93c2VyLCBub2RlLCBhdXRvfVxudmFyIGVudmlyb25tZW50ID0gXCJhdXRvXCI7XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSBjb250ZW50c1xudmFyIGZpbGVDb250ZW50c0NhY2hlID0ge307XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzb3VyY2UgbWFwIGZvciB0aGF0IGZpbGVcbnZhciBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuXG4vLyBSZWdleCBmb3IgZGV0ZWN0aW5nIHNvdXJjZSBtYXBzXG52YXIgcmVTb3VyY2VNYXAgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uW14sXStiYXNlNjQsLztcblxuLy8gUHJpb3JpdHkgbGlzdCBvZiByZXRyaWV2ZSBoYW5kbGVyc1xudmFyIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gW107XG52YXIgcmV0cmlldmVNYXBIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBpc0luQnJvd3NlcigpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcImJyb3dzZXJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcIm5vZGVcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSAmJiAhKHdpbmRvdy5yZXF1aXJlICYmIHdpbmRvdy5tb2R1bGUgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiKSk7XG59XG5cbmZ1bmN0aW9uIGhhc0dsb2JhbFByb2Nlc3NFdmVudEVtaXR0ZXIoKSB7XG4gIHJldHVybiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gJ2Z1bmN0aW9uJykpO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxQcm9jZXNzVmVyc2lvbigpIHtcbiAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIChwcm9jZXNzICE9PSBudWxsKSkge1xuICAgIHJldHVybiBwcm9jZXNzLnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdsb2JhbFByb2Nlc3NTdGRlcnIoKSB7XG4gIGlmICgodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKSAmJiAocHJvY2VzcyAhPT0gbnVsbCkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2xvYmFsUHJvY2Vzc0V4aXQoY29kZSkge1xuICBpZiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5leGl0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHJldHVybiBwcm9jZXNzLmV4aXQoY29kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlckV4ZWMobGlzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gbGlzdFtpXShhcmcpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcblxucmV0cmlldmVGaWxlSGFuZGxlcnMucHVzaChmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFRyaW0gdGhlIHBhdGggdG8gbWFrZSBzdXJlIHRoZXJlIGlzIG5vIGV4dHJhIHdoaXRlc3BhY2UuXG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgaWYgKC9eZmlsZTovLnRlc3QocGF0aCkpIHtcbiAgICAvLyBleGlzdHNTeW5jL3JlYWRGaWxlU3luYyBjYW4ndCBoYW5kbGUgZmlsZSBwcm90b2NvbCwgYnV0IG9uY2Ugc3RyaXBwZWQsIGl0IHdvcmtzXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvZmlsZTpcXC9cXC9cXC8oXFx3Oik/LywgZnVuY3Rpb24ocHJvdG9jb2wsIGRyaXZlKSB7XG4gICAgICByZXR1cm4gZHJpdmUgP1xuICAgICAgICAnJyA6IC8vIGZpbGU6Ly8vQzovZGlyL2ZpbGUgLT4gQzovZGlyL2ZpbGVcbiAgICAgICAgJy8nOyAvLyBmaWxlOi8vL3Jvb3QtZGlyL2ZpbGUgLT4gL3Jvb3QtZGlyL2ZpbGVcbiAgICB9KTtcbiAgfVxuICBpZiAocGF0aCBpbiBmaWxlQ29udGVudHNDYWNoZSkge1xuICAgIHJldHVybiBmaWxlQ29udGVudHNDYWNoZVtwYXRoXTtcbiAgfVxuXG4gIHZhciBjb250ZW50cyA9ICcnO1xuICB0cnkge1xuICAgIGlmICghZnMpIHtcbiAgICAgIC8vIFVzZSBTSkFYIGlmIHdlIGFyZSBpbiB0aGUgYnJvd3NlclxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIC8qKiBhc3luYyAqLyBmYWxzZSk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29udGVudHMgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4Jyk7XG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIC8qIGlnbm9yZSBhbnkgZXJyb3JzICovXG4gIH1cblxuICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF0gPSBjb250ZW50cztcbn0pO1xuXG4vLyBTdXBwb3J0IFVSTHMgcmVsYXRpdmUgdG8gYSBkaXJlY3RvcnksIGJ1dCBiZSBjYXJlZnVsIGFib3V0IGEgcHJvdG9jb2wgcHJlZml4XG4vLyBpbiBjYXNlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciAoaS5lLiBkaXJlY3RvcmllcyBtYXkgc3RhcnQgd2l0aCBcImh0dHA6Ly9cIiBvciBcImZpbGU6Ly8vXCIpXG5mdW5jdGlvbiBzdXBwb3J0UmVsYXRpdmVVUkwoZmlsZSwgdXJsKSB7XG4gIGlmICghZmlsZSkgcmV0dXJuIHVybDtcbiAgdmFyIGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgdmFyIG1hdGNoID0gL15cXHcrOlxcL1xcL1teXFwvXSovLmV4ZWMoZGlyKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICB2YXIgc3RhcnRQYXRoID0gZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCk7XG4gIGlmIChwcm90b2NvbCAmJiAvXlxcL1xcd1xcOi8udGVzdChzdGFydFBhdGgpKSB7XG4gICAgLy8gaGFuZGxlIGZpbGU6Ly8vQzovIHBhdGhzXG4gICAgcHJvdG9jb2wgKz0gJy8nO1xuICAgIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cbiAgcmV0dXJuIHByb3RvY29sICsgcGF0aC5yZXNvbHZlKGRpci5zbGljZShwcm90b2NvbC5sZW5ndGgpLCB1cmwpO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpIHtcbiAgdmFyIGZpbGVEYXRhO1xuXG4gIGlmIChpc0luQnJvd3NlcigpKSB7XG4gICAgIHRyeSB7XG4gICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgIHhoci5vcGVuKCdHRVQnLCBzb3VyY2UsIGZhbHNlKTtcbiAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICBmaWxlRGF0YSA9IHhoci5yZWFkeVN0YXRlID09PSA0ID8geGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG5cbiAgICAgICAvLyBTdXBwb3J0IHByb3ZpZGluZyBhIHNvdXJjZU1hcHBpbmdVUkwgdmlhIHRoZSBTb3VyY2VNYXAgaGVhZGVyXG4gICAgICAgdmFyIHNvdXJjZU1hcEhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIlNvdXJjZU1hcFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJYLVNvdXJjZU1hcFwiKTtcbiAgICAgICBpZiAoc291cmNlTWFwSGVhZGVyKSB7XG4gICAgICAgICByZXR1cm4gc291cmNlTWFwSGVhZGVyO1xuICAgICAgIH1cbiAgICAgfSBjYXRjaCAoZSkge1xuICAgICB9XG4gIH1cblxuICAvLyBHZXQgdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBmaWxlRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2UpO1xuICB2YXIgcmUgPSAvKD86XFwvXFwvW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspW1xcc10qJCl8KD86XFwvXFwqW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzKidcIl0rKVtcXHNdKig/OlxcKlxcLylbXFxzXSokKS9tZztcbiAgLy8gS2VlcCBleGVjdXRpbmcgdGhlIHNlYXJjaCB0byBmaW5kIHRoZSAqbGFzdCogc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZFxuICAvLyBwaWNraW5nIHVwIHNvdXJjZU1hcHBpbmdVUkxzIGZyb20gY29tbWVudHMsIHN0cmluZ3MsIGV0Yy5cbiAgdmFyIGxhc3RNYXRjaCwgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZmlsZURhdGEpKSBsYXN0TWF0Y2ggPSBtYXRjaDtcbiAgaWYgKCFsYXN0TWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4gbGFzdE1hdGNoWzFdO1xufTtcblxuLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHJldHJpZXZlU291cmNlTWFwIG9wdGlvbiB0byBpbnN0YWxsLiBUYWtlcyBhXG4vLyBnZW5lcmF0ZWQgc291cmNlIGZpbGVuYW1lOyByZXR1cm5zIGEge21hcCwgb3B0aW9uYWwgdXJsfSBvYmplY3QsIG9yIG51bGwgaWZcbi8vIHRoZXJlIGlzIG5vIHNvdXJjZSBtYXAuICBUaGUgbWFwIGZpZWxkIG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgdGhlIHBhcnNlZFxuLy8gSlNPTiBvYmplY3QgKGllLCBpdCBtdXN0IGJlIGEgdmFsaWQgYXJndW1lbnQgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyXG4vLyBjb25zdHJ1Y3RvcikuXG52YXIgcmV0cmlldmVTb3VyY2VNYXAgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZU1hcEhhbmRsZXJzKTtcbnJldHJpZXZlTWFwSGFuZGxlcnMucHVzaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZU1hcHBpbmdVUkwgPSByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpO1xuICBpZiAoIXNvdXJjZU1hcHBpbmdVUkwpIHJldHVybiBudWxsO1xuXG4gIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzb3VyY2UgbWFwXG4gIHZhciBzb3VyY2VNYXBEYXRhO1xuICBpZiAocmVTb3VyY2VNYXAudGVzdChzb3VyY2VNYXBwaW5nVVJMKSkge1xuICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkwgYXMgYSBkYXRhIHVybFxuICAgIHZhciByYXdEYXRhID0gc291cmNlTWFwcGluZ1VSTC5zbGljZShzb3VyY2VNYXBwaW5nVVJMLmluZGV4T2YoJywnKSArIDEpO1xuICAgIHNvdXJjZU1hcERhdGEgPSBidWZmZXJGcm9tKHJhd0RhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgc291cmNlTWFwcGluZ1VSTCA9IHNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMcyByZWxhdGl2ZSB0byB0aGUgc291cmNlIFVSTFxuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzdXBwb3J0UmVsYXRpdmVVUkwoc291cmNlLCBzb3VyY2VNYXBwaW5nVVJMKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gcmV0cmlldmVGaWxlKHNvdXJjZU1hcHBpbmdVUkwpO1xuICB9XG5cbiAgaWYgKCFzb3VyY2VNYXBEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVybDogc291cmNlTWFwcGluZ1VSTCxcbiAgICBtYXA6IHNvdXJjZU1hcERhdGFcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBtYXBTb3VyY2VQb3NpdGlvbihwb3NpdGlvbikge1xuICB2YXIgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXTtcbiAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAvLyBDYWxsIHRoZSAob3ZlcnJpZGVhYmxlKSByZXRyaWV2ZVNvdXJjZU1hcCBmdW5jdGlvbiB0byBnZXQgdGhlIHNvdXJjZSBtYXAuXG4gICAgdmFyIHVybEFuZE1hcCA9IHJldHJpZXZlU291cmNlTWFwKHBvc2l0aW9uLnNvdXJjZSk7XG4gICAgaWYgKHVybEFuZE1hcCkge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiB1cmxBbmRNYXAudXJsLFxuICAgICAgICBtYXA6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1cmxBbmRNYXAubWFwKVxuICAgICAgfTtcblxuICAgICAgLy8gTG9hZCBhbGwgc291cmNlcyBzdG9yZWQgaW5saW5lIHdpdGggdGhlIHNvdXJjZSBtYXAgaW50byB0aGUgZmlsZSBjYWNoZVxuICAgICAgLy8gdG8gcHJldGVuZCBsaWtlIHRoZXkgYXJlIGFscmVhZHkgbG9hZGVkLiBUaGV5IG1heSBub3QgZXhpc3Qgb24gZGlzay5cbiAgICAgIGlmIChzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHNvdXJjZU1hcC5tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSwgaSkge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHNvdXJjZU1hcC5tYXAuc291cmNlc0NvbnRlbnRbaV07XG4gICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZU1hcC51cmwsIHNvdXJjZSk7XG4gICAgICAgICAgICBmaWxlQ29udGVudHNDYWNoZVt1cmxdID0gY29udGVudHM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBtYXA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgc291cmNlIFVSTCByZWxhdGl2ZSB0byB0aGUgVVJMIG9mIHRoZSBzb3VyY2UgbWFwXG4gIGlmIChzb3VyY2VNYXAgJiYgc291cmNlTWFwLm1hcCAmJiB0eXBlb2Ygc291cmNlTWFwLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG9yaWdpbmFsUG9zaXRpb24gPSBzb3VyY2VNYXAubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IocG9zaXRpb24pO1xuXG4gICAgLy8gT25seSByZXR1cm4gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlmIGEgbWF0Y2hpbmcgbGluZSB3YXMgZm91bmQuIElmIG5vXG4gICAgLy8gbWF0Y2hpbmcgbGluZSBpcyBmb3VuZCB0aGVuIHdlIHJldHVybiBwb3NpdGlvbiBpbnN0ZWFkLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIHRvIHByaW50IHRoZSBwYXRoIGFuZCBsaW5lIGZvciB0aGUgY29tcGlsZWQgZmlsZS4gSXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSBhIHByZWNpc2UgbG9jYXRpb24gaW4gdGhlIGNvbXBpbGVkIGZpbGUgdGhhbiBhIHZhZ3VlXG4gICAgLy8gbG9jYXRpb24gaW4gdGhlIG9yaWdpbmFsIGZpbGUuXG4gICAgaWYgKG9yaWdpbmFsUG9zaXRpb24uc291cmNlICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9IHN1cHBvcnRSZWxhdGl2ZVVSTChcbiAgICAgICAgc291cmNlTWFwLnVybCwgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UpO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vLyBQYXJzZXMgY29kZSBnZW5lcmF0ZWQgYnkgRm9ybWF0RXZhbE9yaWdpbigpLCBhIGZ1bmN0aW9uIGluc2lkZSBWODpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanNcbmZ1bmN0aW9uIG1hcEV2YWxPcmlnaW4ob3JpZ2luKSB7XG4gIC8vIE1vc3QgZXZhbCgpIGNhbGxzIGFyZSBpbiB0aGlzIGZvcm1hdFxuICB2YXIgbWF0Y2ggPSAvXmV2YWwgYXQgKFteKF0rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogbWF0Y2hbMl0sXG4gICAgICBsaW5lOiArbWF0Y2hbM10sXG4gICAgICBjb2x1bW46IG1hdGNoWzRdIC0gMVxuICAgIH0pO1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgcG9zaXRpb24uc291cmNlICsgJzonICtcbiAgICAgIHBvc2l0aW9uLmxpbmUgKyAnOicgKyAocG9zaXRpb24uY29sdW1uICsgMSkgKyAnKSc7XG4gIH1cblxuICAvLyBQYXJzZSBuZXN0ZWQgZXZhbCgpIGNhbGxzIHVzaW5nIHJlY3Vyc2lvblxuICBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgbWFwRXZhbE9yaWdpbihtYXRjaFsyXSkgKyAnKSc7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHVzZWZ1bCBpbmZvcm1hdGlvbiBpZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyBUaGlzIGlzIGNvcGllZCBhbG1vc3QgdmVyYmF0aW0gZnJvbSB0aGUgVjggc291cmNlIGNvZGUgYXRcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanMuIFRoZVxuLy8gaW1wbGVtZW50YXRpb24gb2Ygd3JhcENhbGxTaXRlKCkgdXNlZCB0byBqdXN0IGZvcndhcmQgdG8gdGhlIGFjdHVhbCBzb3VyY2Vcbi8vIGNvZGUgb2YgQ2FsbFNpdGUucHJvdG90eXBlLnRvU3RyaW5nIGJ1dCB1bmZvcnR1bmF0ZWx5IGEgbmV3IHJlbGVhc2Ugb2YgVjhcbi8vIGRpZCBzb21ldGhpbmcgdG8gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgYnJva2UgdGhlIHNoaW0uIFRoZSBvbmx5IGZpeCBJXG4vLyBjb3VsZCBmaW5kIHdhcyBjb3B5L3Bhc3RlLlxuZnVuY3Rpb24gQ2FsbFNpdGVUb1N0cmluZygpIHtcbiAgdmFyIGZpbGVOYW1lO1xuICB2YXIgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOYXRpdmUoKSkge1xuICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSB0aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICAgIGlmICghZmlsZU5hbWUgJiYgdGhpcy5pc0V2YWwoKSkge1xuICAgICAgZmlsZUxvY2F0aW9uID0gdGhpcy5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgfVxuXG4gICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXG4gICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCk7XG4gICAgaWYgKGxpbmVOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgbGluZU51bWJlcjtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpO1xuICAgICAgaWYgKGNvbHVtbk51bWJlcikge1xuICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpbmUgPSBcIlwiO1xuICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgdmFyIGFkZFN1ZmZpeCA9IHRydWU7XG4gIHZhciBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc0NvbnN0cnVjdG9yKCk7XG4gIHZhciBpc01ldGhvZENhbGwgPSAhKHRoaXMuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xuICBpZiAoaXNNZXRob2RDYWxsKSB7XG4gICAgdmFyIHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZSgpO1xuICAgIC8vIEZpeGVzIHNoaW0gdG8gYmUgYmFja3dhcmQgY29tcGF0YWJsZSB3aXRoIE5vZGUgdjAgdG8gdjRcbiAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgIHR5cGVOYW1lID0gXCJudWxsXCI7XG4gICAgfVxuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5nZXRNZXRob2ROYW1lKCk7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPSAwKSB7XG4gICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPSBmdW5jdGlvbk5hbWUubGVuZ3RoIC0gbWV0aG9kTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmUgKz0gXCIgW2FzIFwiICsgbWV0aG9kTmFtZSArIFwiXVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCIgKyAobWV0aG9kTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgbGluZSArPSBcIm5ldyBcIiArIChmdW5jdGlvbk5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lICs9IGZpbGVMb2NhdGlvbjtcbiAgICBhZGRTdWZmaXggPSBmYWxzZTtcbiAgfVxuICBpZiAoYWRkU3VmZml4KSB7XG4gICAgbGluZSArPSBcIiAoXCIgKyBmaWxlTG9jYXRpb24gKyBcIilcIjtcbiAgfVxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDYWxsU2l0ZShmcmFtZSkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihmcmFtZSkpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIG9iamVjdFtuYW1lXSA9IC9eKD86aXN8Z2V0KS8udGVzdChuYW1lKSA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVbbmFtZV0uY2FsbChmcmFtZSk7IH0gOiBmcmFtZVtuYW1lXTtcbiAgfSk7XG4gIG9iamVjdC50b1N0cmluZyA9IENhbGxTaXRlVG9TdHJpbmc7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHdyYXBDYWxsU2l0ZShmcmFtZSwgc3RhdGUpIHtcbiAgLy8gcHJvdmlkZXMgaW50ZXJmYWNlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZSA9IHsgbmV4dFBvc2l0aW9uOiBudWxsLCBjdXJQb3NpdGlvbjogbnVsbCB9XG4gIH1cbiAgaWYoZnJhbWUuaXNOYXRpdmUoKSkge1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gbnVsbDtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgdmFyIHNvdXJjZSA9IGZyYW1lLmdldEZpbGVOYW1lKCkgfHwgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgbGluZSA9IGZyYW1lLmdldExpbmVOdW1iZXIoKTtcbiAgICB2YXIgY29sdW1uID0gZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCkgLSAxO1xuXG4gICAgLy8gRml4IHBvc2l0aW9uIGluIE5vZGUgd2hlcmUgc29tZSAoaW50ZXJuYWwpIGNvZGUgaXMgcHJlcGVuZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgLy8gSGVhZGVyIHJlbW92ZWQgaW4gbm9kZSBhdCBeMTAuMTYgfHwgPj0xMS4xMS4wXG4gICAgLy8gdjExIGlzIG5vdCBhbiBMVFMgY2FuZGlkYXRlLCB3ZSBjYW4ganVzdCB0ZXN0IHRoZSBvbmUgdmVyc2lvbiB3aXRoIGl0LlxuICAgIC8vIFRlc3Qgbm9kZSB2ZXJzaW9ucyBmb3I6IDEwLjE2LTE5LCAxMC4yMCssIDEyLTE5LCAyMC05OSwgMTAwKywgb3IgMTEuMTFcbiAgICB2YXIgbm9IZWFkZXIgPSAvXnYoMTBcXC4xWzYtOV18MTBcXC5bMi05XVswLTldfDEwXFwuWzAtOV17Myx9fDFbMi05XVxcZCp8WzItOV1cXGR8XFxkezMsfXwxMVxcLjExKS87XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IG5vSGVhZGVyLnRlc3QoZ2xvYmFsUHJvY2Vzc1ZlcnNpb24oKSkgPyAwIDogNjI7XG4gICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoICYmICFpc0luQnJvd3NlcigpICYmICFmcmFtZS5pc0V2YWwoKSkge1xuICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2x1bW46IGNvbHVtblxuICAgIH0pO1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICB2YXIgb3JpZ2luYWxGdW5jdGlvbk5hbWUgPSBmcmFtZS5nZXRGdW5jdGlvbk5hbWU7XG4gICAgZnJhbWUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhdGUubmV4dFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25OYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubmV4dFBvc2l0aW9uLm5hbWUgfHwgb3JpZ2luYWxGdW5jdGlvbk5hbWUoKTtcbiAgICB9O1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgdmFyIGVycm9yU3RyaW5nID0gbmFtZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cbiAgdmFyIHN0YXRlID0geyBuZXh0UG9zaXRpb246IG51bGwsIGN1clBvc2l0aW9uOiBudWxsIH07XG4gIHZhciBwcm9jZXNzZWRTdGFjayA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwcm9jZXNzZWRTdGFjay5wdXNoKCdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShzdGFja1tpXSwgc3RhdGUpKTtcbiAgICBzdGF0ZS5uZXh0UG9zaXRpb24gPSBzdGF0ZS5jdXJQb3NpdGlvbjtcbiAgfVxuICBzdGF0ZS5jdXJQb3NpdGlvbiA9IHN0YXRlLm5leHRQb3NpdGlvbiA9IG51bGw7XG4gIHJldHVybiBlcnJvclN0cmluZyArIHByb2Nlc3NlZFN0YWNrLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgICBhdCBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICAvLyBFbnN1cmUgZXJyb3IgaXMgcHJpbnRlZCBzeW5jaHJvbm91c2x5IGFuZCBub3QgdHJ1bmNhdGVkXG4gIHZhciBzdGRlcnIgPSBnbG9iYWxQcm9jZXNzU3RkZXJyKCk7XG4gIGlmIChzdGRlcnIgJiYgc3RkZXJyLl9oYW5kbGUgJiYgc3RkZXJyLl9oYW5kbGUuc2V0QmxvY2tpbmcpIHtcbiAgICBzdGRlcnIuX2hhbmRsZS5zZXRCbG9ja2luZyh0cnVlKTtcbiAgfVxuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcihzb3VyY2UpO1xuICB9XG5cbiAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XG4gIGdsb2JhbFByb2Nlc3NFeGl0KDEpO1xufVxuXG5mdW5jdGlvbiBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uICgpIHtcbiAgdmFyIG9yaWdFbWl0ID0gcHJvY2Vzcy5lbWl0O1xuXG4gIHByb2Nlc3MuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICAgIHZhciBoYXNTdGFjayA9IChhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnN0YWNrKTtcbiAgICAgIHZhciBoYXNMaXN0ZW5lcnMgPSAodGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoID4gMCk7XG5cbiAgICAgIGlmIChoYXNTdGFjayAmJiAhaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBwcmludEVycm9yQW5kRXhpdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycyA9IHJldHJpZXZlRmlsZUhhbmRsZXJzLnNsaWNlKDApO1xudmFyIG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycyA9IHJldHJpZXZlTWFwSGFuZGxlcnMuc2xpY2UoMCk7XG5cbmV4cG9ydHMud3JhcENhbGxTaXRlID0gd3JhcENhbGxTaXRlO1xuZXhwb3J0cy5nZXRFcnJvclNvdXJjZSA9IGdldEVycm9yU291cmNlO1xuZXhwb3J0cy5tYXBTb3VyY2VQb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uO1xuZXhwb3J0cy5yZXRyaWV2ZVNvdXJjZU1hcCA9IHJldHJpZXZlU291cmNlTWFwO1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgIGlmIChbXCJub2RlXCIsIFwiYnJvd3NlclwiLCBcImF1dG9cIl0uaW5kZXhPZihlbnZpcm9ubWVudCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBcIiArIGVudmlyb25tZW50ICsgXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cIilcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2VzIHRvIGJlIGZvdW5kIGJ5IG1ldGhvZHMgb3RoZXIgdGhhbiByZWFkaW5nIHRoZSBmaWxlc1xuICAvLyBkaXJlY3RseSBmcm9tIGRpc2suXG4gIGlmIChvcHRpb25zLnJldHJpZXZlRmlsZSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVGaWxlKSB7XG4gICAgICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZUZpbGUpO1xuICB9XG5cbiAgLy8gQWxsb3cgc291cmNlIG1hcHMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJldHJpZXZlU291cmNlTWFwKSB7XG4gICAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVNYXBIYW5kbGVycy51bnNoaWZ0KG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBydW50aW1lIHRyYW5zcGlsZXJzIHRoYXQgaW5jbHVkZSBpbmxpbmUgc291cmNlIG1hcHNcbiAgaWYgKG9wdGlvbnMuaG9va1JlcXVpcmUgJiYgIWlzSW5Ccm93c2VyKCkpIHtcbiAgICAvLyBVc2UgZHluYW1pY1JlcXVpcmUgdG8gYXZvaWQgaW5jbHVkaW5nIGluIGJyb3dzZXIgYnVuZGxlc1xuICAgIHZhciBNb2R1bGUgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdtb2R1bGUnKTtcbiAgICB2YXIgJGNvbXBpbGUgPSBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlO1xuXG4gICAgaWYgKCEkY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQpIHtcbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihjb250ZW50LCBmaWxlbmFtZSkge1xuICAgICAgICBmaWxlQ29udGVudHNDYWNoZVtmaWxlbmFtZV0gPSBjb250ZW50O1xuICAgICAgICBzb3VyY2VNYXBDYWNoZVtmaWxlbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAkY29tcGlsZS5jYWxsKHRoaXMsIGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmUgb3B0aW9uc1xuICBpZiAoIWVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9ICdlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5lbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIEluc3RhbGwgdGhlIGVycm9yIHJlZm9ybWF0dGVyXG4gIGlmICghZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQpIHtcbiAgICBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IHRydWU7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGlmICghdW5jYXVnaHRTaGltSW5zdGFsbGVkKSB7XG4gICAgdmFyIGluc3RhbGxIYW5kbGVyID0gJ2hhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucyA6IHRydWU7XG5cbiAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgJ3VuY2F1Z2h0RXhjZXB0aW9uJyB3aXRoIG91ciBvd24gaGFuZGxlciBpbiBOb2RlLmpzXG4gICAgLy8gV29ya2VyIHRocmVhZHMuIFdvcmtlcnMgcGFzcyB0aGUgZXJyb3IgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGFuIGV2ZW50LFxuICAgIC8vIHJhdGhlciB0aGFuIHByaW50aW5nIHNvbWV0aGluZyB0byBzdGRlcnIgYW5kIGV4aXRpbmcuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGBkeW5hbWljUmVxdWlyZWAgYmVjYXVzZSBgcmVxdWlyZWAgb24gaXQncyBvd24gd2lsbCBiZSBvcHRpbWl6ZWQgYnkgV2ViUGFjay9Ccm93c2VyaWZ5LlxuICAgICAgdmFyIHdvcmtlcl90aHJlYWRzID0gZHluYW1pY1JlcXVpcmUobW9kdWxlLCAnd29ya2VyX3RocmVhZHMnKTtcbiAgICAgIGlmICh3b3JrZXJfdGhyZWFkcy5pc01haW5UaHJlYWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc3RhbGxIYW5kbGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7fVxuXG4gICAgLy8gUHJvdmlkZSB0aGUgb3B0aW9uIHRvIG5vdCBpbnN0YWxsIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlci4gVGhpcyBpc1xuICAgIC8vIHRvIHN1cHBvcnQgb3RoZXIgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJzIChpbiB0ZXN0IGZyYW1ld29ya3MsIGZvclxuICAgIC8vIGV4YW1wbGUpLiBJZiB0aGlzIGhhbmRsZXIgaXMgbm90IGluc3RhbGxlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuY2F1Z2h0XG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgY2F1Z2h0IGJ5IG5vZGUncyBidWlsdC1pblxuICAgIC8vIGV4Y2VwdGlvbiBoYW5kbGVyIGFuZCB0aGUgcHJvY2VzcyB3aWxsIHN0aWxsIGJlIHRlcm1pbmF0ZWQuIEhvd2V2ZXIsIHRoZVxuICAgIC8vIGdlbmVyYXRlZCBKYXZhU2NyaXB0IGNvZGUgd2lsbCBiZSBzaG93biBhYm92ZSB0aGUgc3RhY2sgdHJhY2UgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICBpZiAoaW5zdGFsbEhhbmRsZXIgJiYgaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpKSB7XG4gICAgICB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5yZXNldFJldHJpZXZlSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0cmlldmVGaWxlSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgcmV0cmlldmVNYXBIYW5kbGVycy5sZW5ndGggPSAwO1xuXG4gIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycy5zbGljZSgwKTtcbiAgcmV0cmlldmVNYXBIYW5kbGVycyA9IG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycy5zbGljZSgwKTtcblxuICByZXRyaWV2ZVNvdXJjZU1hcCA9IGhhbmRsZXJFeGVjKHJldHJpZXZlTWFwSGFuZGxlcnMpO1xuICByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG59XG4iLCAicmVxdWlyZSgnLi8nKS5pbnN0YWxsKCk7XG4iLCAiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjMwLjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcygpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnM6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlcjogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkRXJhOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXG4gICAgICAgICAgICBlcmE6IG51bGwsXG4gICAgICAgICAgICBtZXJpZGllbTogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjI6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIHZhciBmbGFncyA9IG51bGwsXG4gICAgICAgICAgICBwYXJzZWRQYXJ0cyA9IGZhbHNlLFxuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IG0uX2QgJiYgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKGlzTm93VmFsaWQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBtb21lbnRQcm9wZXJ0aWVzTGVuID0gbW9tZW50UHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgICAgICAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHtcbiAgICAgICAgRDogJ2RhdGUnLFxuICAgICAgICBkYXRlczogJ2RhdGUnLFxuICAgICAgICBkYXRlOiAnZGF0ZScsXG4gICAgICAgIGQ6ICdkYXknLFxuICAgICAgICBkYXlzOiAnZGF5JyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgZTogJ3dlZWtkYXknLFxuICAgICAgICB3ZWVrZGF5czogJ3dlZWtkYXknLFxuICAgICAgICB3ZWVrZGF5OiAnd2Vla2RheScsXG4gICAgICAgIEU6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgaXNvd2Vla2RheXM6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgaXNvd2Vla2RheTogJ2lzb1dlZWtkYXknLFxuICAgICAgICBEREQ6ICdkYXlPZlllYXInLFxuICAgICAgICBkYXlvZnllYXJzOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgZGF5b2Z5ZWFyOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgaDogJ2hvdXInLFxuICAgICAgICBob3VyczogJ2hvdXInLFxuICAgICAgICBob3VyOiAnaG91cicsXG4gICAgICAgIG1zOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICBtaWxsaXNlY29uZHM6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgIG1pbGxpc2Vjb25kOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICBtOiAnbWludXRlJyxcbiAgICAgICAgbWludXRlczogJ21pbnV0ZScsXG4gICAgICAgIG1pbnV0ZTogJ21pbnV0ZScsXG4gICAgICAgIE06ICdtb250aCcsXG4gICAgICAgIG1vbnRoczogJ21vbnRoJyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIFE6ICdxdWFydGVyJyxcbiAgICAgICAgcXVhcnRlcnM6ICdxdWFydGVyJyxcbiAgICAgICAgcXVhcnRlcjogJ3F1YXJ0ZXInLFxuICAgICAgICBzOiAnc2Vjb25kJyxcbiAgICAgICAgc2Vjb25kczogJ3NlY29uZCcsXG4gICAgICAgIHNlY29uZDogJ3NlY29uZCcsXG4gICAgICAgIGdnOiAnd2Vla1llYXInLFxuICAgICAgICB3ZWVreWVhcnM6ICd3ZWVrWWVhcicsXG4gICAgICAgIHdlZWt5ZWFyOiAnd2Vla1llYXInLFxuICAgICAgICBHRzogJ2lzb1dlZWtZZWFyJyxcbiAgICAgICAgaXNvd2Vla3llYXJzOiAnaXNvV2Vla1llYXInLFxuICAgICAgICBpc293ZWVreWVhcjogJ2lzb1dlZWtZZWFyJyxcbiAgICAgICAgdzogJ3dlZWsnLFxuICAgICAgICB3ZWVrczogJ3dlZWsnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIFc6ICdpc29XZWVrJyxcbiAgICAgICAgaXNvd2Vla3M6ICdpc29XZWVrJyxcbiAgICAgICAgaXNvd2VlazogJ2lzb1dlZWsnLFxuICAgICAgICB5OiAneWVhcicsXG4gICAgICAgIHllYXJzOiAneWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7XG4gICAgICAgIGRhdGU6IDksXG4gICAgICAgIGRheTogMTEsXG4gICAgICAgIHdlZWtkYXk6IDExLFxuICAgICAgICBpc29XZWVrZGF5OiAxMSxcbiAgICAgICAgZGF5T2ZZZWFyOiA0LFxuICAgICAgICBob3VyOiAxMyxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDE2LFxuICAgICAgICBtaW51dGU6IDE0LFxuICAgICAgICBtb250aDogOCxcbiAgICAgICAgcXVhcnRlcjogNyxcbiAgICAgICAgc2Vjb25kOiAxNSxcbiAgICAgICAgd2Vla1llYXI6IDEsXG4gICAgICAgIGlzb1dlZWtZZWFyOiAxLFxuICAgICAgICB3ZWVrOiA1LFxuICAgICAgICBpc29XZWVrOiA1LFxuICAgICAgICB5ZWFyOiAxLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgPSAvXFxkLywgLy8gICAgICAgMCAtIDlcbiAgICAgICAgbWF0Y2gyID0gL1xcZFxcZC8sIC8vICAgICAgMDAgLSA5OVxuICAgICAgICBtYXRjaDMgPSAvXFxkezN9LywgLy8gICAgIDAwMCAtIDk5OVxuICAgICAgICBtYXRjaDQgPSAvXFxkezR9LywgLy8gICAgMDAwMCAtIDk5OTlcbiAgICAgICAgbWF0Y2g2ID0gL1srLV0/XFxkezZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzIgPSAvXFxkXFxkPy8sIC8vICAgICAgIDAgLSA5OVxuICAgICAgICBtYXRjaDN0bzQgPSAvXFxkXFxkXFxkXFxkPy8sIC8vICAgICA5OTkgLSA5OTk5XG4gICAgICAgIG1hdGNoNXRvNiA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LywgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzMgPSAvXFxkezEsM30vLCAvLyAgICAgICAwIC0gOTk5XG4gICAgICAgIG1hdGNoMXRvNCA9IC9cXGR7MSw0fS8sIC8vICAgICAgIDAgLSA5OTk5XG4gICAgICAgIG1hdGNoMXRvNiA9IC9bKy1dP1xcZHsxLDZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaFVuc2lnbmVkID0gL1xcZCsvLCAvLyAgICAgICAwIC0gaW5mXG4gICAgICAgIG1hdGNoU2lnbmVkID0gL1srLV0/XFxkKy8sIC8vICAgIC1pbmYgLSBpbmZcbiAgICAgICAgbWF0Y2hPZmZzZXQgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2ksIC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcbiAgICAgICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICAgICAgbWF0Y2hXb3JkID1cbiAgICAgICAgICAgIC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pLFxuICAgICAgICBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvID0gL15bMS05XVxcZD8vLCAvLyAgICAgICAgIDEtOTlcbiAgICAgICAgbWF0Y2gxdG8ySGFzWmVybyA9IC9eKFsxLTldXFxkfFxcZCkvLCAvLyAgICAgICAgICAgMC05OVxuICAgICAgICByZWdleGVzO1xuXG4gICAgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbih0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleClcbiAgICAgICAgICAgID8gcmVnZXhcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXggPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUoXG4gICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGZ1bmMgPSBjYWxsYmFjayxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbkxlbiA9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IG1vbS5fZCxcbiAgICAgICAgICAgIGlzVVRDID0gbW9tLl9pc1VUQztcblxuICAgICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ01pbGxpc2Vjb25kcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBjYXNlICdTZWNvbmRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ1NlY29uZHMoKSA6IGQuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgY2FzZSAnTWludXRlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENNaW51dGVzKCkgOiBkLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIGNhc2UgJ0hvdXJzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0hvdXJzKCkgOiBkLmdldEhvdXJzKCk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0RhdGUoKSA6IGQuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgY2FzZSAnRGF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0RheSgpIDogZC5nZXREYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ01vbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ01vbnRoKCkgOiBkLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBjYXNlICdGdWxsWWVhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENGdWxsWWVhcigpIDogZC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOOyAvLyBKdXN0IGluIGNhc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGQsIGlzVVRDLCB5ZWFyLCBtb250aCwgZGF0ZTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkID0gbW9tLl9kO1xuICAgICAgICBpc1VUQyA9IG1vbS5faXNVVEM7XG5cbiAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICBjYXNlICdNaWxsaXNlY29uZHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpc1VUQ1xuICAgICAgICAgICAgICAgICAgICA/IGQuc2V0VVRDTWlsbGlzZWNvbmRzKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGQuc2V0TWlsbGlzZWNvbmRzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdTZWNvbmRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ1NlY29uZHModmFsdWUpIDogZC5zZXRTZWNvbmRzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdNaW51dGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ01pbnV0ZXModmFsdWUpIDogZC5zZXRNaW51dGVzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdIb3Vycyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKGlzVVRDID8gZC5zZXRVVENIb3Vycyh2YWx1ZSkgOiBkLnNldEhvdXJzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ0RhdGUodmFsdWUpIDogZC5zZXREYXRlKHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBjYXNlICdEYXknOiAvLyBOb3QgcmVhbFxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZvaWQgKGlzVVRDID8gZC5zZXRVVENEYXkodmFsdWUpIDogZC5zZXREYXkodmFsdWUpKTtcbiAgICAgICAgICAgIC8vIGNhc2UgJ01vbnRoJzogLy8gTm90IHVzZWQgYmVjYXVzZSB3ZSBuZWVkIHRvIHBhc3MgdHdvIHZhcmlhYmxlc1xuICAgICAgICAgICAgLy8gICAgIHJldHVybiB2b2lkIChpc1VUQyA/IGQuc2V0VVRDTW9udGgodmFsdWUpIDogZC5zZXRNb250aCh2YWx1ZSkpO1xuICAgICAgICAgICAgY2FzZSAnRnVsbFllYXInOlxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBTZWUgYmVsb3cgLi4uXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSnVzdCBpbiBjYXNlXG4gICAgICAgIH1cblxuICAgICAgICB5ZWFyID0gdmFsdWU7XG4gICAgICAgIG1vbnRoID0gbW9tLm1vbnRoKCk7XG4gICAgICAgIGRhdGUgPSBtb20uZGF0ZSgpO1xuICAgICAgICBkYXRlID0gZGF0ZSA9PT0gMjkgJiYgbW9udGggPT09IDEgJiYgIWlzTGVhcFllYXIoeWVhcikgPyAyOCA6IGRhdGU7XG4gICAgICAgIHZvaWQgKGlzVVRDXG4gICAgICAgICAgICA/IGQuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRhdGUpXG4gICAgICAgICAgICA6IGQuc2V0RnVsbFllYXIoeWVhciwgbW9udGgsIGRhdGUpKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHByaW9yaXRpemVkTGVuID0gcHJpb3JpdGl6ZWQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIsIG1hdGNoMXRvMk5vTGVhZGluZ1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPVxuICAgICAgICAgICAgJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KFxuICAgICAgICAgICAgICAgICdfJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID1cbiAgICAgICAgICAgICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LyxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyhtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzW1xuICAgICAgICAgICAgICAgICAgKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbXG4gICAgICAgICAgICAgICAgICBNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGgobW9tLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9udGggPSB2YWx1ZSxcbiAgICAgICAgICAgIGRhdGUgPSBtb20uZGF0ZSgpO1xuXG4gICAgICAgIGRhdGUgPSBkYXRlIDwgMjkgPyBkYXRlIDogTWF0aC5taW4oZGF0ZSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgbW9udGgpKTtcbiAgICAgICAgdm9pZCAobW9tLl9pc1VUQ1xuICAgICAgICAgICAgPyBtb20uX2Quc2V0VVRDTW9udGgobW9udGgsIGRhdGUpXG4gICAgICAgICAgICA6IG1vbS5fZC5zZXRNb250aChtb250aCwgZGF0ZSkpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBzaG9ydFAsXG4gICAgICAgICAgICBsb25nUDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFAgPSByZWdleEVzY2FwZSh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQID0gcmVnZXhFc2NhcGUodGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydFApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdQKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ1ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydFApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSArIDQwMCwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUoeSkge1xuICAgICAgICB2YXIgZGF0ZSwgYXJncztcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhcixcbiAgICAgICAgICAgIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssXG4gICAgICAgICAgICByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9XG4gICAgICAgICAgICAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cylcbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNcbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNbXG4gICAgICAgICAgICAgICAgICBtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF07XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV1cbiAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzKG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXkgPSBnZXQodGhpcywgJ0RheScpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJIYXNaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgLy8gRW5zdXJlIG5hbWUgaXMgYXZhaWxhYmxlIGFuZCBmdW5jdGlvbiByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgcmV0dXJuICEhKG5hbWUgJiYgbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbCxcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBtb2R1bGUgJiZcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgICAgICAgICBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayBhcyBub3QgZm91bmQgdG8gYXZvaWQgcmVwZWF0aW5nIGV4cGVuc2l2ZSBmaWxlIHJlcXVpcmUgY2FsbCBjYXVzaW5nIGhpZ2ggQ1BVXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gZmluZCBlbi1VUywgZW5fVVMsIGVuLXVzIGZvciBldmVyeSBmb3JtYXQgY2FsbFxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBudWxsOyAvLyBudWxsIG1lYW5zIG5vdCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICdMb2NhbGUgJyArIGtleSArICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PydcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwgJiYgbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjaGlsZCBsb2NhbGUgaW4tcGxhY2UgdG8gYXZvaWQgbWVtb3J5LWxlYWtzXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQobWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUxvY2FsZSBpcyBjYWxsZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWJiciBzbyBpdCB3aWxsIGhhdmUgYSBuYW1lIChnZXR0ZXJzIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgb3RoZXJ3aXNlKS5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGdldFNldEdsb2JhbExvY2FsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZShrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3csXG4gICAgICAgICAgICBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gPCAwIHx8IGFbTU9OVEhdID4gMTFcbiAgICAgICAgICAgICAgICAgICAgPyBNT05USFxuICAgICAgICAgICAgICAgICAgICA6IGFbREFURV0gPCAxIHx8IGFbREFURV0gPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSlcbiAgICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSAhPT0gMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsyXVxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCksXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxuICAgICAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIDEpIEFTUC5ORVQsIDIpIElTTywgMykgUkZDIDI4MjIgZm9ybWF0cywgb3IgNCkgb3B0aW9uYWwgZmFsbGJhY2sgaWYgcGFyc2luZyBpc24ndCBzdHJpY3RcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgICAgICdkaXNjb3VyYWdlZC4gUGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWRXZWVrZGF5LFxuICAgICAgICAgICAgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID1cbiAgICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPT0gbnVsbCA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcbiAgICAgICAgICAgIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB3LkdHLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSxcbiAgICAgICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGVyYSxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcbiAgICAgICAgICAgICAgICBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBoYW5kbGUgZXJhXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcbiAgICAgICAgaWYgKGVyYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUsXG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kLFxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ2ZMZW4gPSBjb25maWcuX2YubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjb25maWdmTGVuID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnZkxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG9yZGVyTGVuID0gb3JkZXJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICsgcXVhcnRlcnMgKiAzICsgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNpZ24gK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn5vZmZzZXQgJSA2MCwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICBwYXJ0cyA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID1cbiAgICAgICAgICAgICAgICAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgb3RoZXI7XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKTooXFxkKykoPzo6KFxcZCspKFxcLlxcZCopPyk/JC8sXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgICBpc29SZWdleCA9XG4gICAgICAgICAgICAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5TGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICAgIDogZGlmZiA8IDBcbiAgICAgICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICAgICAgICAgIDogZGlmZiA8IDdcbiAgICAgICAgICAgICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFxuICAgICAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgdmFyIGVyYSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRSZWdleFRva2VuKCd5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneW8nLCBtYXRjaEVyYVllYXJPcmRpbmFsKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWyd5byddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLl9lcmFzIHx8IGdldExvY2FsZSgnZW4nKS5fZXJhcztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0uc2luY2UgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnVudGlsKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc1BhcnNlKGVyYU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmJyLFxuICAgICAgICAgICAgbmFycm93O1xuICAgICAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGVyYXNbaV0ubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbmFycm93ID0gZXJhc1tpXS5uYXJyb3cudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJiciA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hcnJvdyA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbbmFtZSwgYWJiciwgbmFycm93XS5pbmRleE9mKGVyYU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICAgICAgdmFyIGRpciA9IGVyYS5zaW5jZSA8PSBlcmEudW50aWwgPyArMSA6IC0xO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFtZSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhWWVhcigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB8fFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFtZVJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFtZVJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc0FiYnJSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc0FiYnJSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzQWJiclJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4IHx8IG1hdGNoVW5zaWduZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICAgICAgdmFyIGFiYnJQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhc05hbWUsXG4gICAgICAgICAgICBlcmFzQWJicixcbiAgICAgICAgICAgIGVyYXNOYXJyb3csXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBlcmFzTmFtZSA9IHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSk7XG4gICAgICAgICAgICBlcmFzQWJiciA9IHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicik7XG4gICAgICAgICAgICBlcmFzTmFycm93ID0gcmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpO1xuXG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2goZXJhc05hbWUpO1xuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKGVyYXNBYmJyKTtcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKGVyYXNOYXJyb3cpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChlcmFzTmFtZSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGVyYXNBYmJyKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goZXJhc05hcnJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lcmFzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFycm93UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCkgKyB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPVxuICAgICAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNVxuICAgICAgICAgICAgKSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoaW5wdXQgLSBkYXlPZlllYXIsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCBtYXRjaDF0bzIsIG1hdGNoMXRvMkhhc1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJIYXNaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICduZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyksXG4gICAgICAgIGFzU2Vjb25kcyA9IG1ha2VBcygncycpLFxuICAgICAgICBhc01pbnV0ZXMgPSBtYWtlQXMoJ20nKSxcbiAgICAgICAgYXNIb3VycyA9IG1ha2VBcygnaCcpLFxuICAgICAgICBhc0RheXMgPSBtYWtlQXMoJ2QnKSxcbiAgICAgICAgYXNXZWVrcyA9IG1ha2VBcygndycpLFxuICAgICAgICBhc01vbnRocyA9IG1ha2VBcygnTScpLFxuICAgICAgICBhc1F1YXJ0ZXJzID0gbWFrZUFzKCdRJyksXG4gICAgICAgIGFzWWVhcnMgPSBtYWtlQXMoJ3knKSxcbiAgICAgICAgdmFsdWVPZiQxID0gYXNNaWxsaXNlY29uZHM7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMzAuMSc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGpvaSkgPT4ge1xuXG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgZm9ybWF0OiBqb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgIGpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGpvaS5hcnJheSgpLml0ZW1zKGpvaS5zdHJpbmcoKS5pbnZhbGlkKCdpc28nLCAnamF2YXNjcmlwdCcsICd1bml4JykpXG4gICAgICAgIF0pXG4gICAgfTtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICBiYXNlOiBqb2kuZGF0ZSgpLFxuXG4gICAgICAgIGNvZXJjZToge1xuICAgICAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLiRfZ2V0RmxhZygnZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBzY2hlbWEuJF9nZXRGbGFnKCd1dGMnKSA/IE1vbWVudC51dGModmFsdWUsIGZvcm1hdCwgdHJ1ZSkgOiBNb21lbnQodmFsdWUsIGZvcm1hdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBkYXRlLnRvRGF0ZSgpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgICB1dGM6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndXRjJywgZW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBqb2kuYXR0ZW1wdChmb3JtYXQsIGFyZ3MuZm9ybWF0LCAnSW52YWxpZCBmb3JtYXQnKTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc3VwZXIuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBUeXBlU2NyaXB0IG1vZHVsZSBpbnRlcm9wXG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gJ1tDYW5ub3QgZGlzcGxheSBvYmplY3Q6ICcgKyBlcnIubWVzc2FnZSArICddJztcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoYXJncykge1xuXG4gICAgICAgIGNvbnN0IG1zZ3MgPSBhcmdzXG4gICAgICAgICAgICAuZmlsdGVyKChhcmcpID0+IGFyZyAhPT0gJycpXG4gICAgICAgICAgICAubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6IGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLm1lc3NhZ2UgOiBTdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykgeyAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZXhwb3J0cy5hc3NlcnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgLi4uYXJncykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuXG4gICAgICAgIHRocm93IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKGFyZ3MpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBjaGFpbiwgb3B0aW9ucykge1xuXG4gICAgaWYgKGNoYWluID09PSBmYWxzZSB8fFxuICAgICAgICBjaGFpbiA9PT0gbnVsbCB8fFxuICAgICAgICBjaGFpbiA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHNlcGFyYXRvcjogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGNvbnN0IGlzQ2hhaW5BcnJheSA9IEFycmF5LmlzQXJyYXkoY2hhaW4pO1xuXG4gICAgQXNzZXJ0KCFpc0NoYWluQXJyYXkgfHwgIW9wdGlvbnMuc2VwYXJhdG9yLCAnU2VwYXJhdG9yIG9wdGlvbiBpcyBub3QgdmFsaWQgZm9yIGFycmF5LWJhc2VkIGNoYWluJyk7XG5cbiAgICBjb25zdCBwYXRoID0gaXNDaGFpbkFycmF5ID8gY2hhaW4gOiBjaGFpbi5zcGxpdChvcHRpb25zLnNlcGFyYXRvciB8fCAnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBrZXkgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5pdGVyYWJsZXMgJiYgaW50ZXJuYWxzLml0ZXJhYmxlcyhyZWYpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bWJlciA8IDAgPyByZWYubGVuZ3RoICsgbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWYgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5mdW5jdGlvbnMgPT09IGZhbHNlIHx8ICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgIXR5cGUgJiYgcmVmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBBc3NlcnQoIW9wdGlvbnMuc3RyaWN0IHx8IGkgKyAxID09PSBwYXRoLmxlbmd0aCwgJ01pc3Npbmcgc2VnbWVudCcsIGtleSwgJ2luIHJlYWNoIHBhdGggJywgY2hhaW4pO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuZnVuY3Rpb25zID09PSB0cnVlIHx8IHR5cGVvZiByZWYgIT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIHJlZiA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZWYgPSByZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2V0Jykge1xuICAgICAgICAgICAgcmVmID0gWy4uLnJlZl1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgIC8vIHR5cGUgPT09ICdtYXAnXG4gICAgICAgICAgICByZWYgPSByZWYuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmO1xufTtcblxuXG5pbnRlcm5hbHMuaXRlcmFibGVzID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gJ3NldCc7XG4gICAgfVxuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gJ21hcCc7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheTogQXJyYXkucHJvdG90eXBlLFxuICAgIGJ1ZmZlcjogQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUsICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGRhdGU6IERhdGUucHJvdG90eXBlLFxuICAgIGVycm9yOiBFcnJvci5wcm90b3R5cGUsXG4gICAgZ2VuZXJpYzogT2JqZWN0LnByb3RvdHlwZSxcbiAgICBtYXA6IE1hcC5wcm90b3R5cGUsXG4gICAgcHJvbWlzZTogUHJvbWlzZS5wcm90b3R5cGUsXG4gICAgcmVnZXg6IFJlZ0V4cC5wcm90b3R5cGUsXG4gICAgc2V0OiBTZXQucHJvdG90eXBlLFxuICAgIHdlYWtNYXA6IFdlYWtNYXAucHJvdG90eXBlLFxuICAgIHdlYWtTZXQ6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG5cbmludGVybmFscy50eXBlTWFwID0gbmV3IE1hcChbXG4gICAgWydbb2JqZWN0IEVycm9yXScsIGV4cG9ydHMuZXJyb3JdLFxuICAgIFsnW29iamVjdCBNYXBdJywgZXhwb3J0cy5tYXBdLFxuICAgIFsnW29iamVjdCBQcm9taXNlXScsIGV4cG9ydHMucHJvbWlzZV0sXG4gICAgWydbb2JqZWN0IFNldF0nLCBleHBvcnRzLnNldF0sXG4gICAgWydbb2JqZWN0IFdlYWtNYXBdJywgZXhwb3J0cy53ZWFrTWFwXSxcbiAgICBbJ1tvYmplY3QgV2Vha1NldF0nLCBleHBvcnRzLndlYWtTZXRdXG5dKTtcblxuXG5leHBvcnRzLmdldEludGVybmFsUHJvdG8gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFycmF5O1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQnVmZmVyKSB7ICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICByZXR1cm4gZXhwb3J0cy5idWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlZ2V4O1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgcmV0dXJuIGludGVybmFscy50eXBlTWFwLmdldChvYmpOYW1lKSB8fCBleHBvcnRzLmdlbmVyaWM7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5zeW1ib2xzICE9PSBmYWxzZSA/IFJlZmxlY3Qub3duS2V5cyhvYmopIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTsgIC8vIERlZmF1bHRzIHRvIHRydWVcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJy4vcmVhY2gnKTtcbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5lZWRzUHJvdG9IYWNrOiBuZXcgU2V0KFtUeXBlcy5zZXQsIFR5cGVzLm1hcCwgVHlwZXMud2Vha1NldCwgVHlwZXMud2Vha01hcF0pXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLmNsb25lID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9LCBfc2VlbiA9IG51bGwpIHtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxldCBjbG9uZSA9IGludGVybmFscy5jbG9uZTtcbiAgICBsZXQgc2VlbiA9IF9zZWVuO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFsbG93ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb25lV2l0aFNoYWxsb3cob2JqLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2Vlbikge1xuICAgICAgICBjb25zdCBsb29rdXAgPSBzZWVuLmdldChvYmopO1xuICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWx0LWluIG9iamVjdCB0eXBlc1xuXG4gICAgY29uc3QgYmFzZVByb3RvID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKG9iaik7ICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5kYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5yZWdleCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmopO1xuICAgIH1cblxuICAgIC8vIEdlbmVyaWMgb2JqZWN0c1xuXG4gICAgY29uc3QgbmV3T2JqID0gaW50ZXJuYWxzLmJhc2Uob2JqLCBiYXNlUHJvdG8sIG9wdGlvbnMpO1xuICAgIGlmIChuZXdPYmogPT09IG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4uc2V0KG9iaiwgbmV3T2JqKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2Vlbiwgc2luY2Ugb2JqIGNvdWxkIHJlY3Vyc2VcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5hZGQoY2xvbmUodmFsdWUsIG9wdGlvbnMsIHNlZW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLm1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5zZXQoa2V5LCBjbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IFV0aWxzLmtleXMob2JqLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ICYmXG4gICAgICAgICAgICBrZXkgPT09ICdsZW5ndGgnKSB7XG5cbiAgICAgICAgICAgIG5ld09iai5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCkge1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBzZWVuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqO1xufTtcblxuXG5pbnRlcm5hbHMuY2xvbmVXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gUmVhY2goc291cmNlLCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgc2Vlbi5zZXQocmVmLCByZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5jbG9uZShzb3VyY2UsIG9wdGlvbnMsIHNlZW4pO1xufTtcblxuXG5pbnRlcm5hbHMuYmFzZSA9IGZ1bmN0aW9uIChvYmosIGJhc2VQcm90bywgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMucHJvdG90eXBlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNlUHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ID8gW10gOiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIGlmIChwcm90byAmJlxuICAgICAgICBwcm90by5pc0ltbXV0YWJsZSkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gW107XG4gICAgICAgIGlmIChwcm90byAhPT0gYmFzZVByb3RvKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3T2JqLCBwcm90byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbHMubmVlZHNQcm90b0hhY2suaGFzKGJhc2VQcm90bykpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gbmV3IHByb3RvLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChwcm90byAhPT0gYmFzZVByb3RvKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3T2JqLCBwcm90byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbn07XG4iLCAie1xuICAgIFwibmFtZVwiOiBcImpvaVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPYmplY3Qgc2NoZW1hIHZhbGlkYXRpb25cIixcbiAgICBcInZlcnNpb25cIjogXCIxNy4xMi4yXCIsXG4gICAgXCJyZXBvc2l0b3J5XCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9oYXBpanMvam9pXCIsXG4gICAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gICAgXCJ0eXBlc1wiOiBcImxpYi9pbmRleC5kLnRzXCIsXG4gICAgXCJicm93c2VyXCI6IFwiZGlzdC9qb2ktYnJvd3Nlci5taW4uanNcIixcbiAgICBcImZpbGVzXCI6IFtcbiAgICAgICAgXCJsaWIvKiovKlwiLFxuICAgICAgICBcImRpc3QvKlwiXG4gICAgXSxcbiAgICBcImtleXdvcmRzXCI6IFtcbiAgICAgICAgXCJzY2hlbWFcIixcbiAgICAgICAgXCJ2YWxpZGF0aW9uXCJcbiAgICBdLFxuICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgXCJAaGFwaS9ob2VrXCI6IFwiXjkuMy4wXCIsXG4gICAgICAgIFwiQGhhcGkvdG9wb1wiOiBcIl41LjEuMFwiLFxuICAgICAgICBcIkBzaWRld2F5L2FkZHJlc3NcIjogXCJeNC4xLjVcIixcbiAgICAgICAgXCJAc2lkZXdheS9mb3JtdWxhXCI6IFwiXjMuMC4xXCIsXG4gICAgICAgIFwiQHNpZGV3YXkvcGlucG9pbnRcIjogXCJeMi4wLjBcIlxuICAgIH0sXG4gICAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICBcIkBoYXBpL2JvdXJuZVwiOiBcIjIueC54XCIsXG4gICAgICAgIFwiQGhhcGkvY29kZVwiOiBcIjgueC54XCIsXG4gICAgICAgIFwiQGhhcGkvam9pLWxlZ2FjeS10ZXN0XCI6IFwibnBtOkBoYXBpL2pvaUAxNS54LnhcIixcbiAgICAgICAgXCJAaGFwaS9sYWJcIjogXCJeMjUuMS4zXCIsXG4gICAgICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMTQuMTguNjNcIixcbiAgICAgICAgXCJ0eXBlc2NyaXB0XCI6IFwiNC4zLnhcIlxuICAgIH0sXG4gICAgXCJzY3JpcHRzXCI6IHtcbiAgICAgICAgXCJwcmVwdWJsaXNoT25seVwiOiBcImNkIGJyb3dzZXIgJiYgbnBtIGluc3RhbGwgJiYgbnBtIHJ1biBidWlsZFwiLFxuICAgICAgICBcInRlc3RcIjogXCJsYWIgLXQgMTAwIC1hIEBoYXBpL2NvZGUgLUwgLVlcIixcbiAgICAgICAgXCJ0ZXN0LWNvdi1odG1sXCI6IFwibGFiIC1yIGh0bWwgLW8gY292ZXJhZ2UuaHRtbCAtYSBAaGFwaS9jb2RlXCJcbiAgICB9LFxuICAgIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gUHJlZmVyZW5jZXNcblxuaW50ZXJuYWxzLndyYXAgPSBKb2kuc3RyaW5nKClcbiAgICAubWluKDEpXG4gICAgLm1heCgyKVxuICAgIC5hbGxvdyhmYWxzZSk7XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IEpvaS5vYmplY3Qoe1xuICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGFydGlmYWN0czogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBzdHJpbmc6IGludGVybmFscy53cmFwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICBtZXNzYWdlczogSm9pLm9iamVjdCgpLFxuICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgbm9uRW51bWVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgcHJlc2VuY2U6IEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJyksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IEpvaS5vYmplY3Qoe1xuICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICB9KVxuICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICB3YXJuaW5nczogSm9pLmJvb2xlYW4oKVxufSlcbiAgICAuc3RyaWN0KCk7XG5cblxuLy8gRXh0ZW5zaW9uc1xuXG5pbnRlcm5hbHMubmFtZVJ4ID0gL15bYS16QS1aMC05XVxcdyokLztcblxuXG5pbnRlcm5hbHMucnVsZSA9IEpvaS5vYmplY3Qoe1xuICAgIGFsaWFzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KSkuc2luZ2xlKCksXG4gICAgYXJnczogSm9pLmFycmF5KCkuaXRlbXMoXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgcmVmOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgYXNzZXJ0OiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLmNvbmRpdGlvbmFsKCdyZWYnLCB7IGlzOiB0cnVlLCB0aGVuOiBKb2kucmVxdWlyZWQoKSB9KSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBKb2kuc3RyaW5nKCkud2hlbignYXNzZXJ0JywgeyBpczogSm9pLmZ1bmN0aW9uKCksIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pXG4gICAgICAgIH0pXG4gICAgKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1hbmlmZXN0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkuYWxsb3coZmFsc2UpLFxuICAgIG11bHRpOiBKb2kuYm9vbGVhbigpLFxuICAgIHZhbGlkYXRlOiBKb2kuZnVuY3Rpb24oKVxufSk7XG5cblxuZXhwb3J0cy5leHRlbnNpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KCkucmVnZXgoKVxuICAgIF0pXG4gICAgICAgIC5yZXF1aXJlZCgpLFxuICAgIGFyZ3M6IEpvaS5mdW5jdGlvbigpLFxuICAgIGNhc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBmcm9tOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgxKS5yZXF1aXJlZCgpLFxuICAgICAgICB0bzogSm9pLmZ1bmN0aW9uKCkubWluQXJpdHkoMSkubWF4QXJpdHkoMikucmVxdWlyZWQoKVxuICAgIH0pKSxcbiAgICBiYXNlOiBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgLndoZW4oJ3R5cGUnLCB7IGlzOiBKb2kub2JqZWN0KCkucmVnZXgoKSwgdGhlbjogSm9pLmZvcmJpZGRlbigpIH0pLFxuICAgIGNvZXJjZTogW1xuICAgICAgICBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICAgICAgSm9pLm9iamVjdCh7IG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMykucmVxdWlyZWQoKSwgZnJvbTogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSB9KVxuICAgIF0sXG4gICAgZmxhZ3M6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBzZXR0ZXI6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpXG4gICAgfSkpLFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICAgIGJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgyKVxuICAgIH0sXG4gICAgbWVzc2FnZXM6IFtKb2kub2JqZWN0KCksIEpvaS5zdHJpbmcoKV0sXG4gICAgbW9kaWZpZXJzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKSksXG4gICAgb3ZlcnJpZGVzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKSksXG4gICAgcHJlcGFyZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMyksXG4gICAgcmVidWlsZDogSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIGludGVybmFscy5ydWxlKSxcbiAgICB0ZXJtczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGluaXQ6IEpvaS5hcnJheSgpLmFsbG93KG51bGwpLnJlcXVpcmVkKCksXG4gICAgICAgIG1hbmlmZXN0OiBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NjaGVtYScsICdzaW5nbGUnKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1hcHBlZDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB0bzogSm9pLnN0cmluZygpLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICB9KSksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kub2JqZWN0KCksIEpvaS5mdW5jdGlvbigpLmFyaXR5KDEpKS5zdHJpY3QoKTtcblxuXG4vLyBNYW5pZmVzdFxuXG5pbnRlcm5hbHMuZGVzYyA9IHtcblxuICAgIGJ1ZmZlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGJ1ZmZlcjogSm9pLnN0cmluZygpXG4gICAgfSksXG5cbiAgICBmdW5jOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZnVuY3Rpb246IEpvaS5mdW5jdGlvbigpLnJlcXVpcmVkKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3ZlcnJpZGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdmVycmlkZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IEpvaS52YWxpZCgndmFsdWUnLCAnZ2xvYmFsJywgJ2xvY2FsJyksXG4gICAgICAgICAgICBwYXRoOiBKb2kuYXJyYXkoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiBKb2kuc3RyaW5nKCkubGVuZ3RoKDEpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgICAgIGFuY2VzdG9yOiBKb2kubnVtYmVyKCkubWluKDApLmludGVnZXIoKS5hbGxvdygncm9vdCcpLFxuICAgICAgICAgICAgbWFwOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuYXJyYXkoKS5sZW5ndGgoMikpLm1pbigxKSxcbiAgICAgICAgICAgIGFkanVzdDogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBpdGVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBpbjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHJlZ2V4OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVnZXg6IEpvaS5zdHJpbmcoKS5taW4oMylcbiAgICB9KSxcblxuICAgIHNwZWNpYWw6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzcGVjaWFsOiBKb2kudmFsaWQoJ2RlZXAnKS5yZXF1aXJlZCgpXG4gICAgfSksXG5cbiAgICB0ZW1wbGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHRlbXBsYXRlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgfSksXG5cbiAgICB2YWx1ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHZhbHVlOiBKb2kuYWx0ZXJuYXRpdmVzKFtKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpXSkucmVxdWlyZWQoKVxuICAgIH0pXG59O1xuXG5cbmludGVybmFscy5kZXNjLmVudGl0eSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5saW5rKCcuLi4nKSksXG4gICAgSm9pLmJvb2xlYW4oKSxcbiAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICBKb2kubnVtYmVyKCksXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICBpbnRlcm5hbHMuZGVzYy5zcGVjaWFsLFxuICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgIGludGVybmFscy5kZXNjLnZhbHVlLFxuICAgIEpvaS5saW5rKCcvJylcbl0pO1xuXG5cbmludGVybmFscy5kZXNjLnZhbHVlcyA9IEpvaS5hcnJheSgpXG4gICAgLml0ZW1zKFxuICAgICAgICBudWxsLFxuICAgICAgICBKb2kuYm9vbGVhbigpLFxuICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgSm9pLm51bWJlcigpLmFsbG93KEluZmluaXR5LCAtSW5maW5pdHkpLFxuICAgICAgICBKb2kuc3RyaW5nKCkuYWxsb3coJycpLFxuICAgICAgICBKb2kuc3ltYm9sKCksXG4gICAgICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuZnVuYyxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2Mub3ZlcnJpZGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVnZXgsXG4gICAgICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy52YWx1ZVxuICAgICk7XG5cblxuaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMgPSBKb2kub2JqZWN0KClcbiAgICAucGF0dGVybigvLisvLCBbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtKb2kuc3RyaW5nKCksIGludGVybmFscy5kZXNjLnRlbXBsYXRlXSlcbiAgICBdKTtcblxuXG5leHBvcnRzLmRlc2NyaXB0aW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgZmxhZ3M6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjYXN0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGRlZmF1bHQ6IEpvaS5hbnkoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZW1wdHk6IEpvaS5saW5rKCcvJyksXG4gICAgICAgIGZhaWxvdmVyOiBpbnRlcm5hbHMuZGVzYy5lbnRpdHksXG4gICAgICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGxhYmVsOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG9ubHk6IHRydWUsXG4gICAgICAgIHByZXNlbmNlOiBbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLFxuICAgICAgICByZXN1bHQ6IFsncmF3JywgJ3N0cmlwJ10sXG4gICAgICAgIHN0cmlwOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB1bml0OiBKb2kuc3RyaW5nKClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgZGF0ZUZvcm1hdDogWydkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnXSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgbGFiZWw6IFsncGF0aCcsICdrZXknXSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5kZXNjLnJlZlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGludGVybmFscy53cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZXM6IGludGVybmFscy5kZXNjLm1lc3NhZ2VzLFxuICAgICAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJlc2VuY2U6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBhbGxvdzogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIGludmFsaWQ6IGludGVybmFscy5kZXNjLnZhbHVlcyxcbiAgICBydWxlczogSm9pLmFycmF5KCkubWluKDEpLml0ZW1zKHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgIGFyZ3M6IEpvaS5vYmplY3QoKS5taW4oMSksXG4gICAgICAgIGtlZXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGludGVybmFscy5kZXNjLm1lc3NhZ2VzXG4gICAgICAgIF0sXG4gICAgICAgIHdhcm46IEpvaS5ib29sZWFuKClcbiAgICB9KSxcblxuICAgIC8vIFRlcm1zXG5cbiAgICBrZXlzOiBKb2kub2JqZWN0KCkucGF0dGVybigvLiovLCBKb2kubGluaygnLycpKSxcbiAgICBsaW5rOiBpbnRlcm5hbHMuZGVzYy5yZWZcbn0pXG4gICAgLnBhdHRlcm4oL15bYS16XVxcdyokLywgSm9pLmFueSgpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICBjb25zdCBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWwuZ2V0KGNoYXJDb2RlKTtcbiAgICBpZiAobmFtZWRFc2NhcGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkRXNjYXBlO1xuICAgIH1cblxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyBjaGFyQ29kZSArICc7JztcbiAgICB9XG5cbiAgICBjb25zdCBoZXhWYWx1ZSA9IGNoYXJDb2RlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIHJldHVybiBgJiN4JHtoZXhWYWx1ZX07YDtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5zYWZlQ2hhckNvZGVzLmhhcyhjaGFyQ29kZSk7XG59O1xuXG5cbmludGVybmFscy5uYW1lZEh0bWwgPSBuZXcgTWFwKFtcbiAgICBbMzgsICcmYW1wOyddLFxuICAgIFs2MCwgJyZsdDsnXSxcbiAgICBbNjIsICcmZ3Q7J10sXG4gICAgWzM0LCAnJnF1b3Q7J10sXG4gICAgWzE2MCwgJyZuYnNwOyddLFxuICAgIFsxNjIsICcmY2VudDsnXSxcbiAgICBbMTYzLCAnJnBvdW5kOyddLFxuICAgIFsxNjQsICcmY3VycmVuOyddLFxuICAgIFsxNjksICcmY29weTsnXSxcbiAgICBbMTc0LCAnJnJlZzsnXVxuXSk7XG5cblxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgc2FmZSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8IDEyMzsgKytpKSB7XG5cbiAgICAgICAgaWYgKChpID49IDk3KSB8fCAgICAgICAgICAgICAgICAgICAgLy8gYS16XG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgIC8vIEEtWlxuICAgICAgICAgICAgKGkgPj0gNDggJiYgaSA8PSA1NykgfHwgICAgICAgICAvLyAwLTlcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLlxuICAgICAgICAgICAgaSA9PT0gNDQgfHwgICAgICAgICAgICAgICAgICAgICAvLyAsXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgIC8vIC1cbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gOlxuICAgICAgICAgICAgaSA9PT0gOTUpIHsgICAgICAgICAgICAgICAgICAgICAvLyBfXG5cbiAgICAgICAgICAgIHNhZmUuYWRkKGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhZmU7XG59KCkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG9wZXJhdG9yczogWychJywgJ14nLCAnKicsICcvJywgJyUnLCAnKycsICctJywgJzwnLCAnPD0nLCAnPicsICc+PScsICc9PScsICchPScsICcmJicsICd8fCcsICc/PyddLFxuICAgIG9wZXJhdG9yQ2hhcmFjdGVyczogWychJywgJ14nLCAnKicsICcvJywgJyUnLCAnKycsICctJywgJzwnLCAnPScsICc+JywgJyYnLCAnfCcsICc/J10sXG4gICAgb3BlcmF0b3JzT3JkZXI6IFtbJ14nXSwgWycqJywgJy8nLCAnJSddLCBbJysnLCAnLSddLCBbJzwnLCAnPD0nLCAnPicsICc+PSddLCBbJz09JywgJyE9J10sIFsnJiYnXSwgWyd8fCcsICc/PyddXSxcbiAgICBvcGVyYXRvcnNQcmVmaXg6IFsnIScsICduJ10sXG5cbiAgICBsaXRlcmFsczoge1xuICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAnYCc6ICdgJyxcbiAgICAgICAgJ1xcJyc6ICdcXCcnLFxuICAgICAgICAnWyc6ICddJ1xuICAgIH0sXG5cbiAgICBudW1iZXJSeDogL14oPzpbMC05XSooXFwuWzAtOV0qKT8pezF9JC8sXG4gICAgdG9rZW5SeDogL15bXFx3XFwkXFwjXFwuXFxAXFw6XFx7XFx9XSskLyxcblxuICAgIHN5bWJvbDogU3ltYm9sKCdmb3JtdWxhJyksXG4gICAgc2V0dGluZ3M6IFN5bWJvbCgnc2V0dGluZ3MnKVxufTtcblxuXG5leHBvcnRzLlBhcnNlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zW2ludGVybmFscy5zZXR0aW5nc10gJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29uc3RhbnRzKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uc3RhbnQgaW4gb3B0aW9ucy5jb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuY29uc3RhbnRzW2NvbnN0YW50XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIVsnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb25zdGFudCAke2NvbnN0YW50fSBjb250YWlucyBpbnZhbGlkICR7dHlwZW9mIHZhbHVlfSB2YWx1ZSB0eXBlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHsgW2ludGVybmFscy5zZXR0aW5nc106IHRydWUsIGNvbnN0YW50czoge30sIGZ1bmN0aW9uczoge30gfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2luZ2xlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcnNlKHN0cmluZyk7XG4gICAgfVxuXG4gICAgX3BhcnNlKHN0cmluZykge1xuXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGZsdXNoID0gKGlubmVyKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBtaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhcnRzLmxlbmd0aCA/IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFsaXRlcmFsICYmXG4gICAgICAgICAgICAgICAgIWN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAhaW5uZXIpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPT09ICdyZWZlcmVuY2UnICYmXG4gICAgICAgICAgICAgICAgaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvblxuXG4gICAgICAgICAgICAgICAgbGFzdC50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBsYXN0LnZhbHVlID0gdGhpcy5fc3ViRm9ybXVsYShjdXJyZW50LCBsYXN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWdtZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gbmV3IGV4cG9ydHMuUGFyc2VyKGN1cnJlbnQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnc2VnbWVudCcsIHZhbHVlOiBzdWIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwgPT09ICddJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdyZWZlcmVuY2UnLCB2YWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6IGN1cnJlbnQgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXRlcmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRvclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ29wZXJhdG9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzLmluY2x1ZGVzKGxhc3QudmFsdWUgKyBjdXJyZW50KSkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gMiBjaGFyYWN0ZXJzIG9wZXJhdG9yXG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdC52YWx1ZSArPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnY29uc3RhbnQnLCB2YWx1ZTogcGFyc2VGbG9hdChjdXJyZW50KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiB0aGlzLnNldHRpbmdzLmNvbnN0YW50c1tjdXJyZW50XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5tYXRjaChpbnRlcm5hbHMudG9rZW5SeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgdG9rZW46ICR7Y3VycmVudH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHN0cmluZykge1xuICAgICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLm9wZXJhdG9yQ2hhcmFjdGVycy5pbmNsdWRlcyhjKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgcHJlZml4IC0gdG8gaW50ZXJuYWwgbmVnYXRpdmUgb3BlcmF0b3JcblxuICAgICAgICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCwgaSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlICE9PSAnb3BlcmF0b3InIHx8XG4gICAgICAgICAgICAgICAgcGFydC52YWx1ZSAhPT0gJy0nIHx8XG4gICAgICAgICAgICAgICAgaSAmJiBwYXJ0c1tpIC0gMV0udHlwZSAhPT0gJ29wZXJhdG9yJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnbicgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdG9rZW5zIG9yZGVyXG5cbiAgICAgICAgbGV0IG9wZXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIGNvbnRhaW5zIGFuIG9wZXJhdG9yIGluIGludmFsaWQgcG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGFuIHVua25vd24gb3BlcmF0b3IgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0b3IgPSAhb3BlcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgaW52YWxpZCB0cmFpbGluZyBvcGVyYXRvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWRlbnRpZnkgc2luZ2xlIHBhcnRcblxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBbJ3JlZmVyZW5jZScsICdsaXRlcmFsJywgJ2NvbnN0YW50J10uaW5jbHVkZXMocGFydHNbMF0udHlwZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5zaW5nbGUgPSB7IHR5cGU6IHBhcnRzWzBdLnR5cGUgPT09ICdyZWZlcmVuY2UnID8gJ3JlZmVyZW5jZScgOiAndmFsdWUnLCB2YWx1ZTogcGFydHNbMF0udmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBPcGVyYXRvcnNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpID8gcGFydCA6IHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpdGVyYWxzLCBjb25zdGFudHMsIHNlZ21lbnRzXG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudG9rZW5SeCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnNldHRpbmdzLnRva2VuUngudGVzdChwYXJ0LnZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgcmVmZXJlbmNlICR7cGFydC52YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZmVyZW5jZShwYXJ0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3N1YkZvcm11bGEoc3RyaW5nLCBuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5zZXR0aW5ncy5mdW5jdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgdW5rbm93biBmdW5jdGlvbiAke25hbWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgbGV0IHBhcmVudGhlc2lzID0gMDtcbiAgICAgICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBmdW5jdGlvbiAke25hbWV9IHdpdGggaW52YWxpZCBhcmd1bWVudHMgJHtzdHJpbmd9YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnLCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzID0gYXJncy5tYXAoKGFyZykgPT4gbmV3IGV4cG9ydHMuUGFyc2VyKGFyZywgdGhpcy5zZXR0aW5ncykpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgICAgICBjb25zdCBpbm5lclZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWVzLnB1c2goYXJnLmV2YWx1YXRlKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNvbnRleHQsIC4uLmlubmVyVmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9wYXJ0cy5zbGljZSgpO1xuXG4gICAgICAgIC8vIFByZWZpeCBvcGVyYXRvcnNcblxuICAgICAgICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICYmXG4gICAgICAgICAgICAgICAgcGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnRlcm5hbHMuZXZhbHVhdGUoY3VycmVudCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBpbnRlcm5hbHMuc2luZ2xlKHBhcnQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExlZnQtcmlnaHQgb3BlcmF0b3JzXG5cbiAgICAgICAgaW50ZXJuYWxzLm9wZXJhdG9yc09yZGVyLmZvckVhY2goKHNldCkgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5pbmNsdWRlcyhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpIC0gMV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpICsgMV0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmNhbGN1bGF0ZShvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpIC0gMV0gPSByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IC0wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzWzBdLCBjb250ZXh0KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuUGFyc2VyLnByb3RvdHlwZVtpbnRlcm5hbHMuc3ltYm9sXSA9IHRydWU7XG5cblxuaW50ZXJuYWxzLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcblxuICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0W25hbWVdICE9PSB1bmRlZmluZWQgPyBjb250ZXh0W25hbWVdIDogbnVsbDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuZXZhbHVhdGUgPSBmdW5jdGlvbiAocGFydCwgY29udGV4dCkge1xuXG4gICAgaWYgKHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwYXJ0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0W2ludGVybmFscy5zeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0O1xufTtcblxuXG5pbnRlcm5hbHMuc2luZ2xlID0gZnVuY3Rpb24gKG9wZXJhdG9yLCB2YWx1ZSkge1xuXG4gICAgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIC8vIG9wZXJhdG9yID09PSAnbidcblxuICAgIGNvbnN0IG5lZ2F0aXZlID0gLXZhbHVlO1xuICAgIGlmIChuZWdhdGl2ZSA9PT0gMCkgeyAgICAgICAvLyBPdmVycmlkZSAtMFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVnYXRpdmU7XG59O1xuXG5cbmludGVybmFscy5jYWxjdWxhdGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICc/PycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnKycpIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnRlcm5hbHMuZXhpc3RzKGxlZnQpID8gbGVmdCA6ICcnO1xuICAgICAgICAgICAgcmlnaHQgPSBpbnRlcm5hbHMuZXhpc3RzKHJpZ2h0KSA/IHJpZ2h0IDogJyc7XG4gICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICdeJzogcmV0dXJuIE1hdGgucG93KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBsZWZ0IDw9IHJpZ2h0O1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgY2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICBjYXNlICcmJic6IHJldHVybiBsZWZ0ICYmIHJpZ2h0O1xuICAgICAgICBjYXNlICd8fCc6IHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuZXhpc3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFubm90YXRpb25zOiBTeW1ib2woJ2Fubm90YXRpb25zJylcbn07XG5cblxuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uIChzdHJpcENvbG9yQ29kZXMpIHtcblxuICAgIGlmICghdGhpcy5fb3JpZ2luYWwgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuX29yaWdpbmFsICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICBjb25zdCByZWRCZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbNDFtJztcbiAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgY29uc3Qgb2JqID0gQ2xvbmUodGhpcy5fb3JpZ2luYWwpO1xuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZGV0YWlscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciB0byBwcm9jZXNzIGRlZXBlc3QgY2hpbGQgZmlyc3RcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5kZXRhaWxzW2ldO1xuICAgICAgICBjb25zdCBwYXRoID0gZXJyb3IucGF0aDtcbiAgICAgICAgbGV0IG5vZGUgPSBvYmo7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyA7ICsraikge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gcGF0aFtqXTtcblxuICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShub2RlKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gam9pIHNjaGVtYXMgYXJlIG5vdCBjbG9uZWQgYnkgaG9laywgd2UgaGF2ZSB0byB0YWtlIHRoaXMgZXh0cmEgc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaiArIDEgPCBwYXRoLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtzZWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmQW5ub3RhdGlvbnMgPSBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gfHwgeyBlcnJvcnM6IHt9LCBtaXNzaW5nOiB7fSB9O1xuICAgICAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSA9IHJlZkFubm90YXRpb25zO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzZWcgfHwgZXJyb3IuY29udGV4dC5rZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZVtzZWddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgIGtleTogL19cXCRrZXlcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIvZyxcbiAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICBzcGVjaWFsczogL1wiXFxbKE5hTnxTeW1ib2wuKnwtP0luZmluaXR5fGZ1bmN0aW9uLip8XFwoLiopXVwiL2dcbiAgICB9O1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5rZXksICgkMCwgJDEpID0+IGBcIiAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5zcGVjaWFscywgKCQwLCAkMSkgPT4gJDEpO1xuXG4gICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSArIGVuZENvbG9yO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5cbi8vIEluc3BpcmVkIGJ5IGpzb24tc3RyaW5naWZ5LXNhZmVcblxuaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBzcGFjZXMpIHtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGludGVybmFscy5zZXJpYWxpemVyKCksIHNwYWNlcyk7XG59O1xuXG5cbmludGVybmFscy5zZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG5cbiAgICBjb25zdCBjeWNsZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcblxuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+LicgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgKyAnXSc7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmICh+dGhpc1Bvcykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5c1t0aGlzUG9zXSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN5Y2xlUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHZhbHVlW2ludGVybmFscy5hbm5vdGF0aW9uc107XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGVkID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmVycm9yc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKGBfJGlkeCRfJHthbm5vdGF0aW9ucy5lcnJvcnNbaV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFubm90YXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3JLZXkgaW4gYW5ub3RhdGlvbnMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgJHtlcnJvcktleX1fJGtleSRfJHthbm5vdGF0aW9ucy5lcnJvcnNbZXJyb3JLZXldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gXSA9IHZhbHVlW2Vycm9yS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Vycm9yS2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlzc2luZ0tleSBpbiBhbm5vdGF0aW9ucy5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgXyRtaXNzJF8ke21pc3NpbmdLZXl9fCR7YW5ub3RhdGlvbnMubWlzc2luZ1ttaXNzaW5nS2V5XX1fJGVuZCRfYF0gPSAnX19taXNzaW5nX18nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSB8fFxuICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAnWycgKyB2YWx1ZS50b1N0cmluZygpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQW5ub3RhdGUgPSByZXF1aXJlKCcuL2Fubm90YXRlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5SZXBvcnQgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIGZsYWdzLCBtZXNzYWdlcywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMucGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIHRoaXMucHJlZnMgPSBwcmVmcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IHt9O1xuICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gZXhwb3J0cy5sYWJlbCh0aGlzLmZsYWdzLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzLCB0aGlzLm1lc3NhZ2VzKTtcblxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhdGhpcy5sb2NhbC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuXG4gICAgICAgICAgICB0aGlzLmxvY2FsLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbC5rZXkgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmxhYmVsICYmXG4gICAgICAgICAgICB0aGlzLnBhdGgubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUsICdyb290Jyk7XG4gICAgICAgICAgICBpZiAobG9jYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbC5sYWJlbCA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuXG4gICAgICAgIGlmICghdGhpcy5wcmVmcy5lcnJvcnMucmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5wcmVmcy5tZXNzYWdlcykgfHxcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlKHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNvZGUgXCIke2NvZGV9XCIgaXMgbm90IGRlZmluZWQsIHlvdXIgY3VzdG9tIHR5cGUgaXMgbWlzc2luZyB0aGUgY29ycmVjdCBtZXNzYWdlcyBkZWZpbml0aW9uYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciBhbmQgY2FjaGUgcmVzdWx0XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGVtcGxhdGUucmVuZGVyKHRoaXMudmFsdWUsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubG9jYWwsIHsgZXJyb3JzOiB0aGlzLnByZWZzLmVycm9ycywgbWVzc2FnZXM6IFt0aGlzLnByZWZzLm1lc3NhZ2VzLCB0aGlzLm1lc3NhZ2VzXSB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlLnJlcGxhY2UoL15cIlwiIC8sICcnKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cblxuICAgIF90ZW1wbGF0ZShtZXNzYWdlcywgY29kZSkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLnRlbXBsYXRlKHRoaXMudmFsdWUsIG1lc3NhZ2VzLCBjb2RlIHx8IHRoaXMuY29kZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcyk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgbGV0IGxhYmVsID0gJyc7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnb2JqZWN0JykgeyAgICAgICAgICAvLyBFeGNsdWRlIGFycmF5IHNpbmdsZSBwYXRoIHNlZ21lbnRcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgKz0gJy4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYWJlbCArPSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgKz0gYFske3NlZ21lbnR9XWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWw7XG59O1xuXG5cbmV4cG9ydHMudGVtcGxhdGUgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2VzKSkge1xuICAgICAgICByZXR1cm4gY29kZSAhPT0gJ3Jvb3QnID8gbWVzc2FnZXMgOiBudWxsO1xuICAgIH1cblxuICAgIGxldCBsYW5nID0gcHJlZnMuZXJyb3JzLmxhbmd1YWdlO1xuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGxhbmcpKSB7XG4gICAgICAgIGxhbmcgPSBsYW5nLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaWYgKGxhbmcgJiZcbiAgICAgICAgbWVzc2FnZXNbbGFuZ10pIHtcblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bY29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddW2NvZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2VzW2xhbmddWycqJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddWycqJ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1lc3NhZ2VzW2NvZGVdKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlc1snKiddO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlc1tjb2RlXTtcbn07XG5cblxuZXhwb3J0cy5sYWJlbCA9IGZ1bmN0aW9uIChmbGFncywgc3RhdGUsIHByZWZzLCBtZXNzYWdlcykge1xuXG4gICAgaWYgKGZsYWdzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoIXByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBzdGF0ZS5wYXRoO1xuICAgIGlmIChwcmVmcy5lcnJvcnMubGFiZWwgPT09ICdrZXknICYmXG4gICAgICAgIHN0YXRlLnBhdGgubGVuZ3RoID4gMSkge1xuXG4gICAgICAgIHBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKC0xKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gZXhwb3J0cy5wYXRoKHBhdGgpO1xuICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIHByZWZzLm1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgbWVzc2FnZXMgJiYgZXhwb3J0cy50ZW1wbGF0ZShudWxsLCBtZXNzYWdlcywgJ3Jvb3QnLCBzdGF0ZSwgcHJlZnMpIHx8XG4gICAgICAgICd2YWx1ZSc7XG59O1xuXG5cbmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9yaWdpbmFsLCBwcmVmcykge1xuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvdmVycmlkZSwgbWVzc2FnZSwgZGV0YWlscyB9ID0gZXhwb3J0cy5kZXRhaWxzKGVycm9ycyk7XG4gICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuZXJyb3JzLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGRldGFpbHMsIG9yaWdpbmFsKTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yO1xufTtcblxuXG5leHBvcnRzLmRldGFpbHMgPSBmdW5jdGlvbiAoZXJyb3JzLCBvcHRpb25zID0ge30pIHtcblxuICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBlcnJvcnMpIHtcblxuICAgICAgICAvLyBPdmVycmlkZVxuXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG92ZXJyaWRlOiBpdGVtIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogJ292ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7IGVycm9yOiBpdGVtIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcG9ydFxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGguZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiAhPT0gJ29iamVjdCcpLFxuICAgICAgICAgICAgdHlwZTogaXRlbS5jb2RlLFxuICAgICAgICAgICAgY29udGV4dDogaXRlbS5sb2NhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtZXNzYWdlcyA9IFsuLi5uZXcgU2V0KG1lc3NhZ2VzKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZXMuam9pbignLiAnKSwgZGV0YWlscyB9O1xufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpIHtcblxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWwgPSBvcmlnaW5hbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNFcnJvcihlcnIpIHtcblxuICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3I7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaXNKb2kgPSB0cnVlO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuYW5ub3RhdGUgPSBBbm5vdGF0ZS5lcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5sZXQgVGVtcGxhdGU7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCdyZWYnKSwgICAgICAvLyBVc2VkIHRvIGludGVybmFsbHkgaWRlbnRpZnkgcmVmZXJlbmNlcyAoc2hhcmVkIHdpdGggb3RoZXIgam9pIHZlcnNpb25zKVxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGFkanVzdDogbnVsbCxcbiAgICAgICAgaW46IGZhbHNlLFxuICAgICAgICBpdGVyYWJsZXM6IG51bGwsXG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgc2VwYXJhdG9yOiAnLicsXG4gICAgICAgIHR5cGU6ICd2YWx1ZSdcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQodHlwZW9mIGtleSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJlZmVyZW5jZSBrZXk6Jywga2V5KTtcbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3ByZWZpeCcsICdyZW5kZXInLCAnc2VwYXJhdG9yJ10pO1xuICAgIEFzc2VydCghb3B0aW9ucy5wcmVmaXggfHwgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnb2JqZWN0JywgJ29wdGlvbnMucHJlZml4IG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcblxuICAgIGNvbnN0IHJlZiA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgZGVsZXRlIHJlZi5wcmVmaXg7XG5cbiAgICBjb25zdCBzZXBhcmF0b3IgPSByZWYuc2VwYXJhdG9yO1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnRlcm5hbHMuY29udGV4dChrZXksIHNlcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIHJlZi50eXBlID0gY29udGV4dC50eXBlO1xuICAgIGtleSA9IGNvbnRleHQua2V5O1xuXG4gICAgaWYgKHJlZi50eXBlID09PSAndmFsdWUnKSB7XG4gICAgICAgIGlmIChjb250ZXh0LnJvb3QpIHtcbiAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IHNwZWNpZnkgcmVsYXRpdmUgcGF0aCB3aXRoIHJvb3QgcHJlZml4Jyk7XG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSAncm9vdCc7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBzZXBhcmF0b3IgPT09IGtleSkge1xuXG4gICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWYuYW5jZXN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8ICFrZXkgfHwga2V5WzBdICE9PSBzZXBhcmF0b3IsICdDYW5ub3QgY29tYmluZSBwcmVmaXggd2l0aCBhbmNlc3RvciBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFthbmNlc3Rvciwgc2xpY2VdID0gaW50ZXJuYWxzLmFuY2VzdG9yKGtleSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWYuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5wYXRoID0gc2VwYXJhdG9yID8gKGtleSA9PT0gbnVsbCA/IFtdIDoga2V5LnNwbGl0KHNlcGFyYXRvcikpIDogW2tleV07XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYocmVmKTtcbn07XG5cblxuZXhwb3J0cy5pbiA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuY3JlYXRlKGtleSwgeyAuLi5vcHRpb25zLCBpbjogdHJ1ZSB9KTtcbn07XG5cblxuZXhwb3J0cy5pc1JlZiA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgIHJldHVybiByZWYgPyAhIXJlZltDb21tb24uc3ltYm9scy5yZWZdIDogZmFsc2U7XG59O1xuXG5cbmludGVybmFscy5SZWYgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcmVmZXJlbmNlIGNvbnN0cnVjdGlvbicpO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbXG4gICAgICAgICAgICAnYWRqdXN0JywgJ2FuY2VzdG9yJywgJ2luJywgJ2l0ZXJhYmxlcycsICdtYXAnLCAncGF0aCcsICdyZW5kZXInLCAnc2VwYXJhdG9yJywgJ3R5cGUnLCAgLy8gQ29waWVkXG4gICAgICAgICAgICAnZGVwdGgnLCAna2V5JywgJ3Jvb3QnLCAnZGlzcGxheScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGRlblxuICAgICAgICBdKTtcblxuICAgICAgICBBc3NlcnQoW2ZhbHNlLCB1bmRlZmluZWRdLmluY2x1ZGVzKG9wdGlvbnMuc2VwYXJhdG9yKSB8fCB0eXBlb2Ygb3B0aW9ucy5zZXBhcmF0b3IgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuc2VwYXJhdG9yLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgc2VwYXJhdG9yJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5hZGp1c3QgfHwgdHlwZW9mIG9wdGlvbnMuYWRqdXN0ID09PSAnZnVuY3Rpb24nLCAnb3B0aW9ucy5hZGp1c3QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcCksICdvcHRpb25zLm1hcCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgIW9wdGlvbnMuYWRqdXN0LCAnQ2Fubm90IHNldCBib3RoIG1hcCBhbmQgYWRqdXN0IG9wdGlvbnMnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyB8fCB0aGlzLmFuY2VzdG9yID09PSB1bmRlZmluZWQsICdOb24tdmFsdWUgcmVmZXJlbmNlcyBjYW5ub3QgcmVmZXJlbmNlIGFuY2VzdG9ycycpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWFwKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKHRoaXMubWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLnBhdGgubGVuZ3RoO1xuICAgICAgICB0aGlzLmtleSA9IHRoaXMucGF0aC5sZW5ndGggPyB0aGlzLnBhdGguam9pbih0aGlzLnNlcGFyYXRvcikgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhdGhbMF07XG5cbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLmluIHx8IG9wdGlvbnMuaW4sICdJbnZhbGlkIGluKCkgcmVmZXJlbmNlIHVzYWdlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHByZWZzLmNvbnRleHQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKGxvY2FsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShzdGF0ZS5hbmNlc3RvcnNbc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCAtIDFdLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodGhpcy5hbmNlc3RvciA8PSBzdGF0ZS5hbmNlc3RvcnMubGVuZ3RoLCAnSW52YWxpZCByZWZlcmVuY2UgZXhjZWVkcyB0aGUgc2NoZW1hIHJvb3Q6JywgdGhpcy5kaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3RoaXMuYW5jZXN0b3IgLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9yZXNvbHZlKHRhcmdldCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgcmVzb2x2ZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuc2hhZG93ICYmXG4gICAgICAgICAgICBvcHRpb25zLnNoYWRvdyAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBzdGF0ZS5tYWluc3RheS5zaGFkb3cuZ2V0KHRoaXMuYWJzb2x1dGUoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IFJlYWNoKHRhcmdldCwgdGhpcy5wYXRoLCB7IGl0ZXJhYmxlczogdGhpcy5pdGVyYWJsZXMsIGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFkanVzdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0aGlzLmFkanVzdChyZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRoaXMubWFwLmdldChyZXNvbHZlZCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IG1hcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5tYWluc3RheSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnJlc29sdmUoc3RhdGUsIHRoaXMsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5O1xuICAgIH1cblxuICAgIGFic29sdXRlKHN0YXRlKSB7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZS5wYXRoLnNsaWNlKDAsIC10aGlzLmFuY2VzdG9yKSwgLi4udGhpcy5wYXRoXTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYodGhpcyk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgcmVmID0geyBwYXRoOiB0aGlzLnBhdGggfTtcblxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICByZWYudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICByZWYuc2VwYXJhdG9yID0gdGhpcy5zZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9yICE9PSAxKSB7XG5cbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IHRoaXMuYW5jZXN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHJlZi5tYXAgPSBbLi4udGhpcy5tYXBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydhZGp1c3QnLCAnaXRlcmFibGVzJywgJ3JlbmRlciddKSB7XG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHJlZltrZXldID0gdGhpc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZWYuaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVmIH07XG4gICAgfVxuXG4gICAgdXBkYXRlRGlzcGxheSgpIHtcblxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleSAhPT0gbnVsbCA/IHRoaXMua2V5IDogJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHt0aGlzLnR5cGV9OiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHt0aGlzLnNlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjpyb290OiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleSB8fCAnLi4nfWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZWFkID0gbmV3IEFycmF5KHRoaXMuYW5jZXN0b3IgKyAxKS5maWxsKHRoaXMuc2VwYXJhdG9yKS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2xlYWR9JHtrZXkgfHwgJyd9YDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5SZWYucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnJlZl0gPSB0cnVlO1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoZGVzYykge1xuXG4gICAgZGVzYyA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFscy5kZWZhdWx0cywgZGVzYyk7XG4gICAgaWYgKGRlc2MudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICBkZXNjLmFuY2VzdG9yID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBkZXNjLmFuY2VzdG9yID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5jb250ZXh0ID0gZnVuY3Rpb24gKGtleSwgc2VwYXJhdG9yLCBwcmVmaXggPSB7fSkge1xuXG4gICAga2V5ID0ga2V5LnRyaW0oKTtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscCA9IHByZWZpeC5nbG9iYWwgPT09IHVuZGVmaW5lZCA/ICckJyA6IHByZWZpeC5nbG9iYWw7XG4gICAgICAgIGlmIChnbG9iYWxwICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGdsb2JhbHApKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGdsb2JhbHAubGVuZ3RoKSwgdHlwZTogJ2dsb2JhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvY2FsID0gcHJlZml4LmxvY2FsID09PSB1bmRlZmluZWQgPyAnIycgOiBwcmVmaXgubG9jYWw7XG4gICAgICAgIGlmIChsb2NhbCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChsb2NhbCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2UobG9jYWwubGVuZ3RoKSwgdHlwZTogJ2xvY2FsJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm9vdCA9IHByZWZpeC5yb290ID09PSB1bmRlZmluZWQgPyAnLycgOiBwcmVmaXgucm9vdDtcbiAgICAgICAgaWYgKHJvb3QgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgocm9vdCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2Uocm9vdC5sZW5ndGgpLCB0eXBlOiAndmFsdWUnLCByb290OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBrZXksIHR5cGU6ICd2YWx1ZScgfTtcbn07XG5cblxuaW50ZXJuYWxzLmFuY2VzdG9yID0gZnVuY3Rpb24gKGtleSwgc2VwYXJhdG9yKSB7XG5cbiAgICBpZiAoIXNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gWzEsIDBdOyAgICAgICAgICAgICAgLy8gJ2FfYicgLT4gMSAocGFyZW50KVxuICAgIH1cblxuICAgIGlmIChrZXlbMF0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJ2EuYicgLT4gMSAocGFyZW50KVxuICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgIH1cblxuICAgIGlmIChrZXlbMV0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJy5hLmInIC0+IDAgKHNlbGYpXG4gICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgfVxuXG4gICAgbGV0IGkgPSAyO1xuICAgIHdoaWxlIChrZXlbaV0gPT09IHNlcGFyYXRvcikge1xuICAgICAgICArK2k7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpIC0gMSwgaV07ICAgICAgICAgICAgICAvLyAnLi4uYS5iLicgLT4gMiAoZ3JhbmRwYXJlbnQpXG59O1xuXG5cbmV4cG9ydHMudG9TaWJsaW5nID0gMDtcblxuZXhwb3J0cy50b1BhcmVudCA9IDE7XG5cblxuZXhwb3J0cy5NYW5hZ2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107ICAgICAgICAgICAgICAgICAgICAgLy8gMDogW3NlbGYgcmVmc10sIDE6IFtwYXJlbnQgcmVmc10sIDI6IFtncmFuZHBhcmVudCByZWZzXSwgLi4uXG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc291cmNlLCB0YXJnZXQpIHtcblxuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBleHBvcnRzLnRvUGFyZW50IDogdGFyZ2V0O1xuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2Ygc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjaGVtYVxuXG4gICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZS5fcmVmcy5yZWZzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYW5jZXN0b3IgLSB0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnMucHVzaCh7IGFuY2VzdG9yOiBpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBpdGVtLnJvb3QgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoZXhwb3J0cy5pc1JlZihzb3VyY2UpICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcblxuICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3Rvcjogc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBzb3VyY2Uucm9vdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBsYXRlXG5cbiAgICAgICAgVGVtcGxhdGUgPSBUZW1wbGF0ZSB8fCByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihzb3VyY2UucmVmcygpLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IGV4cG9ydHMuTWFuYWdlcigpO1xuICAgICAgICBjb3B5LnJlZnMgPSBDbG9uZSh0aGlzLnJlZnMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLnJlZnMgPSBbXTtcbiAgICB9XG5cbiAgICByb290cygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmZpbHRlcigocmVmKSA9PiAhcmVmLmFuY2VzdG9yKS5tYXAoKHJlZikgPT4gcmVmLnJvb3QpO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IEVzY2FwZUh0bWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sJyk7XG5jb25zdCBGb3JtdWxhID0gcmVxdWlyZSgnQHNpZGV3YXkvZm9ybXVsYScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuXG4gICAgb3BlbnM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAwJyksXG4gICAgY2xvc2VzOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMScpLFxuXG4gICAgZGF0ZUZvcm1hdDoge1xuICAgICAgICBkYXRlOiBEYXRlLnByb3RvdHlwZS50b0RhdGVTdHJpbmcsXG4gICAgICAgIGlzbzogRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcsXG4gICAgICAgIHN0cmluZzogRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIHRpbWU6IERhdGUucHJvdG90eXBlLnRvVGltZVN0cmluZyxcbiAgICAgICAgdXRjOiBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZ1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gaW50ZXJuYWxzLlRlbXBsYXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnVGVtcGxhdGUgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDAnKSAmJiAhc291cmNlLmluY2x1ZGVzKCdcXHUwMDAxJyksICdUZW1wbGF0ZSBzb3VyY2UgY2Fubm90IGNvbnRhaW4gcmVzZXJ2ZWQgY29udHJvbCBjaGFyYWN0ZXJzJyk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBzb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9ucywgLi4ub3B0cyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID8gQ2xvbmUob3B0cykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX2Z1bmN0aW9ucykuZXZlcnkoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpLCAnRnVuY3Rpb25zIGtleXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC52YWx1ZXModGhpcy5fZnVuY3Rpb25zKS5ldmVyeSgoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSwgJ0Z1bmN0aW9ucyB2YWx1ZXMgbXVzdCBiZSBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IHBhcnQuc2xpY2UocmF3ID8gMCA6IDEsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdmFyaWFibGVbMF0gPT09ICc6JztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgeyByYXcsIHdyYXBwZWQgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGRlc2MuZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMgfHwgZGVzYy5mdW5jdGlvbnMgPyB7IC4uLmRlc2Mub3B0aW9ucywgZnVuY3Rpb25zOiBkZXNjLmZ1bmN0aW9ucyB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVybmFscy53cmFwKHJlc3VsdCwgcGFydC53cmFwcGVkICYmIHByZWZzLmVycm9ycy53cmFwLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgeyByYXcsIHdyYXBwZWQgfSkge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZWQgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zID8geyAuLi5pbnRlcm5hbHMuZnVuY3Rpb25zLCAuLi50aGlzLl9mdW5jdGlvbnMgfSA6IGludGVybmFscy5mdW5jdGlvbnM7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhLlBhcnNlcihjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWYsIHJhdywgcmVmcywgd3JhcHBlZDogd3JhcHBlZCB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJyAmJiByZWYua2V5ID09PSAnbGFiZWwnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc3RyaW5naWZ5KGZvcm11bGEuc2luZ2xlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZvcm11bGEsIHJhdywgcmVmcyB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdID0gdHJ1ZTtcbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx7KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZW5zLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcfSspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9zZXMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSk7XG59O1xuXG5cbmludGVybmFscy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICd7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDEvZywgJ30nKTtcbn07XG5cblxuaW50ZXJuYWxzLnNwbGl0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcblxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgc3RyaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICd7Jykge1xuXG4gICAgICAgICAgICAgICAgbmV4dCArPSAneyc7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgIHJldHVybiBwYXJ0cztcbn07XG5cblxuaW50ZXJuYWxzLndyYXAgPSBmdW5jdGlvbiAodmFsdWUsIGVuZHMpIHtcblxuICAgIGlmICghZW5kcykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmRzfSR7dmFsdWV9JHtlbmRzfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2VuZHNbMF19JHt2YWx1ZX0ke2VuZHNbMV19YDtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjb25zdCB3cmFwID0gcHJlZnMgJiYgcHJlZnMuZXJyb3JzICYmIHByZWZzLmVycm9ycy53cmFwIHx8IHt9O1xuXG4gICAgbGV0IHNraXBXcmFwID0gZmFsc2U7XG4gICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUucmVuZGVyKSB7XG5cbiAgICAgICAgc2tpcFdyYXAgPSB2YWx1ZS5pbjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNvbHZlKG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCB7IGluOiB2YWx1ZS5pbiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHZhbHVlLCBvcHRpb25zLmFycmF5SXRlbXMgJiYgd3JhcC5zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLlRlbXBsYXRlLmRhdGUodmFsdWUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzeW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChgJHtrZXkudG9TdHJpbmcoKX0gLT4gJHtzeW0udG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcGFpcnM7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goaW50ZXJuYWxzLnN0cmluZ2lmeShpdGVtLCBvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgeyBhcnJheUl0ZW1zOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAodmFsdWVzLmpvaW4oJywgJyksICFza2lwV3JhcCAmJiB3cmFwLmFycmF5KTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnN0YW50cyA9IHtcblxuICAgIHRydWU6IHRydWUsXG4gICAgZmFsc2U6IGZhbHNlLFxuICAgIG51bGw6IG51bGwsXG5cbiAgICBzZWNvbmQ6IDEwMDAsXG4gICAgbWludXRlOiA2MCAqIDEwMDAsXG4gICAgaG91cjogNjAgKiA2MCAqIDEwMDAsXG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG5cbmludGVybmFscy5mdW5jdGlvbnMgPSB7XG5cbiAgICBpZihjb25kaXRpb24sIHRoZW4sIG90aGVyd2lzZSkge1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGgoaXRlbSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIHRhcmdldCkge1xuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZyAoJ3BsYWluIGVycm9yIG1lc3NhZ2UnLCAndGVtcGxhdGUge2Vycm9yfSBtZXNzYWdlJylcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShtZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHRlbXBsYXRlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSwgJ0ludmFsaWQgbWVzc2FnZSBvcHRpb25zJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgPyBDbG9uZSh0YXJnZXQpIDoge307XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0YXJnZXQucm9vdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV0ucm9vdCA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZC5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGJhc2UsIGV4dGVuZGVkKSB7XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcGlsZShleHRlbmRlZCk7XG4gICAgfVxuXG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nXG5cbiAgICBpZiAodHlwZW9mIGV4dGVuZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKGV4dGVuZGVkKSkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBDbG9uZShiYXNlKTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gZXh0ZW5kZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4dGVuZGVkW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBBc3NlcnRFcnJvciA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Vycm9yJyk7XG5cbmNvbnN0IFBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5sZXQgTWVzc2FnZXM7XG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgaXNvRGF0ZTogL14oPzpbLStdXFxkezJ9KT8oPzpcXGR7NH0oPyFcXGR7Mn1cXGIpKSg/OigtPykoPzooPzowWzEtOV18MVswLTJdKSg/OlxcMSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoPzpbMC00XVxcZHw1WzAtMl0pKD86LT9bMS03XSk/fCg/OjAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18Myg/OlswLTVdXFxkfDZbMS02XSkpKSg/IVtUXSR8W1RdW1xcZF0rWiQpKD86W1RcXHNdKD86KD86KD86WzAxXVxcZHwyWzAtM10pKD86KDo/KVswLTVdXFxkKT98MjRcXDo/MDApKD86Wy4sXVxcZCsoPyE6KSk/KSg/OlxcMlswLTVdXFxkKD86Wy4sXVxcZCspPyk/KD86W1pdfCg/OlsrLV0pKD86WzAxXVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KT8pPyk/JC9cbn07XG5cblxuZXhwb3J0cy52ZXJzaW9uID0gUGtnLnZlcnNpb247XG5cblxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgIGFsbG93VW5rbm93bjogZmFsc2UsXG4gICAgYXJ0aWZhY3RzOiBmYWxzZSxcbiAgICBjYWNoZTogdHJ1ZSxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgZGF0ZUZvcm1hdDogJ2lzbycsXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IGZhbHNlLFxuICAgICAgICBsYWJlbDogJ3BhdGgnLFxuICAgICAgICBsYW5ndWFnZTogbnVsbCxcbiAgICAgICAgcmVuZGVyOiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UsXG4gICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnXCInLFxuICAgICAgICAgICAgYXJyYXk6ICdbXSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiB0cnVlLFxuICAgIG1lc3NhZ2VzOiB7fSxcbiAgICBub25FbnVtZXJhYmxlczogZmFsc2UsXG4gICAgbm9EZWZhdWx0czogZmFsc2UsXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXG4gICAgc2tpcEZ1bmN0aW9uczogZmFsc2UsXG4gICAgc3RyaXBVbmtub3duOiBmYWxzZSxcbiAgICB3YXJuaW5nczogZmFsc2Vcbn07XG5cblxuZXhwb3J0cy5zeW1ib2xzID0ge1xuICAgIGFueTogU3ltYm9sLmZvcignQGhhcGkvam9pL3NjaGVtYScpLCAgICAgICAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSBhbnktYmFzZWQgdHlwZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBhcnJheVNpbmdsZTogU3ltYm9sKCdhcnJheVNpbmdsZScpLFxuICAgIGRlZXBEZWZhdWx0OiBTeW1ib2woJ2RlZXBEZWZhdWx0JyksXG4gICAgZXJyb3JzOiBTeW1ib2woJ2Vycm9ycycpLFxuICAgIGxpdGVyYWw6IFN5bWJvbCgnbGl0ZXJhbCcpLFxuICAgIG92ZXJyaWRlOiBTeW1ib2woJ292ZXJyaWRlJyksXG4gICAgcGFyZW50OiBTeW1ib2woJ3BhcmVudCcpLFxuICAgIHByZWZzOiBTeW1ib2woJ3ByZWZzJyksXG4gICAgcmVmOiBTeW1ib2woJ3JlZicpLFxuICAgIHRlbXBsYXRlOiBTeW1ib2woJ3RlbXBsYXRlJyksXG4gICAgdmFsdWVzOiBTeW1ib2woJ3ZhbHVlcycpXG59O1xuXG5cbmV4cG9ydHMuYXNzZXJ0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXlzLCBuYW1lID0gJ09wdGlvbnMnKSB7XG5cbiAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucyksICdPcHRpb25zIG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcbiAgICBjb25zdCB1bmtub3duS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoaykgPT4gIWtleXMuaW5jbHVkZXMoaykpO1xuICAgIEFzc2VydCh1bmtub3duS2V5cy5sZW5ndGggPT09IDAsIGAke25hbWV9IGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25LZXlzfWApO1xufTtcblxuXG5leHBvcnRzLmNoZWNrUHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAocHJlZnMpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gU2NoZW1hcy5wcmVmZXJlbmNlcy52YWxpZGF0ZShwcmVmcyk7XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRFcnJvcihbcmVzdWx0LmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZV0pO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIG9wZXJhdG9yKSB7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz0nOiByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgY2FzZSAnPic6IHJldHVybiBhID4gYjtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBhIDwgYjtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gYSA+PSBiO1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBhIDw9IGI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn07XG5cblxuZXhwb3J0cy5pc0lzb0RhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5pc29EYXRlLnRlc3QoZGF0ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZXNvbHZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnJlZl0gfHwgb2JqW2V4cG9ydHMuc3ltYm9scy50ZW1wbGF0ZV07XG59O1xuXG5cbmV4cG9ydHMuaXNTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYSAmJiBzY2hlbWFbZXhwb3J0cy5zeW1ib2xzLmFueV07XG4gICAgaWYgKCFhbnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIEFzc2VydChvcHRpb25zLmxlZ2FjeSB8fCBhbnkudmVyc2lvbiA9PT0gZXhwb3J0cy52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXMnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnZhbHVlc107XG59O1xuXG5cbmV4cG9ydHMubGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbn07XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXG4gICAgTWVzc2FnZXMgPSBNZXNzYWdlcyB8fCByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgc291cmNlID0gc291cmNlIHx8IHt9O1xuXG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UuZXJyb3JzICYmXG4gICAgICAgIHRhcmdldC5lcnJvcnMpIHtcblxuICAgICAgICBtZXJnZWQuZXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LmVycm9ycywgc291cmNlLmVycm9ycyk7XG4gICAgICAgIG1lcmdlZC5lcnJvcnMud3JhcCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMud3JhcCwgc291cmNlLmVycm9ycy53cmFwKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm1lc3NhZ2VzKSB7XG4gICAgICAgIG1lcmdlZC5tZXNzYWdlcyA9IE1lc3NhZ2VzLmNvbXBpbGUoc291cmNlLm1lc3NhZ2VzLCB0YXJnZXQubWVzc2FnZXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBtZXJnZWRbZXhwb3J0cy5zeW1ib2xzLnByZWZzXTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufTtcblxuXG5leHBvcnRzLnRyeVdpdGhQYXRoID0gZnVuY3Rpb24gKGZuLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5ICsgJy4nICsgZXJyLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlQXJnID0gZnVuY3Rpb24gKHZhbHVlLCBsYWJlbCwgeyBhc3NlcnQsIG1lc3NhZ2UgfSkge1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTY2hlbWEoYXNzZXJ0KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhc3NlcnQudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYXNzZXJ0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGFiZWwgPyBgJHtsYWJlbH0gJHttZXNzYWdlfWAgOiBtZXNzYWdlO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52ZXJpZnlGbGF0ID0gZnVuY3Rpb24gKGFyZ3MsIG1ldGhvZCkge1xuXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBBc3NlcnQoIUFycmF5LmlzQXJyYXkoYXJnKSwgJ01ldGhvZCBubyBsb25nZXIgYWNjZXB0cyBhcnJheSBhcmd1bWVudHM6JywgbWV0aG9kKTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1heDogMTAwMCxcbiAgICBzdXBwb3J0ZWQ6IG5ldyBTZXQoWyd1bmRlZmluZWQnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10pXG59O1xuXG5cbmV4cG9ydHMucHJvdmlkZXIgPSB7XG5cbiAgICBwcm92aXNpb24ob3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkNhY2hlKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuLy8gTGVhc3QgUmVjZW50bHkgVXNlZCAoTFJVKSBDYWNoZVxuXG5pbnRlcm5hbHMuQ2FjaGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ21heCddKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubWF4ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXggJiYgb3B0aW9ucy5tYXggPiAwICYmIGlzRmluaXRlKG9wdGlvbnMubWF4KSwgJ0ludmFsaWQgbWF4IGNhY2hlIHNpemUnKTtcblxuICAgICAgICB0aGlzLl9tYXggPSBvcHRpb25zLm1heCB8fCBpbnRlcm5hbHMubWF4O1xuXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCBvZiBub2RlcyBieSBrZXlcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBpbnRlcm5hbHMuTGlzdCgpOyAgICAgICAgICAgICAgLy8gTGlzdCBvZiBub2RlcyAobW9zdCByZWNlbnRseSB1c2VkIGluIGhlYWQpXG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gICAgfVxuXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoa2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnN1cHBvcnRlZC5oYXModHlwZW9mIGtleSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHRoaXMuX2xpc3QudW5zaGlmdCh7IGtleSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBub2RlKTtcbiAgICAgICAgdGhpcy5fY29tcGFjdCgpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb21wYWN0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXAuc2l6ZSA+IHRoaXMuX21heCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2xpc3QucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkxpc3QgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIH1cblxuICAgIHVuc2hpZnQobm9kZSkge1xuXG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgIG5vZGUucHJldiA9IHRoaXMuaGVhZDtcblxuICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQubmV4dCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZmlyc3Qobm9kZSkge1xuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcbiAgICAgICAgdGhpcy51bnNoaWZ0KG5vZGUpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKHRoaXMudGFpbCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZShub2RlKSB7XG5cbiAgICAgICAgY29uc3QgeyBuZXh0LCBwcmV2IH0gPSBub2RlO1xuXG4gICAgICAgIG5leHQucHJldiA9IHByZXY7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYXBwZW5kUGF0aCcsICdvdmVycmlkZSddKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2NoZW1hKEpvaSwgY29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAob3B0aW9ucy5hcHBlbmRQYXRoICYmXG4gICAgICAgICAgICBlcnIucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5wYXRofSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGNvbmZpZyAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCB1bmRlZmluZWQgc2NoZW1hJyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIEFzc2VydChjb25maWcubGVuZ3RoLCAnSW52YWxpZCBlbXB0eSBhcnJheSBzY2hlbWEnKTtcblxuICAgICAgICBpZiAoY29uZmlnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSAoYmFzZSwgLi4udmFsdWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS52YWxpZChKb2kub3ZlcnJpZGUsIC4uLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZS52YWxpZCguLi52YWx1ZXMpO1xuICAgIH07XG5cbiAgICBpZiAoaW50ZXJuYWxzLnNpbXBsZShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIEpvaS5jdXN0b20oY29uZmlnKTtcbiAgICB9XG5cbiAgICBBc3NlcnQodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNjaGVtYSBjb250ZW50OicsIHR5cGVvZiBjb25maWcpO1xuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuc2ltcGxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpvaS5hbHRlcm5hdGl2ZXMoKS50cnkoLi4uY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIC4uLmNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnJlZ2V4KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaS5kYXRlKCksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25maWcpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pLCAnU2NoZW1hIGNhbiBvbmx5IGNvbnRhaW4gcGxhaW4gb2JqZWN0cycpO1xuXG4gICAgcmV0dXJuIEpvaS5vYmplY3QoKS5rZXlzKGNvbmZpZyk7XG59O1xuXG5cbmV4cG9ydHMucmVmID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gUmVmLmlzUmVmKGlkKSA/IGlkIDogUmVmLmNyZWF0ZShpZCwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChyb290LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydsZWdhY3knXSk7XG5cbiAgICAvLyBDb21waWxlZCBieSBhbnkgc3VwcG9ydGVkIHZlcnNpb25cblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYSAmJiBzY2hlbWFbQ29tbW9uLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoYW55KSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmxlZ2FjeSB8fCBhbnkudmVyc2lvbiA9PT0gQ29tbW9uLnZlcnNpb24sICdDYW5ub3QgbWl4IGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBqb2kgc2NoZW1hczonLCBhbnkudmVyc2lvbiwgQ29tbW9uLnZlcnNpb24pO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFVuY29tcGlsZWQgcm9vdFxuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICFvcHRpb25zLmxlZ2FjeSkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLnNjaGVtYShyb290LCBzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTsgICAgICAgICAgLy8gV2lsbCBlcnJvciBpZiBzY2hlbWEgY29udGFpbnMgb3RoZXIgdmVyc2lvbnNcbiAgICB9XG5cbiAgICAvLyBTY2FuIHNjaGVtYSBmb3IgY29tcGlsZWQgcGFydHNcblxuICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoc2NoZW1hKTtcbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnNjaGVtYShyb290LCBzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGlsZXIuY29tcGlsZShjb21waWxlci5yb290LCBzY2hlbWEpO1xufTtcblxuXG5pbnRlcm5hbHMud2FsayA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoaXRlbSk7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWFbQ29tbW9uLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoYW55KSB7XG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHNjaGVtYVthbnkucm9vdF0sIGNvbXBpbGU6IGFueS5jb21waWxlIH07XG4gICAgfVxuXG4gICAgQXNzZXJ0KE9iamVjdC5nZXRQcm90b3R5cGVPZihzY2hlbWEpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pLCAnU2NoZW1hIGNhbiBvbmx5IGNvbnRhaW4gcGxhaW4gb2JqZWN0cycpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoc2NoZW1hW2tleV0pO1xuICAgICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuc2ltcGxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgWydib29sZWFuJywgJ3N0cmluZycsICdudW1iZXInXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpO1xufTtcblxuXG5leHBvcnRzLndoZW4gPSBmdW5jdGlvbiAoc2NoZW1hLCBjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQXNzZXJ0KGNvbmRpdGlvbiAmJiB0eXBlb2YgY29uZGl0aW9uID09PSAnb2JqZWN0JywgJ01pc3Npbmcgb3B0aW9ucycpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBjb25kaXRpb247XG4gICAgICAgIGNvbmRpdGlvbiA9IFJlZi5jcmVhdGUoJy4nKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBzd2l0Y2g6IG9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lzJywgJ25vdCcsICd0aGVuJywgJ290aGVyd2lzZScsICdzd2l0Y2gnLCAnYnJlYWsnXSk7XG5cbiAgICAvLyBTY2hlbWEgY29uZGl0aW9uXG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmRpdGlvbikpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ1wiaXNcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQsICdcIm5vdFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5zd2l0Y2ggPT09IHVuZGVmaW5lZCwgJ1wic3dpdGNoXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jb25kaXRpb24oc2NoZW1hLCB7IGlzOiBjb25kaXRpb24sIHRoZW46IG9wdGlvbnMudGhlbiwgb3RoZXJ3aXNlOiBvcHRpb25zLm90aGVyd2lzZSwgYnJlYWs6IG9wdGlvbnMuYnJlYWsgfSk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbmRpdGlvblxuXG4gICAgQXNzZXJ0KFJlZi5pc1JlZihjb25kaXRpb24pIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnLCAnSW52YWxpZCBjb25kaXRpb246JywgY29uZGl0aW9uKTtcbiAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcImlzXCIgd2l0aCBcIm5vdFwiJyk7XG5cbiAgICBpZiAob3B0aW9ucy5zd2l0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcnVsZSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm5vdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydWxlID0geyBpczogb3B0aW9ucy5ub3QsIHRoZW46IG9wdGlvbnMub3RoZXJ3aXNlLCBvdGhlcndpc2U6IG9wdGlvbnMudGhlbiwgYnJlYWs6IG9wdGlvbnMuYnJlYWsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpcyA9IHJ1bGUuaXMgIT09IHVuZGVmaW5lZCA/IHNjaGVtYS4kX2NvbXBpbGUocnVsZS5pcykgOiBzY2hlbWEuJF9yb290LmludmFsaWQobnVsbCwgZmFsc2UsIDAsICcnKS5yZXF1aXJlZCgpO1xuICAgICAgICBBc3NlcnQocnVsZS50aGVuICE9PSB1bmRlZmluZWQgfHwgcnVsZS5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCwgJ29wdGlvbnMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBcInRoZW5cIiwgXCJvdGhlcndpc2VcIiwgb3IgXCJzd2l0Y2hcIicpO1xuICAgICAgICBBc3NlcnQocnVsZS5icmVhayA9PT0gdW5kZWZpbmVkIHx8IHJ1bGUudGhlbiA9PT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSB0aGVuLCBvdGhlcndpc2UsIGFuZCBicmVhayBhbGwgdG9nZXRoZXInKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5pcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhUmVmLmlzUmVmKG9wdGlvbnMuaXMpICYmXG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKG9wdGlvbnMuaXMpKSB7XG5cbiAgICAgICAgICAgIGlzID0gaXMucmVxdWlyZWQoKTsgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWZcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyByZWY6IGV4cG9ydHMucmVmKGNvbmRpdGlvbiksIGlzLCB0aGVuOiBydWxlLnRoZW4sIG90aGVyd2lzZTogcnVsZS5vdGhlcndpc2UsIGJyZWFrOiBydWxlLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCBzdGF0ZW1lbnRcblxuICAgIEFzc2VydChBcnJheS5pc0FycmF5KG9wdGlvbnMuc3dpdGNoKSwgJ1wic3dpdGNoXCIgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJpc1wiJyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJub3RcIicpO1xuICAgIEFzc2VydChvcHRpb25zLnRoZW4gPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcInRoZW5cIicpO1xuXG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLFxuICAgICAgICBzd2l0Y2g6IFtdLFxuICAgICAgICBicmVhazogb3B0aW9ucy5icmVha1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuc3dpdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRlc3QgPSBvcHRpb25zLnN3aXRjaFtpXTtcbiAgICAgICAgY29uc3QgbGFzdCA9IGkgPT09IG9wdGlvbnMuc3dpdGNoLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnModGVzdCwgbGFzdCA/IFsnaXMnLCAndGhlbicsICdvdGhlcndpc2UnXSA6IFsnaXMnLCAndGhlbiddKTtcblxuICAgICAgICBBc3NlcnQodGVzdC5pcyAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwiaXNcIicpO1xuICAgICAgICBBc3NlcnQodGVzdC50aGVuICE9PSB1bmRlZmluZWQsICdTd2l0Y2ggc3RhdGVtZW50IG1pc3NpbmcgXCJ0aGVuXCInKTtcblxuICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgaXM6IHNjaGVtYS4kX2NvbXBpbGUodGVzdC5pcyksXG4gICAgICAgICAgICB0aGVuOiBzY2hlbWEuJF9jb21waWxlKHRlc3QudGhlbilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIVJlZi5pc1JlZih0ZXN0LmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYSh0ZXN0LmlzKSkge1xuXG4gICAgICAgICAgICBpdGVtLmlzID0gaXRlbS5pcy5yZXF1aXJlZCgpOyAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMub3RoZXJ3aXNlID09PSB1bmRlZmluZWQgfHwgdGVzdC5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IFwib3RoZXJ3aXNlXCIgaW5zaWRlIGFuZCBvdXRzaWRlIGEgXCJzd2l0Y2hcIicpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gb3B0aW9ucy5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3RoZXJ3aXNlIDogdGVzdC5vdGhlcndpc2U7XG4gICAgICAgICAgICBpZiAob3RoZXJ3aXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgYm90aCBvdGhlcndpc2UgYW5kIGJyZWFrJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UgPSBzY2hlbWEuJF9jb21waWxlKG90aGVyd2lzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydWxlLnN3aXRjaC5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlO1xufTtcblxuXG5pbnRlcm5hbHMuY29uZGl0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uKSB7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ3RoZW4nLCAnb3RoZXJ3aXNlJ10pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25kaXRpb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbltrZXldID0gc2NoZW1hLiRfY29tcGlsZShjb25kaXRpb25ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uZGl0aW9uO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKGZyb20sIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG4gICAgY29uc3QgcHJvdG90eXBlID0gQ2xvbmUoYmFzZSk7XG4gICAgY29uc3Qgc2NoZW1hID0gZnJvbS5fYXNzaWduKE9iamVjdC5jcmVhdGUocHJvdG90eXBlKSk7XG4gICAgY29uc3QgZGVmID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICBkZWxldGUgZGVmLmJhc2U7XG5cbiAgICBwcm90b3R5cGUuX2RlZmluaXRpb24gPSBkZWY7XG5cbiAgICBjb25zdCBwYXJlbnQgPSBiYXNlLl9kZWZpbml0aW9uIHx8IHt9O1xuICAgIGRlZi5tZXNzYWdlcyA9IE1lc3NhZ2VzLm1lcmdlKHBhcmVudC5tZXNzYWdlcywgZGVmLm1lc3NhZ2VzKTtcbiAgICBkZWYucHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5wcm9wZXJ0aWVzLCBkZWYucHJvcGVydGllcyk7XG5cbiAgICAvLyBUeXBlXG5cbiAgICBzY2hlbWEudHlwZSA9IGRlZi50eXBlO1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGRlZi5mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5mbGFncywgZGVmLmZsYWdzKTtcblxuICAgIC8vIFRlcm1zXG5cbiAgICBjb25zdCB0ZXJtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC50ZXJtcyk7XG4gICAgaWYgKGRlZi50ZXJtcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnRlcm1zKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgb3duIHRlcm1zXG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gZGVmLnRlcm1zW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Rlcm1zW25hbWVdID09PSB1bmRlZmluZWQsICdJbnZhbGlkIHRlcm0gb3ZlcnJpZGUgZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXNbbmFtZV0gPSB0ZXJtLmluaXQ7XG4gICAgICAgICAgICB0ZXJtc1tuYW1lXSA9IHRlcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYudGVybXMgPSB0ZXJtcztcblxuICAgIC8vIENvbnN0cnVjdG9yIGFyZ3VtZW50c1xuXG4gICAgaWYgKCFkZWYuYXJncykge1xuICAgICAgICBkZWYuYXJncyA9IHBhcmVudC5hcmdzO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmVcblxuICAgIGRlZi5wcmVwYXJlID0gaW50ZXJuYWxzLnByZXBhcmUoZGVmLnByZXBhcmUsIHBhcmVudC5wcmVwYXJlKTtcblxuICAgIC8vIENvZXJjZVxuXG4gICAgaWYgKGRlZi5jb2VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWYuY29lcmNlLmZyb20gJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGRlZi5jb2VyY2UuZnJvbSkpIHtcblxuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlLm1ldGhvZCwgZnJvbTogW10uY29uY2F0KGRlZi5jb2VyY2UuZnJvbSkgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5jb2VyY2UgPSBpbnRlcm5hbHMuY29lcmNlKGRlZi5jb2VyY2UsIHBhcmVudC5jb2VyY2UpO1xuXG4gICAgLy8gVmFsaWRhdGVcblxuICAgIGRlZi52YWxpZGF0ZSA9IGludGVybmFscy52YWxpZGF0ZShkZWYudmFsaWRhdGUsIHBhcmVudC52YWxpZGF0ZSk7XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgY29uc3QgcnVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucnVsZXMpO1xuICAgIGlmIChkZWYucnVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IGRlZi5ydWxlc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcnVsZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJ1bGUgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGxldCBtZXRob2QgPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCghcnVsZXNbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgcnVsZXNbbmFtZV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAocnVsZS5hbGlhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXS5jb25jYXQocnVsZS5hbGlhcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVthbGlhc10gPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzID0gcnVsZS5hcmdzLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB7IG5hbWU6IGFyZyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFydWxlLmFyZ3NCeU5hbWUuaGFzKGFyZy5uYW1lKSwgJ0R1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZScsIGFyZy5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGFyZy5hc3NlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcuYXNzZXJ0ID0gYXJnLmFzc2VydC5zdHJpY3QoKS5sYWJlbChhcmcubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUuc2V0KGFyZy5uYW1lLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnJ1bGVzID0gcnVsZXM7XG5cbiAgICAvLyBNb2RpZmllcnNcblxuICAgIGNvbnN0IG1vZGlmaWVycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tb2RpZmllcnMpO1xuICAgIGlmIChkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gZGVmLm1vZGlmaWVyc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIG1vZGlmaWVyIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoYXJnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlKHsgW25hbWVdOiBhcmcgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICBtb2RpZmllcnNbbmFtZV0gPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG5cbiAgICAvLyBPdmVycmlkZXNcblxuICAgIGlmIChkZWYub3ZlcnJpZGVzKSB7XG4gICAgICAgIHByb3RvdHlwZS5fc3VwZXIgPSBiYXNlO1xuICAgICAgICBzY2hlbWEuJF9zdXBlciA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgaW4gZGVmLm92ZXJyaWRlcykge1xuICAgICAgICAgICAgQXNzZXJ0KGJhc2Vbb3ZlcnJpZGVdLCAnQ2Fubm90IG92ZXJyaWRlIG1pc3NpbmcnLCBvdmVycmlkZSk7XG4gICAgICAgICAgICBkZWYub3ZlcnJpZGVzW292ZXJyaWRlXVtDb21tb24uc3ltYm9scy5wYXJlbnRdID0gYmFzZVtvdmVycmlkZV07XG4gICAgICAgICAgICBzY2hlbWEuJF9zdXBlcltvdmVycmlkZV0gPSBiYXNlW292ZXJyaWRlXS5iaW5kKHNjaGVtYSk7ICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLCBkZWYub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0c1xuXG4gICAgZGVmLmNhc3QgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQuY2FzdCwgZGVmLmNhc3QpO1xuXG4gICAgLy8gTWFuaWZlc3RcblxuICAgIGNvbnN0IG1hbmlmZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50Lm1hbmlmZXN0LCBkZWYubWFuaWZlc3QpO1xuICAgIG1hbmlmZXN0LmJ1aWxkID0gaW50ZXJuYWxzLmJ1aWxkKGRlZi5tYW5pZmVzdCAmJiBkZWYubWFuaWZlc3QuYnVpbGQsIHBhcmVudC5tYW5pZmVzdCAmJiBwYXJlbnQubWFuaWZlc3QuYnVpbGQpO1xuICAgIGRlZi5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuXG4gICAgLy8gUmVidWlsZFxuXG4gICAgZGVmLnJlYnVpbGQgPSBpbnRlcm5hbHMucmVidWlsZChkZWYucmVidWlsZCwgcGFyZW50LnJlYnVpbGQpO1xuXG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYnVpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVzYykge1xuXG4gICAgICAgIHJldHVybiBwYXJlbnQoY2hpbGQob2JqLCBkZXNjKSwgZGVzYyk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLmNvZXJjZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGNoaWxkLmZyb20gJiYgcGFyZW50LmZyb20gPyBbLi4ubmV3IFNldChbLi4uY2hpbGQuZnJvbSwgLi4ucGFyZW50LmZyb21dKV0gOiBudWxsLFxuICAgICAgICBtZXRob2QodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvZXJjZWQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50LmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29lcmNlZCA9IHBhcmVudC5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkLmVycm9ycyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29lcmNlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgY2hpbGQuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvd24gPSBjaGlsZC5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG93bjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnByZXBhcmUgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBjaGlsZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkLmVycm9ycyB8fFxuICAgICAgICAgICAgICAgIHByZXBhcmVkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBwcmVwYXJlZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnQodmFsdWUsIGhlbHBlcnMpIHx8IHByZXBhcmVkO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5yZWJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgICAgICBwYXJlbnQoc2NoZW1hKTtcbiAgICAgICAgY2hpbGQoc2NoZW1hKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyZW50KHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAoIUFycmF5LmlzQXJyYXkocmVzdWx0LmVycm9ycykgfHwgcmVzdWx0LmVycm9ycy5sZW5ndGgpKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZCh2YWx1ZSwgaGVscGVycykgfHwgcmVzdWx0O1xuICAgIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5kZXNjcmliZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgIC8vIFR5cGVcblxuICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS50eXBlLFxuICAgICAgICBmbGFnczoge30sXG4gICAgICAgIHJ1bGVzOiBbXVxuICAgIH07XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZm9yIChjb25zdCBmbGFnIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgZGVzYy5mbGFnc1tmbGFnXSA9IGludGVybmFscy5kZXNjcmliZShzY2hlbWEuX2ZsYWdzW2ZsYWddKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmtleXMoZGVzYy5mbGFncykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLmZsYWdzO1xuICAgIH1cblxuICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICBpZiAoc2NoZW1hLl9wcmVmZXJlbmNlcykge1xuICAgICAgICBkZXNjLnByZWZlcmVuY2VzID0gQ2xvbmUoc2NoZW1hLl9wcmVmZXJlbmNlcywgeyBzaGFsbG93OiBbJ21lc3NhZ2VzJ10gfSk7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXTtcbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMgPSBNZXNzYWdlcy5kZWNvbXBpbGUoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBkZXNjLmFsbG93ID0gc2NoZW1hLl92YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBkZXNjLmludmFsaWQgPSBzY2hlbWEuX2ludmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVEZWYgPSBkZWYucnVsZXNbcnVsZS5uYW1lXTtcbiAgICAgICAgaWYgKHJ1bGVEZWYubWFuaWZlc3QgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpdGVtID0geyBuYW1lOiBydWxlLm5hbWUgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtW2N1c3RvbV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgIGl0ZW0uYXJncyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gcnVsZS5hcmdzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29wdGlvbnMnICYmXG4gICAgICAgICAgICAgICAgICAgICFPYmplY3Qua2V5cyhhcmcpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uYXJnc1trZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKGFyZywgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhpdGVtLmFyZ3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLmFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjLnJ1bGVzLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5ydWxlcztcbiAgICB9XG5cbiAgICAvLyBUZXJtcyAobXVzdCBiZSBsYXN0IHRvIHZlcmlmeSBubyBuYW1lIGNvbmZsaWN0cylcblxuICAgIGZvciAoY29uc3QgdGVybSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAodGVybVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCghZGVzY1t0ZXJtXSwgJ0Nhbm5vdCBkZXNjcmliZSBzY2hlbWEgZHVlIHRvIGludGVybmFsIG5hbWUgY29uZmxpY3Qgd2l0aCcsIHRlcm0pO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLiRfdGVybXNbdGVybV07XG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV0gPSBbLi4uaXRlbXMuZW50cmllcygpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tbW9uLmlzVmFsdWVzKGl0ZW1zKSkge1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IGl0ZW1zLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChkZWYudGVybXNbdGVybV0sICdUZXJtJywgdGVybSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1t0ZXJtXS5tYW5pZmVzdDtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0JztcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFtYXBwZWQpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGludGVybmFscy5kZXNjcmliZShpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXBwZWRcblxuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBtYW5pZmVzdC5tYXBwZWQ7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV1baXRlbVt0b11dID0gaXRlbVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGVcblxuICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBBc3NlcnQobm9ybWFsaXplZC5sZW5ndGggPT09IDEsICdUZXJtJywgdGVybSwgJ2NvbnRhaW5zIG1vcmUgdGhhbiBvbmUgaXRlbScpO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWRbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlKHNjaGVtYS4kX3Jvb3QsIGRlc2MpO1xuICAgIHJldHVybiBkZXNjO1xufTtcblxuXG5pbnRlcm5hbHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbS5tYXAoaW50ZXJuYWxzLmRlc2NyaWJlKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSA9PT0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3BlY2lhbDogJ2RlZXAnIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBpdGVtID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgcmV0dXJuIENsb25lKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgcmV0dXJuIHsgYnVmZmVyOiBpdGVtLnRvU3RyaW5nKCdiaW5hcnknKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVnZXg6IGl0ZW0udG9TdHJpbmcoKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiB7IGZ1bmN0aW9uOiBpdGVtLmxpdGVyYWwgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uZGVzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKS5yZWY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUodmFsdWUsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGludGVybmFscy5CdWlsZGVyKGpvaSk7XG4gICAgcmV0dXJuIGJ1aWxkZXIucGFyc2UoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5CdWlsZGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioam9pKSB7XG5cbiAgICAgICAgdGhpcy5qb2kgPSBqb2k7XG4gICAgfVxuXG4gICAgcGFyc2UoZGVzYykge1xuXG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZSh0aGlzLmpvaSwgZGVzYyk7XG5cbiAgICAgICAgLy8gVHlwZVxuXG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmpvaVtkZXNjLnR5cGVdKCkuX2JhcmUoKTtcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGVyID0gZGVmLmZsYWdzW2ZsYWddICYmIGRlZi5mbGFnc1tmbGFnXS5zZXR0ZXIgfHwgZmxhZztcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtzZXR0ZXJdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBmbGFnJywgZmxhZywgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbc2V0dGVyXSh0aGlzLmJ1aWxkKGRlc2MuZmxhZ3NbZmxhZ10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5wcmVmZXJlbmNlcyh0aGlzLmJ1aWxkKGRlc2MucHJlZmVyZW5jZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgICAgIGlmIChkZXNjLmFsbG93KSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuYWxsb3coLi4udGhpcy5idWlsZChkZXNjLmFsbG93KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5pbnZhbGlkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuaW52YWxpZCguLi50aGlzLmJ1aWxkKGRlc2MuaW52YWxpZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBpZiAoZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtydWxlLm5hbWVdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBydWxlJywgcnVsZS5uYW1lLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVpbHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsdFtrZXldID0gdGhpcy5idWlsZChydWxlLmFyZ3Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhidWlsdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkZWYucnVsZXNbcnVsZS5uYW1lXS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoIDw9IGRlZmluaXRpb24ubGVuZ3RoLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvJywgZGVmaW5pdGlvbi5sZW5ndGgsICcsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSB9IG9mIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoID09PSAxLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvIDEsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRba2V5c1swXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHlcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtydWxlLm5hbWVdKC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZXNldFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2N1c3RvbV0gPSB0aGlzLmJ1aWxkKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5ydWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgY29uc3QgdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgaWYgKFsnYWxsb3cnLCAnZmxhZ3MnLCAnaW52YWxpZCcsICd3aGVucycsICdwcmVmZXJlbmNlcycsICdydWxlcycsICd0eXBlJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW2tleV0sICdUZXJtJywga2V5LCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1trZXldLm1hbmlmZXN0O1xuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMucGFyc2UoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICd2YWx1ZXMnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlc2Nba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2Nba2V5XVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdGVybXNba2V5XVtuYW1lXSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2Mud2hlbnMpIHtcbiAgICAgICAgICAgIHRlcm1zLndoZW5zID0gZGVzYy53aGVucy5tYXAoKHdoZW4pID0+IHRoaXMuYnVpbGQod2hlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1hID0gZGVmLm1hbmlmZXN0LmJ1aWxkKHNjaGVtYSwgdGVybXMpO1xuICAgICAgICBzY2hlbWEuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICBidWlsZChkZXNjLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoZGVzYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXNjKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZXNjKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChkZXNjLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIsICdCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIuZnJvbShkZXNjLmJ1ZmZlciwgJ2JpbmFyeScpOyAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLCBsaXRlcmFsOiBkZXNjLmZ1bmN0aW9uIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MucmVmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVnZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MucmVnZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5zcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnZGVlcCddLmluY2x1ZGVzKGRlc2Muc3BlY2lhbCksICdVbmtub3duIHNwZWNpYWwgdmFsdWUnLCBkZXNjLnNwZWNpYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICBjb25zdCBlbmQgPSBzdHJpbmcubGFzdEluZGV4T2YoJy8nKTtcbiAgICBjb25zdCBleHAgPSBzdHJpbmcuc2xpY2UoMSwgZW5kKTtcbiAgICBjb25zdCBmbGFncyA9IHN0cmluZy5zbGljZShlbmQgKyAxKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChleHAsIGZsYWdzKTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBqb2kuYXNzZXJ0KGRlc2MsIFNjaGVtYXMuZGVzY3JpcHRpb24pO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaXNtYXRjaGVkOiBudWxsXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByb3RvdHlwZTogdHJ1ZSB9LCBvcHRpb25zKTtcblxuICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbChvYmosIHJlZiwgb3B0aW9ucywgW10pO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGlmIChvYmogPT09IHJlZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcGllZCBmcm9tIERlZXAtZXFsLCBjb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIsIGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbSwgTUlUIExpY2Vuc2VkLCBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsXG4gICAgICAgIHJldHVybiBvYmogIT09IDAgfHwgMSAvIG9iaiA9PT0gMSAvIHJlZjtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iajtcblxuICAgIGlmICh0eXBlICE9PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHJlZiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZGVlcEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBvYmoudG9TdHJpbmcoKSAhPT0gcmVmLnRvU3RyaW5nKCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGludWUgYXMgb2JqZWN0XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IG9iaiAmJiByZWYgIT09IHJlZjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFOXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUob2JqLCByZWYsICEhb3B0aW9ucy5wcm90b3R5cGUpO1xuICAgIHN3aXRjaCAoaW5zdGFuY2VUeXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZXMuYnVmZmVyOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIucHJvdG90eXBlLmVxdWFscy5jYWxsKG9iaiwgcmVmKTsgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBjYXNlIFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICByZXR1cm4gb2JqID09PSByZWY7XG4gICAgICAgIGNhc2UgVHlwZXMucmVnZXg6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkgPT09IHJlZi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIGludGVybmFscy5taXNtYXRjaGVkOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzZWVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChzZWVuW2ldLmlzU2FtZShvYmosIHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBjb21wYXJpc29uIGZhaWxlZCwgaXQgd291bGQgaGF2ZSBzdG9wcGVkIGV4ZWN1dGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5wdXNoKG5ldyBpbnRlcm5hbHMuU2VlbkVudHJ5KG9iaiwgcmVmKSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmooaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzZWVuLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUgPSBmdW5jdGlvbiAob2JqLCByZWYsIGNoZWNrUHJvdG90eXBlKSB7XG5cbiAgICBpZiAoY2hlY2tQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmICh0eXBlICE9PSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuXG5pbnRlcm5hbHMudmFsdWVPZiA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGNvbnN0IG9ialZhbHVlT2YgPSBvYmoudmFsdWVPZjtcbiAgICBpZiAob2JqVmFsdWVPZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9ialZhbHVlT2YuY2FsbChvYmopO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaGFzT3duRW51bWVyYWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYpIHtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChvYmopKSB7XG4gICAgICAgIGlmICghU2V0LnByb3RvdHlwZS5oYXMuY2FsbChyZWYsIGVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy5pc0RlZXBFcXVhbE9iaiA9IGZ1bmN0aW9uIChpbnN0YW5jZVR5cGUsIG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKSB7XG5cbiAgICBjb25zdCB7IGlzRGVlcEVxdWFsLCB2YWx1ZU9mLCBoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkgfSA9IGludGVybmFscztcbiAgICBjb25zdCB7IGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyB9ID0gT2JqZWN0O1xuXG4gICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFydCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgaW5kZXggbWF0Y2ggYW55IG90aGVyIGluZGV4XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqVmFsdWUgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZWYWx1ZSBvZiByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKG9ialZhbHVlLCByZWZWYWx1ZSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHJlZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpbaV0sIHJlZltpXSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuaXNTZXRTaW1wbGVFcXVhbChvYmosIHJlZikpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlZXAgZXF1YWxpdHlcblxuICAgICAgICAgICAgY29uc3QgcmVmMiA9IG5ldyBTZXQoU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChyZWYpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqRW50cnkgb2YgU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZjIuZGVsZXRlKG9iakVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZkVudHJ5IG9mIHJlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKG9iakVudHJ5LCByZWZFbnRyeSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjIuZGVsZXRlKHJlZkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMubWFwKSB7XG4gICAgICAgIGlmIChvYmouc2l6ZSAhPT0gcmVmLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE1hcC5wcm90b3R5cGUuZW50cmllcy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICFNYXAucHJvdG90eXBlLmhhcy5jYWxsKHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbCh2YWx1ZSwgTWFwLnByb3RvdHlwZS5nZXQuY2FsbChyZWYsIGtleSksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuZXJyb3IpIHtcblxuICAgICAgICAvLyBBbHdheXMgY2hlY2sgbmFtZSBhbmQgbWVzc2FnZVxuXG4gICAgICAgIGlmIChvYmoubmFtZSAhPT0gcmVmLm5hbWUgfHxcbiAgICAgICAgICAgIG9iai5tZXNzYWdlICE9PSByZWYubWVzc2FnZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayAudmFsdWVPZigpXG5cbiAgICBjb25zdCB2YWx1ZU9mT2JqID0gdmFsdWVPZihvYmopO1xuICAgIGNvbnN0IHZhbHVlT2ZSZWYgPSB2YWx1ZU9mKHJlZik7XG4gICAgaWYgKChvYmogIT09IHZhbHVlT2ZPYmogfHwgcmVmICE9PSB2YWx1ZU9mUmVmKSAmJlxuICAgICAgICAhaXNEZWVwRXF1YWwodmFsdWVPZk9iaiwgdmFsdWVPZlJlZiwgb3B0aW9ucywgc2VlbikpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcHJvcGVydGllc1xuXG4gICAgY29uc3Qgb2JqS2V5cyA9IGtleXMob2JqKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAhPT0ga2V5cyhyZWYpLmxlbmd0aCAmJlxuICAgICAgICAhb3B0aW9ucy5za2lwKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBza2lwcGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmpLZXlzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXAgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcC5pbmNsdWRlcyhrZXkpKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWZba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKytza2lwcGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAtIHNraXBwZWQgIT09IGtleXMocmVmKS5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc3ltYm9sc1xuXG4gICAgaWYgKG9wdGlvbnMuc3ltYm9scyAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgY29uc3Qgb2JqU3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuICAgICAgICBjb25zdCByZWZTeW1ib2xzID0gbmV3IFNldChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocmVmKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb2JqU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNraXAgfHxcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5za2lwLmluY2x1ZGVzKGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWZTeW1ib2xzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVmU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLlNlZW5FbnRyeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGlzU2FtZShvYmosIHJlZikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9iaiA9PT0gb2JqICYmIHRoaXMucmVmID09PSByZWY7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMubG9jYXRpb24gPSBmdW5jdGlvbiAoZGVwdGggPSAwKSB7XG5cbiAgICBjb25zdCBvcmlnID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoaWdub3JlLCBzdGFjaykgPT4gc3RhY2s7XG5cbiAgICBjb25zdCBjYXB0dXJlID0ge307XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgdGhpcyk7XG4gICAgY29uc3QgbGluZSA9IGNhcHR1cmUuc3RhY2tbZGVwdGggKyAxXTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVuYW1lOiBsaW5lLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGxpbmU6IGxpbmUuZ2V0TGluZU51bWJlcigpXG4gICAgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IFBpbnBvaW50ID0gcmVxdWlyZSgnQHNpZGV3YXkvcGlucG9pbnQnKTtcblxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgY29kZXM6IHtcbiAgICAgICAgZXJyb3I6IDEsXG4gICAgICAgIHBhc3M6IDIsXG4gICAgICAgIGZ1bGw6IDNcbiAgICB9LFxuICAgIGxhYmVsczoge1xuICAgICAgICAwOiAnbmV2ZXIgdXNlZCcsXG4gICAgICAgIDE6ICdhbHdheXMgZXJyb3InLFxuICAgICAgICAyOiAnYWx3YXlzIHBhc3MnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLnNldHVwID0gZnVuY3Rpb24gKHJvb3QpIHtcblxuICAgIGNvbnN0IHRyYWNlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJvb3QuX3RyYWNlciA9IHJvb3QuX3RyYWNlciB8fCBuZXcgaW50ZXJuYWxzLlRyYWNlcigpO1xuICAgICAgICByZXR1cm4gcm9vdC5fdHJhY2VyO1xuICAgIH07XG5cbiAgICByb290LnRyYWNlID0gdHJhY2U7XG4gICAgcm9vdFtTeW1ib2wuZm9yKCdAaGFwaS9sYWIvY292ZXJhZ2UvaW5pdGlhbGl6ZScpXSA9IHRyYWNlO1xuXG4gICAgcm9vdC51bnRyYWNlID0gKCkgPT4ge1xuXG4gICAgICAgIHJvb3QuX3RyYWNlciA9IG51bGw7XG4gICAgfTtcbn07XG5cblxuZXhwb3J0cy5sb2NhdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIHJldHVybiBzY2hlbWEuJF9zZXRGbGFnKCdfdHJhY2VyTG9jYXRpb24nLCBQaW5wb2ludC5sb2NhdGlvbigyKSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlLnRyYWNlcigpLCBjYWxsZXJcbn07XG5cblxuaW50ZXJuYWxzLlRyYWNlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdKb2knO1xuICAgICAgICB0aGlzLl9zY2hlbWFzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIF9yZWdpc3RlcihzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX3NjaGVtYXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nLnN0b3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBuZXcgaW50ZXJuYWxzLlN0b3JlKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHsgZmlsZW5hbWUsIGxpbmUgfSA9IHNjaGVtYS5fZmxhZ3MuX3RyYWNlckxvY2F0aW9uIHx8IFBpbnBvaW50LmxvY2F0aW9uKDUpOyAgIC8vIGludGVybmFscy50cmFjZXIoKSwgaW50ZXJuYWxzLmVudHJ5KCksIGV4cG9ydHMuZW50cnkoKSwgdmFsaWRhdGUoKSwgY2FsbGVyXG4gICAgICAgIHRoaXMuX3NjaGVtYXMuc2V0KHNjaGVtYSwgeyBmaWxlbmFtZSwgbGluZSwgc3RvcmUgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG5cbiAgICBfY29tYmluZShtZXJnZWQsIHNvdXJjZXMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHsgc3RvcmUgfSBvZiB0aGlzLl9zY2hlbWFzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzdG9yZS5fY29tYmluZShtZXJnZWQsIHNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwb3J0KGZpbGUpIHtcblxuICAgICAgICBjb25zdCBjb3ZlcmFnZSA9IFtdO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCByZWdpc3RlcmVkIHNjaGVtYVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBmaWxlbmFtZSwgbGluZSwgc3RvcmUgfSBvZiB0aGlzLl9zY2hlbWFzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSAmJlxuICAgICAgICAgICAgICAgIGZpbGUgIT09IGZpbGVuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBzdWIgc2NoZW1hcyBvZiB0aGUgcmVnaXN0ZXJlZCByb290XG5cbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBbc2NoZW1hLCBsb2ddIG9mIHN0b3JlLl9zb3VyY2VzLmVudHJpZXMoKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3ViIHNjaGVtYSBwYXJlbnQgc2tpcHBlZFxuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5zdWIobG9nLnBhdGhzLCBza2lwcGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHJlYWNoZWRcblxuICAgICAgICAgICAgICAgIGlmICghbG9nLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICduZXZlciByZWFjaGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzOiBbLi4ubG9nLnBhdGhzXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goLi4ubG9nLnBhdGhzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdmFsdWVzXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgWyd2YWxpZCcsICdpbnZhbGlkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gc2NoZW1hW2BfJHt0eXBlfXNgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChzZXQuX3ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnMgPSBuZXcgU2V0KHNldC5fcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgcmVmIH0gb2YgbG9nW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLnNpemUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnMuc2l6ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogWy4uLnZhbHVlcywgLi4uWy4uLnJlZnNdLm1hcCgocmVmKSA9PiByZWYuZGlzcGxheSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAke3R5cGV9c2BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgcnVsZXMgc3RhdHVzXG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlcyA9IHNjaGVtYS5fcnVsZXMubWFwKChydWxlKSA9PiBydWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ2RlZmF1bHQnLCAnZmFpbG92ZXInXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFnc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGludGVybmFscy5sYWJlbHNbbG9nLnJ1bGVbbmFtZV0gfHwgMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHsgcnVsZTogbmFtZSwgc3RhdHVzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLnBhdGhzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aHMgPSBbLi4ubG9nLnBhdGhzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvdmVyYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTY2hlbWEgbWlzc2luZyB0ZXN0cyBmb3IgJHttaXNzaW5nLm1hcChpbnRlcm5hbHMubWVzc2FnZSkuam9pbignLCAnKX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY292ZXJhZ2UubGVuZ3RoID8gY292ZXJhZ2UgOiBudWxsO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlN0b3JlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG5cbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zb3VyY2VzID0gbmV3IE1hcCgpOyAgICAgICAgICAvLyBzY2hlbWEgLT4geyBwYXRocywgZW50cnksIHJ1bGUsIHZhbGlkLCBpbnZhbGlkIH1cbiAgICAgICAgdGhpcy5fY29tYm9zID0gbmV3IE1hcCgpOyAgICAgICAgICAgLy8gbWVyZ2VkIC0+IFtzb3VyY2VzXVxuICAgICAgICB0aGlzLl9zY2FuKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgZGVidWcoc3RhdGUsIHNvdXJjZSwgbmFtZSwgcmVzdWx0KSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcgJiYgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaCh7IHR5cGU6IHNvdXJjZSwgbmFtZSwgcmVzdWx0LCBwYXRoOiBzdGF0ZS5wYXRoIH0pO1xuICAgIH1cblxuICAgIGVudHJ5KHNjaGVtYSwgc3RhdGUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogJ2VudHJ5JyB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZy5lbnRyeSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZpbHRlcihzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIHZhbHVlKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmRlYnVnKHN0YXRlLCB7IHR5cGU6IHNvdXJjZSwgLi4udmFsdWUgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXS5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2coc2NoZW1hLCBzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQ6IHJlc3VsdCA9PT0gJ2Z1bGwnID8gJ3Bhc3MnIDogcmVzdWx0IH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nW3NvdXJjZV1bbmFtZV0gPSBsb2dbc291cmNlXVtuYW1lXSB8fCAwO1xuICAgICAgICAgICAgbG9nW3NvdXJjZV1bbmFtZV0gfD0gaW50ZXJuYWxzLmNvZGVzW3Jlc3VsdF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc29sdmUoc3RhdGUsIHJlZiwgdG8pIHtcblxuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2cgPSB7IHR5cGU6ICdyZXNvbHZlJywgcmVmOiByZWYuZGlzcGxheSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaChsb2cpO1xuICAgIH1cblxuICAgIHZhbHVlKHN0YXRlLCBieSwgZnJvbSwgdG8sIG5hbWUpIHtcblxuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LmRlYnVnIHx8XG4gICAgICAgICAgICBEZWVwRXF1YWwoZnJvbSwgdG8pKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3ZhbHVlJywgYnksIGZyb20sIHRvLCBwYXRoOiBzdGF0ZS5wYXRoIH07XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBsb2cubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgX3JlY29yZChzY2hlbWEsIGVhY2gpIHtcblxuICAgICAgICBjb25zdCBsb2cgPSB0aGlzLl9zb3VyY2VzLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBlYWNoKGxvZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3VyY2VzID0gdGhpcy5fY29tYm9zLmdldChzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmQoc291cmNlLCBlYWNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zY2FuKHNjaGVtYSwgX3BhdGgpIHtcblxuICAgICAgICBjb25zdCBwYXRoID0gX3BhdGggfHwgW107XG5cbiAgICAgICAgbGV0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmICghbG9nKSB7XG4gICAgICAgICAgICBsb2cgPSB7XG4gICAgICAgICAgICAgICAgcGF0aHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBlbnRyeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVsZToge30sXG4gICAgICAgICAgICAgICAgdmFsaWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXMuc2V0KHNjaGVtYSwgbG9nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nLnBhdGhzLmFkZChwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoc3ViLCBzb3VyY2UpID0+IHtcblxuICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSBpbnRlcm5hbHMuaWQoc3ViLCBzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5fc2NhbihzdWIsIHBhdGguY29uY2F0KHN1YklkKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBfY29tYmluZShtZXJnZWQsIHNvdXJjZXMpIHtcblxuICAgICAgICB0aGlzLl9jb21ib3Muc2V0KG1lcmdlZCwgc291cmNlcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubWVzc2FnZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICBjb25zdCBwYXRoID0gaXRlbS5wYXRocyA/IEVycm9ycy5wYXRoKGl0ZW0ucGF0aHNbMF0pICsgKGl0ZW0ucnVsZSA/ICc6JyA6ICcnKSA6ICcnO1xuICAgIHJldHVybiBgJHtwYXRofSR7aXRlbS5ydWxlIHx8ICcnfSAoJHtpdGVtLnN0YXR1c30pYDtcbn07XG5cblxuaW50ZXJuYWxzLmlkID0gZnVuY3Rpb24gKHNjaGVtYSwgeyBzb3VyY2UsIG5hbWUsIHBhdGgsIGtleSB9KSB7XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5pZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLl9mbGFncy5pZDtcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgbmFtZSA9IGBAJHtuYW1lfWA7XG5cbiAgICBpZiAoc291cmNlID09PSAndGVybXMnKSB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgcGF0aFtNYXRoLm1pbihwYXRoLmxlbmd0aCAtIDEsIDEpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5cbmludGVybmFscy5zdWIgPSBmdW5jdGlvbiAocGF0aHMsIHNraXBwZWQpIHtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBmb3IgKGNvbnN0IHNraXAgb2Ygc2tpcHBlZCkge1xuICAgICAgICAgICAgaWYgKERlZXBFcXVhbChwYXRoLnNsaWNlKDAsIHNraXAubGVuZ3RoKSwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlYnVnID0gZnVuY3Rpb24gKHN0YXRlLCBldmVudCkge1xuXG4gICAgaWYgKHN0YXRlLm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIGV2ZW50LnBhdGggPSBzdGF0ZS5kZWJ1ZyA/IFsuLi5zdGF0ZS5wYXRoLCBzdGF0ZS5kZWJ1Z10gOiBzdGF0ZS5wYXRoO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGV2ZW50KTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBBc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBudWxsT3ZlcnJpZGU6IHRydWUsIG1lcmdlQXJyYXlzOiB0cnVlIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBBc3NlcnQoQXJyYXkuaXNBcnJheSh0YXJnZXQpLCAnQ2Fubm90IG1lcmdlIGFycmF5IG9udG8gYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXJnZUFycmF5cykge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IGNoYW5nZSB0YXJnZXQgYXNzaWdubWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKENsb25lKHNvdXJjZVtpXSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4gb2NjdXIgZm9yIHNoYWxsb3cgbWVyZ2VzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgICAgICAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHx8ICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gQ2xvbmUodmFsdWUsIHsgc3ltYm9sczogb3B0aW9ucy5zeW1ib2xzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLm1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubnVsbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cblxuZXhwb3J0cy5JZHMgPSBpbnRlcm5hbHMuSWRzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgaW50ZXJuYWxzLklkcygpO1xuICAgICAgICBjbG9uZS5fYnlJZCA9IG5ldyBNYXAodGhpcy5fYnlJZCk7XG4gICAgICAgIGNsb25lLl9ieUtleSA9IG5ldyBNYXAodGhpcy5fYnlLZXkpO1xuICAgICAgICBjbG9uZS5fc2NoZW1hQ2hhaW4gPSB0aGlzLl9zY2hlbWFDaGFpbjtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBpZiAoc291cmNlLl9zY2hlbWFDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHZhbHVlXSBvZiBzb3VyY2UuX2J5SWQuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzb3VyY2UuX2J5S2V5LmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yayhwYXRoLCBhZGp1c3Rlciwgcm9vdCkge1xuXG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fY29sbGVjdChwYXRoKTtcbiAgICAgICAgY2hhaW4ucHVzaCh7IHNjaGVtYTogcm9vdCB9KTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGNoYWluLnNoaWZ0KCk7XG4gICAgICAgIGxldCBhZGp1c3RlZCA9IHsgaWQ6IHRhaWwuaWQsIHNjaGVtYTogYWRqdXN0ZXIodGFpbC5zY2hlbWEpIH07XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShhZGp1c3RlZC5zY2hlbWEpLCAnYWRqdXN0ZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJldHVybiBhIGpvaSBzY2hlbWEgdHlwZScpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGFpbikge1xuICAgICAgICAgICAgYWRqdXN0ZWQgPSB7IGlkOiBub2RlLmlkLCBzY2hlbWE6IGludGVybmFscy5mb3JrKG5vZGUuc2NoZW1hLCBhZGp1c3RlZC5pZCwgYWRqdXN0ZWQuc2NoZW1hKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkanVzdGVkLnNjaGVtYTtcbiAgICB9XG5cbiAgICBsYWJlbHMocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGJlaGluZCA9IFsuLi5iZWhpbmQsIG5vZGUuc2NoZW1hLl9mbGFncy5sYWJlbCB8fCBjdXJyZW50XTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlaGluZC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5sYWJlbHMoZm9yd2FyZCwgYmVoaW5kKTtcbiAgICB9XG5cbiAgICByZWFjaChwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5yZWFjaChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc2NoZW1hLCB7IGtleSB9ID0ge30pIHtcblxuICAgICAgICBpZiAoIXNjaGVtYSB8fFxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuJF9wcm9wZXJ0eSgnc2NoZW1hQ2hhaW4nKSB8fFxuICAgICAgICAgICAgc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX2J5SWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghZXhpc3RpbmcgfHwgZXhpc3Rpbmcuc2NoZW1hID09PSBzY2hlbWEsICdDYW5ub3QgYWRkIGRpZmZlcmVudCBzY2hlbWFzIHdpdGggdGhlIHNhbWUgaWQ6JywgaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB7IHNjaGVtYSwgaWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhrZXkpLCAnU2NoZW1hIGFscmVhZHkgY29udGFpbnMga2V5OicsIGtleSk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHsgc2NoZW1hLCBpZDoga2V5IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2NvbGxlY3QocGF0aCwgYmVoaW5kID0gW10sIG5vZGVzID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBub2RlcyA9IFtub2RlLCAuLi5ub2Rlc107XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLl9jb2xsZWN0KGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgX2dldChpZCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ieUlkLmdldChpZCkgfHwgdGhpcy5fYnlLZXkuZ2V0KGlkKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mb3JrID0gZnVuY3Rpb24gKHNjaGVtYSwgaWQsIHJlcGxhY2VtZW50KSB7XG5cbiAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHsga2V5IH0pID0+IHtcblxuICAgICAgICBpZiAoaWQgPT09IChpdGVtLl9mbGFncy5pZCB8fCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb2JqID0gZXhwb3J0cy5zY2hlbWEoc2NoZW1hLCB7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgcmV0dXJuIG9iaiA/IG9iai4kX211dGF0ZVJlYnVpbGQoKSA6IHNjaGVtYTtcbn07XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICBsZXQgb2JqO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuX2ZsYWdzW25hbWVdLCB7IHNvdXJjZTogJ2ZsYWdzJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuX3J1bGVzW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihydWxlLmFyZ3MsIHsgc291cmNlOiAncnVsZXMnLCBuYW1lOiBydWxlLm5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBydWxlKTtcbiAgICAgICAgICAgIGNsb25lLmFyZ3MgPSByZXN1bHQ7XG4gICAgICAgICAgICBvYmouX3J1bGVzW2ldID0gY2xvbmU7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVW5pcXVlID0gb2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1VuaXF1ZSA9PT0gcnVsZSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLiRfdGVybXNbbmFtZV0sIHsgc291cmNlOiAndGVybXMnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnNjYW4gPSBmdW5jdGlvbiAoaXRlbSwgc291cmNlLCBvcHRpb25zLCBfcGF0aCwgX2tleSkge1xuXG4gICAgY29uc3QgcGF0aCA9IF9wYXRoIHx8IFtdO1xuXG4gICAgaWYgKGl0ZW0gPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbG9uZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gc291cmNlLnNvdXJjZSA9PT0gJ3Rlcm1zJyAmJiBzb3VyY2UubmFtZSA9PT0gJ2tleXMnICYmIGl0ZW1baV0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtpXSwgc291cmNlLCBvcHRpb25zLCBbaSwgLi4ucGF0aF0sIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IGl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWEgIT09IGZhbHNlICYmIENvbW1vbi5pc1NjaGVtYShpdGVtKSB8fFxuICAgICAgICBvcHRpb25zLnJlZiAhPT0gZmFsc2UgJiYgUmVmLmlzUmVmKGl0ZW0pKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9ucy5lYWNoKGl0ZW0sIHsgLi4uc291cmNlLCBwYXRoLCBrZXk6IF9rZXkgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtrZXldLCBzb3VyY2UsIG9wdGlvbnMsIFtrZXksIC4uLnBhdGhdLCBfa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgfTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdmFsdWU6IFN5bWJvbCgndmFsdWUnKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5TdGF0ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGFuY2VzdG9ycywgc3RhdGUpIHtcblxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmFuY2VzdG9ycyA9IGFuY2VzdG9yczsgICAgICAgICAgICAgICAgIC8vIFtwYXJlbnQsIC4uLiwgcm9vdF1cblxuICAgICAgICB0aGlzLm1haW5zdGF5ID0gc3RhdGUubWFpbnN0YXk7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXM7ICAgICAgICAgICAgICAgLy8gW2N1cnJlbnQsIC4uLiwgcm9vdF1cbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG51bGw7XG4gICAgfVxuXG4gICAgbG9jYWxpemUocGF0aCwgYW5jZXN0b3JzID0gbnVsbCwgc2NoZW1hID0gbnVsbCkge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZShwYXRoLCBhbmNlc3RvcnMsIHRoaXMpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgJiZcbiAgICAgICAgICAgIHN0YXRlLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcyA9IFtpbnRlcm5hbHMuc2NoZW1hcyhzY2hlbWEpLCAuLi5zdGF0ZS5zY2hlbWFzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBuZXN0KHNjaGVtYSwgZGVidWcpIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBpbnRlcm5hbHMuU3RhdGUodGhpcy5wYXRoLCB0aGlzLmFuY2VzdG9ycywgdGhpcyk7XG4gICAgICAgIHN0YXRlLnNjaGVtYXMgPSBzdGF0ZS5zY2hlbWFzICYmIFtpbnRlcm5hbHMuc2NoZW1hcyhzY2hlbWEpLCAuLi5zdGF0ZS5zY2hlbWFzXTtcbiAgICAgICAgc3RhdGUuZGVidWcgPSBkZWJ1ZztcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHNoYWRvdyh2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cgPSB0aGlzLm1haW5zdGF5LnNoYWRvdyB8fCBuZXcgaW50ZXJuYWxzLlNoYWRvdygpO1xuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdy5zZXQodGhpcy5wYXRoLCB2YWx1ZSwgcmVhc29uKTtcbiAgICB9XG5cbiAgICBzbmFwc2hvdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gQ2xvbmUodGhpcy5tYWluc3RheS5zaGFkb3cubm9kZSh0aGlzLnBhdGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuc25hcHNob3QoKTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cub3ZlcnJpZGUodGhpcy5wYXRoLCB0aGlzLl9zbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGNvbW1pdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1haW5zdGF5LmNvbW1pdCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYXMgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cblxuaW50ZXJuYWxzLlNoYWRvdyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc2V0KHBhdGgsIHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc3RvcmUgcm9vdCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gJ3N0cmlwJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHsgICAgICAgIC8vIENhbm5vdCBzdG9yZSBzdHJpcHBlZCBhcnJheSB2YWx1ZXMgKGR1ZSB0byBzaGlmdClcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdGhpcy5fdmFsdWVzIHx8IG5ldyBNYXAoKTtcblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5nZXQoc2VnbWVudCk7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0KHNlZ21lbnQsIG5leHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVbaW50ZXJuYWxzLnZhbHVlXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldChwYXRoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZShwYXRoKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW2ludGVybmFscy52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlKHBhdGgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWNoKHRoaXMuX3ZhbHVlcywgcGF0aCwgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUocGF0aCwgbm9kZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnRzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IG93biA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gUmVhY2godGhpcy5fdmFsdWVzLCBwYXJlbnRzLCB7IGl0ZXJhYmxlczogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnNldChvd24sIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZShvd24pO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsIG9mIG1haW5zdGF5LmV4dGVybmFscykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV4dGVybmFsLnN0YXRlLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBleHRlcm5hbC5zY2hlbWEudHlwZSA9PT0gJ2xpbmsnID8gbWFpbnN0YXkubGlua3MuZ2V0KGV4dGVybmFsLnNjaGVtYSkgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByb290O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHBhdGgubGVuZ3RoID8gW3Jvb3RdIDogW107XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHBhdGgubGVuZ3RoID8gUmVhY2godmFsdWUsIHBhdGgpIDogdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc2VnbWVudF07XG4gICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFuY2VzdG9yc1swXTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKGNvZGUsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGV4dGVybmFsLm1ldGhvZChub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXh0ZXJuYWwuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBsaW5rZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBleHRlcm5hbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZnMsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc0FycmF5OiBpbnRlcm5hbHMuZXJyb3JzQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCkgPT4gbWFpbnN0YXkud2FybmluZ3MucHVzaCgobGlua2VkIHx8IGV4dGVybmFsLnNjaGVtYSkuJF9jcmVhdGVFcnJvcihjb2RlLCBub2RlLCBsb2NhbCwgZXh0ZXJuYWwuc3RhdGUsIHNldHRpbmdzKSksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKCdleHRlcm5hbCcsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MsIHsgbWVzc2FnZXMgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IG5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLm91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgbm9kZSwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgcm9vdCwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArPSBgICgkeyhleHRlcm5hbC5sYWJlbCl9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IEVycm9ycy5wcm9jZXNzKGVycm9ycywgdmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKG1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3Mud2FybmluZ3MgJiZcbiAgICAgICAgIXNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICFzZXR0aW5ncy5hcnRpZmFjdHMpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSBtYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5NYWluc3RheSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHRyYWNlciwgZGVidWcsIGxpbmtzKSB7XG5cbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cyA9IFtdO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cy5wdXNoKHtcbiAgICAgICAgICAgIGV4dGVybmFsczogdGhpcy5leHRlcm5hbHMuc2xpY2UoKSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuX3NuYXBzaG90cy5wb3AoKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBzbmFwc2hvdC5leHRlcm5hbHM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBzbmFwc2hvdC53YXJuaW5ncztcbiAgICB9XG5cbiAgICBjb21taXQoKSB7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICAvLyBQcmVwYXJlIHN0YXRlXG5cbiAgICBjb25zdCB7IHRyYWNlciwgY2xlYW51cCB9ID0gaW50ZXJuYWxzLnRyYWNlcihzY2hlbWEsIHByZWZzKTtcbiAgICBjb25zdCBkZWJ1ZyA9IHByZWZzLmRlYnVnID8gW10gOiBudWxsO1xuICAgIGNvbnN0IGxpbmtzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gbmV3IE1hcCgpIDogbnVsbDtcbiAgICBjb25zdCBtYWluc3RheSA9IG5ldyBpbnRlcm5hbHMuTWFpbnN0YXkodHJhY2VyLCBkZWJ1ZywgbGlua3MpO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBbeyBzY2hlbWEgfV0gOiBudWxsO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKFtdLCBbXSwgeyBtYWluc3RheSwgc2NoZW1hcyB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHZhbHVlXG5cbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAvLyBQcm9jZXNzIHZhbHVlIGFuZCBlcnJvcnNcblxuICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgIHNjaGVtYS4kX3Jvb3QudW50cmFjZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUsIHByZWZzKTtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBlcnJvciwgbWFpbnN0YXkgfTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYWNlciA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC5fdHJhY2VyLl9yZWdpc3RlcihzY2hlbWEpIH07XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmRlYnVnKSB7XG4gICAgICAgIEFzc2VydChzY2hlbWEuJF9yb290LnRyYWNlLCAnRGVidWcgbW9kZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC50cmFjZSgpLl9yZWdpc3RlcihzY2hlbWEpLCBjbGVhbnVwOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhY2VyOiBpbnRlcm5hbHMuaWdub3JlIH07XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMgPSB7fSkge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHN0YXRlIGFuZCBzZXR0aW5nc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcHJlZnMgPSBpbnRlcm5hbHMucHJlZnMoc2NoZW1hLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9jYWNoZS5nZXQodmFsdWUpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICd2YWxpZGF0ZScsICdjYWNoZWQnLCAhIXJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBsb2NhbFN0YXRlIHx8IHN0YXRlLCBwcmVmcyk7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICBwcmVmcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yLFxuICAgICAgICBlcnJvcnNBcnJheTogaW50ZXJuYWxzLmVycm9yc0FycmF5LFxuICAgICAgICB3YXJuOiAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goY3JlYXRlRXJyb3IoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpKSxcbiAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2N1c3RvbScsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCB7IG1lc3NhZ2VzIH0pXG4gICAgfTtcblxuICAgIC8vIFByZXBhcmVcblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5lbnRyeShzY2hlbWEsIHN0YXRlKTtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmLnByZXBhcmUgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBkZWYucHJlcGFyZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncHJlcGFyZScsIHZhbHVlLCBwcmVwYXJlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShwcmVwYXJlZC52YWx1ZSwgW10uY29uY2F0KHByZXBhcmVkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgIC8vIFByZXBhcmUgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBjb2VyY2lvblxuXG4gICAgaWYgKGRlZi5jb2VyY2UgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0ICYmXG4gICAgICAgICghZGVmLmNvZXJjZS5mcm9tIHx8IGRlZi5jb2VyY2UuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSkge1xuXG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBkZWYuY29lcmNlLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjb2VyY2VkJywgdmFsdWUsIGNvZXJjZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShjb2VyY2VkLnZhbHVlLCBbXS5jb25jYXQoY29lcmNlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAgIC8vIENvZXJjZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHZhbHVlXG5cbiAgICBjb25zdCBlbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgaWYgKGVtcHR5ICYmXG4gICAgICAgIGVtcHR5LiRfbWF0Y2goaW50ZXJuYWxzLnRyaW0odmFsdWUsIHNjaGVtYSksIHN0YXRlLm5lc3QoZW1wdHkpLCBDb21tb24uZGVmYXVsdHMpKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZW1wdHknLCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUHJlc2VuY2UgcmVxdWlyZW1lbnRzIChyZXF1aXJlZCwgb3B0aW9uYWwsIGZvcmJpZGRlbilcblxuICAgIGNvbnN0IHByZXNlbmNlID0gb3ZlcnJpZGVzLnByZXNlbmNlIHx8IHNjaGVtYS5fZmxhZ3MucHJlc2VuY2UgfHwgKHNjaGVtYS5fZmxhZ3MuX2VuZGVkU3dpdGNoID8gbnVsbCA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIHJldFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgc2NoZW1hLCBzdGF0ZSwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIEFydGlmYWN0c1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5hcnRpZmFjdCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzID0gc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuaGFzKHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuc2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5nZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkucHVzaChzdGF0ZS5wYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIGhlbHBlcnNdIDogW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoYGFueS4ke2ZsYWd9YCwgbnVsbCwgeyBlcnJvcjogZXJyIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpdGVyYWw7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsb25lKHNvdXJjZSk7XG59O1xuXG5cbmludGVybmFscy50cmltID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgIGlmICghdHJpbSB8fFxuICAgICAgICAhdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbn07XG5cblxuaW50ZXJuYWxzLmlnbm9yZSA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBJZ25vcmUsXG4gICAgZW50cnk6IElnbm9yZSxcbiAgICBmaWx0ZXI6IElnbm9yZSxcbiAgICBsb2c6IElnbm9yZSxcbiAgICByZXNvbHZlOiBJZ25vcmUsXG4gICAgdmFsdWU6IElnbm9yZVxufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnNbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlZhbHVlcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcywgcmVmcykge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgIHRoaXMuX2xvd2VyY2FzZSA9IGludGVybmFscy5sb3dlcmNhc2VzKHZhbHVlcyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuc2l6ZSArIHRoaXMuX3JlZnMuc2l6ZTtcbiAgICB9XG5cbiAgICBhZGQodmFsdWUsIHJlZnMpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVmcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZnMpIHsgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwcGVkIGluIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUsIG51bGwsIG51bGwsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHJlbW92ZSkge1xuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgaW50ZXJuYWxzLlZhbHVlcygpO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnNvdXJjZS5fdmFsdWVzLCAuLi5zb3VyY2UuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4ucmVtb3ZlLl92YWx1ZXMsIC4uLnJlbW92ZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiBudWxsO1xuICAgIH1cblxuICAgIHJlbW92ZSh2YWx1ZSkge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVmcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICB0aGlzLl92YWx1ZXMuZGVsZXRlKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLmRlbGV0ZSh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhcyh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBtYXRjaFxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9sb3dlcmNhc2UuZ2V0KHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3JlZnMuc2l6ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXMuX3JlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgaW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSAhcmVmLmluIHx8IHR5cGVvZiByZXNvbHZlZCAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBbcmVzb2x2ZWRdXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShyZXNvbHZlZCkgPyByZXNvbHZlZCA6IE9iamVjdC5rZXlzKHJlc29sdmVkKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZW5zaXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvdmVycmlkZSgpIHtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5kaXNwbGF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyh0aGlzLl92YWx1ZXMsIHRoaXMuX3JlZnMpO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydCghc291cmNlLl9vdmVycmlkZSwgJ0Nhbm5vdCBjb25jYXQgb3ZlcnJpZGUgc2V0IG9mIHZhbHVlcycpO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKFsuLi50aGlzLl92YWx1ZXMsIC4uLnNvdXJjZS5fdmFsdWVzXSwgWy4uLnRoaXMuX3JlZnMsIC4uLnNvdXJjZS5fcmVmc10pO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHsgb3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3ZhbHVlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB7IHZhbHVlIH0gOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3JlZnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZS5kZXNjcmliZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudmFsdWVzXSA9IHRydWU7XG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5zbGljZSA9IGludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLmNsb25lO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmxvd2VyY2FzZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBNb2RpZnkgPSByZXF1aXJlKCcuL21vZGlmeScpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi90cmFjZScpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkJhc2UgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG5cbiAgICAgICAgLy8gTmFtaW5nOiBwdWJsaWMsIF9wcml2YXRlLCAkX2V4dGVuc2lvbiwgJF9tdXRhdGV7YWN0aW9ufVxuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgdGhpcy4kX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0ge307XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfVxuXG4gICAgX3Jlc2V0KCkge1xuXG4gICAgICAgIHRoaXMuX2lkcyA9IG5ldyBNb2RpZnkuSWRzKCk7XG4gICAgICAgIHRoaXMuX3ByZWZlcmVuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBSZWYuTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdmFsaWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW52YWxpZHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ZsYWdzID0ge307XG4gICAgICAgIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIHRoaXMuX3NpbmdsZVJ1bGVzID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgLy8gVGhlIHJ1bGUgb3B0aW9ucyBwYXNzZWQgZm9yIG5vbi1tdWx0aSBydWxlc1xuXG4gICAgICAgIHRoaXMuJF90ZXJtcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzaCBvZiBhcnJheXMgb2YgaW1tdXRhYmxlIG9iamVjdHMgKGV4dGVuZGVkIGJ5IG90aGVyIHR5cGVzKVxuXG4gICAgICAgIHRoaXMuJF90ZW1wID0geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBzdGF0ZSAobm90IGNsb25lZClcbiAgICAgICAgICAgIHJ1bGVzZXQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsOiB1c2UgbGFzdCwgZmFsc2U6IGVycm9yLCBudW1iZXI6IHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICB3aGVuczoge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBjYWNoZSBvZiBnZW5lcmF0ZWQgd2hlbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5kZXNjcmliZSA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmRlc2NyaWJlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBhbGxvdyguLi52YWx1ZXMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICdhbGxvdycpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKHZhbHVlcywgJ192YWxpZHMnKTtcbiAgICB9XG5cbiAgICBhbHRlcih0YXJnZXRzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhcmdldHMgJiYgdHlwZW9mIHRhcmdldHMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRhcmdldHMpLCAnSW52YWxpZCB0YXJnZXRzIGFyZ3VtZW50Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGFsdGVyYXRpb25zIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zID0gb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVyID0gdGFyZ2V0c1t0YXJnZXRdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBhZGp1c3RlciA9PT0gJ2Z1bmN0aW9uJywgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucy5wdXNoKHsgdGFyZ2V0LCBhZGp1c3RlciB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGFydGlmYWN0KGlkKSB7XG5cbiAgICAgICAgQXNzZXJ0KGlkICE9PSB1bmRlZmluZWQsICdBcnRpZmFjdCBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgc2V0IGFuIGFydGlmYWN0IHdpdGggYSBydWxlIGNhY2hlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdhcnRpZmFjdCcsIGlkKTtcbiAgICB9XG5cbiAgICBjYXN0KHRvKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRvID09PSBmYWxzZSB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnLCAnSW52YWxpZCB0byB2YWx1ZScpO1xuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHRoaXMuX2RlZmluaXRpb24uY2FzdFt0b10sICdUeXBlJywgdGhpcy50eXBlLCAnZG9lcyBub3Qgc3VwcG9ydCBjYXN0aW5nIHRvJywgdG8pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnY2FzdCcsIHRvID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0KHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQoJ2RlZmF1bHQnLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZGVzY3JpcHRpb24oZGVzYykge1xuXG4gICAgICAgIEFzc2VydChkZXNjICYmIHR5cGVvZiBkZXNjID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdkZXNjcmlwdGlvbicsIGRlc2MpO1xuICAgIH1cblxuICAgIGVtcHR5KHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IG9iai4kX2NvbXBpbGUoc2NoZW1hLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdlbXB0eScsIHNjaGVtYSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgZXJyb3IoZXJyKSB7XG5cbiAgICAgICAgQXNzZXJ0KGVyciwgJ01pc3NpbmcgZXJyb3InKTtcbiAgICAgICAgQXNzZXJ0KGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicsICdNdXN0IHByb3ZpZGUgYSB2YWxpZCBFcnJvciBvYmplY3Qgb3IgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZXJyb3InLCBlcnIpO1xuICAgIH1cblxuICAgIGV4YW1wbGUoZXhhbXBsZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KGV4YW1wbGUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcgZXhhbXBsZScpO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ292ZXJyaWRlJ10pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignZXhhbXBsZXMnLCBleGFtcGxlLCB7IHNpbmdsZTogdHJ1ZSwgb3ZlcnJpZGU6IG9wdGlvbnMub3ZlcnJpZGUgfSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwobWV0aG9kLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgQXNzZXJ0KCFkZXNjcmlwdGlvbiwgJ0Nhbm5vdCBjb21iaW5lIG9wdGlvbnMgd2l0aCBkZXNjcmlwdGlvbicpO1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBtZXRob2QuZGVzY3JpcHRpb247XG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2QubWV0aG9kO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignZXh0ZXJuYWxzJywgeyBtZXRob2QsIGRlc2NyaXB0aW9uIH0sIHsgc2luZ2xlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZhaWxvdmVyKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQoJ2ZhaWxvdmVyJywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvcmJpZGRlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnZm9yYmlkZGVuJyk7XG4gICAgfVxuXG4gICAgaWQoaWQpIHtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2lkJywgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgaWQgPT09ICdzdHJpbmcnLCAnaWQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KC9eW15cXC5dKyQvLnRlc3QoaWQpLCAnaWQgY2Fubm90IGNvbnRhaW4gcGVyaW9kIGNoYXJhY3RlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCBpZCk7XG4gICAgfVxuXG4gICAgaW52YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKHZhbHVlcywgJ19pbnZhbGlkcycpO1xuICAgIH1cblxuICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdMYWJlbCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdsYWJlbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIG1ldGEobWV0YSkge1xuXG4gICAgICAgIEFzc2VydChtZXRhICE9PSB1bmRlZmluZWQsICdNZXRhIGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ21ldGFzJywgbWV0YSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgbm90ZSguLi5ub3Rlcykge1xuXG4gICAgICAgIEFzc2VydChub3Rlcy5sZW5ndGgsICdNaXNzaW5nIG5vdGVzJyk7XG4gICAgICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xuICAgICAgICAgICAgQXNzZXJ0KG5vdGUgJiYgdHlwZW9mIG5vdGUgPT09ICdzdHJpbmcnLCAnTm90ZXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdub3RlcycsIG5vdGVzKTtcbiAgICB9XG5cbiAgICBvbmx5KG1vZGUgPSB0cnVlKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RlID09PSAnYm9vbGVhbicsICdJbnZhbGlkIG1vZGU6JywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdvbmx5JywgbW9kZSk7XG4gICAgfVxuXG4gICAgb3B0aW9uYWwoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ29wdGlvbmFsJyk7XG4gICAgfVxuXG4gICAgcHJlZnMocHJlZnMpIHtcblxuICAgICAgICBBc3NlcnQocHJlZnMsICdNaXNzaW5nIHByZWZlcmVuY2VzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5jb250ZXh0ID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgY29udGV4dCcpO1xuICAgICAgICBBc3NlcnQocHJlZnMuZXh0ZXJuYWxzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZXh0ZXJuYWxzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5kZWJ1ZyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGRlYnVnJyk7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCBwcmVmcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcHJlc2VuY2UobW9kZSkge1xuXG4gICAgICAgIEFzc2VydChbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLmluY2x1ZGVzKG1vZGUpLCAnVW5rbm93biBwcmVzZW5jZSBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdwcmVzZW5jZScsIG1vZGUpO1xuICAgIH1cblxuICAgIHJhdyhlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgZW5hYmxlZCA/ICdyYXcnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXN1bHQobW9kZSkge1xuXG4gICAgICAgIEFzc2VydChbJ3JhdycsICdzdHJpcCddLmluY2x1ZGVzKG1vZGUpLCAnVW5rbm93biByZXN1bHQgbW9kZScsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmVxdWlyZWQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ3JlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgc3RyaWN0KGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3QgY29udmVydCA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogIWVuYWJsZWQ7XG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgeyBjb252ZXJ0IH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0cmlwKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3N0cmlwJyA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdGFnKC4uLnRhZ3MpIHtcblxuICAgICAgICBBc3NlcnQodGFncy5sZW5ndGgsICdNaXNzaW5nIHRhZ3MnKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgQXNzZXJ0KHRhZyAmJiB0eXBlb2YgdGFnID09PSAnc3RyaW5nJywgJ1RhZ3MgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCd0YWdzJywgdGFncyk7XG4gICAgfVxuXG4gICAgdW5pdChuYW1lKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnVW5pdCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bml0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAndmFsaWQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmFsbG93KC4uLnZhbHVlcyk7XG4gICAgICAgIG9iai4kX3NldEZsYWcoJ29ubHknLCAhIW9iai5fdmFsaWRzLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB3aGVuKGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2hlbiA9IENvbXBpbGUud2hlbihvYmosIGNvbmRpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghWydhbnknLCAnbGluayddLmluY2x1ZGVzKG9iai50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFpdGVtLnRoZW4gfHwgaXRlbS50aGVuLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0udGhlbi50eXBlID09PSBvYmoudHlwZSwgJ0Nhbm5vdCBjb21iaW5lJywgb2JqLnR5cGUsICd3aXRoJywgaXRlbS50aGVuICYmIGl0ZW0udGhlbi50eXBlKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0ub3RoZXJ3aXNlIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLm90aGVyd2lzZSAmJiBpdGVtLm90aGVyd2lzZS50eXBlKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVybXMud2hlbnMucHVzaCh3aGVuKTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjYWNoZShjYWNoZSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGNhY2hpbmcgaW5zaWRlIGEgcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2NhY2hlLCAnQ2Fubm90IG92ZXJyaWRlIHNjaGVtYSBjYWNoZScpO1xuICAgICAgICBBc3NlcnQodGhpcy5fZmxhZ3MuYXJ0aWZhY3QgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWNoZSBhIHJ1bGUgd2l0aCBhbiBhcnRpZmFjdCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9jYWNoZSA9IGNhY2hlIHx8IENhY2hlLnByb3ZpZGVyLnByb3Zpc2lvbigpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob2JqKTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzb3VyY2UpLCAnSW52YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSAnYW55JyB8fCBzb3VyY2UudHlwZSA9PT0gdGhpcy50eXBlLCAnQ2Fubm90IG1lcmdlIHR5cGUnLCB0aGlzLnR5cGUsICd3aXRoIGFub3RoZXIgdHlwZTonLCBzb3VyY2UudHlwZSk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgb250byBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgYSBzY2hlbWEgd2l0aCBvcGVuIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdhbnknICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSAhPT0gJ2FueScpIHtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIG9iaiB0byBtYXRjaCBzb3VyY2UgdHlwZVxuXG4gICAgICAgICAgICBjb25zdCB0bXBPYmogPSBzb3VyY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wT2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iaiA9IHRtcE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5faWRzLmNvbmNhdChzb3VyY2UuX2lkcyk7XG4gICAgICAgIG9iai5fcmVmcy5yZWdpc3Rlcihzb3VyY2UsIFJlZi50b1NpYmxpbmcpO1xuXG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBvYmouX3ByZWZlcmVuY2VzID8gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHNvdXJjZS5fcHJlZmVyZW5jZXMpIDogc291cmNlLl9wcmVmZXJlbmNlcztcbiAgICAgICAgb2JqLl92YWxpZHMgPSBWYWx1ZXMubWVyZ2Uob2JqLl92YWxpZHMsIHNvdXJjZS5fdmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzKTtcbiAgICAgICAgb2JqLl9pbnZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX2ludmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzLCBzb3VyY2UuX3ZhbGlkcyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuaXF1ZSBydWxlcyBwcmVzZW50IGluIHNvdXJjZVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3VyY2UuX3NpbmdsZVJ1bGVzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKG9iai5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9ydWxlcyA9IG9iai5fcnVsZXMuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC5rZWVwIHx8IHRhcmdldC5uYW1lICE9PSBuYW1lKTtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHNvdXJjZS5fcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlLl9kZWZpbml0aW9uLnJ1bGVzW3Rlc3QubWV0aG9kXS5tdWx0aSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHRlc3QubmFtZSwgdGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXMucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKG9iai5fZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgIHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcblxuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IG9iai5fZmxhZ3MuZW1wdHkuY29uY2F0KHNvdXJjZS5fZmxhZ3MuZW1wdHkpO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2UuX2ZsYWdzLmVtcHR5KSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gc291cmNlLl9mbGFncy5lbXB0eTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLl9mbGFncyk7XG4gICAgICAgICAgICBkZWxldGUgZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlLiRfdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gc291cmNlLiRfdGVybXNba2V5XTtcbiAgICAgICAgICAgIGlmICghdGVybXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IHRlcm1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IG9iai4kX3Rlcm1zW2tleV0uY29uY2F0KHRlcm1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNpbmdcblxuICAgICAgICBpZiAodGhpcy4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICAgICAgdGhpcy4kX3Jvb3QuX3RyYWNlci5fY29tYmluZShvYmosIFt0aGlzLCBzb3VyY2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlYnVpbGRcblxuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIGV4dGVuZChvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLmJhc2UsICdDYW5ub3QgZXh0ZW5kIHR5cGUgd2l0aCBhbm90aGVyIGJhc2UnKTtcblxuICAgICAgICByZXR1cm4gRXh0ZW5kLnR5cGUodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZXh0cmFjdChwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgIGZvcmsocGF0aHMsIGFkanVzdGVyKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBmb3JrIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIFtdLmNvbmNhdChwYXRocykpIHtcbiAgICAgICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5faWRzLmZvcmsocGF0aCwgYWRqdXN0ZXIsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBydWxlKG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBPYmplY3Qua2V5cyhkZWYubW9kaWZpZXJzKSk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlLCAnQ2Fubm90IGFwcGx5IHJ1bGVzIHRvIGVtcHR5IHJ1bGVzZXQgb3IgdGhlIGxhc3QgcnVsZSBhZGRlZCBkb2VzIG5vdCBzdXBwb3J0IHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuJF90ZW1wLnJ1bGVzZXQgPT09IG51bGwgPyB0aGlzLl9ydWxlcy5sZW5ndGggLSAxIDogdGhpcy4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgQXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLl9ydWxlcy5sZW5ndGgsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBvYmouX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBjb25zdCBydWxlID0gQ2xvbmUob3JpZ2luYWwpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGRlZi5tb2RpZmllcnNbbmFtZV0ocnVsZSwgb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUubmFtZSA9PT0gb3JpZ2luYWwubmFtZSwgJ0Nhbm5vdCBjaGFuZ2UgcnVsZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKSA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJ1bGVzZXQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzdGFydCBhIG5ldyBydWxlc2V0IHdpdGhvdXQgY2xvc2luZyB0aGUgcHJldmlvdXMgb25lJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBvYmouX3J1bGVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBnZXQgJCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlc2V0O1xuICAgIH1cblxuICAgIHRhaWxvcih0YXJnZXRzKSB7XG5cbiAgICAgICAgdGFyZ2V0cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHRhaWxvciBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgICAgIGlmICh0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdGhpcy4kX3Rlcm1zLmFsdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBhZGp1c3RlcihvYmopO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKG9iaiksICdBbHRlcmF0aW9uIGFkanVzdGVyIGZvcicsIHRhcmdldCwgJ2ZhaWxlZCB0byByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqLiRfbW9kaWZ5KHsgZWFjaDogKGl0ZW0pID0+IGl0ZW0udGFpbG9yKHRhcmdldHMpLCByZWY6IGZhbHNlIH0pO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICB0cmFjZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIFRyYWNlLmxvY2F0aW9uID8gVHJhY2UubG9jYXRpb24odGhpcykgOiB0aGlzOyAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnkodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlQXN5bmModmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmVudHJ5QXN5bmModmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEV4dGVuc2lvbnNcblxuICAgICRfYWRkUnVsZShvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHJ1bGVcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubmFtZSAmJiB0eXBlb2Ygb3B0aW9ucy5uYW1lID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcnVsZSBuYW1lJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgQXNzZXJ0KGtleVswXSAhPT0gJ18nLCAnQ2Fubm90IHNldCBwcml2YXRlIHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcnVsZSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcnVsZS5fcmVzb2x2ZSA9IFtdO1xuICAgICAgICBydWxlLm1ldGhvZCA9IHJ1bGUubWV0aG9kIHx8IHJ1bGUubmFtZTtcblxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm1ldGhvZF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBydWxlLmFyZ3M7XG5cbiAgICAgICAgQXNzZXJ0KGRlZmluaXRpb24sICdVbmtub3duIHJ1bGUnLCBydWxlLm1ldGhvZCk7XG5cbiAgICAgICAgLy8gQXJnc1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gMSB8fCBPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IHRoaXMuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5uYW1lXS5hcmdzLmxlbmd0aCwgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIHRoaXMudHlwZSwgcnVsZS5uYW1lKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5hcmdzQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5yZWYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5pc1Jlc29sdmFibGUoYXJnKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLl9yZXNvbHZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gcmVzb2x2ZXIubm9ybWFsaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIuYXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBDb21tb24udmFsaWRhdGVBcmcoYXJnLCBrZXksIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIWVycm9yLCBlcnJvciwgJ29yIHJlZmVyZW5jZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuaXF1ZSBydWxlc1xuXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5tdWx0aSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlUmVtb3ZlKHJ1bGUubmFtZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai4kX3RlbXAucnVsZXNldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5wcmlvcml0eSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy51bnNoaWZ0KHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX2NvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuc2NoZW1hKHRoaXMuJF9yb290LCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgICRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBzdGF0ZSwgcHJlZnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5mbGFncyAhPT0gZmFsc2UgPyB0aGlzLl9mbGFncyA6IHt9O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXMgPyBNZXNzYWdlcy5tZXJnZSh0aGlzLl9kZWZpbml0aW9uLm1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzKSA6IHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXM7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JzLlJlcG9ydChjb2RlLCB2YWx1ZSwgbG9jYWwsIGZsYWdzLCBtZXNzYWdlcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAkX2dldEZsYWcobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFnc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX2dldFJ1bGUobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVSdWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgJF9tYXBMYWJlbHMocGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5sYWJlbHMocGF0aCk7XG4gICAgfVxuXG4gICAgJF9tYXRjaCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMpIHtcblxuICAgICAgICBwcmVmcyA9IE9iamVjdC5hc3NpZ24oe30sIHByZWZzKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcHJlZnMuYWJvcnRFYXJseSA9IHRydWU7XG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgPSBmYWxzZTtcblxuICAgICAgICBzdGF0ZS5zbmFwc2hvdCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAhVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykuZXJyb3JzO1xuICAgICAgICBzdGF0ZS5yZXN0b3JlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAkX21vZGlmeShvcHRpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydlYWNoJywgJ29uY2UnLCAncmVmJywgJ3NjaGVtYSddKTtcbiAgICAgICAgcmV0dXJuIE1vZGlmeS5zY2hlbWEodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlYnVpbGQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBhZGQgdGhpcyBydWxlIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2lkcy5yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBzb3VyY2UsIG5hbWUsIHBhdGgsIGtleSB9KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZhbWlseSA9IHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXSAmJiB0aGlzLl9kZWZpbml0aW9uW3NvdXJjZV1bbmFtZV0ucmVnaXN0ZXI7XG4gICAgICAgICAgICBpZiAoZmFtaWx5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9tdXRhdGVSZWdpc3RlcihpdGVtLCB7IGZhbWlseSwga2V5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJF9tb2RpZnkoeyBlYWNoIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLnJlYnVpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEsIHsgZmFtaWx5LCBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy5fcmVmcy5yZWdpc3RlcihzY2hlbWEsIGZhbWlseSk7XG4gICAgICAgIHRoaXMuX2lkcy5yZWdpc3RlcihzY2hlbWEsIHsga2V5IH0pO1xuICAgIH1cblxuICAgICRfcHJvcGVydHkobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uLnByb3BlcnRpZXNbbmFtZV07XG4gICAgfVxuXG4gICAgJF9yZWFjaChwYXRoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5yZWFjaChwYXRoKTtcbiAgICB9XG5cbiAgICAkX3Jvb3RSZWZlcmVuY2VzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZzLnJvb3RzKCk7XG4gICAgfVxuXG4gICAgJF9zZXRGbGFnKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQobmFtZVswXSA9PT0gJ18nIHx8ICF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgZmxhZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuX2RlZmluaXRpb24uZmxhZ3NbbmFtZV0gfHwge307XG4gICAgICAgIGlmIChEZWVwRXF1YWwodmFsdWUsIGZsYWcuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgdGhpcy5fZmxhZ3NbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9iai5fZmxhZ3NbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgJF9wYXJlbnQobWV0aG9kLCAuLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXVtDb21tb24uc3ltYm9scy5wYXJlbnRdLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfVxuXG4gICAgJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSwgdGhpcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbHNcblxuICAgIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICAgICAgdGFyZ2V0LnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgdGFyZ2V0LiRfcm9vdCA9IHRoaXMuJF9yb290O1xuXG4gICAgICAgIHRhcmdldC4kX3RlbXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfdGVtcCk7XG4gICAgICAgIHRhcmdldC4kX3RlbXAud2hlbnMgPSB7fTtcblxuICAgICAgICB0YXJnZXQuX2lkcyA9IHRoaXMuX2lkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3ByZWZlcmVuY2VzID0gdGhpcy5fcHJlZmVyZW5jZXM7XG4gICAgICAgIHRhcmdldC5fdmFsaWRzID0gdGhpcy5fdmFsaWRzICYmIHRoaXMuX3ZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX2ludmFsaWRzID0gdGhpcy5faW52YWxpZHMgJiYgdGhpcy5faW52YWxpZHMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9ydWxlcyA9IHRoaXMuX3J1bGVzLnNsaWNlKCk7XG4gICAgICAgIHRhcmdldC5fc2luZ2xlUnVsZXMgPSBDbG9uZSh0aGlzLl9zaW5nbGVSdWxlcywgeyBzaGFsbG93OiB0cnVlIH0pO1xuICAgICAgICB0YXJnZXQuX3JlZnMgPSB0aGlzLl9yZWZzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mbGFncyk7XG4gICAgICAgIHRhcmdldC5fY2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHRhcmdldC4kX3Rlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJF90ZXJtcykge1xuICAgICAgICAgICAgdGFyZ2V0LiRfdGVybXNba2V5XSA9IHRoaXMuJF90ZXJtc1trZXldID8gdGhpcy4kX3Rlcm1zW2tleV0uc2xpY2UoKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgICAgIHRhcmdldC4kX3N1cGVyID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgaW4gdGhpcy4kX3N1cGVyKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF9zdXBlcltvdmVycmlkZV0gPSB0aGlzLl9zdXBlcltvdmVycmlkZV0uYmluZCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBfYmFyZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fcmVzZXQoKTtcblxuICAgICAgICBjb25zdCB0ZXJtcyA9IG9iai5fZGVmaW5pdGlvbi50ZXJtcztcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRlcm1zKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gdGVybXNbbmFtZV07XG4gICAgICAgICAgICBvYmouJF90ZXJtc1tuYW1lXSA9IHRlcm0uaW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgX2RlZmF1bHQoZmxhZywgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsICdsaXRlcmFsJyk7XG5cbiAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nJywgZmxhZywgJ3ZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgIW9wdGlvbnMubGl0ZXJhbCwgJ09ubHkgZnVuY3Rpb24gdmFsdWUgc3VwcG9ydHMgbGl0ZXJhbCBvcHRpb24nKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRpb25zLmxpdGVyYWwpIHtcblxuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpdGVyYWw6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3NldEZsYWcoZmxhZywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdCBtYXRjaGluZyB3aGVuc1xuXG4gICAgICAgIGNvbnN0IHdoZW5zID0gW107XG4gICAgICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuJF90ZXJtcy53aGVucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgd2hlbiA9IHRoaXMuJF90ZXJtcy53aGVuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHdoZW4uY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgd2hlbnMucHVzaCh3aGVuLmNvbmNhdCk7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7aX0uY29uY2F0YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gd2hlbi5yZWYgPyB3aGVuLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGlkcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3RzW2pdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUlkID0gYCR7aX0ke3doZW4uc3dpdGNoID8gJy4nICsgaiA6ICcnfWA7XG4gICAgICAgICAgICAgICAgaWYgKGlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2Jhc2VJZH0uaXNgKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0udGhlbmBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWE6IGdlbmVyYXRlZCwgaWQgfSA9IHRoZW4uX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtiYXNlSWR9LnRoZW4ke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlcndpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBgJHtiYXNlSWR9Lm90aGVyd2lzZWBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gb3RoZXJ3aXNlLl9nZW5lcmF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0ub3RoZXJ3aXNlJHtpZCA/IGAoJHtpZH0pYCA6ICcnfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3aGVuLmJyZWFrICYmXG4gICAgICAgICAgICAgICAgaWRzLmxlbmd0aCA+IGJlZm9yZSkgeyAgICAgICAgICAvLyBTb21ldGhpbmcgbWF0Y2hlZFxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjYWNoZVxuXG4gICAgICAgIGNvbnN0IGlkID0gaWRzLmpvaW4oJywgJyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCAnd2hlbicsIGlkKTtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHRoaXMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkudHJhY2VyLmFjdGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy4kX3RlbXAud2hlbnNbaWRdKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcy4kX3RlbXAud2hlbnNbaWRdLCBpZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgZHluYW1pYyBzY2hlbWFcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSkge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSh0aGlzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IHdoZW5zXG5cbiAgICAgICAgZm9yIChjb25zdCB3aGVuIG9mIHdoZW5zKSB7XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KHdoZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIC4uLndoZW5zXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0gPSBvYmo7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogb2JqLCBpZCB9O1xuICAgIH1cblxuICAgIF9pbm5lcih0eXBlLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksIGBDYW5ub3Qgc2V0ICR7dHlwZX0gaW5zaWRlIGEgcnVsZXNldGApO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKCFvYmouJF90ZXJtc1t0eXBlXSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5vdmVycmlkZSkge1xuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2luZ2xlKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfaW5SdWxlc2V0KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBudWxsICYmIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIF9ydWxlUmVtb3ZlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBvYmouX3J1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRlc3QubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICF0ZXN0LmtlZXApIHtcblxuICAgICAgICAgICAgICAgIGlmIChvYmouX2luUnVsZXNldCgpICYmXG4gICAgICAgICAgICAgICAgICAgIGkgPCBvYmouJF90ZW1wLnJ1bGVzZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAtLW9iai4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fcnVsZXMgPSBmaWx0ZXJlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfdmFsdWVzKHZhbHVlcywga2V5KSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCBrZXkuc2xpY2UoMSwgLTEpKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSB2YWx1ZXNbMF0gPT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0gJiZcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgb2JqW2tleV0gPSBuZXcgVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVzLmxlbmd0aCA/IG5ldyBWYWx1ZXMoKSA6IG51bGw7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9ialtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBvYmpba2V5XS5vdmVycmlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgYWxsb3cvdmFsaWQvaW52YWxpZCB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSBDb21tb24uc3ltYm9scy5vdmVycmlkZSwgJ092ZXJyaWRlIG11c3QgYmUgdGhlIGZpcnN0IHZhbHVlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga2V5ID09PSAnX2ludmFsaWRzJyA/ICdfdmFsaWRzJyA6ICdfaW52YWxpZHMnO1xuICAgICAgICAgICAgaWYgKG9ialtvdGhlcl0pIHtcbiAgICAgICAgICAgICAgICBvYmpbb3RoZXJdLnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmpbb3RoZXJdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5ID09PSAnX3ZhbGlkcycgfHwgIW9iai5fZmxhZ3Mub25seSwgJ1NldHRpbmcgaW52YWxpZCB2YWx1ZScsIHZhbHVlLCAnbGVhdmVzIHNjaGVtYSByZWplY3RpbmcgYWxsIHZhbHVlcyBkdWUgdG8gcHJldmlvdXMgdmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgICAgICBvYmpbb3RoZXJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ialtrZXldLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMuYW55XSA9IHtcbiAgICB2ZXJzaW9uOiBDb21tb24udmVyc2lvbixcbiAgICBjb21waWxlOiBDb21waWxlLmNvbXBpbGUsXG4gICAgcm9vdDogJyRfcm9vdCdcbn07XG5cblxuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgSG9layBmcm9tIGRlZXAgY2xvbmluZyBzY2hlbWEgb2JqZWN0cyAobXVzdCBiZSBvbiBwcm90b3R5cGUpXG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGVueSA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5pbnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmRpc2FsbG93ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXF1YWwgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUudmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXhpc3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucmVxdWlyZWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUubm90ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUub3B0aW9ucyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmZXJlbmNlcyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQmFzZSgpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhbnknLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBvbmx5OiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBhbHRlcmF0aW9uczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGV4YW1wbGVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgbWV0YXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgbm90ZXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgc2hhcmVkOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgdGFnczogeyBpbml0OiBbXSB9LFxuICAgICAgICB3aGVuczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjdXN0b20nLCBhcmdzOiB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBtZXRob2QgfSkge1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FueS5jdXN0b20nLCB7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbWV0aG9kJywgJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICBtZXRob2QobWVzc2FnZXMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZzKHsgbWVzc2FnZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcmVkOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkgJiYgc2NoZW1hLl9mbGFncy5pZCwgJ1NjaGVtYSBtdXN0IGJlIGEgc2NoZW1hIHdpdGggYW4gaWQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQgPSBvYmouJF90ZXJtcy5zaGFyZWQgfHwgW107XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuc2hhcmVkLnB1c2goc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGNvZGUsIGxvY2FsKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoY29kZSAmJiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHdhcm5pbmcgY29kZScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3dhcm5pbmcnLCBhcmdzOiB7IGNvZGUsIGxvY2FsIH0sIHdhcm46IHRydWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29kZSwgbG9jYWwgfSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoY29kZSwgbG9jYWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29kZScsICdsb2NhbCddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb2RpZmllcnM6IHtcblxuICAgICAgICBrZWVwKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUua2VlcCA9IGVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZShydWxlLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUubWVzc2FnZSA9IE1lc3NhZ2VzLmNvbXBpbGUobWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybihydWxlLCBlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBydWxlLndhcm4gPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXNjW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoWydleGFtcGxlcycsICdleHRlcm5hbHMnLCAnbWV0YXMnLCAnbm90ZXMnLCAndGFncyddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtrZXkuc2xpY2UoMCwgLTEpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnYWx0ZXJhdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsdGVyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlclt0YXJnZXRdID0gYWRqdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouYWx0ZXIoYWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnd2hlbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgaXMsIG5vdCwgdGhlbiwgb3RoZXJ3aXNlLCBjb25jYXQgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmNhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQoY29uY2F0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKHJlZiwgeyBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIHN3aXRjaDogdmFsdWUuc3dpdGNoLCBicmVhazogdmFsdWUuYnJlYWsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoud2hlbihpcywgeyB0aGVuLCBvdGhlcndpc2UsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouc2hhcmVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYW55LmN1c3RvbSc6ICd7eyNsYWJlbH19IGZhaWxlZCBjdXN0b20gdmFsaWRhdGlvbiBiZWNhdXNlIHt7I2Vycm9yLm1lc3NhZ2V9fScsXG4gICAgICAgICdhbnkuZGVmYXVsdCc6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBkZWZhdWx0IG1ldGhvZCcsXG4gICAgICAgICdhbnkuZmFpbG92ZXInOiAne3sjbGFiZWx9fSB0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZmFpbG92ZXIgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5pbnZhbGlkJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgICdhbnkub25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUge2lmKCN2YWxpZHMubGVuZ3RoID09IDEsIFwiXCIsIFwib25lIG9mIFwiKX17eyN2YWxpZHN9fScsXG4gICAgICAgICdhbnkucmVmJzogJ3t7I2xhYmVsfX0ge3sjYXJnfX0gcmVmZXJlbmNlcyB7ezojcmVmfX0gd2hpY2gge3sjcmVhc29ufX0nLFxuICAgICAgICAnYW55LnJlcXVpcmVkJzogJ3t7I2xhYmVsfX0gaXMgcmVxdWlyZWQnLFxuICAgICAgICAnYW55LnVua25vd24nOiAne3sjbGFiZWx9fSBpcyBub3QgYWxsb3dlZCdcbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FsdGVybmF0aXZlcycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG1hdGNoOiB7IGRlZmF1bHQ6ICdhbnknIH0gICAgICAgICAgICAgICAgIC8vICdhbnknLCAnb25lJywgJ2FsbCdcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXRjaGVzOiB7IGluaXQ6IFtdLCByZWdpc3RlcjogUmVmLnRvU2libGluZyB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCAuLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHJ5KC4uLnNjaGVtYXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hcyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAgICAgLy8gTWF0Y2ggYWxsIG9yIG9uZVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLm5lc3QoaXRlbS5zY2hlbWEsIGBtYXRjaC4ke2l9YCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuJF92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZC5wdXNoKHJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGZhaWxlZC5tYXAoKGYpID0+IEVycm9ycy5kZXRhaWxzKGYsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYW55JywgY29udGV4dCkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggb25lXG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoID09PSAnb25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkLmxlbmd0aCA9PT0gMSA/IHsgdmFsdWU6IG1hdGNoZWRbMF0gfSA6IHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLm9uZScpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIGFsbFxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGggIT09IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbGwnLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc0FueU9iaiA9IChhbHRlcm5hdGl2ZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdGVybmF0aXZlLiRfdGVybXMubWF0Y2hlcy5zb21lKCh2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodi5zY2hlbWEudHlwZSA9PT0gJ2FsdGVybmF0aXZlcycgJiYgaXNBbnlPYmoodi5zY2hlbWEpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBpc0FueU9iaihzY2hlbWEpID8geyB2YWx1ZTogbWF0Y2hlZC5yZWR1Y2UoKGFjYywgdikgPT4gTWVyZ2UoYWNjLCB2LCB7IG1lcmdlQXJyYXlzOiBmYWxzZSB9KSkgfSA6IHsgdmFsdWU6IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggYW55XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFRyeVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBzY2hlbWE6IGl0ZW0uc2NoZW1hLCByZXBvcnRzOiByZXN1bHQuZXJyb3JzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25kaXRpb25hbFxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGl0ZW0ucmVmID8gaXRlbS5yZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGVzdHMgPSBpdGVtLmlzID8gW2l0ZW1dIDogaXRlbS5zd2l0Y2g7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpcywgdGhlbiwgb3RoZXJ3aXNlIH0gPSB0ZXN0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBgbWF0Y2guJHtpfSR7aXRlbS5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2lkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyd2lzZS4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KG90aGVyd2lzZSwgYCR7aWR9Lm90aGVyd2lzZWApLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbi4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KHRoZW4sIGAke2lkfS50aGVuYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9ycyhlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbmRpdGlvbmFsOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MubWF0Y2gsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgdGhpcy5fZmxhZ3MubWF0Y2gsICd3aXRoIGNvbmRpdGlvbmFsIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBicmVhayBvcHRpb24gd2l0aCBhbHRlcm5hdGl2ZXMgY29uZGl0aW9uYWwnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gbWF0Y2guaXMgPyBbbWF0Y2hdIDogbWF0Y2guc3dpdGNoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX3NldEZsYWcoJ19lbmRlZFN3aXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgIG1ldGhvZChtb2RlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydhbnknLCAnb25lJywgJ2FsbCddLmluY2x1ZGVzKG1vZGUpLCAnSW52YWxpZCBhbHRlcm5hdGl2ZXMgbWF0Y2ggbW9kZScsIG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgdGhpcy4kX3Rlcm1zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChtYXRjaC5zY2hlbWEsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgbW9kZSwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbWF0Y2gnLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cnk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hcy5sZW5ndGgsICdNaXNzaW5nIGFsdGVybmF0aXZlIHNjaGVtYXMnKTtcbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAndHJ5Jyk7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWF0Y2hlcy5wdXNoKHsgc2NoZW1hOiBvYmouJF9jb21waWxlKHNjaGVtYSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9wYXJlbnQoJ2xhYmVsJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wYXRoWzBdICE9PSAnaXMnICYmIHR5cGVvZiBpdGVtLl9mbGFncy5sYWJlbCAhPT0gJ3N0cmluZycgPyBpdGVtLmxhYmVsKG5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iai4kX21vZGlmeSh7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICAvLyBGbGFnIHdoZW4gYW4gYWx0ZXJuYXRpdmUgdHlwZSBpcyBhbiBhcnJheVxuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGl0ZW0pICYmXG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSAnYXJyYXknKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEuJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNjaGVtYS4kX21vZGlmeSh7IGVhY2ggfSk7XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UgfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ5KHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwocmVmLCB7IGlzLCB0aGVuLCBub3QsIG90aGVyd2lzZSwgc3dpdGNoOiBtYXRjaC5zd2l0Y2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwoaXMsIHsgdGhlbiwgb3RoZXJ3aXNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYWxsJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYWxsIG9mIHRoZSByZXF1aXJlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYW55JzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5tYXRjaCc6ICd7eyNsYWJlbH19IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMub25lJzogJ3t7I2xhYmVsfX0gbWF0Y2hlcyBtb3JlIHRoYW4gb25lIGFsbG93ZWQgdHlwZScsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMudHlwZXMnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9uZSBvZiB7eyN0eXBlc319J1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmVycm9ycyA9IGZ1bmN0aW9uIChmYWlsdXJlcywgeyBlcnJvciwgc3RhdGUgfSkge1xuXG4gICAgLy8gTm90aGluZyBtYXRjaGVkIGR1ZSB0byB0eXBlIGNyaXRlcmlhIHJ1bGVzXG5cbiAgICBpZiAoIWZhaWx1cmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYW55JykgfTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgZXJyb3JcblxuICAgIGlmIChmYWlsdXJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBmYWlsdXJlc1swXS5yZXBvcnRzIH07XG4gICAgfVxuXG4gICAgLy8gQW5hbHl6ZSByZWFzb25zXG5cbiAgICBjb25zdCB2YWxpZHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgY29tcGxleCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCB7IHJlcG9ydHMsIHNjaGVtYSB9IG9mIGZhaWx1cmVzKSB7XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgZXJyb3JzICghYWJvcnRFYXJseSlcblxuICAgICAgICBpZiAocmVwb3J0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnVubWF0Y2hlZChmYWlsdXJlcywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3VzdG9tIGVycm9yXG5cbiAgICAgICAgY29uc3QgcmVwb3J0ID0gcmVwb3J0c1swXTtcbiAgICAgICAgaWYgKHJlcG9ydCBpbnN0YW5jZW9mIEVycm9ycy5SZXBvcnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnVubWF0Y2hlZChmYWlsdXJlcywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJuYWwgb2JqZWN0IG9yIGFycmF5IGVycm9yXG5cbiAgICAgICAgaWYgKHJlcG9ydC5zdGF0ZS5wYXRoLmxlbmd0aCAhPT0gc3RhdGUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBsZXgucHVzaCh7IHR5cGU6IHNjaGVtYS50eXBlLCByZXBvcnQgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkc1xuXG4gICAgICAgIGlmIChyZXBvcnQuY29kZSA9PT0gJ2FueS5vbmx5Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZCBvZiByZXBvcnQubG9jYWwudmFsaWRzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRzLmFkZCh2YWxpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFzZSB0eXBlXG5cbiAgICAgICAgY29uc3QgW3R5cGUsIGNvZGVdID0gcmVwb3J0LmNvZGUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNvZGUgIT09ICdiYXNlJykge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRzLmFkZCh0eXBlKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgZXJyb3JzIGFyZSBiYXNlIHR5cGVzIG9yIHZhbGlkc1xuXG4gICAgaWYgKCFjb21wbGV4Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMudHlwZXMnLCB7IHR5cGVzOiBbLi4udmFsaWRzXSB9KSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb21wbGV4IGVycm9yXG5cbiAgICBpZiAoY29tcGxleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBjb21wbGV4WzBdLnJlcG9ydCB9O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG59O1xuXG5cbmludGVybmFscy51bm1hdGNoZWQgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGVycm9yKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZmFpbHVyZS5yZXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMubWF0Y2gnLCBFcnJvcnMuZGV0YWlscyhlcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKSB9O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhcnJheScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNpbmdsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICBzcGFyc2U6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGl0ZW1zOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcbiAgICAgICAgb3JkZXJlZDogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG5cbiAgICAgICAgX2V4Y2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX2luY2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX3JlcXVpcmVkczogeyBpbml0OiBbXSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnb2JqZWN0JyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHNjaGVtYS4kX2dldFJ1bGUoJ3NvcnQnKTtcbiAgICAgICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIHNvcnQuYXJncy5vcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHNpbmdsZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhcnJheS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfZ2V0UnVsZSgnaXRlbXMnKSAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKSB9OyAgICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5IHNvIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGhhczoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGFzJywgYXJnczogeyBzY2hlbWEgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIHByZWZzLCBlcnJvciB9LCB7IHNjaGVtYTogaGFzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIGFuY2VzdG9ycywgaGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcy4kX21hdGNoKHZhbHVlW2ldLCBsb2NhbFN0YXRlLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MYWJlbCA9IGhhcy5fZmxhZ3MubGFiZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5MYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc0tub3duJywgeyBwYXR0ZXJuTGFiZWwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNVbmtub3duJywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLml0ZW1zLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMsIGVycm9yc0FycmF5IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdXNpb25zID0gWy4uLnNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLCAuLi5yZXF1aXJlZHNdO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQXJyYXkgPSAhdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBlcnJvcnNBcnJheSgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlsID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB3YXNBcnJheSA/IGkgOiBuZXcgTnVtYmVyKGkpOyAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdXNpb24gb2Ygc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhjbHVzaW9uLiRfbWF0Y2goaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBleGNsdXNpb24pLCBwcmVmcywgeyBwcmVzZW5jZTogJ2lnbm9yZScgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmV4Y2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXJlZFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG9yZGVyZWQuJF92YWxpZGF0ZShpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuJF90ZXJtcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkub3JkZXJlZExlbmd0aCcsIHsgcG9zOiBpLCBsaW1pdDogc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGggfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gTm8gcmVhc29uIHRvIGNvbnRpbnVlIHNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB2YWxpZGF0ZSBvdGhlciB0aGFuIGFycmF5Lm9yZGVyZWRMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQ2hlY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBqbCA9IHJlcXVpcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgcmVxdWlyZWRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcmVxdWlyZWRzW2pdLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDaGVja3Nbal0gPSByZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UocmVxdWlyZWRzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gJiYgISFwcmVmcy5zdHJpcFVua25vd24uYXJyYXlzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGpsID0gaW5jbHVzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5jbHVzaW9uIG9mIGluY2x1c2lvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcmUtcnVubmluZyByZXF1aXJlZHMgdGhhdCBhbHJlYWR5IGRpZG4ndCBtYXRjaCBpbiB0aGUgcHJldmlvdXMgbG9vcFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGVjayA9IHJlcXVpcmVkcy5pbmRleE9mKGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDaGVjayAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1twcmV2aW91c0NoZWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gaW5jbHVzaW9uLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgZXJyb3IgaWYgb25seSBvbmUgaW5jbHVzaW9uIGRlZmluZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLmxlbmd0aCB8fCBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1ZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5pbmNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsRGVmYXVsdChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICBtYW5pZmVzdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhcnJheS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnb3JkZXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBvYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5vcmRlcmVkLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF2YWx1ZSB8fCAhdGhpcy5fZmxhZ3MuX2FycmF5SXRlbXMsICdDYW5ub3Qgc3BlY2lmeSBzaW5nbGUgcnVsZSB3aGVuIGFycmF5IGhhcyBhcnJheSBpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzaW5nbGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29ydDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieScsICdvcmRlciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogb3B0aW9ucy5vcmRlciB8fCAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ieSA9IENvbXBpbGUucmVmKG9wdGlvbnMuYnksIHsgYW5jZXN0b3I6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0dGluZ3MuYnkuYW5jZXN0b3IsICdDYW5ub3Qgc29ydCBieSBhbmNlc3RvcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzb3J0JywgYXJnczogeyBvcHRpb25zOiBzZXR0aW5ncyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYSB9LCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogc29ydGVkLCBlcnJvcnMgfSA9IGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIG9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSBzb3J0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuc29ydCcsIHsgb3JkZXI6IG9wdGlvbnMub3JkZXIsIGJ5OiBvcHRpb25zLmJ5ID8gb3B0aW9ucy5ieS5rZXkgOiAndmFsdWUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzcGFyc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3BhcnNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB2YWx1ZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdzcGFyc2UnLCB2YWx1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pcXVlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29tcGFyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIWNvbXBhcmF0b3IgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnLCAnY29tcGFyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lnbm9yZVVuZGVmaW5lZCcsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0geyBuYW1lOiAndW5pcXVlJywgYXJnczogeyBvcHRpb25zLCBjb21wYXJhdG9yIH0gfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5wYXRoID0gc2VwYXJhdG9yID8gY29tcGFyYXRvci5zcGxpdChzZXBhcmF0b3IpIDogW2NvbXBhcmF0b3JdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgZXJyb3IsIHNjaGVtYSB9LCB7IGNvbXBhcmF0b3I6IHJhdywgb3B0aW9ucyB9LCB7IGNvbXBhcmF0b3IsIHBhdGggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b206IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlID0gY29tcGFyYXRvciB8fCBEZWVwRXF1YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwYXRoID8gUmVhY2godmFsdWVbaV0sIHBhdGgpIDogdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBjb21wYXJhdG9yID8gZm91bmQuY3VzdG9tIDogZm91bmRbdHlwZW9mIGl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVjb3JkcywgJ0ZhaWxlZCB0byBmaW5kIHVuaXF1ZSBtYXAgY29udGFpbmVyIGZvciB0eXBlJywgdHlwZW9mIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVjb3Jkcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGN1cnJlbnQgPSBlbnRyaWVzLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGN1cnJlbnQudmFsdWVbMF0sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiBjdXJyZW50LnZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtjdXJyZW50LnZhbHVlWzFdXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoaXRlbSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFpZ25vcmVVbmRlZmluZWQgfHwgaXRlbSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHNbaXRlbV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IHJlY29yZHNbaXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbcmVjb3Jkc1tpdGVtXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb21wYXJhdG9yJywgJ29wdGlvbnMnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgIGZyb206IEFycmF5LmlzQXJyYXksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBzY2hlbWEuJF90ZXJtcy5pdGVtcykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQpIHtcbiAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLml0ZW1zKC4uLmRlc2MuaXRlbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm9yZGVyZWQoLi4uZGVzYy5vcmRlcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYXJyYXkuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gYXJyYXknLFxuICAgICAgICAnYXJyYXkuZXhjbHVkZXMnOiAne3sjbGFiZWx9fSBjb250YWlucyBhbiBleGNsdWRlZCB2YWx1ZScsXG4gICAgICAgICdhcnJheS5oYXNLbm93bic6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoIGZvciB0eXBlIHs6I3BhdHRlcm5MYWJlbH0nLFxuICAgICAgICAnYXJyYXkuaGFzVW5rbm93bic6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRCb3RoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319IGFuZCB7eyN1bmtub3duTWlzc2VzfX0gb3RoZXIgcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sja25vd25NaXNzZXN9fScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I3Vua25vd25NaXNzZXN9fSByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5sZW5ndGgnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkub3JkZXJlZExlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBhdCBtb3N0IHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkuc29ydCc6ICd7eyNsYWJlbH19IG11c3QgYmUgc29ydGVkIGluIHsjb3JkZXJ9IG9yZGVyIGJ5IHt7I2J5fX0nLFxuICAgICAgICAnYXJyYXkuc29ydC5taXNtYXRjaGluZyc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIG1pc21hdGNoaW5nIHR5cGVzJyxcbiAgICAgICAgJ2FycmF5LnNvcnQudW5zdXBwb3J0ZWQnOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgc29ydGVkIGR1ZSB0byB1bnN1cHBvcnRlZCB0eXBlIHsjdHlwZX0nLFxuICAgICAgICAnYXJyYXkuc3BhcnNlJzogJ3t7I2xhYmVsfX0gbXVzdCBub3QgYmUgYSBzcGFyc2UgYXJyYXkgaXRlbScsXG4gICAgICAgICdhcnJheS51bmlxdWUnOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGR1cGxpY2F0ZSB2YWx1ZSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5maWxsTWlzc2VkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IGtub3duTWlzc2VzID0gW107XG4gICAgbGV0IHVua25vd25NaXNzZXMgPSAwO1xuICAgIGZvciAoY29uc3QgcmVxdWlyZWQgb2YgcmVxdWlyZWRzKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gcmVxdWlyZWQuX2ZsYWdzLmxhYmVsO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGtub3duTWlzc2VzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKyt1bmtub3duTWlzc2VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtub3duTWlzc2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAodW5rbm93bk1pc3Nlcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRCb3RoJywgdmFsdWUsIHsga25vd25NaXNzZXMsIHVua25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducycsIHZhbHVlLCB7IGtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZFVua25vd25zJywgdmFsdWUsIHsgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsT3JkZXJlZEVycm9ycyA9IGZ1bmN0aW9uIChzY2hlbWEsIGVycm9ycywgb3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IHJlcXVpcmVkT3JkZXJlZHMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qgb3JkZXJlZCBvZiBvcmRlcmVkcykge1xuICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3MucHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkT3JkZXJlZHMucHVzaChvcmRlcmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1aXJlZE9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICBpbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRPcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmlsbERlZmF1bHQgPSBmdW5jdGlvbiAob3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IFtdO1xuICAgIGxldCB0cmFpbGluZ1VuZGVmaW5lZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gb3JkZXJlZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyZWRzW2ldO1xuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gb3JkZXJlZC4kX3ZhbGlkYXRlKHVuZGVmaW5lZCwgc3RhdGUubG9jYWxpemUoc3RhdGUucGF0aCwgYW5jZXN0b3JzLCBvcmRlcmVkKSwgcHJlZnMpLnZhbHVlO1xuXG4gICAgICAgIGlmICh0cmFpbGluZ1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhaWxpbmdVbmRlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJyaWRlcy51bnNoaWZ0KG92ZXJyaWRlKTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcnJpZGVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZS5wdXNoKC4uLm92ZXJyaWRlcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmFzdFNwbGljZSA9IGZ1bmN0aW9uIChhcnIsIGkpIHtcblxuICAgIGxldCBwb3MgPSBpO1xuICAgIHdoaWxlIChwb3MgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGFycltwb3MrK10gPSBhcnJbcG9zXTtcbiAgICB9XG5cbiAgICAtLWFyci5sZW5ndGg7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZVNpbmdsZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcblxuICAgIGlmICh0eXBlLnR5cGUgPT09ICdhcnJheScgfHxcbiAgICAgICAgdHlwZS5fZmxhZ3MuX2FycmF5SXRlbXMpIHtcblxuICAgICAgICBBc3NlcnQoIW9iai5fZmxhZ3Muc2luZ2xlLCAnQ2Fubm90IHNwZWNpZnkgYXJyYXkgaXRlbSB3aXRoIHNpbmdsZSBydWxlIGVuYWJsZWQnKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnX2FycmF5SXRlbXMnLCB0cnVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zb3J0ID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHNldHRpbmdzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IG9yZGVyID0gc2V0dGluZ3Mub3JkZXIgPT09ICdhc2NlbmRpbmcnID8gMSA6IC0xO1xuICAgIGNvbnN0IGFGaXJzdCA9IC0xICogb3JkZXI7XG4gICAgY29uc3QgYkZpcnN0ID0gb3JkZXI7XG5cbiAgICBjb25zdCBzb3J0ID0gKGEsIGIpID0+IHtcblxuICAgICAgICBsZXQgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmJ5KSB7XG4gICAgICAgICAgICBhID0gc2V0dGluZ3MuYnkucmVzb2x2ZShhLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgYiA9IHNldHRpbmdzLmJ5LnJlc29sdmUoYiwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBhcmUgPSBpbnRlcm5hbHMuY29tcGFyZShhLCBiLCBhRmlyc3QsIGJGaXJzdCk7XG4gICAgICAgIGlmIChjb21wYXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICAgICAgaWYgKHR5cGUgIT09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICB0aHJvdyBzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuc29ydC5taXNtYXRjaGluZycsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICB0aHJvdyBzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuc29ydC51bnN1cHBvcnRlZCcsIHZhbHVlLCB7IHR5cGUgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIChhIC0gYikgKiBvcmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhIDwgYiA/IGFGaXJzdCA6IGJGaXJzdDtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLnNsaWNlKCkuc29ydChzb3J0KSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyIH07XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiLCBhRmlyc3QsIGJGaXJzdCkge1xuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMTsgICAgICAgICAgIC8vIEFsd2F5cyBsYXN0IHJlZ2FyZGxlc3Mgb2Ygc29ydCBvcmRlclxuICAgIH1cblxuICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJGaXJzdDtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYUZpcnN0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNCb29sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYm9vbGVhbicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfSxcblxuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2UodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUgPyB2YWx1ZSA6IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQgPT09ICd0cnVlJyA/IHRydWUgOiAobm9ybWFsaXplZCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNjaGVtYS4kX3Rlcm1zLnRydXRoeSAmJiBzY2hlbWEuJF90ZXJtcy50cnV0aHkuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKHNjaGVtYS4kX3Rlcm1zLmZhbHN5ICYmIHNjaGVtYS4kX3Rlcm1zLmZhbHN5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2Jvb2xlYW4uYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd0cnV0aHknKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkgPSBvYmouJF90ZXJtcy50cnV0aHkgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCB0cnV0aHkgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnZmFsc3knKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeSA9IG9iai4kX3Rlcm1zLmZhbHN5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgZmFsc3kgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NlbnNpdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy50cnV0aHkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ1dGh5KC4uLmRlc2MudHJ1dGh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZmFsc3kpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouZmFsc3koLi4uZGVzYy5mYWxzeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Jvb2xlYW4uYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBib29sZWFuJ1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2RhdGUnLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnbnVtYmVyJywgJ3N0cmluZyddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGludGVybmFscy5wYXJzZSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5mb3JtYXQpIHx8IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5fZmxhZ3MuZm9ybWF0O1xuXG4gICAgICAgIGlmICghcHJlZnMuY29udmVydCB8fFxuICAgICAgICAgICAgIWZvcm1hdCB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignZGF0ZS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmZvcm1hdCcsIHsgZm9ybWF0IH0pIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRhdGUgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0byA9IGRhdGUgPT09ICdub3cnID8gRGF0ZS5ub3coKSA6IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5nZXRUaW1lKCksIHRvLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdkYXRlLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmRhdGUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemU6IChkYXRlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlID09PSAnbm93JyA/IGRhdGUgOiBpbnRlcm5hbHMucGFyc2UoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKGRhdGUpID0+IGRhdGUgIT09IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGhhdmUgYSB2YWxpZCBkYXRlIGZvcm1hdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydpc28nLCAnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXMoZm9ybWF0KSwgJ1Vua25vd24gZGF0ZSBmb3JtYXQnLCBmb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc286IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCgnaXNvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnamF2YXNjcmlwdCcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKHR5cGUpLCAnXCJ0eXBlXCIgbXVzdCBiZSBvbmUgb2YgXCJqYXZhc2NyaXB0LCB1bml4XCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0RhdGUsXG4gICAgICAgICAgICB0byh2YWx1ZSwgeyBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdkYXRlLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdCc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4ge21zZyhcImRhdGUuZm9ybWF0LlwiICsgI2Zvcm1hdCkgfHwgI2Zvcm1hdH0gZm9ybWF0JyxcbiAgICAgICAgJ2RhdGUuZ3JlYXRlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubGVzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG5cbiAgICAgICAgLy8gTWVzc2FnZXMgdXNlZCBpbiBkYXRlLmZvcm1hdFxuXG4gICAgICAgICdkYXRlLmZvcm1hdC5pc28nOiAnSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdC5qYXZhc2NyaXB0JzogJ3RpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LnVuaXgnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSVNPXG5cbiAgICBpZiAoZm9ybWF0ID09PSAnaXNvJykge1xuICAgICAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgbnVtYmVyIHN0cmluZ1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAvXlsrLV0/XFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGltZXN0YW1wXG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqYXZhc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKDEgKiB2YWx1ZSk7ICAgICAgICAvLyBDYXN0aW5nIHRvIG51bWJlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3VuaXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMTAwMCAqIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBsYWluXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUodmFsdWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIGRlZmF1bHRzIHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydCghc291cmNlIHx8IHNvdXJjZSA9PT0gdHJ1ZSB8fCB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc291cmNlIHZhbHVlOiBtdXN0IGJlIHRydWUsIGZhbHN5IG9yIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICBpZiAoIXNvdXJjZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc291cmNlLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuYXBwbHlUb0RlZmF1bHRzV2l0aFNoYWxsb3coZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29weSA9IENsb25lKGRlZmF1bHRzKTtcblxuICAgIGlmIChzb3VyY2UgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb3VyY2UgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBjb25zdCBudWxsT3ZlcnJpZGUgPSBvcHRpb25zLm51bGxPdmVycmlkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5udWxsT3ZlcnJpZGUgOiBmYWxzZTtcbiAgICByZXR1cm4gTWVyZ2UoY29weSwgc291cmNlLCB7IG51bGxPdmVycmlkZSwgbWVyZ2VBcnJheXM6IGZhbHNlIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuYXBwbHlUb0RlZmF1bHRzV2l0aFNoYWxsb3cgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3Qga2V5cyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShrZXlzKSwgJ0ludmFsaWQga2V5cycpO1xuXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBtZXJnZSA9IHNvdXJjZSA9PT0gdHJ1ZSA/IG51bGwgOiBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICBrZXkgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKTsgICAgICAgICAgICAvLyBQcmUtc3BsaXQgb3B0aW1pemF0aW9uXG5cbiAgICAgICAgY29uc3QgcmVmID0gUmVhY2goZGVmYXVsdHMsIGtleSk7XG4gICAgICAgIGlmIChyZWYgJiZcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIHNlZW4uc2V0KHJlZiwgbWVyZ2UgJiYgUmVhY2goc291cmNlLCBrZXkpIHx8IHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgIG1lcmdlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY29weSA9IENsb25lKGRlZmF1bHRzLCB7fSwgc2Vlbik7XG5cbiAgICBpZiAoIW1lcmdlKSB7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIG1lcmdlKSB7XG4gICAgICAgIGludGVybmFscy5yZWFjaENvcHkoY29weSwgc291cmNlLCBrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBNZXJnZShjb3B5LCBzb3VyY2UsIHsgbnVsbE92ZXJyaWRlLCBtZXJnZUFycmF5czogZmFsc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5yZWFjaENvcHkgPSBmdW5jdGlvbiAoZHN0LCBzcmMsIHBhdGgpIHtcblxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoKSB7XG4gICAgICAgIGlmICghKHNlZ21lbnQgaW4gc3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsID0gc3JjW3NlZ21lbnRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyYyA9IHZhbDtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHNyYztcbiAgICBsZXQgcmVmID0gZHN0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgcmVmW3NlZ21lbnRdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVmW3NlZ21lbnRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZWYgPSByZWZbc2VnbWVudF07XG4gICAgfVxuXG4gICAgcmVmW3BhdGhbcGF0aC5sZW5ndGggLSAxXV0gPSB2YWx1ZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlNvcnRlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBhZGQobm9kZXMsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBydWxlc1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IFtdLmNvbmNhdChvcHRpb25zLmJlZm9yZSB8fCBbXSk7XG4gICAgICAgIGNvbnN0IGFmdGVyID0gW10uY29uY2F0KG9wdGlvbnMuYWZ0ZXIgfHwgW10pO1xuICAgICAgICBjb25zdCBncm91cCA9IG9wdGlvbnMuZ3JvdXAgfHwgJz8nO1xuICAgICAgICBjb25zdCBzb3J0ID0gb3B0aW9ucy5zb3J0IHx8IDA7ICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgZm9yIG1lcmdpbmcgb25seVxuXG4gICAgICAgIEFzc2VydCghYmVmb3JlLmluY2x1ZGVzKGdyb3VwKSwgYEl0ZW0gY2Fubm90IGNvbWUgYmVmb3JlIGl0c2VsZjogJHtncm91cH1gKTtcbiAgICAgICAgQXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYmVmb3JlIHVuYXNzb2NpYXRlZCBpdGVtcycpO1xuICAgICAgICBBc3NlcnQoIWFmdGVyLmluY2x1ZGVzKGdyb3VwKSwgYEl0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgaXRzZWxmOiAke2dyb3VwfWApO1xuICAgICAgICBBc3NlcnQoIWFmdGVyLmluY2x1ZGVzKCc/JyksICdJdGVtIGNhbm5vdCBjb21lIGFmdGVyIHVuYXNzb2NpYXRlZCBpdGVtcycpO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBzZXE6IHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICAgICAgICBhZnRlcixcbiAgICAgICAgICAgICAgICBncm91cCxcbiAgICAgICAgICAgICAgICBub2RlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IGV2ZW50XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLm1hbnVhbCkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zb3J0KCk7XG4gICAgICAgICAgICBBc3NlcnQodmFsaWQsICdpdGVtJywgZ3JvdXAgIT09ICc/JyA/IGBhZGRlZCBpbnRvIGdyb3VwICR7Z3JvdXB9YCA6ICcnLCAnY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuXG4gICAgbWVyZ2Uob3RoZXJzKSB7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG90aGVycykpIHtcbiAgICAgICAgICAgIG90aGVycyA9IFtvdGhlcnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBvdGhlciBvZiBvdGhlcnMpIHtcbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvdGhlci5faXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChPYmplY3QuYXNzaWduKHt9LCBpdGVtKSk7ICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IGl0ZW1zXG5cbiAgICAgICAgdGhpcy5faXRlbXMuc29ydChpbnRlcm5hbHMubWVyZ2VTb3J0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXNbaV0uc2VxID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc29ydCgpO1xuICAgICAgICBBc3NlcnQodmFsaWQsICdtZXJnZSBjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuXG4gICAgc29ydCgpIHtcblxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgQXNzZXJ0KHZhbGlkLCAnc29ydCBjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuXG4gICAgX3NvcnQoKSB7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGdyYXBoXG5cbiAgICAgICAgY29uc3QgZ3JhcGggPSB7fTtcbiAgICAgICAgY29uc3QgZ3JhcGhBZnRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAgICAgICAgICAgIC8vIEEgcHJvdG90eXBlIGNhbiBidW5nbGUgbG9va3VwcyB3LyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcSA9IGl0ZW0uc2VxOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaXF1ZSBhY3Jvc3MgYWxsIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IGl0ZW0uZ3JvdXA7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBHcm91cHNcblxuICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdLnB1c2goc2VxKTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgaW50ZXJtZWRpYXJ5IGdyYXBoIHVzaW5nICdiZWZvcmUnXG5cbiAgICAgICAgICAgIGdyYXBoW3NlcV0gPSBpdGVtLmJlZm9yZTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgc2Vjb25kIGludGVybWVkaWFyeSBncmFwaCB3aXRoICdhZnRlcidcblxuICAgICAgICAgICAgZm9yIChjb25zdCBhZnRlciBvZiBpdGVtLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhBZnRlcnNbYWZ0ZXJdID0gZ3JhcGhBZnRlcnNbYWZ0ZXJdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGdyYXBoQWZ0ZXJzW2FmdGVyXS5wdXNoKHNlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBhbmQgaW50ZXJtZWRpYXJ5IGdyYXBoXG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIGluIGdyYXBoKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZEdyb3VwcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdyYXBoTm9kZUl0ZW0gaW4gZ3JhcGhbbm9kZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGdyYXBoW25vZGVdW2dyYXBoTm9kZUl0ZW1dO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cF0gPSBncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkR3JvdXBzLnB1c2goLi4uZ3JvdXBzW2dyb3VwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyYXBoW25vZGVdID0gZXhwYW5kZWRHcm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNZXJnZSBpbnRlcm1lZGlhcnkgZ3JhcGggdXNpbmcgZ3JhcGhBZnRlcnMgaW50byBmaW5hbCBncmFwaFxuXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgaW4gZ3JhcGhBZnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChncm91cHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGdyb3Vwc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhbbm9kZV0ucHVzaCguLi5ncmFwaEFmdGVyc1tncm91cF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBpbGUgYW5jZXN0b3JzXG5cbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBpbiBncmFwaCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBncmFwaFtub2RlXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnNbY2hpbGRdID0gYW5jZXN0b3JzW2NoaWxkXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnNbY2hpbGRdLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb3BvIHNvcnRcblxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2kpIHsgICAgICAgICAgLy8gTG9vcGluZyB0aHJvdWdoIGl0ZW0uc2VxIHZhbHVlcyBvdXQgb2Ygb3JkZXJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaTtcblxuICAgICAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2opIHsgIC8vIEFzIGFib3ZlLCB0aGVzZSBhcmUgaXRlbS5zZXEgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2pdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5jZXN0b3JzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvcnNbal0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNlZUNvdW50ID0gYW5jZXN0b3JzW2pdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZW5Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hvdWxkU2VlQ291bnQ7ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbYW5jZXN0b3JzW2pdW2tdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrc2VlbkNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Db3VudCA9PT0gc2hvdWxkU2VlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtuZXh0XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc29ydGVkLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc29ydGVkLmxlbmd0aCAhPT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXFJbmRleCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgICAgIHNlcUluZGV4W2l0ZW0uc2VxXSA9IGl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZEl0ZW0gPSBzZXFJbmRleFt2YWx1ZV07XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goc29ydGVkSXRlbS5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goc29ydGVkSXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXJnZVNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgcmV0dXJuIGEuc29ydCA9PT0gYi5zb3J0ID8gMCA6IChhLnNvcnQgPCBiLnNvcnQgPyAtMSA6IDEpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFwcGx5VG9EZWZhdWx0cyA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2FwcGx5VG9EZWZhdWx0cycpO1xuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBUb3BvID0gcmVxdWlyZSgnQGhhcGkvdG9wbycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmVuYW1lRGVmYXVsdHM6IHtcbiAgICAgICAgYWxpYXM6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9sZCB2YWx1ZSBpbiBwbGFjZVxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsICAgICAgICAgICAgICAgIC8vIEFsbG93IHJlbmFtaW5nIG11bHRpcGxlIGtleXMgaW50byB0aGUgc2FtZSB0YXJnZXRcbiAgICAgICAgb3ZlcnJpZGU6IGZhbHNlICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgYW4gZXhpc3Rpbmcga2V5XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ19rZXlzJyxcblxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgICAgICB0eXBlb2Y6ICdvYmplY3QnXG4gICAgfSxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgdW5rbm93bjogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAga2V5czogeyBpbml0OiBudWxsLCBtYW5pZmVzdDogeyBtYXBwZWQ6IHsgZnJvbTogJ3NjaGVtYScsIHRvOiAna2V5JyB9IH0gfSxcbiAgICAgICAgcGF0dGVybnM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICByZW5hbWVzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBhcmdzKHNjaGVtYSwga2V5cykge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEua2V5cyhrZXlzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ29iamVjdC5iYXNlJywgeyB0eXBlOiBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgaWYgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHRlc3RcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoYWxsb3cgY2xvbmUgdmFsdWVcblxuICAgICAgICB2YWx1ZSA9IGludGVybmFscy5jbG9uZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgICAgICAvLyBSZW5hbWUga2V5c1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnJlbmFtZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW55dGhpbmcgYWxsb3dlZFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmVkIGtleXNcblxuICAgICAgICBjb25zdCB1bnByb2Nlc3NlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwga2V5XSwgYW5jZXN0b3JzLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuc2NoZW1hLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5zY2hlbWEuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJyB8fFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmtub3duIGtleXNcblxuICAgICAgICBpZiAodW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAgICAgc2NoZW1hLl9mbGFncy5faGFzUGF0dGVybk1hdGNoKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVhcmx5ID0gaW50ZXJuYWxzLnVua25vd24oc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChlYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXJseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRlcGVuZGVuY2llc1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZGVwLmtleSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKShkZXAua2V5LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBpbnRlcm5hbHMuZGVwZW5kZW5jaWVzW2RlcC5yZWxdKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGZhaWxlZC5jb2RlLCB2YWx1ZSwgZmFpbGVkLmNvbnRleHQsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFuZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNzZXJ0OiB7XG4gICAgICAgICAgICBtZXRob2Qoc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIVRlbXBsYXRlLmlzVGVtcGxhdGUoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdCA9IENvbXBpbGUucmVmKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Fzc2VydCcsIGFyZ3M6IHsgc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBwcmVmcywgc3RhdGUgfSwgeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWJvdXQgPSBzdWJqZWN0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFJlZi5pc1JlZihzdWJqZWN0KSA/IHN1YmplY3QuYWJzb2x1dGUoc3RhdGUpIDogW107XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX21hdGNoKGFib3V0LCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10sIHNjaGVtYSksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdvYmplY3QuYXNzZXJ0JywgeyBzdWJqZWN0LCBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnc3ViamVjdCcsICdzY2hlbWEnLCAnbWVzc2FnZSddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbnN0cnVjdG9yLCBuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nLCAnY29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2luc3RhbmNlJywgYXJnczogeyBjb25zdHJ1Y3RvciwgbmFtZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvbnN0cnVjdG9yLCBuYW1lIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0Lmluc3RhbmNlJywgeyB0eXBlOiBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbnN0cnVjdG9yJywgJ25hbWUnXVxuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdPYmplY3Qgc2NoZW1hIGNhbm5vdCBiZSBhIGpvaSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2NoZW1hKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbGxcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCkgeyAgICAgICAgICAgICAvLyBBbGxvdyBub25lXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBvYmouJF90ZXJtcy5rZXlzID8gb2JqLiRfdGVybXMua2V5cy5maWx0ZXIoKGNoaWxkKSA9PiAhc2NoZW1hLmhhc093blByb3BlcnR5KGNoaWxkLmtleSkpIDogbmV3IGludGVybmFscy5LZXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IG9iai4kX3Rlcm1zLmtleXMucHVzaCh7IGtleSwgc2NoZW1hOiB0aGlzLiRfY29tcGlsZShzY2hlbWFba2V5XSkgfSksIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICduYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ25hbmQnLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ29yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG94b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ294b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy4kX2NvbXBpbGUocGF0dGVybiwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnZmFsbHRocm91Z2gnLCAnbWF0Y2hlcyddKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcGF0dGVybi5mbGFncy5pbmNsdWRlcygneScpLCAncGF0dGVybiBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucyA9IG9iai4kX3Rlcm1zLnBhdHRlcm5zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgW2lzUmVnRXhwID8gJ3JlZ2V4JyA6ICdzY2hlbWEnXTogcGF0dGVybiwgcnVsZTogc2NoZW1hIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IHRoaXMuJF9jb21waWxlKG9wdGlvbnMubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF0Y2hlcy50eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IGNvbmZpZy5tYXRjaGVzLiRfcm9vdC5hcnJheSgpLml0ZW1zKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2hhc1BhdHRlcm5NYXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5mYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMucHVzaChjb25maWcpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVmJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZlR5cGUnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3JlZ2V4Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5yZWdleCcsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0byBpbnN0YW5jZW9mIFRlbXBsYXRlLCAnSW52YWxpZCByZW5hbWUgdG8gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodG8gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIGtleSB0byBzYW1lIG5hbWU6JywgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsaWFzJywgJ2lnbm9yZVVuZGVmaW5lZCcsICdvdmVycmlkZScsICdtdWx0aXBsZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMgPSBvYmouJF90ZXJtcy5yZW5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIG9iai4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlbmFtZS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0byk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnYW55Jykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NjaGVtYScsIGFyZ3M6IHsgdHlwZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHR5cGUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09ICdhbnknIHx8IHZhbHVlLnR5cGUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3Quc2NoZW1hJywgeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVua25vd246IHtcbiAgICAgICAgICAgIG1ldGhvZChhbGxvdykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bmtub3duJywgYWxsb3cgIT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGgnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRob3V0OiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGhvdXQnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB4b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ3hvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfcGFyZW50KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcG8gPSBuZXcgVG9wby5Tb3J0ZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuc2NoZW1hLiRfcm9vdFJlZmVyZW5jZXMoKSwgZ3JvdXA6IGNoaWxkLmtleSB9KSwgY2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cyguLi50b3BvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmtleXMoZGVzYy5rZXlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlbCwga2V5ID0gbnVsbCwgcGVlcnMsIG9wdGlvbnMgfSBvZiBkZXNjLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnRlcm5hbHMuZGVwZW5kZW5jeShvYmosIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWdleCwgc2NoZW1hLCBydWxlLCBmYWxsdGhyb3VnaCwgbWF0Y2hlcyB9IG9mIGRlc2MucGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnBhdHRlcm4ocmVnZXggfHwgc2NoZW1hLCBydWxlLCB7IGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBmcm9tLCB0bywgb3B0aW9ucyB9IG9mIGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVuYW1lKGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ29iamVjdC5hbmQnOiAne3sjbGFiZWx9fSBjb250YWlucyB7eyNwcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7I21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LmFzc2VydCc6ICd7eyNsYWJlbH19IGlzIGludmFsaWQgYmVjYXVzZSB7aWYoI3N1YmplY3Qua2V5LCBgXCJgICsgI3N1YmplY3Qua2V5ICsgYFwiIGZhaWxlZCB0byBgICsgKCNtZXNzYWdlIHx8IFwicGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3RcIiksICNtZXNzYWdlIHx8IFwidGhlIGFzc2VydGlvbiBmYWlsZWRcIil9JyxcbiAgICAgICAgJ29iamVjdC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvZiB0eXBlIHt7I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QuaW5zdGFuY2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHt7OiN0eXBlfX0nLFxuICAgICAgICAnb2JqZWN0Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGF0IGxlYXN0IHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taXNzaW5nJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QubmFuZCc6ICd7ezojbWFpbldpdGhMYWJlbH19IG11c3Qgbm90IGV4aXN0IHNpbXVsdGFuZW91c2x5IHdpdGgge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm94b3InOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gb3B0aW9uYWwgZXhjbHVzaXZlIHBlZXJzIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5wYXR0ZXJuLm1hdGNoJzogJ3t7I2xhYmVsfX0ga2V5cyBmYWlsZWQgdG8gbWF0Y2ggcGF0dGVybiByZXF1aXJlbWVudHMnLFxuICAgICAgICAnb2JqZWN0LnJlZlR5cGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHJlZmVyZW5jZScsXG4gICAgICAgICdvYmplY3QucmVnZXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgUmVnRXhwIG9iamVjdCcsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8ge3s6I3RvfX0nLFxuICAgICAgICAnb2JqZWN0LnJlbmFtZS5vdmVycmlkZSc6ICd7eyNsYWJlbH19IGNhbm5vdCByZW5hbWUge3s6I2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQge3s6I3RvfX0gZXhpc3RzJyxcbiAgICAgICAgJ29iamVjdC5zY2hlbWEnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHNjaGVtYSBvZiB7eyN0eXBlfX0gdHlwZScsXG4gICAgICAgICdvYmplY3QudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgJ29iamVjdC53aXRoJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbWlzc2luZyByZXF1aXJlZCBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0LndpdGhvdXQnOiAne3s6I21haW5XaXRoTGFiZWx9fSBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0Lnhvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzKSB7XG5cbiAgICAvLyBPYmplY3RcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwcmVmcy5ub25FbnVtZXJhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKHZhbHVlLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2xvbmUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uXG5cbiAgICBjb25zdCBjbG9uZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbG9uZS5wcm90b3R5cGUgPSBDbG9uZSh2YWx1ZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB2YWx1ZS5uYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbGVuZ3RoJywgeyB2YWx1ZTogdmFsdWUubGVuZ3RoLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2NoZW1hLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycsIHJlbCwgJ2tleSBtdXN0IGJlIGEgc3RyaW5ncycpO1xuXG4gICAgLy8gRXh0cmFjdCBvcHRpb25zIGZyb20gcGVlcnMgYXJyYXlcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGVlcnMubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGVlcnNbcGVlcnMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gcGVlcnMucG9wKCkgOiB7fTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3NlcGFyYXRvcicsICdpc1ByZXNlbnQnXSk7XG5cbiAgICBwZWVycyA9IFtdLmNvbmNhdChwZWVycyk7XG5cbiAgICAvLyBDYXN0IHBlZXIgcGF0aHNcblxuICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzKSB7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycsIHJlbCwgJ3BlZXJzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICBwYXRocy5wdXNoKENvbXBpbGUucmVmKHBlZXIsIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KSk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdCBrZXlcblxuICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAga2V5ID0gQ29tcGlsZS5yZWYoa2V5LCB7IHNlcGFyYXRvciwgYW5jZXN0b3I6IDAsIHByZWZpeDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJ1bGVcblxuICAgIGNvbnN0IG9iaiA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyA9IG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyB8fCBbXTtcbiAgICBvYmouJF90ZXJtcy5kZXBlbmRlbmNpZXMucHVzaChuZXcgaW50ZXJuYWxzLkRlcGVuZGVuY3kocmVsLCBrZXksIHBhdGhzLCBwZWVycywgb3B0aW9ucykpO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5kZXBlbmRlbmNpZXMgPSB7XG5cbiAgICBhbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBkZXAucGVlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCAhPT0gY291bnQgJiZcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoICE9PSBjb3VudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3QuYW5kJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCksXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgbWlzc2luZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCAhPT0gZGVwLnBlZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFpbiA9IGRlcC5wYXRoc1swXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZGVwLnBhdGhzLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5uYW5kJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBtYWluLFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtYWluKSxcbiAgICAgICAgICAgICAgICBwZWVyczogdmFsdWVzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHZhbHVlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm1pc3NpbmcnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIHBlZXJzOiBkZXAucGF0aHMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBveG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBwZWVyczogZGVwLnBhdGhzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpIH07XG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3Qub3hvcicsIGNvbnRleHQgfTtcbiAgICB9LFxuXG4gICAgd2l0aChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3Qud2l0aCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGRlcC5rZXkua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5rZXkua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXI6IHBlZXIua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHBlZXIua2V5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3aXRob3V0KHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGhvdXQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgeG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0Lm1pc3NpbmcnLCBjb250ZXh0IH07XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByZXNlbnQgPSBwcmVzZW50O1xuICAgICAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHByZXNlbnQpO1xuICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0LnhvcicsIGNvbnRleHQgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5rZXlzVG9MYWJlbHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBrZXlzKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gc2NoZW1hLiRfbWFwTGFiZWxzKGtleSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5cyk7XG59O1xuXG5cbmludGVybmFscy5pc1ByZXNlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLmlzUHJlc2VudCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuaXNQcmVzZW50IDogKHJlc29sdmVkKSA9PiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkO1xufTtcblxuXG5pbnRlcm5hbHMucmVuYW1lID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcywgZXJyb3JzKSB7XG5cbiAgICBjb25zdCByZW5hbWVkID0ge307XG4gICAgZm9yIChjb25zdCByZW5hbWUgb2Ygc2NoZW1hLiRfdGVybXMucmVuYW1lcykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0eXBlb2YgcmVuYW1lLmZyb20gIT09ICdzdHJpbmcnO1xuXG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVuYW1lLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlW3JlbmFtZS5mcm9tXSAhPT0gdW5kZWZpbmVkIHx8ICFyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gocmVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJvbSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtmcm9tXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSByZW5hbWUudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZW5hbWUuZnJvbS5leGVjKGZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHsgZnJvbSwgdG86IHJlbmFtZS50bywgbWF0Y2ggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBtYXRjaC5mcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gbWF0Y2gudG87XG4gICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHRvID0gdG8ucmVuZGVyKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG1hdGNoLm1hdGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICByZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUubXVsdGlwbGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCB0bykgJiZcbiAgICAgICAgICAgICAgICAhcmVuYW1lLm9wdGlvbnMub3ZlcnJpZGUgJiZcbiAgICAgICAgICAgICAgICAhcmVuYW1lZFt0b10pIHtcblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm92ZXJyaWRlJywgdmFsdWUsIHsgZnJvbSwgdG8sIHBhdHRlcm4gfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbdG9dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbdG9dID0gdmFsdWVbZnJvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmFtZWRbdG9dID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMudW5rbm93biA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucykge1xuICAgICAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnMubWFwKChwYXR0ZXJuKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMucGF0dGVybnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLnJlZ2V4LnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsIGBwYXR0ZXJuLiR7aX1gLCBtYXRjaCA/ICdwYXNzJyA6ICdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLnNjaGVtYS4kX21hdGNoKGtleSwgc3RhdGUubmVzdChwYXR0ZXJuLnNjaGVtYSwgYHBhdHRlcm4uJHtpfWApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCB7IHNjaGVtYTogcGF0dGVybi5ydWxlLCBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGF0dGVybi5ydWxlLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXN1bHQuZXJyb3JzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbaV0ucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHBhdHRlcm4gbWF0Y2hlcyBydWxlc1xuXG4gICAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHBtID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnNbaV0ubWF0Y2hlcztcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoc3RhdGUucGF0aCwgYW5jZXN0b3JzLCBzdHBtKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdHBtLiRfdmFsaWRhdGUobWF0Y2gsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gRXJyb3JzLmRldGFpbHMocmVzdWx0LmVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnBhdHRlcm4ubWF0Y2gnLCB2YWx1ZSwgZGV0YWlscywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVucHJvY2Vzc2VkLnNpemUgfHxcbiAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7ICAgICAvLyBJZiBubyBrZXlzIG9yIHBhdHRlcm5zIHNwZWNpZmllZCwgdW5rbm93biBrZXlzIGFsbG93ZWRcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLnN0cmlwVW5rbm93biAmJiAhc2NoZW1hLl9mbGFncy51bmtub3duIHx8XG4gICAgICAgIHByZWZzLnNraXBGdW5jdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gPyAocHJlZnMuc3RyaXBVbmtub3duID09PSB0cnVlID8gdHJ1ZSA6ICEhcHJlZnMuc3RyaXBVbmtub3duLm9iamVjdHMpIDogZmFsc2U7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb3JiaWRVbmtub3duID0gIUNvbW1vbi5kZWZhdWx0KHNjaGVtYS5fZmxhZ3MudW5rbm93biwgcHJlZnMuYWxsb3dVbmtub3duKTtcbiAgICBpZiAoZm9yYmlkVW5rbm93bikge1xuICAgICAgICBmb3IgKGNvbnN0IHVucHJvY2Vzc2VkS2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIHVucHJvY2Vzc2VkS2V5XSwgW10pO1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC51bmtub3duJywgdmFsdWVbdW5wcm9jZXNzZWRLZXldLCB7IGNoaWxkOiB1bnByb2Nlc3NlZEtleSB9LCBsb2NhbFN0YXRlLCBwcmVmcywgeyBmbGFnczogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuRGVwZW5kZW5jeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlbCwga2V5LCBwZWVycywgcGF0aHMsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnJlbCA9IHJlbDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGVlcnMgPSBwZWVycztcbiAgICAgICAgdGhpcy5wYXRocyA9IHBhdGhzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgICAgICByZWw6IHRoaXMucmVsLFxuICAgICAgICAgICAgcGVlcnM6IHRoaXMucGF0aHNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlc2Mua2V5ID0gdGhpcy5rZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGVlcnNbMF0uc2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHsgLi4uZGVzYy5vcHRpb25zLCBzZXBhcmF0b3I6IHRoaXMucGVlcnNbMF0uc2VwYXJhdG9yIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzUHJlc2VudCkge1xuICAgICAgICAgICAgZGVzYy5vcHRpb25zID0geyAuLi5kZXNjLm9wdGlvbnMsIGlzUHJlc2VudDogdGhpcy5vcHRpb25zLmlzUHJlc2VudCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuS2V5cyA9IGNsYXNzIGV4dGVuZHMgQXJyYXkge1xuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2xpY2UoKTtcblxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAga2V5cy5zZXQocmVzdWx0W2ldLmtleSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGtleXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcG9zXSA9IHsga2V5LCBzY2hlbWE6IHJlc3VsdFtwb3NdLnNjaGVtYS5jb25jYXQoaXRlbS5zY2hlbWEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlb2Y6ICdmdW5jdGlvbidcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgYXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2FyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24uYXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY2xhc3MnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCgvXlxccypjbGFzc1xccy8pLnRlc3QodmFsdWUudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5jbGFzcycsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluQXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+IDAsICduIG11c3QgYmUgYSBzdHJpY3QgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbkFyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5taW5Bcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhBcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4QXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1heEFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdmdW5jdGlvbi5hcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBvZiB7eyNufX0nLFxuICAgICAgICAnZnVuY3Rpb24uY2xhc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgY2xhc3MnLFxuICAgICAgICAnZnVuY3Rpb24ubWF4QXJpdHknOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYW4gYXJpdHkgbGVzc2VyIG9yIGVxdWFsIHRvIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5taW5Bcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBncmVhdGVyIG9yIGVxdWFsIHRvIHt7I259fSdcbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdsaW5rJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2NoZW1hQ2hhaW46IHRydWVcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBsaW5rOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiAnc2luZ2xlJywgcmVnaXN0ZXI6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIHJlZikge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEucmVmKHJlZik7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBsaW5rZWQgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgICAgIHJldHVybiBsaW5rZWQuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChsaW5rZWQsIGBsaW5rOiR7cmVmLmRpc3BsYXl9OiR7bGlua2VkLnR5cGV9YCksIHByZWZzKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKHJlZikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLiRfdGVybXMubGluaywgJ0Nhbm5vdCByZWluaXRpYWxpemUgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICByZWYgPSBDb21waWxlLnJlZihyZWYpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAndmFsdWUnIHx8IHJlZi50eXBlID09PSAnbG9jYWwnLCAnSW52YWxpZCByZWZlcmVuY2UgdHlwZTonLCByZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAnbG9jYWwnIHx8IHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnIHx8IHJlZi5hbmNlc3RvciA+IDAsICdMaW5rIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubGluayA9IFt7IHJlZiB9XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVsYXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCh0aGlzLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHNvdXJjZS50eXBlICE9PSAnbGluaycsICdDYW5ub3QgbWVyZ2UgdHlwZSBsaW5rIHdpdGggYW5vdGhlciBsaW5rJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2goeyBjb25jYXQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KGRlc2MubGluaywgJ0ludmFsaWQgbGluayBkZXNjcmlwdGlvbiBtaXNzaW5nIGxpbmsnKTtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVmKGRlc2MubGluayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGxldCBsaW5rZWQgPSBzdGF0ZS5tYWluc3RheS5saW5rcy5nZXQoc2NoZW1hKTtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICBjb25zdCB7IHBlcnNwZWN0aXZlLCBwYXRoIH0gPSBpbnRlcm5hbHMucGVyc3BlY3RpdmUocmVmLCBzdGF0ZSk7XG4gICAgaW50ZXJuYWxzLmFzc2VydChwZXJzcGVjdGl2ZSwgJ3doaWNoIGlzIG91dHNpZGUgb2Ygc2NoZW1hIGJvdW5kYXJpZXMnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxpbmtlZCA9IHBhdGgubGVuZ3RoID8gcGVyc3BlY3RpdmUuJF9yZWFjaChwYXRoKSA6IHBlcnNwZWN0aXZlO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlRXJyKSB7XG4gICAgICAgIGludGVybmFscy5hc3NlcnQoZmFsc2UsICd0byBub24tZXhpc3Rpbmcgc2NoZW1hJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLmFzc2VydChsaW5rZWQudHlwZSAhPT0gJ2xpbmsnLCAnd2hpY2ggaXMgYW5vdGhlciBsaW5rJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICBpZiAoIXNjaGVtYS5fZmxhZ3MucmVsYXRpdmUpIHtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkubGlua3Muc2V0KHNjaGVtYSwgbGlua2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChyZWYsIHN0YXRlKSB7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHNjaGVtYSwga2V5IH0gb2Ygc3RhdGUuc2NoZW1hcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gcGFyZW50IHRvIHJvb3RcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZCB8fCBrZXk7XG4gICAgICAgICAgICBpZiAoaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNjaGVtYSwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcmVkIG9mIHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLl9mbGFncy5pZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzaGFyZWQsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogbnVsbCwgcGF0aDogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChyZWYuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tzdGF0ZS5zY2hlbWFzLmxlbmd0aCAtIDFdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdICYmIHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG59O1xuXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7ICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBjaGVjayB0byBhdm9pZCBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXNzZXJ0KGZhbHNlLCBgXCIke0Vycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpfVwiIGNvbnRhaW5zIGxpbmsgcmVmZXJlbmNlIFwiJHtyZWYuZGlzcGxheX1cIiAke21lc3NhZ2V9YCk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbnVtYmVyUng6IC9eXFxzKlsrLV0/KD86KD86XFxkKyg/OlxcLlxcZCopPyl8KD86XFwuXFxkKykpKD86ZShbKy1dP1xcZCspKT9cXHMqJC9pLFxuICAgIHByZWNpc2lvblJ4OiAvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvLFxuICAgIGV4cG9uZW50aWFsUGFydFJlZ2V4OiAvW2VFXVsrLV0/XFxkKyQvLFxuICAgIGxlYWRpbmdTaWduQW5kWmVyb3NSZWdleDogL15bKy1dPygwKik/LyxcbiAgICBkb3RSZWdleDogL1xcLi8sXG4gICAgdHJhaWxpbmdaZXJvc1JlZ2V4OiAvMCskLyxcbiAgICBkZWNpbWFsUGxhY2VzKHZhbHVlKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgY29uc3QgZWluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChkaW5kZXggPCAwID8gMCA6IChlaW5kZXggPCAwID8gc3RyLmxlbmd0aCA6IGVpbmRleCkgLSBkaW5kZXggLSAxKSArXG4gICAgICAgICAgICAoZWluZGV4IDwgMCA/IDAgOiBNYXRoLm1heCgwLCAtcGFyc2VJbnQoc3RyLnNsaWNlKGVpbmRleCArIDEpKSkpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ251bWJlcicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVuc2FmZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSB9O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpICE9PSBpbnRlcm5hbHMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKFN0cmluZyhyZXN1bHQudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSByZXN1bHQudmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IGludGVybmFscy5ub3JtYWxpemVEZWNpbWFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuaW5maW5pdHknKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFDb21tb24uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSB9O1xuXG4gICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBydWxlLmFyZ3MubGltaXQpOyAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBjb25jZXB0dWFsbHkgZXF1aXZhbGVudCB0byB1c2luZyB0b0ZpeGVkIGJ1dCBpdCBzaG91bGQgYmUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJlc3VsdC52YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHZhbHVlIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24uaXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBncmVhdGVyOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2ludGVnZXInKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmModmFsdWUpIC0gdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtdWx0aXBsZToge1xuICAgICAgICAgICAgbWV0aG9kKGJhc2UpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEZWNpbWFsUGxhY2UgPSB0eXBlb2YgYmFzZSA9PT0gJ251bWJlcicgPyBpbnRlcm5hbHMuZGVjaW1hbFBsYWNlcyhiYXNlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgcGZhY3RvciA9IE1hdGgucG93KDEwLCBiYXNlRGVjaW1hbFBsYWNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlRGVjaW1hbFBsYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGZhY3RvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgYmFzZSwgYmFzZURlY2ltYWxQbGFjZSwgcGZhY3RvciB9LCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURlY2ltYWxQbGFjZSA9IGludGVybmFscy5kZWNpbWFsUGxhY2VzKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZURlY2ltYWxQbGFjZSA+IGJhc2VEZWNpbWFsUGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWUgd2l0aCBoaWdoZXIgcHJlY2lzaW9uIHRoYW4gYmFzZSBjYW4gbmV2ZXIgYmUgYSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBmYWN0b3IgKiB2YWx1ZSkgJSBNYXRoLnJvdW5kKHBmYWN0b3IgKiBiYXNlKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdiYXNlRGVjaW1hbFBsYWNlJyxcbiAgICAgICAgICAgICAgICAncGZhY3RvcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCduZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncG9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPD0gNjU1MzUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wb3J0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ3Bvc2l0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlY2lzaW9uOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwcmVjaXNpb24nLCBhcmdzOiB7IGxpbWl0IH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIG1ldGhvZChzaWduKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWyduZWdhdGl2ZScsICdwb3NpdGl2ZSddLmluY2x1ZGVzKHNpZ24pLCAnSW52YWxpZCBzaWduJywgc2lnbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2lnbicsIGFyZ3M6IHsgc2lnbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHNpZ24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPT09ICduZWdhdGl2ZScgJiYgdmFsdWUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPT09ICdwb3NpdGl2ZScgJiYgdmFsdWUgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBudW1iZXIuJHtzaWdufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5zYWZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnbnVtYmVyLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIuaW5maW5pdHknOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgaW5maW5pdHknLFxuICAgICAgICAnbnVtYmVyLmludGVnZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgICAnbnVtYmVyLmxlc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tdWx0aXBsZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB7eyNtdWx0aXBsZX19JyxcbiAgICAgICAgJ251bWJlci5uZWdhdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnBvcnQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgcG9ydCcsXG4gICAgICAgICdudW1iZXIucG9zaXRpdmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5wcmVjaXNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7I2xpbWl0fX0gZGVjaW1hbCBwbGFjZXMnLFxuICAgICAgICAnbnVtYmVyLnVuc2FmZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzYWZlIG51bWJlcidcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZXhwb25lbnRpYWxQYXJ0UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZG90UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMudHJhaWxpbmdaZXJvc1JlZ2V4LCAnJylcbiAgICAgICAgLnJlcGxhY2UoaW50ZXJuYWxzLmxlYWRpbmdTaWduQW5kWmVyb3NSZWdleCwgJycpO1xufTtcblxuXG5pbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHN0ciA9IHN0clxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBwbHVzIHNpZ25zXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBpZiB0aGVyZSBpcyBhIGRlY2ltYWwgcG9pbnQgYW5kIHVuZWNlc3NhcnkgZGVjaW1hbCBwb2ludHNcbiAgICAgICAgLnJlcGxhY2UoL1xcLjAqJC8sICcnKVxuICAgICAgICAvLyBBZGQgYSBpbnRlZ2VyIDAgaWYgdGhlIG51bWJlcnMgc3RhcnRzIHdpdGggYSBkZWNpbWFsIHBvaW50XG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KVxcLihbXlxcLl0qKSQvLCAnJDEwLiQyJylcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzAtOV0pLywgJyQxJDInKTtcblxuICAgIGlmIChzdHIuaW5jbHVkZXMoJy4nKSAmJlxuICAgICAgICBzdHIuZW5kc1dpdGgoJzAnKSkge1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ciA9PT0gJy0wJykge1xuICAgICAgICByZXR1cm4gJzAnO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cy5leHRlbmQoe1xuXG4gICAgdHlwZTogJ29iamVjdCcsXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuY29kZXMgPSB7XG4gICAgRU1QVFlfU1RSSU5HOiAnQWRkcmVzcyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycsXG4gICAgRk9SQklEREVOX1VOSUNPREU6ICdBZGRyZXNzIGNvbnRhaW5zIGZvcmJpZGRlbiBVbmljb2RlIGNoYXJhY3RlcnMnLFxuICAgIE1VTFRJUExFX0FUX0NIQVI6ICdBZGRyZXNzIGNhbm5vdCBjb250YWluIG1vcmUgdGhhbiBvbmUgQCBjaGFyYWN0ZXInLFxuICAgIE1JU1NJTkdfQVRfQ0hBUjogJ0FkZHJlc3MgbXVzdCBjb250YWluIG9uZSBAIGNoYXJhY3RlcicsXG4gICAgRU1QVFlfTE9DQUw6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY2Fubm90IGJlIGVtcHR5JyxcbiAgICBBRERSRVNTX1RPT19MT05HOiAnQWRkcmVzcyB0b28gbG9uZycsXG4gICAgTE9DQUxfVE9PX0xPTkc6ICdBZGRyZXNzIGxvY2FsIHBhcnQgdG9vIGxvbmcnLFxuICAgIEVNUFRZX0xPQ0FMX1NFR01FTlQ6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgZW1wdHkgZG90LXNlcGFyYXRlZCBzZWdtZW50JyxcbiAgICBJTlZBTElEX0xPQ0FMX0NIQVJTOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyxcbiAgICBET01BSU5fTk9OX0VNUFRZX1NUUklORzogJ0RvbWFpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycsXG4gICAgRE9NQUlOX1RPT19MT05HOiAnRG9tYWluIHRvbyBsb25nJyxcbiAgICBET01BSU5fSU5WQUxJRF9VTklDT0RFX0NIQVJTOiAnRG9tYWluIGNvbnRhaW5zIGZvcmJpZGRlbiBVbmljb2RlIGNoYXJhY3RlcnMnLFxuICAgIERPTUFJTl9JTlZBTElEX0NIQVJTOiAnRG9tYWluIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyxcbiAgICBET01BSU5fSU5WQUxJRF9UTERTX0NIQVJTOiAnRG9tYWluIGNvbnRhaW5zIGludmFsaWQgdGxkIGNoYXJhY3RlcicsXG4gICAgRE9NQUlOX1NFR01FTlRTX0NPVU5UOiAnRG9tYWluIGxhY2tzIHRoZSBtaW5pbXVtIHJlcXVpcmVkIG51bWJlciBvZiBzZWdtZW50cycsXG4gICAgRE9NQUlOX1NFR01FTlRTX0NPVU5UX01BWDogJ0RvbWFpbiBjb250YWlucyB0b28gbWFueSBzZWdtZW50cycsXG4gICAgRE9NQUlOX0ZPUkJJRERFTl9UTERTOiAnRG9tYWluIHVzZXMgZm9yYmlkZGVuIFRMRCcsXG4gICAgRE9NQUlOX0VNUFRZX1NFR01FTlQ6ICdEb21haW4gY29udGFpbnMgZW1wdHkgZG90LXNlcGFyYXRlZCBzZWdtZW50JyxcbiAgICBET01BSU5fTE9OR19TRUdNRU5UOiAnRG9tYWluIGNvbnRhaW5zIGRvdC1zZXBhcmF0ZWQgc2VnbWVudCB0aGF0IGlzIHRvbyBsb25nJ1xufTtcblxuXG5leHBvcnRzLmNvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuXG4gICAgcmV0dXJuIHsgY29kZSwgZXJyb3I6IGV4cG9ydHMuY29kZXNbY29kZV0gfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWluRG9tYWluU2VnbWVudHM6IDIsXG4gICAgbm9uQXNjaWlSeDogL1teXFx4MDAtXFx4N2ZdLyxcbiAgICBkb21haW5Db250cm9sUng6IC9bXFx4MDAtXFx4MjBAXFw6XFwvXFxcXCMhXFwkJlxcJ1xcKFxcKVxcKlxcKyw7PVxcP10vLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJvbCArIHNwYWNlICsgc2VwYXJhdG9yc1xuICAgIHRsZFNlZ21lbnRSeDogL15bYS16QS1aXSg/OlthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKT8kLyxcbiAgICBkb21haW5TZWdtZW50Ung6IC9eW2EtekEtWjAtOV0oPzpbYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSk/JC8sXG4gICAgVVJMOiBVcmwuVVJMIHx8IFVSTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuXG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIChkb21haW4sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCFkb21haW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggbnVsbCAvIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9OT05fRU1QVFlfU1RSSU5HJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkb21haW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dDogZG9tYWluIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoZG9tYWluLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9UT09fTE9ORycpO1xuICAgIH1cblxuICAgIGNvbnN0IGFzY2lpID0gIWludGVybmFscy5ub25Bc2NpaVJ4LnRlc3QoZG9tYWluKTtcbiAgICBpZiAoIWFzY2lpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93VW5pY29kZSA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fSU5WQUxJRF9VTklDT0RFX0NIQVJTJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb21haW4gPSBkb21haW4ubm9ybWFsaXplKCdORkMnKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxzLmRvbWFpbkNvbnRyb2xSeC50ZXN0KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fSU5WQUxJRF9DSEFSUycpO1xuICAgIH1cblxuICAgIGRvbWFpbiA9IGludGVybmFscy5wdW55Y29kZShkb21haW4pO1xuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzUgc2VjdGlvbiAyLjMuMVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dGdWxseVF1YWxpZmllZCAmJlxuICAgICAgICBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdID09PSAnLicpIHtcblxuICAgICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbkRvbWFpblNlZ21lbnRzID0gb3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyB8fCBpbnRlcm5hbHMubWluRG9tYWluU2VnbWVudHM7XG5cbiAgICBjb25zdCBzZWdtZW50cyA9IGRvbWFpbi5zcGxpdCgnLicpO1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPCBtaW5Eb21haW5TZWdtZW50cykge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9TRUdNRU5UU19DT1VOVCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1heERvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiBvcHRpb25zLm1heERvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9TRUdNRU5UU19DT1VOVF9NQVgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRsZHMgPSBvcHRpb25zLnRsZHM7XG4gICAgaWYgKHRsZHMpIHtcbiAgICAgICAgY29uc3QgdGxkID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRsZHMuZGVueSAmJiB0bGRzLmRlbnkuaGFzKHRsZCkgfHxcbiAgICAgICAgICAgIHRsZHMuYWxsb3cgJiYgIXRsZHMuYWxsb3cuaGFzKHRsZCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fRk9SQklEREVOX1RMRFMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0VNUFRZX1NFR01FTlQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9MT05HX1NFR01FTlQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgc2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuZG9tYWluU2VnbWVudFJ4LnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy50bGRTZWdtZW50UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0lOVkFMSURfVExEU19DSEFSUycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIChkb21haW4sIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiAhZXhwb3J0cy5hbmFseXplKGRvbWFpbiwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5wdW55Y29kZSA9IGZ1bmN0aW9uIChkb21haW4pIHtcblxuICAgIGlmIChkb21haW4uaW5jbHVkZXMoJyUnKSkge1xuICAgICAgICBkb21haW4gPSBkb21haW4ucmVwbGFjZSgvJS9nLCAnJTI1Jyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuVVJMKGBodHRwOi8vJHtkb21haW59YCkuaG9zdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBEb21haW4gPSByZXF1aXJlKCcuL2RvbWFpbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbm9uQXNjaWlSeDogL1teXFx4MDAtXFx4N2ZdLyxcbiAgICBlbmNvZGVyOiBuZXcgKFV0aWwuVGV4dEVuY29kZXIgfHwgVGV4dEVuY29kZXIpKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxufTtcblxuXG5leHBvcnRzLmFuYWx5emUgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmlzVmFsaWQgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiAhaW50ZXJuYWxzLmVtYWlsKGVtYWlsLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmVtYWlsID0gZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dDogZW1haWwgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghZW1haWwpIHtcbiAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdFTVBUWV9TVFJJTkcnKTtcbiAgICB9XG5cbiAgICAvLyBVbmljb2RlXG5cbiAgICBjb25zdCBhc2NpaSA9ICFpbnRlcm5hbHMubm9uQXNjaWlSeC50ZXN0KGVtYWlsKTtcbiAgICBpZiAoIWFzY2lpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93VW5pY29kZSA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0ZPUkJJRERFTl9VTklDT0RFJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWFpbCA9IGVtYWlsLm5vcm1hbGl6ZSgnTkZDJyk7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgc3RydWN0dXJlXG5cbiAgICBjb25zdCBwYXJ0cyA9IGVtYWlsLnNwbGl0KCdAJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMiA/IEVycm9ycy5jb2RlKCdNVUxUSVBMRV9BVF9DSEFSJykgOiBFcnJvcnMuY29kZSgnTUlTU0lOR19BVF9DSEFSJyk7XG4gICAgfVxuXG4gICAgY29uc3QgW2xvY2FsLCBkb21haW5dID0gcGFydHM7XG5cbiAgICBpZiAoIWxvY2FsKSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRU1QVFlfTE9DQUwnKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChlbWFpbC5sZW5ndGggPiAyNTQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuM1xuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdBRERSRVNTX1RPT19MT05HJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmVuY29kZXIuZW5jb2RlKGxvY2FsKS5sZW5ndGggPiA2NCkgeyAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjUuMy4xLjFcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnTE9DQUxfVE9PX0xPTkcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHBhcnRzXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmxvY2FsKGxvY2FsLCBhc2NpaSkgfHwgRG9tYWluLmFuYWx5emUoZG9tYWluLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmxvY2FsID0gZnVuY3Rpb24gKGxvY2FsLCBhc2NpaSkge1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSBsb2NhbC5zcGxpdCgnLicpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoIXNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0VNUFRZX0xPQ0FMX1NFR01FTlQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc2NpaSkge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuYXRleHRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdJTlZBTElEX0xPQ0FMX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBjaGFyIG9mIHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuYXRleHRSeC50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IGludGVybmFscy5iaW5hcnkoY2hhcik7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5hdG9tUngudGVzdChiaW5hcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdJTlZBTElEX0xPQ0FMX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5iaW5hcnkgPSBmdW5jdGlvbiAoY2hhcikge1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oaW50ZXJuYWxzLmVuY29kZXIuZW5jb2RlKGNoYXIpKS5tYXAoKHYpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUodikpLmpvaW4oJycpO1xufTtcblxuXG4vKlxuICAgIEZyb20gUkZDIDUzMjE6XG5cbiAgICAgICAgTWFpbGJveCAgICAgICAgID0gICBMb2NhbC1wYXJ0IFwiQFwiICggRG9tYWluIC8gYWRkcmVzcy1saXRlcmFsIClcblxuICAgICAgICBMb2NhbC1wYXJ0ICAgICAgPSAgIERvdC1zdHJpbmcgLyBRdW90ZWQtc3RyaW5nXG4gICAgICAgIERvdC1zdHJpbmcgICAgICA9ICAgQXRvbSAqKFwiLlwiICBBdG9tKVxuICAgICAgICBBdG9tICAgICAgICAgICAgPSAgIDEqYXRleHRcbiAgICAgICAgYXRleHQgICAgICAgICAgID0gICBBTFBIQSAvIERJR0lUIC8gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCIgLyBcIitcIiAvIFwiLVwiIC8gXCIvXCIgLyBcIj1cIiAvIFwiP1wiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ7XCIgLyBcInxcIiAvIFwifVwiIC8gXCJ+XCJcblxuICAgICAgICBEb21haW4gICAgICAgICAgPSAgIHN1Yi1kb21haW4gKihcIi5cIiBzdWItZG9tYWluKVxuICAgICAgICBzdWItZG9tYWluICAgICAgPSAgIExldC1kaWcgW0xkaC1zdHJdXG4gICAgICAgIExldC1kaWcgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVFxuICAgICAgICBMZGgtc3RyICAgICAgICAgPSAgICooIEFMUEhBIC8gRElHSVQgLyBcIi1cIiApIExldC1kaWdcblxuICAgICAgICBBTFBIQSAgICAgICAgICAgPSAgICV4NDEtNUEgLyAleDYxLTdBICAgICAgICA7IGEteiwgQS1aXG4gICAgICAgIERJR0lUICAgICAgICAgICA9ICAgJXgzMC0zOSAgICAgICAgICAgICAgICAgIDsgMC05XG5cbiAgICBGcm9tIFJGQyA2NTMxOlxuXG4gICAgICAgIHN1Yi1kb21haW4gICAgICA9LyAgVS1sYWJlbFxuICAgICAgICBhdGV4dCAgICAgICAgICAgPS8gIFVURjgtbm9uLWFzY2lpXG5cbiAgICAgICAgVVRGOC1ub24tYXNjaWkgID0gICBVVEY4LTIgLyBVVEY4LTMgLyBVVEY4LTRcblxuICAgICAgICBVVEY4LTIgICAgICAgICAgPSAgICV4QzItREYgVVRGOC10YWlsXG4gICAgICAgIFVURjgtMyAgICAgICAgICA9ICAgJXhFMCAleEEwLUJGIFVURjgtdGFpbCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFRCAleDgwLTlGIFVURjgtdGFpbCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFRS1FRiAyKCBVVEY4LXRhaWwgKVxuICAgICAgICBVVEY4LTQgICAgICAgICAgPSAgICV4RjAgJXg5MC1CRiAyKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhGMS1GMyAzKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhGNCAleDgwLThGIDIoIFVURjgtdGFpbCApXG5cbiAgICAgICAgVVRGOC10YWlsICAgICAgID0gICAleDgwLUJGXG5cbiAgICBOb3RlOiBUaGUgZm9sbG93aW5nIGFyZSBub3Qgc3VwcG9ydGVkOlxuXG4gICAgICAgIFJGQyA1MzIxOiBhZGRyZXNzLWxpdGVyYWwsIFF1b3RlZC1zdHJpbmdcbiAgICAgICAgUkZDIDUzMjI6IG9icy0qLCBDRldTXG4qL1xuXG5cbmludGVybmFscy5hdGV4dFJ4ID0gL15bXFx3ISNcXCQlJidcXCpcXCtcXC0vPVxcP1xcXmBcXHtcXHxcXH1+XSskLzsgICAgICAgICAgICAgICAvLyBfIGluY2x1ZGVkIGluIFxcd1xuXG5cbmludGVybmFscy5hdG9tUnggPSBuZXcgUmVnRXhwKFtcblxuICAgIC8vICAleEMyLURGIFVURjgtdGFpbFxuICAgICcoPzpbXFxcXHhjMi1cXFxceGRmXVtcXFxceDgwLVxcXFx4YmZdKScsXG5cbiAgICAvLyAgJXhFMCAleEEwLUJGIFVURjgtdGFpbCAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RUQgJXg4MC05RiBVVEY4LXRhaWwgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcbiAgICAnKD86XFxcXHhlMFtcXFxceGEwLVxcXFx4YmZdW1xcXFx4ODAtXFxcXHhiZl0pfCg/OltcXFxceGUxLVxcXFx4ZWNdW1xcXFx4ODAtXFxcXHhiZl17Mn0pfCg/OlxcXFx4ZWRbXFxcXHg4MC1cXFxceDlmXVtcXFxceDgwLVxcXFx4YmZdKXwoPzpbXFxcXHhlZS1cXFxceGVmXVtcXFxceDgwLVxcXFx4YmZdezJ9KScsXG5cbiAgICAvLyAgJXhGMCAleDkwLUJGIDIoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhGMS1GMyAzKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxuICAgICcoPzpcXFxceGYwW1xcXFx4OTAtXFxcXHhiZl1bXFxcXHg4MC1cXFxceGJmXXsyfSl8KD86W1xcXFx4ZjEtXFxcXHhmM11bXFxcXHg4MC1cXFxceGJmXXszfSl8KD86XFxcXHhmNFtcXFxceDgwLVxcXFx4OGZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pJ1xuXG5dLmpvaW4oJ3wnKSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcXlxcJFxcLlxcKlxcK1xcLVxcP1xcPVxcIVxcOlxcfFxcXFxcXC9cXChcXClcXFtcXF1cXHtcXH1cXCxdL2csICdcXFxcJCYnKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByZmMzOTg2ID0ge307XG5cbiAgICBjb25zdCBoZXhEaWdpdCA9ICdcXFxcZEEtRmEtZic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIRVhESUcgPSBESUdJVCAvIFwiQVwiIC8gXCJCXCIgLyBcIkNcIiAvIFwiRFwiIC8gXCJFXCIgLyBcIkZcIlxuICAgIGNvbnN0IGhleERpZ2l0T25seSA9ICdbJyArIGhleERpZ2l0ICsgJ10nO1xuXG4gICAgY29uc3QgdW5yZXNlcnZlZCA9ICdcXFxcdy1cXFxcLn4nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnJlc2VydmVkID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgY29uc3Qgc3ViRGVsaW1zID0gJyFcXFxcJCZcXCdcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLWRlbGltcyA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICBjb25zdCBwY3RFbmNvZGVkID0gJyUnICsgaGV4RGlnaXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGN0LWVuY29kZWQgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gICAgY29uc3QgcGNoYXIgPSB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICc6QCc7ICAgICAgICAgICAgICAgICAgIC8vIHBjaGFyID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICBjb25zdCBwY2hhck9ubHkgPSAnWycgKyBwY2hhciArICddJztcbiAgICBjb25zdCBkZWNPY3RlY3QgPSAnKD86MHswLDJ9XFxcXGR8MD9bMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pJzsgICAgIC8vIGRlYy1vY3RldCA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiIDJESUdJVCAvIFwiMlwiICV4MzAtMzQgRElHSVQgLyBcIjI1XCIgJXgzMC0zNSAgOyAwLTkgLyAxMC05OSAvIDEwMC0xOTkgLyAyMDAtMjQ5IC8gMjUwLTI1NVxuXG4gICAgcmZjMzk4Ni5pcHY0YWRkcmVzcyA9ICcoPzonICsgZGVjT2N0ZWN0ICsgJ1xcXFwuKXszfScgKyBkZWNPY3RlY3Q7ICAgICAgICAgICAgLy8gSVB2NGFkZHJlc3MgPSBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXRcblxuICAgIC8qXG4gICAgICAgIGgxNiA9IDEqNEhFWERJRyA7IDE2IGJpdHMgb2YgYWRkcmVzcyByZXByZXNlbnRlZCBpbiBoZXhhZGVjaW1hbFxuICAgICAgICBsczMyID0gKCBoMTYgXCI6XCIgaDE2ICkgLyBJUHY0YWRkcmVzcyA7IGxlYXN0LXNpZ25pZmljYW50IDMyIGJpdHMgb2YgYWRkcmVzc1xuICAgICAgICBJUHY2YWRkcmVzcyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgICovXG5cbiAgICBjb25zdCBoMTYgPSBoZXhEaWdpdE9ubHkgKyAnezEsNH0nO1xuICAgIGNvbnN0IGxzMzIgPSAnKD86JyArIGgxNiArICc6JyArIGgxNiArICd8JyArIHJmYzM5ODYuaXB2NGFkZHJlc3MgKyAnKSc7XG4gICAgY29uc3QgSVB2NlNpeEhleCA9ICcoPzonICsgaDE2ICsgJzopezZ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZpdmVIZXggPSAnOjooPzonICsgaDE2ICsgJzopezV9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZvdXJIZXggPSAnKD86JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXs0fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUaHJlZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMX0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezN9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlR3b0hleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMn0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezJ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsM30nICsgaDE2ICsgJyk/OjonICsgaDE2ICsgJzonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNH0nICsgaDE2ICsgJyk/OjonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDIgPSAnKD86KD86JyArIGgxNiArICc6KXswLDV9JyArIGgxNiArICcpPzo6JyArIGgxNjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDMgPSAnKD86KD86JyArIGgxNiArICc6KXswLDZ9JyArIGgxNiArICcpPzo6JztcblxuICAgIHJmYzM5ODYuaXB2NENpZHIgPSAnKD86XFxcXGR8WzEtMl1cXFxcZHwzWzAtMl0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVB2NCBjaWRyID0gRElHSVQgLyAleDMxLTMyIERJR0lUIC8gXCIzXCIgJXgzMC0zMiAgOyAwLTkgLyAxMC0yOSAvIDMwLTMyXG4gICAgcmZjMzk4Ni5pcHY2Q2lkciA9ICcoPzowezAsMn1cXFxcZHwwP1sxLTldXFxcXGR8MVswMV1cXFxcZHwxMlswLThdKSc7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElQdjYgY2lkciA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiICV4MC0xIERJR0lUIC8gXCIxMlwiICV4MC04OyAgIDAtOSAvIDEwLTk5IC8gMTAwLTExOSAvIDEyMC0xMjhcbiAgICByZmMzOTg2LmlwdjZhZGRyZXNzID0gJyg/OicgKyBJUHY2U2l4SGV4ICsgJ3wnICsgSVB2NkZpdmVIZXggKyAnfCcgKyBJUHY2Rm91ckhleCArICd8JyArIElQdjZUaHJlZUhleCArICd8JyArIElQdjZUd29IZXggKyAnfCcgKyBJUHY2T25lSGV4ICsgJ3wnICsgSVB2Nk5vbmVIZXggKyAnfCcgKyBJUHY2Tm9uZUhleDIgKyAnfCcgKyBJUHY2Tm9uZUhleDMgKyAnKSc7XG4gICAgcmZjMzk4Ni5pcHZGdXR1cmUgPSAndicgKyBoZXhEaWdpdE9ubHkgKyAnK1xcXFwuWycgKyB1bnJlc2VydmVkICsgc3ViRGVsaW1zICsgJzpdKyc7ICAgICAgLy8gSVB2RnV0dXJlID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuXG4gICAgcmZjMzk4Ni5zY2hlbWUgPSAnW2EtekEtWl1bYS16QS1aXFxcXGQrLVxcXFwuXSonOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgICByZmMzOTg2LnNjaGVtZVJlZ2V4ID0gbmV3IFJlZ0V4cChyZmMzOTg2LnNjaGVtZSk7XG5cbiAgICBjb25zdCB1c2VyaW5mbyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpdKic7ICAgICAgICAgICAgICAgICAgICAgLy8gdXNlcmluZm8gPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgIGNvbnN0IElQTGl0ZXJhbCA9ICdcXFxcWyg/OicgKyByZmMzOTg2LmlwdjZhZGRyZXNzICsgJ3wnICsgcmZjMzk4Ni5pcHZGdXR1cmUgKyAnKVxcXFxdJzsgICAgLy8gSVAtbGl0ZXJhbCA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICBjb25zdCByZWdOYW1lID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnXXsxLDI1NX0nOyAgICAgICAgICAgICAgICAgLy8gcmVnLW5hbWUgPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIClcbiAgICBjb25zdCBob3N0ID0gJyg/OicgKyBJUExpdGVyYWwgKyAnfCcgKyByZmMzOTg2LmlwdjRhZGRyZXNzICsgJ3wnICsgcmVnTmFtZSArICcpJzsgICAgICAgLy8gaG9zdCA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgY29uc3QgcG9ydCA9ICdcXFxcZConOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9ydCA9ICpESUdJVFxuICAgIGNvbnN0IGF1dGhvcml0eSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/JyArIGhvc3QgKyAnKD86OicgKyBwb3J0ICsgJyk/JzsgICAgICAgICAgICAgICAvLyBhdXRob3JpdHkgICA9IFsgdXNlcmluZm8gXCJAXCIgXSBob3N0IFsgXCI6XCIgcG9ydCBdXG4gICAgY29uc3QgYXV0aG9yaXR5Q2FwdHVyZSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/KCcgKyBob3N0ICsgJykoPzo6JyArIHBvcnQgKyAnKT8nO1xuXG4gICAgLypcbiAgICAgICAgc2VnbWVudCAgICAgICA9ICpwY2hhclxuICAgICAgICBzZWdtZW50LW56ICAgID0gMSpwY2hhclxuICAgICAgICBwYXRoICAgICAgICAgID0gcGF0aC1hYmVtcHR5ICAgIDsgYmVnaW5zIHdpdGggXCIvXCIgJ3wnIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZSAgIDsgYmVnaW5zIHdpdGggXCIvXCIgYnV0IG5vdCBcIi8vXCJcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLW5vc2NoZW1lICAgOyBiZWdpbnMgd2l0aCBhIG5vbi1jb2xvbiBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1yb290bGVzcyAgIDsgYmVnaW5zIHdpdGggYSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1lbXB0eSAgICAgIDsgemVybyBjaGFyYWN0ZXJzXG4gICAgICAgIHBhdGgtYWJlbXB0eSAgPSAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAgICAgcGF0aC1hYnNvbHV0ZSA9IFwiL1wiIFsgc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50ICkgXVxuICAgICAgICBwYXRoLXJvb3RsZXNzID0gc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAqL1xuXG4gICAgY29uc3Qgc2VnbWVudCA9IHBjaGFyT25seSArICcqJztcbiAgICBjb25zdCBzZWdtZW50TnogPSBwY2hhck9ubHkgKyAnKyc7XG4gICAgY29uc3Qgc2VnbWVudE56TmMgPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICdAJyArICddKyc7XG4gICAgY29uc3QgcGF0aEVtcHR5ID0gJyc7XG4gICAgY29uc3QgcGF0aEFiRW1wdHkgPSAnKD86XFxcXC8nICsgc2VnbWVudCArICcpKic7XG4gICAgY29uc3QgcGF0aEFic29sdXRlID0gJ1xcXFwvKD86JyArIHNlZ21lbnROeiArIHBhdGhBYkVtcHR5ICsgJyk/JztcbiAgICBjb25zdCBwYXRoUm9vdGxlc3MgPSBzZWdtZW50TnogKyBwYXRoQWJFbXB0eTtcbiAgICBjb25zdCBwYXRoTm9TY2hlbWUgPSBzZWdtZW50TnpOYyArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhBYk5vQXV0aG9yaXR5ID0gJyg/OlxcXFwvXFxcXC9cXFxcLycgKyBzZWdtZW50ICsgcGF0aEFiRW1wdHkgKyAnKSc7ICAgICAvLyBVc2VkIGJ5IGZpbGU6Ly8vXG5cbiAgICAvLyBoaWVyLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGhcblxuICAgIHJmYzM5ODYuaGllclBhcnQgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aFJvb3RsZXNzICsgJ3wnICsgcGF0aEFiTm9BdXRob3JpdHkgKyAnKSc7XG4gICAgcmZjMzk4Ni5oaWVyUGFydENhcHR1cmUgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eUNhcHR1cmUgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhSb290bGVzcyArICcpJztcblxuICAgIC8vIHJlbGF0aXZlLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGgtYWJlbXB0eSAvIHBhdGgtYWJzb2x1dGUgLyBwYXRoLW5vc2NoZW1lIC8gcGF0aC1lbXB0eVxuXG4gICAgcmZjMzk4Ni5yZWxhdGl2ZVJlZiA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoTm9TY2hlbWUgKyAnfCcgKyBwYXRoRW1wdHkgKyAnKSc7XG4gICAgcmZjMzk4Ni5yZWxhdGl2ZVJlZkNhcHR1cmUgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eUNhcHR1cmUgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhOb1NjaGVtZSArICd8JyArIHBhdGhFbXB0eSArICcpJztcblxuICAgIC8vIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAvLyBxdWVyeSA9ICooIHBjaGFyIC8gXCJbXCIgLyBcIl1cIiAvIFwiL1wiIC8gXCI/XCIgKVxuXG4gICAgcmZjMzk4Ni5xdWVyeSA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKig/PSN8JCknOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZpbmlzaCBtYXRjaGluZyBlaXRoZXIgYXQgdGhlIGZyYWdtZW50IHBhcnQgJ3wnIGVuZCBvZiB0aGUgbGluZS5cbiAgICByZmMzOTg2LnF1ZXJ5V2l0aFNxdWFyZUJyYWNrZXRzID0gJ1snICsgcGNoYXIgKyAnXFxcXFtcXFxcXVxcXFwvXFxcXD9dKig/PSN8JCknO1xuXG4gICAgLy8gZnJhZ21lbnQgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuXG4gICAgcmZjMzk4Ni5mcmFnbWVudCA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKic7XG5cbiAgICByZXR1cm4gcmZjMzk4Njtcbn07XG5cbmludGVybmFscy5yZmMzOTg2ID0gaW50ZXJuYWxzLmdlbmVyYXRlKCk7XG5cblxuZXhwb3J0cy5pcCA9IHtcbiAgICB2NENpZHI6IGludGVybmFscy5yZmMzOTg2LmlwdjRDaWRyLFxuICAgIHY2Q2lkcjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NkNpZHIsXG4gICAgaXB2NDogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NGFkZHJlc3MsXG4gICAgaXB2NjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NmFkZHJlc3MsXG4gICAgaXB2ZnV0dXJlOiBpbnRlcm5hbHMucmZjMzk4Ni5pcHZGdXR1cmVcbn07XG5cblxuaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHJmYyA9IGludGVybmFscy5yZmMzOTg2O1xuXG4gICAgLy8gQ29uc3RydWN0IGV4cHJlc3Npb25cblxuICAgIGNvbnN0IHF1ZXJ5ID0gb3B0aW9ucy5hbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPyByZmMucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgOiByZmMucXVlcnk7XG4gICAgY29uc3Qgc3VmZml4ID0gJyg/OlxcXFw/JyArIHF1ZXJ5ICsgJyk/JyArICcoPzojJyArIHJmYy5mcmFnbWVudCArICcpPyc7XG5cbiAgICAvLyByZWxhdGl2ZS1yZWYgPSByZWxhdGl2ZS1wYXJ0IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF1cblxuICAgIGNvbnN0IHJlbGF0aXZlID0gb3B0aW9ucy5kb21haW4gPyByZmMucmVsYXRpdmVSZWZDYXB0dXJlIDogcmZjLnJlbGF0aXZlUmVmO1xuXG4gICAgaWYgKG9wdGlvbnMucmVsYXRpdmVPbmx5KSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMud3JhcChyZWxhdGl2ZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHNjaGVtZXNcblxuICAgIGxldCBjdXN0b21TY2hlbWUgPSAnJztcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBvcHRpb25zLnNjaGVtZSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnNjaGVtZSksICdzY2hlbWUgbXVzdCBiZSBhIFJlZ0V4cCwgU3RyaW5nLCBvciBBcnJheScpO1xuXG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBbXS5jb25jYXQob3B0aW9ucy5zY2hlbWUpO1xuICAgICAgICBBc3NlcnQoc2NoZW1lcy5sZW5ndGggPj0gMSwgJ3NjaGVtZSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBzY2hlbWUgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgYXJyYXkgaW50byBhIHN0cmluZyB0byBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzY2hlbWVzXG5cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IHNjaGVtZXNbaV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgUmVnRXhwIG9yIFN0cmluZycpO1xuXG4gICAgICAgICAgICBpZiAoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHNjaGVtZS5zb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQocmZjLnNjaGVtZVJlZ2V4LnRlc3Qoc2NoZW1lKSwgJ3NjaGVtZSBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHZhbGlkIHNjaGVtZScpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChFc2NhcGVSZWdleChzY2hlbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1c3RvbVNjaGVtZSA9IHNlbGVjdGlvbnMuam9pbignfCcpO1xuICAgIH1cblxuICAgIC8vIFVSSSA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgY29uc3Qgc2NoZW1lID0gY3VzdG9tU2NoZW1lID8gJyg/OicgKyBjdXN0b21TY2hlbWUgKyAnKScgOiByZmMuc2NoZW1lO1xuICAgIGNvbnN0IGFic29sdXRlID0gJyg/OicgKyBzY2hlbWUgKyAnOicgKyAob3B0aW9ucy5kb21haW4gPyByZmMuaGllclBhcnRDYXB0dXJlIDogcmZjLmhpZXJQYXJ0KSArICcpJztcbiAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zLmFsbG93UmVsYXRpdmUgPyAnKD86JyArIGFic29sdXRlICsgJ3wnICsgcmVsYXRpdmUgKyAnKScgOiBhYnNvbHV0ZTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAocHJlZml4ICsgc3VmZml4LCBjdXN0b21TY2hlbWUpO1xufTtcblxuXG5pbnRlcm5hbHMud3JhcCA9IGZ1bmN0aW9uIChyYXcsIHNjaGVtZSkge1xuXG4gICAgcmF3ID0gYCg/PS4pKD8haHR0cHM/XFw6Lyg/OiR8W14vXSkpKD8haHR0cHM/XFw6Ly8vKSg/IWh0dHBzP1xcOlteL10pJHtyYXd9YDsgICAgIC8vIFJlcXVpcmUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhbmQgZXhwbGljaXRseSBmb3JiaWQgJ2h0dHA6Lycgb3IgSFRUUCB3aXRoIGVtcHR5IGRvbWFpblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF3LFxuICAgICAgICByZWdleDogbmV3IFJlZ0V4cChgXiR7cmF3fSRgKSxcbiAgICAgICAgc2NoZW1lXG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnVyaVJlZ2V4ID0gaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4KHt9KTtcblxuXG5leHBvcnRzLnJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lIHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlT25seSB8fFxuICAgICAgICBvcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyB8fFxuICAgICAgICBvcHRpb25zLmRvbWFpbikge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlUmVnZXgob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51cmlSZWdleDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgVXJpID0gcmVxdWlyZSgnLi91cmknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgLy8gQ0lEUlxuXG4gICAgQXNzZXJ0KG9wdGlvbnMuY2lkciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLmNpZHIgPT09ICdzdHJpbmcnLCAnb3B0aW9ucy5jaWRyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBjb25zdCBjaWRyID0gb3B0aW9ucy5jaWRyID8gb3B0aW9ucy5jaWRyLnRvTG93ZXJDYXNlKCkgOiAnb3B0aW9uYWwnO1xuICAgIEFzc2VydChbJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbiddLmluY2x1ZGVzKGNpZHIpLCAnb3B0aW9ucy5jaWRyIG11c3QgYmUgb25lIG9mIHJlcXVpcmVkLCBvcHRpb25hbCwgZm9yYmlkZGVuJyk7XG5cbiAgICAvLyBWZXJzaW9uc1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMudmVyc2lvbiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLnZlcnNpb24gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy52ZXJzaW9uKSwgJ29wdGlvbnMudmVyc2lvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZycpO1xuICAgIGxldCB2ZXJzaW9ucyA9IG9wdGlvbnMudmVyc2lvbiB8fCBbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB7XG4gICAgICAgIHZlcnNpb25zID0gW3ZlcnNpb25zXTtcbiAgICB9XG5cbiAgICBBc3NlcnQodmVyc2lvbnMubGVuZ3RoID49IDEsICdvcHRpb25zLnZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmVyc2lvbiBzcGVjaWZpZWQnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uc1tpXSA9PT0gJ3N0cmluZycsICdvcHRpb25zLnZlcnNpb24gbXVzdCBvbmx5IGNvbnRhaW4gc3RyaW5ncycpO1xuICAgICAgICB2ZXJzaW9uc1tpXSA9IHZlcnNpb25zW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIEFzc2VydChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXS5pbmNsdWRlcyh2ZXJzaW9uc1tpXSksICdvcHRpb25zLnZlcnNpb24gY29udGFpbnMgdW5rbm93biB2ZXJzaW9uICcgKyB2ZXJzaW9uc1tpXSArICcgLSBtdXN0IGJlIG9uZSBvZiBpcHY0LCBpcHY2LCBpcHZmdXR1cmUnKTtcbiAgICB9XG5cbiAgICB2ZXJzaW9ucyA9IEFycmF5LmZyb20obmV3IFNldCh2ZXJzaW9ucykpO1xuXG4gICAgLy8gUmVnZXhcblxuICAgIGNvbnN0IHBhcnRzID0gdmVyc2lvbnMubWFwKCh2ZXJzaW9uKSA9PiB7XG5cbiAgICAgICAgLy8gRm9yYmlkZGVuXG5cbiAgICAgICAgaWYgKGNpZHIgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gVXJpLmlwW3ZlcnNpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWlyZWRcblxuICAgICAgICBjb25zdCBjaWRycGFydCA9IGBcXFxcLyR7dmVyc2lvbiA9PT0gJ2lwdjQnID8gVXJpLmlwLnY0Q2lkciA6IFVyaS5pcC52NkNpZHJ9YDtcblxuICAgICAgICBpZiAoY2lkciA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGAke1VyaS5pcFt2ZXJzaW9uXX0ke2NpZHJwYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbFxuXG4gICAgICAgIHJldHVybiBgJHtVcmkuaXBbdmVyc2lvbl19KD86JHtjaWRycGFydH0pP2A7XG4gICAgfSk7XG5cbiAgICBjb25zdCByYXcgPSBgKD86JHtwYXJ0cy5qb2luKCd8Jyl9KWA7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtyYXd9JGApO1xuICAgIHJldHVybiB7IGNpZHIsIHZlcnNpb25zLCByZWdleCwgcmF3IH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gaHR0cDovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxuLy8gIyBWZXJzaW9uIDIwMjQwMTI5MDAsIExhc3QgVXBkYXRlZCBNb24gSmFuIDI5IDA3OjA3OjAxIDIwMjQgVVRDXG5cblxuaW50ZXJuYWxzLnRsZHMgPSBbXG4gICAgJ0FBQScsXG4gICAgJ0FBUlAnLFxuICAgICdBQkInLFxuICAgICdBQkJPVFQnLFxuICAgICdBQkJWSUUnLFxuICAgICdBQkMnLFxuICAgICdBQkxFJyxcbiAgICAnQUJPR0FETycsXG4gICAgJ0FCVURIQUJJJyxcbiAgICAnQUMnLFxuICAgICdBQ0FERU1ZJyxcbiAgICAnQUNDRU5UVVJFJyxcbiAgICAnQUNDT1VOVEFOVCcsXG4gICAgJ0FDQ09VTlRBTlRTJyxcbiAgICAnQUNPJyxcbiAgICAnQUNUT1InLFxuICAgICdBRCcsXG4gICAgJ0FEUycsXG4gICAgJ0FEVUxUJyxcbiAgICAnQUUnLFxuICAgICdBRUcnLFxuICAgICdBRVJPJyxcbiAgICAnQUVUTkEnLFxuICAgICdBRicsXG4gICAgJ0FGTCcsXG4gICAgJ0FGUklDQScsXG4gICAgJ0FHJyxcbiAgICAnQUdBS0hBTicsXG4gICAgJ0FHRU5DWScsXG4gICAgJ0FJJyxcbiAgICAnQUlHJyxcbiAgICAnQUlSQlVTJyxcbiAgICAnQUlSRk9SQ0UnLFxuICAgICdBSVJURUwnLFxuICAgICdBS0ROJyxcbiAgICAnQUwnLFxuICAgICdBTElCQUJBJyxcbiAgICAnQUxJUEFZJyxcbiAgICAnQUxMRklOQU5aJyxcbiAgICAnQUxMU1RBVEUnLFxuICAgICdBTExZJyxcbiAgICAnQUxTQUNFJyxcbiAgICAnQUxTVE9NJyxcbiAgICAnQU0nLFxuICAgICdBTUFaT04nLFxuICAgICdBTUVSSUNBTkVYUFJFU1MnLFxuICAgICdBTUVSSUNBTkZBTUlMWScsXG4gICAgJ0FNRVgnLFxuICAgICdBTUZBTScsXG4gICAgJ0FNSUNBJyxcbiAgICAnQU1TVEVSREFNJyxcbiAgICAnQU5BTFlUSUNTJyxcbiAgICAnQU5EUk9JRCcsXG4gICAgJ0FOUVVBTicsXG4gICAgJ0FOWicsXG4gICAgJ0FPJyxcbiAgICAnQU9MJyxcbiAgICAnQVBBUlRNRU5UUycsXG4gICAgJ0FQUCcsXG4gICAgJ0FQUExFJyxcbiAgICAnQVEnLFxuICAgICdBUVVBUkVMTEUnLFxuICAgICdBUicsXG4gICAgJ0FSQUInLFxuICAgICdBUkFNQ08nLFxuICAgICdBUkNISScsXG4gICAgJ0FSTVknLFxuICAgICdBUlBBJyxcbiAgICAnQVJUJyxcbiAgICAnQVJURScsXG4gICAgJ0FTJyxcbiAgICAnQVNEQScsXG4gICAgJ0FTSUEnLFxuICAgICdBU1NPQ0lBVEVTJyxcbiAgICAnQVQnLFxuICAgICdBVEhMRVRBJyxcbiAgICAnQVRUT1JORVknLFxuICAgICdBVScsXG4gICAgJ0FVQ1RJT04nLFxuICAgICdBVURJJyxcbiAgICAnQVVESUJMRScsXG4gICAgJ0FVRElPJyxcbiAgICAnQVVTUE9TVCcsXG4gICAgJ0FVVEhPUicsXG4gICAgJ0FVVE8nLFxuICAgICdBVVRPUycsXG4gICAgJ0FWSUFOQ0EnLFxuICAgICdBVycsXG4gICAgJ0FXUycsXG4gICAgJ0FYJyxcbiAgICAnQVhBJyxcbiAgICAnQVonLFxuICAgICdBWlVSRScsXG4gICAgJ0JBJyxcbiAgICAnQkFCWScsXG4gICAgJ0JBSURVJyxcbiAgICAnQkFOQU1FWCcsXG4gICAgJ0JBTkQnLFxuICAgICdCQU5LJyxcbiAgICAnQkFSJyxcbiAgICAnQkFSQ0VMT05BJyxcbiAgICAnQkFSQ0xBWUNBUkQnLFxuICAgICdCQVJDTEFZUycsXG4gICAgJ0JBUkVGT09UJyxcbiAgICAnQkFSR0FJTlMnLFxuICAgICdCQVNFQkFMTCcsXG4gICAgJ0JBU0tFVEJBTEwnLFxuICAgICdCQVVIQVVTJyxcbiAgICAnQkFZRVJOJyxcbiAgICAnQkInLFxuICAgICdCQkMnLFxuICAgICdCQlQnLFxuICAgICdCQlZBJyxcbiAgICAnQkNHJyxcbiAgICAnQkNOJyxcbiAgICAnQkQnLFxuICAgICdCRScsXG4gICAgJ0JFQVRTJyxcbiAgICAnQkVBVVRZJyxcbiAgICAnQkVFUicsXG4gICAgJ0JFTlRMRVknLFxuICAgICdCRVJMSU4nLFxuICAgICdCRVNUJyxcbiAgICAnQkVTVEJVWScsXG4gICAgJ0JFVCcsXG4gICAgJ0JGJyxcbiAgICAnQkcnLFxuICAgICdCSCcsXG4gICAgJ0JIQVJUSScsXG4gICAgJ0JJJyxcbiAgICAnQklCTEUnLFxuICAgICdCSUQnLFxuICAgICdCSUtFJyxcbiAgICAnQklORycsXG4gICAgJ0JJTkdPJyxcbiAgICAnQklPJyxcbiAgICAnQklaJyxcbiAgICAnQkonLFxuICAgICdCTEFDSycsXG4gICAgJ0JMQUNLRlJJREFZJyxcbiAgICAnQkxPQ0tCVVNURVInLFxuICAgICdCTE9HJyxcbiAgICAnQkxPT01CRVJHJyxcbiAgICAnQkxVRScsXG4gICAgJ0JNJyxcbiAgICAnQk1TJyxcbiAgICAnQk1XJyxcbiAgICAnQk4nLFxuICAgICdCTlBQQVJJQkFTJyxcbiAgICAnQk8nLFxuICAgICdCT0FUUycsXG4gICAgJ0JPRUhSSU5HRVInLFxuICAgICdCT0ZBJyxcbiAgICAnQk9NJyxcbiAgICAnQk9ORCcsXG4gICAgJ0JPTycsXG4gICAgJ0JPT0snLFxuICAgICdCT09LSU5HJyxcbiAgICAnQk9TQ0gnLFxuICAgICdCT1NUSUsnLFxuICAgICdCT1NUT04nLFxuICAgICdCT1QnLFxuICAgICdCT1VUSVFVRScsXG4gICAgJ0JPWCcsXG4gICAgJ0JSJyxcbiAgICAnQlJBREVTQ08nLFxuICAgICdCUklER0VTVE9ORScsXG4gICAgJ0JST0FEV0FZJyxcbiAgICAnQlJPS0VSJyxcbiAgICAnQlJPVEhFUicsXG4gICAgJ0JSVVNTRUxTJyxcbiAgICAnQlMnLFxuICAgICdCVCcsXG4gICAgJ0JVSUxEJyxcbiAgICAnQlVJTERFUlMnLFxuICAgICdCVVNJTkVTUycsXG4gICAgJ0JVWScsXG4gICAgJ0JVWlonLFxuICAgICdCVicsXG4gICAgJ0JXJyxcbiAgICAnQlknLFxuICAgICdCWicsXG4gICAgJ0JaSCcsXG4gICAgJ0NBJyxcbiAgICAnQ0FCJyxcbiAgICAnQ0FGRScsXG4gICAgJ0NBTCcsXG4gICAgJ0NBTEwnLFxuICAgICdDQUxWSU5LTEVJTicsXG4gICAgJ0NBTScsXG4gICAgJ0NBTUVSQScsXG4gICAgJ0NBTVAnLFxuICAgICdDQU5PTicsXG4gICAgJ0NBUEVUT1dOJyxcbiAgICAnQ0FQSVRBTCcsXG4gICAgJ0NBUElUQUxPTkUnLFxuICAgICdDQVInLFxuICAgICdDQVJBVkFOJyxcbiAgICAnQ0FSRFMnLFxuICAgICdDQVJFJyxcbiAgICAnQ0FSRUVSJyxcbiAgICAnQ0FSRUVSUycsXG4gICAgJ0NBUlMnLFxuICAgICdDQVNBJyxcbiAgICAnQ0FTRScsXG4gICAgJ0NBU0gnLFxuICAgICdDQVNJTk8nLFxuICAgICdDQVQnLFxuICAgICdDQVRFUklORycsXG4gICAgJ0NBVEhPTElDJyxcbiAgICAnQ0JBJyxcbiAgICAnQ0JOJyxcbiAgICAnQ0JSRScsXG4gICAgJ0NDJyxcbiAgICAnQ0QnLFxuICAgICdDRU5URVInLFxuICAgICdDRU8nLFxuICAgICdDRVJOJyxcbiAgICAnQ0YnLFxuICAgICdDRkEnLFxuICAgICdDRkQnLFxuICAgICdDRycsXG4gICAgJ0NIJyxcbiAgICAnQ0hBTkVMJyxcbiAgICAnQ0hBTk5FTCcsXG4gICAgJ0NIQVJJVFknLFxuICAgICdDSEFTRScsXG4gICAgJ0NIQVQnLFxuICAgICdDSEVBUCcsXG4gICAgJ0NISU5UQUknLFxuICAgICdDSFJJU1RNQVMnLFxuICAgICdDSFJPTUUnLFxuICAgICdDSFVSQ0gnLFxuICAgICdDSScsXG4gICAgJ0NJUFJJQU5JJyxcbiAgICAnQ0lSQ0xFJyxcbiAgICAnQ0lTQ08nLFxuICAgICdDSVRBREVMJyxcbiAgICAnQ0lUSScsXG4gICAgJ0NJVElDJyxcbiAgICAnQ0lUWScsXG4gICAgJ0NLJyxcbiAgICAnQ0wnLFxuICAgICdDTEFJTVMnLFxuICAgICdDTEVBTklORycsXG4gICAgJ0NMSUNLJyxcbiAgICAnQ0xJTklDJyxcbiAgICAnQ0xJTklRVUUnLFxuICAgICdDTE9USElORycsXG4gICAgJ0NMT1VEJyxcbiAgICAnQ0xVQicsXG4gICAgJ0NMVUJNRUQnLFxuICAgICdDTScsXG4gICAgJ0NOJyxcbiAgICAnQ08nLFxuICAgICdDT0FDSCcsXG4gICAgJ0NPREVTJyxcbiAgICAnQ09GRkVFJyxcbiAgICAnQ09MTEVHRScsXG4gICAgJ0NPTE9HTkUnLFxuICAgICdDT00nLFxuICAgICdDT01DQVNUJyxcbiAgICAnQ09NTUJBTksnLFxuICAgICdDT01NVU5JVFknLFxuICAgICdDT01QQU5ZJyxcbiAgICAnQ09NUEFSRScsXG4gICAgJ0NPTVBVVEVSJyxcbiAgICAnQ09NU0VDJyxcbiAgICAnQ09ORE9TJyxcbiAgICAnQ09OU1RSVUNUSU9OJyxcbiAgICAnQ09OU1VMVElORycsXG4gICAgJ0NPTlRBQ1QnLFxuICAgICdDT05UUkFDVE9SUycsXG4gICAgJ0NPT0tJTkcnLFxuICAgICdDT09MJyxcbiAgICAnQ09PUCcsXG4gICAgJ0NPUlNJQ0EnLFxuICAgICdDT1VOVFJZJyxcbiAgICAnQ09VUE9OJyxcbiAgICAnQ09VUE9OUycsXG4gICAgJ0NPVVJTRVMnLFxuICAgICdDUEEnLFxuICAgICdDUicsXG4gICAgJ0NSRURJVCcsXG4gICAgJ0NSRURJVENBUkQnLFxuICAgICdDUkVESVRVTklPTicsXG4gICAgJ0NSSUNLRVQnLFxuICAgICdDUk9XTicsXG4gICAgJ0NSUycsXG4gICAgJ0NSVUlTRScsXG4gICAgJ0NSVUlTRVMnLFxuICAgICdDVScsXG4gICAgJ0NVSVNJTkVMTEEnLFxuICAgICdDVicsXG4gICAgJ0NXJyxcbiAgICAnQ1gnLFxuICAgICdDWScsXG4gICAgJ0NZTVJVJyxcbiAgICAnQ1lPVScsXG4gICAgJ0NaJyxcbiAgICAnREFCVVInLFxuICAgICdEQUQnLFxuICAgICdEQU5DRScsXG4gICAgJ0RBVEEnLFxuICAgICdEQVRFJyxcbiAgICAnREFUSU5HJyxcbiAgICAnREFUU1VOJyxcbiAgICAnREFZJyxcbiAgICAnRENMSycsXG4gICAgJ0REUycsXG4gICAgJ0RFJyxcbiAgICAnREVBTCcsXG4gICAgJ0RFQUxFUicsXG4gICAgJ0RFQUxTJyxcbiAgICAnREVHUkVFJyxcbiAgICAnREVMSVZFUlknLFxuICAgICdERUxMJyxcbiAgICAnREVMT0lUVEUnLFxuICAgICdERUxUQScsXG4gICAgJ0RFTU9DUkFUJyxcbiAgICAnREVOVEFMJyxcbiAgICAnREVOVElTVCcsXG4gICAgJ0RFU0knLFxuICAgICdERVNJR04nLFxuICAgICdERVYnLFxuICAgICdESEwnLFxuICAgICdESUFNT05EUycsXG4gICAgJ0RJRVQnLFxuICAgICdESUdJVEFMJyxcbiAgICAnRElSRUNUJyxcbiAgICAnRElSRUNUT1JZJyxcbiAgICAnRElTQ09VTlQnLFxuICAgICdESVNDT1ZFUicsXG4gICAgJ0RJU0gnLFxuICAgICdESVknLFxuICAgICdESicsXG4gICAgJ0RLJyxcbiAgICAnRE0nLFxuICAgICdETlAnLFxuICAgICdETycsXG4gICAgJ0RPQ1MnLFxuICAgICdET0NUT1InLFxuICAgICdET0cnLFxuICAgICdET01BSU5TJyxcbiAgICAnRE9UJyxcbiAgICAnRE9XTkxPQUQnLFxuICAgICdEUklWRScsXG4gICAgJ0RUVicsXG4gICAgJ0RVQkFJJyxcbiAgICAnRFVOTE9QJyxcbiAgICAnRFVQT05UJyxcbiAgICAnRFVSQkFOJyxcbiAgICAnRFZBRycsXG4gICAgJ0RWUicsXG4gICAgJ0RaJyxcbiAgICAnRUFSVEgnLFxuICAgICdFQVQnLFxuICAgICdFQycsXG4gICAgJ0VDTycsXG4gICAgJ0VERUtBJyxcbiAgICAnRURVJyxcbiAgICAnRURVQ0FUSU9OJyxcbiAgICAnRUUnLFxuICAgICdFRycsXG4gICAgJ0VNQUlMJyxcbiAgICAnRU1FUkNLJyxcbiAgICAnRU5FUkdZJyxcbiAgICAnRU5HSU5FRVInLFxuICAgICdFTkdJTkVFUklORycsXG4gICAgJ0VOVEVSUFJJU0VTJyxcbiAgICAnRVBTT04nLFxuICAgICdFUVVJUE1FTlQnLFxuICAgICdFUicsXG4gICAgJ0VSSUNTU09OJyxcbiAgICAnRVJOSScsXG4gICAgJ0VTJyxcbiAgICAnRVNRJyxcbiAgICAnRVNUQVRFJyxcbiAgICAnRVQnLFxuICAgICdFVScsXG4gICAgJ0VVUk9WSVNJT04nLFxuICAgICdFVVMnLFxuICAgICdFVkVOVFMnLFxuICAgICdFWENIQU5HRScsXG4gICAgJ0VYUEVSVCcsXG4gICAgJ0VYUE9TRUQnLFxuICAgICdFWFBSRVNTJyxcbiAgICAnRVhUUkFTUEFDRScsXG4gICAgJ0ZBR0UnLFxuICAgICdGQUlMJyxcbiAgICAnRkFJUldJTkRTJyxcbiAgICAnRkFJVEgnLFxuICAgICdGQU1JTFknLFxuICAgICdGQU4nLFxuICAgICdGQU5TJyxcbiAgICAnRkFSTScsXG4gICAgJ0ZBUk1FUlMnLFxuICAgICdGQVNISU9OJyxcbiAgICAnRkFTVCcsXG4gICAgJ0ZFREVYJyxcbiAgICAnRkVFREJBQ0snLFxuICAgICdGRVJSQVJJJyxcbiAgICAnRkVSUkVSTycsXG4gICAgJ0ZJJyxcbiAgICAnRklERUxJVFknLFxuICAgICdGSURPJyxcbiAgICAnRklMTScsXG4gICAgJ0ZJTkFMJyxcbiAgICAnRklOQU5DRScsXG4gICAgJ0ZJTkFOQ0lBTCcsXG4gICAgJ0ZJUkUnLFxuICAgICdGSVJFU1RPTkUnLFxuICAgICdGSVJNREFMRScsXG4gICAgJ0ZJU0gnLFxuICAgICdGSVNISU5HJyxcbiAgICAnRklUJyxcbiAgICAnRklUTkVTUycsXG4gICAgJ0ZKJyxcbiAgICAnRksnLFxuICAgICdGTElDS1InLFxuICAgICdGTElHSFRTJyxcbiAgICAnRkxJUicsXG4gICAgJ0ZMT1JJU1QnLFxuICAgICdGTE9XRVJTJyxcbiAgICAnRkxZJyxcbiAgICAnRk0nLFxuICAgICdGTycsXG4gICAgJ0ZPTycsXG4gICAgJ0ZPT0QnLFxuICAgICdGT09UQkFMTCcsXG4gICAgJ0ZPUkQnLFxuICAgICdGT1JFWCcsXG4gICAgJ0ZPUlNBTEUnLFxuICAgICdGT1JVTScsXG4gICAgJ0ZPVU5EQVRJT04nLFxuICAgICdGT1gnLFxuICAgICdGUicsXG4gICAgJ0ZSRUUnLFxuICAgICdGUkVTRU5JVVMnLFxuICAgICdGUkwnLFxuICAgICdGUk9HQU5TJyxcbiAgICAnRlJPTlRJRVInLFxuICAgICdGVFInLFxuICAgICdGVUpJVFNVJyxcbiAgICAnRlVOJyxcbiAgICAnRlVORCcsXG4gICAgJ0ZVUk5JVFVSRScsXG4gICAgJ0ZVVEJPTCcsXG4gICAgJ0ZZSScsXG4gICAgJ0dBJyxcbiAgICAnR0FMJyxcbiAgICAnR0FMTEVSWScsXG4gICAgJ0dBTExPJyxcbiAgICAnR0FMTFVQJyxcbiAgICAnR0FNRScsXG4gICAgJ0dBTUVTJyxcbiAgICAnR0FQJyxcbiAgICAnR0FSREVOJyxcbiAgICAnR0FZJyxcbiAgICAnR0InLFxuICAgICdHQklaJyxcbiAgICAnR0QnLFxuICAgICdHRE4nLFxuICAgICdHRScsXG4gICAgJ0dFQScsXG4gICAgJ0dFTlQnLFxuICAgICdHRU5USU5HJyxcbiAgICAnR0VPUkdFJyxcbiAgICAnR0YnLFxuICAgICdHRycsXG4gICAgJ0dHRUUnLFxuICAgICdHSCcsXG4gICAgJ0dJJyxcbiAgICAnR0lGVCcsXG4gICAgJ0dJRlRTJyxcbiAgICAnR0lWRVMnLFxuICAgICdHSVZJTkcnLFxuICAgICdHTCcsXG4gICAgJ0dMQVNTJyxcbiAgICAnR0xFJyxcbiAgICAnR0xPQkFMJyxcbiAgICAnR0xPQk8nLFxuICAgICdHTScsXG4gICAgJ0dNQUlMJyxcbiAgICAnR01CSCcsXG4gICAgJ0dNTycsXG4gICAgJ0dNWCcsXG4gICAgJ0dOJyxcbiAgICAnR09EQUREWScsXG4gICAgJ0dPTEQnLFxuICAgICdHT0xEUE9JTlQnLFxuICAgICdHT0xGJyxcbiAgICAnR09PJyxcbiAgICAnR09PRFlFQVInLFxuICAgICdHT09HJyxcbiAgICAnR09PR0xFJyxcbiAgICAnR09QJyxcbiAgICAnR09UJyxcbiAgICAnR09WJyxcbiAgICAnR1AnLFxuICAgICdHUScsXG4gICAgJ0dSJyxcbiAgICAnR1JBSU5HRVInLFxuICAgICdHUkFQSElDUycsXG4gICAgJ0dSQVRJUycsXG4gICAgJ0dSRUVOJyxcbiAgICAnR1JJUEUnLFxuICAgICdHUk9DRVJZJyxcbiAgICAnR1JPVVAnLFxuICAgICdHUycsXG4gICAgJ0dUJyxcbiAgICAnR1UnLFxuICAgICdHVUFSRElBTicsXG4gICAgJ0dVQ0NJJyxcbiAgICAnR1VHRScsXG4gICAgJ0dVSURFJyxcbiAgICAnR1VJVEFSUycsXG4gICAgJ0dVUlUnLFxuICAgICdHVycsXG4gICAgJ0dZJyxcbiAgICAnSEFJUicsXG4gICAgJ0hBTUJVUkcnLFxuICAgICdIQU5HT1VUJyxcbiAgICAnSEFVUycsXG4gICAgJ0hCTycsXG4gICAgJ0hERkMnLFxuICAgICdIREZDQkFOSycsXG4gICAgJ0hFQUxUSCcsXG4gICAgJ0hFQUxUSENBUkUnLFxuICAgICdIRUxQJyxcbiAgICAnSEVMU0lOS0knLFxuICAgICdIRVJFJyxcbiAgICAnSEVSTUVTJyxcbiAgICAnSElQSE9QJyxcbiAgICAnSElTQU1JVFNVJyxcbiAgICAnSElUQUNISScsXG4gICAgJ0hJVicsXG4gICAgJ0hLJyxcbiAgICAnSEtUJyxcbiAgICAnSE0nLFxuICAgICdITicsXG4gICAgJ0hPQ0tFWScsXG4gICAgJ0hPTERJTkdTJyxcbiAgICAnSE9MSURBWScsXG4gICAgJ0hPTUVERVBPVCcsXG4gICAgJ0hPTUVHT09EUycsXG4gICAgJ0hPTUVTJyxcbiAgICAnSE9NRVNFTlNFJyxcbiAgICAnSE9OREEnLFxuICAgICdIT1JTRScsXG4gICAgJ0hPU1BJVEFMJyxcbiAgICAnSE9TVCcsXG4gICAgJ0hPU1RJTkcnLFxuICAgICdIT1QnLFxuICAgICdIT1RFTFMnLFxuICAgICdIT1RNQUlMJyxcbiAgICAnSE9VU0UnLFxuICAgICdIT1cnLFxuICAgICdIUicsXG4gICAgJ0hTQkMnLFxuICAgICdIVCcsXG4gICAgJ0hVJyxcbiAgICAnSFVHSEVTJyxcbiAgICAnSFlBVFQnLFxuICAgICdIWVVOREFJJyxcbiAgICAnSUJNJyxcbiAgICAnSUNCQycsXG4gICAgJ0lDRScsXG4gICAgJ0lDVScsXG4gICAgJ0lEJyxcbiAgICAnSUUnLFxuICAgICdJRUVFJyxcbiAgICAnSUZNJyxcbiAgICAnSUtBTk8nLFxuICAgICdJTCcsXG4gICAgJ0lNJyxcbiAgICAnSU1BTUFUJyxcbiAgICAnSU1EQicsXG4gICAgJ0lNTU8nLFxuICAgICdJTU1PQklMSUVOJyxcbiAgICAnSU4nLFxuICAgICdJTkMnLFxuICAgICdJTkRVU1RSSUVTJyxcbiAgICAnSU5GSU5JVEknLFxuICAgICdJTkZPJyxcbiAgICAnSU5HJyxcbiAgICAnSU5LJyxcbiAgICAnSU5TVElUVVRFJyxcbiAgICAnSU5TVVJBTkNFJyxcbiAgICAnSU5TVVJFJyxcbiAgICAnSU5UJyxcbiAgICAnSU5URVJOQVRJT05BTCcsXG4gICAgJ0lOVFVJVCcsXG4gICAgJ0lOVkVTVE1FTlRTJyxcbiAgICAnSU8nLFxuICAgICdJUElSQU5HQScsXG4gICAgJ0lRJyxcbiAgICAnSVInLFxuICAgICdJUklTSCcsXG4gICAgJ0lTJyxcbiAgICAnSVNNQUlMSScsXG4gICAgJ0lTVCcsXG4gICAgJ0lTVEFOQlVMJyxcbiAgICAnSVQnLFxuICAgICdJVEFVJyxcbiAgICAnSVRWJyxcbiAgICAnSkFHVUFSJyxcbiAgICAnSkFWQScsXG4gICAgJ0pDQicsXG4gICAgJ0pFJyxcbiAgICAnSkVFUCcsXG4gICAgJ0pFVFpUJyxcbiAgICAnSkVXRUxSWScsXG4gICAgJ0pJTycsXG4gICAgJ0pMTCcsXG4gICAgJ0pNJyxcbiAgICAnSk1QJyxcbiAgICAnSk5KJyxcbiAgICAnSk8nLFxuICAgICdKT0JTJyxcbiAgICAnSk9CVVJHJyxcbiAgICAnSk9UJyxcbiAgICAnSk9ZJyxcbiAgICAnSlAnLFxuICAgICdKUE1PUkdBTicsXG4gICAgJ0pQUlMnLFxuICAgICdKVUVHT1MnLFxuICAgICdKVU5JUEVSJyxcbiAgICAnS0FVRkVOJyxcbiAgICAnS0RESScsXG4gICAgJ0tFJyxcbiAgICAnS0VSUllIT1RFTFMnLFxuICAgICdLRVJSWUxPR0lTVElDUycsXG4gICAgJ0tFUlJZUFJPUEVSVElFUycsXG4gICAgJ0tGSCcsXG4gICAgJ0tHJyxcbiAgICAnS0gnLFxuICAgICdLSScsXG4gICAgJ0tJQScsXG4gICAgJ0tJRFMnLFxuICAgICdLSU0nLFxuICAgICdLSU5ETEUnLFxuICAgICdLSVRDSEVOJyxcbiAgICAnS0lXSScsXG4gICAgJ0tNJyxcbiAgICAnS04nLFxuICAgICdLT0VMTicsXG4gICAgJ0tPTUFUU1UnLFxuICAgICdLT1NIRVInLFxuICAgICdLUCcsXG4gICAgJ0tQTUcnLFxuICAgICdLUE4nLFxuICAgICdLUicsXG4gICAgJ0tSRCcsXG4gICAgJ0tSRUQnLFxuICAgICdLVU9LR1JPVVAnLFxuICAgICdLVycsXG4gICAgJ0tZJyxcbiAgICAnS1lPVE8nLFxuICAgICdLWicsXG4gICAgJ0xBJyxcbiAgICAnTEFDQUlYQScsXG4gICAgJ0xBTUJPUkdISU5JJyxcbiAgICAnTEFNRVInLFxuICAgICdMQU5DQVNURVInLFxuICAgICdMQU5EJyxcbiAgICAnTEFORFJPVkVSJyxcbiAgICAnTEFOWEVTUycsXG4gICAgJ0xBU0FMTEUnLFxuICAgICdMQVQnLFxuICAgICdMQVRJTk8nLFxuICAgICdMQVRST0JFJyxcbiAgICAnTEFXJyxcbiAgICAnTEFXWUVSJyxcbiAgICAnTEInLFxuICAgICdMQycsXG4gICAgJ0xEUycsXG4gICAgJ0xFQVNFJyxcbiAgICAnTEVDTEVSQycsXG4gICAgJ0xFRlJBSycsXG4gICAgJ0xFR0FMJyxcbiAgICAnTEVHTycsXG4gICAgJ0xFWFVTJyxcbiAgICAnTEdCVCcsXG4gICAgJ0xJJyxcbiAgICAnTElETCcsXG4gICAgJ0xJRkUnLFxuICAgICdMSUZFSU5TVVJBTkNFJyxcbiAgICAnTElGRVNUWUxFJyxcbiAgICAnTElHSFRJTkcnLFxuICAgICdMSUtFJyxcbiAgICAnTElMTFknLFxuICAgICdMSU1JVEVEJyxcbiAgICAnTElNTycsXG4gICAgJ0xJTkNPTE4nLFxuICAgICdMSU5LJyxcbiAgICAnTElQU1knLFxuICAgICdMSVZFJyxcbiAgICAnTElWSU5HJyxcbiAgICAnTEsnLFxuICAgICdMTEMnLFxuICAgICdMTFAnLFxuICAgICdMT0FOJyxcbiAgICAnTE9BTlMnLFxuICAgICdMT0NLRVInLFxuICAgICdMT0NVUycsXG4gICAgJ0xPTCcsXG4gICAgJ0xPTkRPTicsXG4gICAgJ0xPVFRFJyxcbiAgICAnTE9UVE8nLFxuICAgICdMT1ZFJyxcbiAgICAnTFBMJyxcbiAgICAnTFBMRklOQU5DSUFMJyxcbiAgICAnTFInLFxuICAgICdMUycsXG4gICAgJ0xUJyxcbiAgICAnTFREJyxcbiAgICAnTFREQScsXG4gICAgJ0xVJyxcbiAgICAnTFVOREJFQ0snLFxuICAgICdMVVhFJyxcbiAgICAnTFVYVVJZJyxcbiAgICAnTFYnLFxuICAgICdMWScsXG4gICAgJ01BJyxcbiAgICAnTUFEUklEJyxcbiAgICAnTUFJRicsXG4gICAgJ01BSVNPTicsXG4gICAgJ01BS0VVUCcsXG4gICAgJ01BTicsXG4gICAgJ01BTkFHRU1FTlQnLFxuICAgICdNQU5HTycsXG4gICAgJ01BUCcsXG4gICAgJ01BUktFVCcsXG4gICAgJ01BUktFVElORycsXG4gICAgJ01BUktFVFMnLFxuICAgICdNQVJSSU9UVCcsXG4gICAgJ01BUlNIQUxMUycsXG4gICAgJ01BVFRFTCcsXG4gICAgJ01CQScsXG4gICAgJ01DJyxcbiAgICAnTUNLSU5TRVknLFxuICAgICdNRCcsXG4gICAgJ01FJyxcbiAgICAnTUVEJyxcbiAgICAnTUVESUEnLFxuICAgICdNRUVUJyxcbiAgICAnTUVMQk9VUk5FJyxcbiAgICAnTUVNRScsXG4gICAgJ01FTU9SSUFMJyxcbiAgICAnTUVOJyxcbiAgICAnTUVOVScsXG4gICAgJ01FUkNLTVNEJyxcbiAgICAnTUcnLFxuICAgICdNSCcsXG4gICAgJ01JQU1JJyxcbiAgICAnTUlDUk9TT0ZUJyxcbiAgICAnTUlMJyxcbiAgICAnTUlOSScsXG4gICAgJ01JTlQnLFxuICAgICdNSVQnLFxuICAgICdNSVRTVUJJU0hJJyxcbiAgICAnTUsnLFxuICAgICdNTCcsXG4gICAgJ01MQicsXG4gICAgJ01MUycsXG4gICAgJ01NJyxcbiAgICAnTU1BJyxcbiAgICAnTU4nLFxuICAgICdNTycsXG4gICAgJ01PQkknLFxuICAgICdNT0JJTEUnLFxuICAgICdNT0RBJyxcbiAgICAnTU9FJyxcbiAgICAnTU9JJyxcbiAgICAnTU9NJyxcbiAgICAnTU9OQVNIJyxcbiAgICAnTU9ORVknLFxuICAgICdNT05TVEVSJyxcbiAgICAnTU9STU9OJyxcbiAgICAnTU9SVEdBR0UnLFxuICAgICdNT1NDT1cnLFxuICAgICdNT1RPJyxcbiAgICAnTU9UT1JDWUNMRVMnLFxuICAgICdNT1YnLFxuICAgICdNT1ZJRScsXG4gICAgJ01QJyxcbiAgICAnTVEnLFxuICAgICdNUicsXG4gICAgJ01TJyxcbiAgICAnTVNEJyxcbiAgICAnTVQnLFxuICAgICdNVE4nLFxuICAgICdNVFInLFxuICAgICdNVScsXG4gICAgJ01VU0VVTScsXG4gICAgJ01VU0lDJyxcbiAgICAnTVYnLFxuICAgICdNVycsXG4gICAgJ01YJyxcbiAgICAnTVknLFxuICAgICdNWicsXG4gICAgJ05BJyxcbiAgICAnTkFCJyxcbiAgICAnTkFHT1lBJyxcbiAgICAnTkFNRScsXG4gICAgJ05BVFVSQScsXG4gICAgJ05BVlknLFxuICAgICdOQkEnLFxuICAgICdOQycsXG4gICAgJ05FJyxcbiAgICAnTkVDJyxcbiAgICAnTkVUJyxcbiAgICAnTkVUQkFOSycsXG4gICAgJ05FVEZMSVgnLFxuICAgICdORVRXT1JLJyxcbiAgICAnTkVVU1RBUicsXG4gICAgJ05FVycsXG4gICAgJ05FV1MnLFxuICAgICdORVhUJyxcbiAgICAnTkVYVERJUkVDVCcsXG4gICAgJ05FWFVTJyxcbiAgICAnTkYnLFxuICAgICdORkwnLFxuICAgICdORycsXG4gICAgJ05HTycsXG4gICAgJ05ISycsXG4gICAgJ05JJyxcbiAgICAnTklDTycsXG4gICAgJ05JS0UnLFxuICAgICdOSUtPTicsXG4gICAgJ05JTkpBJyxcbiAgICAnTklTU0FOJyxcbiAgICAnTklTU0FZJyxcbiAgICAnTkwnLFxuICAgICdOTycsXG4gICAgJ05PS0lBJyxcbiAgICAnTk9SVE9OJyxcbiAgICAnTk9XJyxcbiAgICAnTk9XUlVaJyxcbiAgICAnTk9XVFYnLFxuICAgICdOUCcsXG4gICAgJ05SJyxcbiAgICAnTlJBJyxcbiAgICAnTlJXJyxcbiAgICAnTlRUJyxcbiAgICAnTlUnLFxuICAgICdOWUMnLFxuICAgICdOWicsXG4gICAgJ09CSScsXG4gICAgJ09CU0VSVkVSJyxcbiAgICAnT0ZGSUNFJyxcbiAgICAnT0tJTkFXQScsXG4gICAgJ09MQVlBTicsXG4gICAgJ09MQVlBTkdST1VQJyxcbiAgICAnT0xMTycsXG4gICAgJ09NJyxcbiAgICAnT01FR0EnLFxuICAgICdPTkUnLFxuICAgICdPTkcnLFxuICAgICdPTkwnLFxuICAgICdPTkxJTkUnLFxuICAgICdPT08nLFxuICAgICdPUEVOJyxcbiAgICAnT1JBQ0xFJyxcbiAgICAnT1JBTkdFJyxcbiAgICAnT1JHJyxcbiAgICAnT1JHQU5JQycsXG4gICAgJ09SSUdJTlMnLFxuICAgICdPU0FLQScsXG4gICAgJ09UU1VLQScsXG4gICAgJ09UVCcsXG4gICAgJ09WSCcsXG4gICAgJ1BBJyxcbiAgICAnUEFHRScsXG4gICAgJ1BBTkFTT05JQycsXG4gICAgJ1BBUklTJyxcbiAgICAnUEFSUycsXG4gICAgJ1BBUlRORVJTJyxcbiAgICAnUEFSVFMnLFxuICAgICdQQVJUWScsXG4gICAgJ1BBWScsXG4gICAgJ1BDQ1cnLFxuICAgICdQRScsXG4gICAgJ1BFVCcsXG4gICAgJ1BGJyxcbiAgICAnUEZJWkVSJyxcbiAgICAnUEcnLFxuICAgICdQSCcsXG4gICAgJ1BIQVJNQUNZJyxcbiAgICAnUEhEJyxcbiAgICAnUEhJTElQUycsXG4gICAgJ1BIT05FJyxcbiAgICAnUEhPVE8nLFxuICAgICdQSE9UT0dSQVBIWScsXG4gICAgJ1BIT1RPUycsXG4gICAgJ1BIWVNJTycsXG4gICAgJ1BJQ1MnLFxuICAgICdQSUNURVQnLFxuICAgICdQSUNUVVJFUycsXG4gICAgJ1BJRCcsXG4gICAgJ1BJTicsXG4gICAgJ1BJTkcnLFxuICAgICdQSU5LJyxcbiAgICAnUElPTkVFUicsXG4gICAgJ1BJWlpBJyxcbiAgICAnUEsnLFxuICAgICdQTCcsXG4gICAgJ1BMQUNFJyxcbiAgICAnUExBWScsXG4gICAgJ1BMQVlTVEFUSU9OJyxcbiAgICAnUExVTUJJTkcnLFxuICAgICdQTFVTJyxcbiAgICAnUE0nLFxuICAgICdQTicsXG4gICAgJ1BOQycsXG4gICAgJ1BPSEwnLFxuICAgICdQT0tFUicsXG4gICAgJ1BPTElUSUUnLFxuICAgICdQT1JOJyxcbiAgICAnUE9TVCcsXG4gICAgJ1BSJyxcbiAgICAnUFJBTUVSSUNBJyxcbiAgICAnUFJBWEknLFxuICAgICdQUkVTUycsXG4gICAgJ1BSSU1FJyxcbiAgICAnUFJPJyxcbiAgICAnUFJPRCcsXG4gICAgJ1BST0RVQ1RJT05TJyxcbiAgICAnUFJPRicsXG4gICAgJ1BST0dSRVNTSVZFJyxcbiAgICAnUFJPTU8nLFxuICAgICdQUk9QRVJUSUVTJyxcbiAgICAnUFJPUEVSVFknLFxuICAgICdQUk9URUNUSU9OJyxcbiAgICAnUFJVJyxcbiAgICAnUFJVREVOVElBTCcsXG4gICAgJ1BTJyxcbiAgICAnUFQnLFxuICAgICdQVUInLFxuICAgICdQVycsXG4gICAgJ1BXQycsXG4gICAgJ1BZJyxcbiAgICAnUUEnLFxuICAgICdRUE9OJyxcbiAgICAnUVVFQkVDJyxcbiAgICAnUVVFU1QnLFxuICAgICdSQUNJTkcnLFxuICAgICdSQURJTycsXG4gICAgJ1JFJyxcbiAgICAnUkVBRCcsXG4gICAgJ1JFQUxFU1RBVEUnLFxuICAgICdSRUFMVE9SJyxcbiAgICAnUkVBTFRZJyxcbiAgICAnUkVDSVBFUycsXG4gICAgJ1JFRCcsXG4gICAgJ1JFRFNUT05FJyxcbiAgICAnUkVEVU1CUkVMTEEnLFxuICAgICdSRUhBQicsXG4gICAgJ1JFSVNFJyxcbiAgICAnUkVJU0VOJyxcbiAgICAnUkVJVCcsXG4gICAgJ1JFTElBTkNFJyxcbiAgICAnUkVOJyxcbiAgICAnUkVOVCcsXG4gICAgJ1JFTlRBTFMnLFxuICAgICdSRVBBSVInLFxuICAgICdSRVBPUlQnLFxuICAgICdSRVBVQkxJQ0FOJyxcbiAgICAnUkVTVCcsXG4gICAgJ1JFU1RBVVJBTlQnLFxuICAgICdSRVZJRVcnLFxuICAgICdSRVZJRVdTJyxcbiAgICAnUkVYUk9USCcsXG4gICAgJ1JJQ0gnLFxuICAgICdSSUNIQVJETEknLFxuICAgICdSSUNPSCcsXG4gICAgJ1JJTCcsXG4gICAgJ1JJTycsXG4gICAgJ1JJUCcsXG4gICAgJ1JPJyxcbiAgICAnUk9DS1MnLFxuICAgICdST0RFTycsXG4gICAgJ1JPR0VSUycsXG4gICAgJ1JPT00nLFxuICAgICdSUycsXG4gICAgJ1JTVlAnLFxuICAgICdSVScsXG4gICAgJ1JVR0JZJyxcbiAgICAnUlVIUicsXG4gICAgJ1JVTicsXG4gICAgJ1JXJyxcbiAgICAnUldFJyxcbiAgICAnUllVS1lVJyxcbiAgICAnU0EnLFxuICAgICdTQUFSTEFORCcsXG4gICAgJ1NBRkUnLFxuICAgICdTQUZFVFknLFxuICAgICdTQUtVUkEnLFxuICAgICdTQUxFJyxcbiAgICAnU0FMT04nLFxuICAgICdTQU1TQ0xVQicsXG4gICAgJ1NBTVNVTkcnLFxuICAgICdTQU5EVklLJyxcbiAgICAnU0FORFZJS0NPUk9NQU5UJyxcbiAgICAnU0FOT0ZJJyxcbiAgICAnU0FQJyxcbiAgICAnU0FSTCcsXG4gICAgJ1NBUycsXG4gICAgJ1NBVkUnLFxuICAgICdTQVhPJyxcbiAgICAnU0InLFxuICAgICdTQkknLFxuICAgICdTQlMnLFxuICAgICdTQycsXG4gICAgJ1NDQicsXG4gICAgJ1NDSEFFRkZMRVInLFxuICAgICdTQ0hNSURUJyxcbiAgICAnU0NIT0xBUlNISVBTJyxcbiAgICAnU0NIT09MJyxcbiAgICAnU0NIVUxFJyxcbiAgICAnU0NIV0FSWicsXG4gICAgJ1NDSUVOQ0UnLFxuICAgICdTQ09UJyxcbiAgICAnU0QnLFxuICAgICdTRScsXG4gICAgJ1NFQVJDSCcsXG4gICAgJ1NFQVQnLFxuICAgICdTRUNVUkUnLFxuICAgICdTRUNVUklUWScsXG4gICAgJ1NFRUsnLFxuICAgICdTRUxFQ1QnLFxuICAgICdTRU5FUicsXG4gICAgJ1NFUlZJQ0VTJyxcbiAgICAnU0VWRU4nLFxuICAgICdTRVcnLFxuICAgICdTRVgnLFxuICAgICdTRVhZJyxcbiAgICAnU0ZSJyxcbiAgICAnU0cnLFxuICAgICdTSCcsXG4gICAgJ1NIQU5HUklMQScsXG4gICAgJ1NIQVJQJyxcbiAgICAnU0hBVycsXG4gICAgJ1NIRUxMJyxcbiAgICAnU0hJQScsXG4gICAgJ1NISUtTSEEnLFxuICAgICdTSE9FUycsXG4gICAgJ1NIT1AnLFxuICAgICdTSE9QUElORycsXG4gICAgJ1NIT1VKSScsXG4gICAgJ1NIT1cnLFxuICAgICdTSScsXG4gICAgJ1NJTEsnLFxuICAgICdTSU5BJyxcbiAgICAnU0lOR0xFUycsXG4gICAgJ1NJVEUnLFxuICAgICdTSicsXG4gICAgJ1NLJyxcbiAgICAnU0tJJyxcbiAgICAnU0tJTicsXG4gICAgJ1NLWScsXG4gICAgJ1NLWVBFJyxcbiAgICAnU0wnLFxuICAgICdTTElORycsXG4gICAgJ1NNJyxcbiAgICAnU01BUlQnLFxuICAgICdTTUlMRScsXG4gICAgJ1NOJyxcbiAgICAnU05DRicsXG4gICAgJ1NPJyxcbiAgICAnU09DQ0VSJyxcbiAgICAnU09DSUFMJyxcbiAgICAnU09GVEJBTksnLFxuICAgICdTT0ZUV0FSRScsXG4gICAgJ1NPSFUnLFxuICAgICdTT0xBUicsXG4gICAgJ1NPTFVUSU9OUycsXG4gICAgJ1NPTkcnLFxuICAgICdTT05ZJyxcbiAgICAnU09ZJyxcbiAgICAnU1BBJyxcbiAgICAnU1BBQ0UnLFxuICAgICdTUE9SVCcsXG4gICAgJ1NQT1QnLFxuICAgICdTUicsXG4gICAgJ1NSTCcsXG4gICAgJ1NTJyxcbiAgICAnU1QnLFxuICAgICdTVEFEQScsXG4gICAgJ1NUQVBMRVMnLFxuICAgICdTVEFSJyxcbiAgICAnU1RBVEVCQU5LJyxcbiAgICAnU1RBVEVGQVJNJyxcbiAgICAnU1RDJyxcbiAgICAnU1RDR1JPVVAnLFxuICAgICdTVE9DS0hPTE0nLFxuICAgICdTVE9SQUdFJyxcbiAgICAnU1RPUkUnLFxuICAgICdTVFJFQU0nLFxuICAgICdTVFVESU8nLFxuICAgICdTVFVEWScsXG4gICAgJ1NUWUxFJyxcbiAgICAnU1UnLFxuICAgICdTVUNLUycsXG4gICAgJ1NVUFBMSUVTJyxcbiAgICAnU1VQUExZJyxcbiAgICAnU1VQUE9SVCcsXG4gICAgJ1NVUkYnLFxuICAgICdTVVJHRVJZJyxcbiAgICAnU1VaVUtJJyxcbiAgICAnU1YnLFxuICAgICdTV0FUQ0gnLFxuICAgICdTV0lTUycsXG4gICAgJ1NYJyxcbiAgICAnU1knLFxuICAgICdTWURORVknLFxuICAgICdTWVNURU1TJyxcbiAgICAnU1onLFxuICAgICdUQUInLFxuICAgICdUQUlQRUknLFxuICAgICdUQUxLJyxcbiAgICAnVEFPQkFPJyxcbiAgICAnVEFSR0VUJyxcbiAgICAnVEFUQU1PVE9SUycsXG4gICAgJ1RBVEFSJyxcbiAgICAnVEFUVE9PJyxcbiAgICAnVEFYJyxcbiAgICAnVEFYSScsXG4gICAgJ1RDJyxcbiAgICAnVENJJyxcbiAgICAnVEQnLFxuICAgICdUREsnLFxuICAgICdURUFNJyxcbiAgICAnVEVDSCcsXG4gICAgJ1RFQ0hOT0xPR1knLFxuICAgICdURUwnLFxuICAgICdURU1BU0VLJyxcbiAgICAnVEVOTklTJyxcbiAgICAnVEVWQScsXG4gICAgJ1RGJyxcbiAgICAnVEcnLFxuICAgICdUSCcsXG4gICAgJ1RIRCcsXG4gICAgJ1RIRUFURVInLFxuICAgICdUSEVBVFJFJyxcbiAgICAnVElBQScsXG4gICAgJ1RJQ0tFVFMnLFxuICAgICdUSUVOREEnLFxuICAgICdUSVBTJyxcbiAgICAnVElSRVMnLFxuICAgICdUSVJPTCcsXG4gICAgJ1RKJyxcbiAgICAnVEpNQVhYJyxcbiAgICAnVEpYJyxcbiAgICAnVEsnLFxuICAgICdUS01BWFgnLFxuICAgICdUTCcsXG4gICAgJ1RNJyxcbiAgICAnVE1BTEwnLFxuICAgICdUTicsXG4gICAgJ1RPJyxcbiAgICAnVE9EQVknLFxuICAgICdUT0tZTycsXG4gICAgJ1RPT0xTJyxcbiAgICAnVE9QJyxcbiAgICAnVE9SQVknLFxuICAgICdUT1NISUJBJyxcbiAgICAnVE9UQUwnLFxuICAgICdUT1VSUycsXG4gICAgJ1RPV04nLFxuICAgICdUT1lPVEEnLFxuICAgICdUT1lTJyxcbiAgICAnVFInLFxuICAgICdUUkFERScsXG4gICAgJ1RSQURJTkcnLFxuICAgICdUUkFJTklORycsXG4gICAgJ1RSQVZFTCcsXG4gICAgJ1RSQVZFTEVSUycsXG4gICAgJ1RSQVZFTEVSU0lOU1VSQU5DRScsXG4gICAgJ1RSVVNUJyxcbiAgICAnVFJWJyxcbiAgICAnVFQnLFxuICAgICdUVUJFJyxcbiAgICAnVFVJJyxcbiAgICAnVFVORVMnLFxuICAgICdUVVNIVScsXG4gICAgJ1RWJyxcbiAgICAnVFZTJyxcbiAgICAnVFcnLFxuICAgICdUWicsXG4gICAgJ1VBJyxcbiAgICAnVUJBTksnLFxuICAgICdVQlMnLFxuICAgICdVRycsXG4gICAgJ1VLJyxcbiAgICAnVU5JQ09NJyxcbiAgICAnVU5JVkVSU0lUWScsXG4gICAgJ1VOTycsXG4gICAgJ1VPTCcsXG4gICAgJ1VQUycsXG4gICAgJ1VTJyxcbiAgICAnVVknLFxuICAgICdVWicsXG4gICAgJ1ZBJyxcbiAgICAnVkFDQVRJT05TJyxcbiAgICAnVkFOQScsXG4gICAgJ1ZBTkdVQVJEJyxcbiAgICAnVkMnLFxuICAgICdWRScsXG4gICAgJ1ZFR0FTJyxcbiAgICAnVkVOVFVSRVMnLFxuICAgICdWRVJJU0lHTicsXG4gICAgJ1ZFUlNJQ0hFUlVORycsXG4gICAgJ1ZFVCcsXG4gICAgJ1ZHJyxcbiAgICAnVkknLFxuICAgICdWSUFKRVMnLFxuICAgICdWSURFTycsXG4gICAgJ1ZJRycsXG4gICAgJ1ZJS0lORycsXG4gICAgJ1ZJTExBUycsXG4gICAgJ1ZJTicsXG4gICAgJ1ZJUCcsXG4gICAgJ1ZJUkdJTicsXG4gICAgJ1ZJU0EnLFxuICAgICdWSVNJT04nLFxuICAgICdWSVZBJyxcbiAgICAnVklWTycsXG4gICAgJ1ZMQUFOREVSRU4nLFxuICAgICdWTicsXG4gICAgJ1ZPREtBJyxcbiAgICAnVk9MVk8nLFxuICAgICdWT1RFJyxcbiAgICAnVk9USU5HJyxcbiAgICAnVk9UTycsXG4gICAgJ1ZPWUFHRScsXG4gICAgJ1ZVJyxcbiAgICAnV0FMRVMnLFxuICAgICdXQUxNQVJUJyxcbiAgICAnV0FMVEVSJyxcbiAgICAnV0FORycsXG4gICAgJ1dBTkdHT1UnLFxuICAgICdXQVRDSCcsXG4gICAgJ1dBVENIRVMnLFxuICAgICdXRUFUSEVSJyxcbiAgICAnV0VBVEhFUkNIQU5ORUwnLFxuICAgICdXRUJDQU0nLFxuICAgICdXRUJFUicsXG4gICAgJ1dFQlNJVEUnLFxuICAgICdXRUQnLFxuICAgICdXRURESU5HJyxcbiAgICAnV0VJQk8nLFxuICAgICdXRUlSJyxcbiAgICAnV0YnLFxuICAgICdXSE9TV0hPJyxcbiAgICAnV0lFTicsXG4gICAgJ1dJS0knLFxuICAgICdXSUxMSUFNSElMTCcsXG4gICAgJ1dJTicsXG4gICAgJ1dJTkRPV1MnLFxuICAgICdXSU5FJyxcbiAgICAnV0lOTkVSUycsXG4gICAgJ1dNRScsXG4gICAgJ1dPTFRFUlNLTFVXRVInLFxuICAgICdXT09EU0lERScsXG4gICAgJ1dPUksnLFxuICAgICdXT1JLUycsXG4gICAgJ1dPUkxEJyxcbiAgICAnV09XJyxcbiAgICAnV1MnLFxuICAgICdXVEMnLFxuICAgICdXVEYnLFxuICAgICdYQk9YJyxcbiAgICAnWEVST1gnLFxuICAgICdYRklOSVRZJyxcbiAgICAnWElIVUFOJyxcbiAgICAnWElOJyxcbiAgICAnWE4tLTExQjRDM0QnLFxuICAgICdYTi0tMUNLMkUxQicsXG4gICAgJ1hOLS0xUVFXMjNBJyxcbiAgICAnWE4tLTJTQ1JKOUMnLFxuICAgICdYTi0tMzBSUjdZJyxcbiAgICAnWE4tLTNCU1QwME0nLFxuICAgICdYTi0tM0RTNDQzRycsXG4gICAgJ1hOLS0zRTBCNzA3RScsXG4gICAgJ1hOLS0zSENSSjlDJyxcbiAgICAnWE4tLTNQWFU4SycsXG4gICAgJ1hOLS00MkMyRDlBJyxcbiAgICAnWE4tLTQ1QlI1Q1lMJyxcbiAgICAnWE4tLTQ1QlJKOUMnLFxuICAgICdYTi0tNDVRMTFDJyxcbiAgICAnWE4tLTREQlJLMENFJyxcbiAgICAnWE4tLTRHQlJJTScsXG4gICAgJ1hOLS01NEI3RlRBMENDJyxcbiAgICAnWE4tLTU1UVc0MkcnLFxuICAgICdYTi0tNTVRWDVEJyxcbiAgICAnWE4tLTVTVTM0SjkzNkJHU0cnLFxuICAgICdYTi0tNVRaTTVHJyxcbiAgICAnWE4tLTZGUlo4MkcnLFxuICAgICdYTi0tNlFROTg2QjNYTCcsXG4gICAgJ1hOLS04MEFEWEhLUycsXG4gICAgJ1hOLS04MEFPMjFBJyxcbiAgICAnWE4tLTgwQVFFQ0RSMUEnLFxuICAgICdYTi0tODBBU0VIREInLFxuICAgICdYTi0tODBBU1dHJyxcbiAgICAnWE4tLThZMEEwNjNBJyxcbiAgICAnWE4tLTkwQTNBQycsXG4gICAgJ1hOLS05MEFFJyxcbiAgICAnWE4tLTkwQUlTJyxcbiAgICAnWE4tLTlEQlEyQScsXG4gICAgJ1hOLS05RVQ1MlUnLFxuICAgICdYTi0tOUtSVDAwQScsXG4gICAgJ1hOLS1CNFc2MDVGRVJEJyxcbiAgICAnWE4tLUJDSzFCOUE1RFJFNEMnLFxuICAgICdYTi0tQzFBVkcnLFxuICAgICdYTi0tQzJCUjdHJyxcbiAgICAnWE4tLUNDSzJCM0InLFxuICAgICdYTi0tQ0NLV0NYRVREJyxcbiAgICAnWE4tLUNHNEJLSScsXG4gICAgJ1hOLS1DTENIQzBFQTBCMkcyQTlHQ0QnLFxuICAgICdYTi0tQ1pSNjk0QicsXG4gICAgJ1hOLS1DWlJTMFQnLFxuICAgICdYTi0tQ1pSVTJEJyxcbiAgICAnWE4tLUQxQUNKM0InLFxuICAgICdYTi0tRDFBTEYnLFxuICAgICdYTi0tRTFBNEMnLFxuICAgICdYTi0tRUNLVkRUQzlEJyxcbiAgICAnWE4tLUVGVlk4OEgnLFxuICAgICdYTi0tRkNUNDI5SycsXG4gICAgJ1hOLS1GSEJFSScsXG4gICAgJ1hOLS1GSVEyMjhDNUhTJyxcbiAgICAnWE4tLUZJUTY0QicsXG4gICAgJ1hOLS1GSVFTOFMnLFxuICAgICdYTi0tRklRWjlTJyxcbiAgICAnWE4tLUZKUTcyMEEnLFxuICAgICdYTi0tRkxXMzUxRScsXG4gICAgJ1hOLS1GUENSSjlDM0QnLFxuICAgICdYTi0tRlpDMkM5RTJDJyxcbiAgICAnWE4tLUZaWVM4RDY5VVZHTScsXG4gICAgJ1hOLS1HMlhYNDhDJyxcbiAgICAnWE4tLUdDS1IzRjBGJyxcbiAgICAnWE4tLUdFQ1JKOUMnLFxuICAgICdYTi0tR0szQVQxRScsXG4gICAgJ1hOLS1IMkJSRUczRVZFJyxcbiAgICAnWE4tLUgyQlJKOUMnLFxuICAgICdYTi0tSDJCUko5QzhDJyxcbiAgICAnWE4tLUhYVDgxNEUnLFxuICAgICdYTi0tSTFCNkIxQTZBMkUnLFxuICAgICdYTi0tSU1SNTEzTicsXG4gICAgJ1hOLS1JTzBBN0knLFxuICAgICdYTi0tSjFBRUYnLFxuICAgICdYTi0tSjFBTUgnLFxuICAgICdYTi0tSjZXMTkzRycsXG4gICAgJ1hOLS1KTFE0ODBOMlJHJyxcbiAgICAnWE4tLUpWUjE4OU0nLFxuICAgICdYTi0tS0NSWDc3RDFYNEEnLFxuICAgICdYTi0tS1BSVzEzRCcsXG4gICAgJ1hOLS1LUFJZNTdEJyxcbiAgICAnWE4tLUtQVVQzSScsXG4gICAgJ1hOLS1MMUFDQycsXG4gICAgJ1hOLS1MR0JCQVQxQUQ4SicsXG4gICAgJ1hOLS1NR0I5QVdCRicsXG4gICAgJ1hOLS1NR0JBM0EzRUpUJyxcbiAgICAnWE4tLU1HQkEzQTRGMTZBJyxcbiAgICAnWE4tLU1HQkE3QzBCQk4wQScsXG4gICAgJ1hOLS1NR0JBQU03QThIJyxcbiAgICAnWE4tLU1HQkFCMkJEJyxcbiAgICAnWE4tLU1HQkFIMUEzSEpLUkQnLFxuICAgICdYTi0tTUdCQUk5QVpHUVA2SicsXG4gICAgJ1hOLS1NR0JBWUg3R1BBJyxcbiAgICAnWE4tLU1HQkJIMUEnLFxuICAgICdYTi0tTUdCQkgxQTcxRScsXG4gICAgJ1hOLS1NR0JDMEE5QVpDRycsXG4gICAgJ1hOLS1NR0JDQTdEWkRPJyxcbiAgICAnWE4tLU1HQkNQUTZHUEExQScsXG4gICAgJ1hOLS1NR0JFUlA0QTVENEFSJyxcbiAgICAnWE4tLU1HQkdVODJBJyxcbiAgICAnWE4tLU1HQkk0RUNFWFAnLFxuICAgICdYTi0tTUdCUEwyRkgnLFxuICAgICdYTi0tTUdCVDNESEQnLFxuICAgICdYTi0tTUdCVFgyQicsXG4gICAgJ1hOLS1NR0JYNENEMEFCJyxcbiAgICAnWE4tLU1JWDg5MUYnLFxuICAgICdYTi0tTUsxQlU0NEMnLFxuICAgICdYTi0tTVhUUTFNJyxcbiAgICAnWE4tLU5HQkM1QVpEJyxcbiAgICAnWE4tLU5HQkU5RTBBJyxcbiAgICAnWE4tLU5HQlJYJyxcbiAgICAnWE4tLU5PREUnLFxuICAgICdYTi0tTlFWN0YnLFxuICAgICdYTi0tTlFWN0ZTMDBFTUEnLFxuICAgICdYTi0tTllRWTI2QScsXG4gICAgJ1hOLS1PM0NXNEgnLFxuICAgICdYTi0tT0dCUEY4RkwnLFxuICAgICdYTi0tT1RVNzk2RCcsXG4gICAgJ1hOLS1QMUFDRicsXG4gICAgJ1hOLS1QMUFJJyxcbiAgICAnWE4tLVBHQlMwREgnLFxuICAgICdYTi0tUFNTWTJVJyxcbiAgICAnWE4tLVE3Q0U2QScsXG4gICAgJ1hOLS1ROUpZQjRDJyxcbiAgICAnWE4tLVFDS0ExUE1DJyxcbiAgICAnWE4tLVFYQTZBJyxcbiAgICAnWE4tLVFYQU0nLFxuICAgICdYTi0tUkhRVjk2RycsXG4gICAgJ1hOLS1ST1ZVODhCJyxcbiAgICAnWE4tLVJWQzFFMEFNM0UnLFxuICAgICdYTi0tUzlCUko5QycsXG4gICAgJ1hOLS1TRVM1NTRHJyxcbiAgICAnWE4tLVQ2MEI1NkEnLFxuICAgICdYTi0tVENLV0UnLFxuICAgICdYTi0tVElRNDlYUVlKJyxcbiAgICAnWE4tLVVOVVA0WScsXG4gICAgJ1hOLS1WRVJNR0VOU0JFUkFURVItQ1RCJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRVTkctUFdCJyxcbiAgICAnWE4tLVZIUVVWJyxcbiAgICAnWE4tLVZVUTg2MUInLFxuICAgICdYTi0tVzRSODVFTDhGSFU1RE5SQScsXG4gICAgJ1hOLS1XNFJTNDBMJyxcbiAgICAnWE4tLVdHQkgxQycsXG4gICAgJ1hOLS1XR0JMNkEnLFxuICAgICdYTi0tWEhRNTIxQicsXG4gICAgJ1hOLS1YS0MyQUwzSFlFMkEnLFxuICAgICdYTi0tWEtDMkRMM0E1RUUwSCcsXG4gICAgJ1hOLS1ZOUEzQVEnLFxuICAgICdYTi0tWUZSTzRJNjdPJyxcbiAgICAnWE4tLVlHQkkyQU1NWCcsXG4gICAgJ1hOLS1aRlIxNjRCJyxcbiAgICAnWFhYJyxcbiAgICAnWFlaJyxcbiAgICAnWUFDSFRTJyxcbiAgICAnWUFIT08nLFxuICAgICdZQU1BWFVOJyxcbiAgICAnWUFOREVYJyxcbiAgICAnWUUnLFxuICAgICdZT0RPQkFTSEknLFxuICAgICdZT0dBJyxcbiAgICAnWU9LT0hBTUEnLFxuICAgICdZT1UnLFxuICAgICdZT1VUVUJFJyxcbiAgICAnWVQnLFxuICAgICdZVU4nLFxuICAgICdaQScsXG4gICAgJ1pBUFBPUycsXG4gICAgJ1pBUkEnLFxuICAgICdaRVJPJyxcbiAgICAnWklQJyxcbiAgICAnWk0nLFxuICAgICdaT05FJyxcbiAgICAnWlVFUklDSCcsXG4gICAgJ1pXJ1xuXTtcblxuXG4vLyBLZWVwIGFzIHVwcGVyLWNhc2UgdG8gbWFrZSB1cGRhdGluZyBmcm9tIHNvdXJjZSBlYXNpZXJcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KGludGVybmFscy50bGRzLm1hcCgodGxkKSA9PiB0bGQudG9Mb3dlckNhc2UoKSkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEb21haW4gPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi9kb21haW4nKTtcbmNvbnN0IEVtYWlsID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwnKTtcbmNvbnN0IElwID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvaXAnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcbmNvbnN0IFRsZHMgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi90bGRzJyk7XG5jb25zdCBVcmkgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi91cmknKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0bGRzOiBUbGRzIGluc3RhbmNlb2YgU2V0ID8geyB0bGRzOiB7IGFsbG93OiBUbGRzLCBkZW55OiBudWxsIH0gfSA6IGZhbHNlLCAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgYmFzZTY0UmVnZXg6IHtcbiAgICAgICAgLy8gcGFkZGluZ1JlcXVpcmVkXG4gICAgICAgIHRydWU6IHtcbiAgICAgICAgICAgIC8vIHVybFNhZmVcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn09PXxbXFx3XFwtXXszfT0pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kL1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZToge1xuICAgICAgICAgICAgdHJ1ZTogL14oPzpbXFx3XFwtXXsyfVtcXHdcXC1dezJ9KSooPzpbXFx3XFwtXXsyfSg9PSk/fFtcXHdcXC1dezN9PT8pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn0oPT0pP3xbQS1aYS16MC05K1xcL117M309Pyk/JC9cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YVVyaVJlZ2V4OiAvXmRhdGE6W1xcdysuLV0rXFwvW1xcdysuLV0rOygoY2hhcnNldD1bXFx3LV0rfGJhc2U2NCksKT8oLiopJC8sXG4gICAgaGV4UmVnZXg6IHtcbiAgICAgICAgd2l0aFByZWZpeDogL14weFswLTlhLWZdKyQvaSxcbiAgICAgICAgd2l0aE9wdGlvbmFsUHJlZml4OiAvXig/OjB4KT9bMC05YS1mXSskL2ksXG4gICAgICAgIHdpdGhvdXRQcmVmaXg6IC9eWzAtOWEtZl0rJC9pXG4gICAgfSxcbiAgICBpcFJlZ2V4OiBJcC5yZWdleCh7IGNpZHI6ICdmb3JiaWRkZW4nIH0pLnJlZ2V4LFxuICAgIGlzb0R1cmF0aW9uUmVnZXg6IC9eUCg/ISQpKFxcZCtZKT8oXFxkK00pPyhcXGQrVyk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pPyQvLFxuXG4gICAgZ3VpZEJyYWNrZXRzOiB7XG4gICAgICAgICd7JzogJ30nLCAnWyc6ICddJywgJygnOiAnKScsICcnOiAnJ1xuICAgIH0sXG4gICAgZ3VpZFZlcnNpb25zOiB7XG4gICAgICAgIHV1aWR2MTogJzEnLFxuICAgICAgICB1dWlkdjI6ICcyJyxcbiAgICAgICAgdXVpZHYzOiAnMycsXG4gICAgICAgIHV1aWR2NDogJzQnLFxuICAgICAgICB1dWlkdjU6ICc1JyxcbiAgICAgICAgdXVpZHY2OiAnNicsXG4gICAgICAgIHV1aWR2NzogJzcnLFxuICAgICAgICB1dWlkdjg6ICc4J1xuICAgIH0sXG4gICAgZ3VpZFNlcGFyYXRvcnM6IG5ldyBTZXQoW3VuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsICctJywgJzonXSksXG5cbiAgICBub3JtYWxpemF0aW9uRm9ybXM6IFsnTkZDJywgJ05GRCcsICdORktDJywgJ05GS0QnXVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ3N0cmluZycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIGluc2Vuc2l0aXZlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHRydW5jYXRlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICByZXBsYWNlbWVudHM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplID0gc2NoZW1hLiRfZ2V0UnVsZSgnbm9ybWFsaXplJyk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5ub3JtYWxpemUobm9ybWFsaXplLmFyZ3MuZm9ybSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhc2luZyA9IHNjaGVtYS4kX2dldFJ1bGUoJ2Nhc2UnKTtcbiAgICAgICAgICAgIGlmIChjYXNpbmcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhc2luZy5hcmdzLmRpcmVjdGlvbiA9PT0gJ3VwcGVyJyA/IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkgOiB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgICAgICAgICAgaWYgKHRyaW0gJiZcbiAgICAgICAgICAgICAgICB0cmltLmFyZ3MuZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlcGxhY2VtZW50IG9mIHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnQucGF0dGVybiwgcmVwbGFjZW1lbnQucmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGV4ID0gc2NoZW1hLiRfZ2V0UnVsZSgnaGV4Jyk7XG4gICAgICAgICAgICBpZiAoaGV4ICYmXG4gICAgICAgICAgICAgICAgaGV4LmFyZ3Mub3B0aW9ucy5ieXRlQWxpZ25lZCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gYDAke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF9nZXRSdWxlKCdpc29EYXRlJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc28gPSBpbnRlcm5hbHMuaXNvRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnRydW5jYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ21heCcpO1xuICAgICAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW1pdCA9IHJ1bGUuYXJncy5saW1pdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IGxpbWl0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUNvbW1vbi5saW1pdChsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnJlZicsIGxpbWl0LCB7IHJlZjogcnVsZS5hcmdzLmxpbWl0LCBhcmc6ICdsaW1pdCcsIHJlYXNvbjogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyB9LCBzdGF0ZSwgcHJlZnMpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBzY2hlbWEuJF9nZXRSdWxlKCdtaW4nKTtcbiAgICAgICAgICAgIGlmIChtaW4gJiZcbiAgICAgICAgICAgICAgICBtaW4uYXJncy5saW1pdCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmVtcHR5JykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFscGhhbnVtOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2FscGhhbnVtJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlthLXpBLVowLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmFscGhhbnVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFzZTY0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCcsICd1cmxTYWZlJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgdXJsU2FmZTogZmFsc2UsIHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudXJsU2FmZSA9PT0gJ2Jvb2xlYW4nLCAndXJsU2FmZSBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdiYXNlNjQnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXVtvcHRpb25zLnVybFNhZmVdO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5iYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydsb3dlcicsICd1cHBlciddLmluY2x1ZGVzKGRpcmVjdGlvbiksICdJbnZhbGlkIGNhc2U6JywgZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjYXNlJywgYXJnczogeyBkaXJlY3Rpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBkaXJlY3Rpb24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xvd2VyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd1cHBlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYHN0cmluZy4ke2RpcmVjdGlvbn1jYXNlYCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWRpdENhcmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbXVsID0gMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhciA9IHZhbHVlLmNoYXJBdChpKSAqIG11bDtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgKGNoYXIgLSAoY2hhciA+IDkpICogOSk7XG4gICAgICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3VtICUgMTAgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YVVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZGF0YVVyaScsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5kYXRhVXJpUmVnZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSAhPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXS5mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2U2NHJlZ2V4LnRlc3QobWF0Y2hlc1szXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZGF0YVVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkb21haW4nLCBhcmdzOiB7IG9wdGlvbnMgfSwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyBhZGRyZXNzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1haWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnaWdub3JlTGVuZ3RoJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ211bHRpcGxlJywgJ3NlcGFyYXRvcicsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm11bHRpcGxlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMubXVsdGlwbGUgPT09ICdib29sZWFuJywgJ211bHRpcGxlIG9wdGlvbiBtdXN0IGJlIGFuIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBpbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBcXFxccypbJHtvcHRpb25zLnNlcGFyYXRvciA/IEVzY2FwZVJlZ2V4KG9wdGlvbnMuc2VwYXJhdG9yKSA6ICcsJ31dXFxcXHMqYCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZW1haWwnLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXgsIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBhZGRyZXNzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVtYWlscyA9IG9wdGlvbnMubXVsdGlwbGUgPyB2YWx1ZS5zcGxpdChyZWdleCkgOiBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbWFpbCBvZiBlbWFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFFbWFpbC5pc1ZhbGlkKGVtYWlsLCBhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZHMucHVzaChlbWFpbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludmFsaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5lbWFpbCcsIHsgdmFsdWUsIGludmFsaWRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGd1aWQ6IHtcbiAgICAgICAgICAgIGFsaWFzOiAndXVpZCcsXG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3ZlcnNpb24nLCAnc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb25OdW1iZXJzID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gW10uY29uY2F0KG9wdGlvbnMudmVyc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25zLmxlbmd0aCA+PSAxLCAndmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YWxpZCB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBpbnRlcm5hbHMuZ3VpZFZlcnNpb25zW3ZlcnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbk51bWJlciwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhpbnRlcm5hbHMuZ3VpZFZlcnNpb25zKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0Lmhhcyh2ZXJzaW9uTnVtYmVyKSwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3Qgbm90IGJlIGEgZHVwbGljYXRlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25OdW1iZXJzICs9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGludGVybmFscy5ndWlkU2VwYXJhdG9ycy5oYXMob3B0aW9ucy5zZXBhcmF0b3IpLCAnc2VwYXJhdG9yIG11c3QgYmUgb25lIG9mIHRydWUsIGZhbHNlLCBcIi1cIiwgb3IgXCI6XCInKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJ1s6LV0/JyA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VwYXJhdG9yID09PSB0cnVlID8gJ1s6LV0nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VwYXJhdG9yID09PSBmYWxzZSA/ICdbXT8nIDogYFxcXFwke29wdGlvbnMuc2VwYXJhdG9yfWA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4oW1xcXFxbe1xcXFwoXT8pWzAtOUEtRl17OH0oJHtzZXBhcmF0b3J9KVswLTlBLUZdezR9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgfHwgJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgPyAnODlBQicgOiAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bMC05QS1GXXsxMn0oW1xcXFxdfVxcXFwpXT8pJGAsICdpJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3VpZCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hpbmcgYnJhY2VzXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmd1aWRCcmFja2V0c1tyZXN1bHRzWzFdXSAhPT0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYnl0ZUFsaWduZWQnLCAncHJlZml4J10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgYnl0ZUFsaWduZWQ6IGZhbHNlLCBwcmVmaXg6IGZhbHNlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLmJ5dGVBbGlnbmVkID09PSAnYm9vbGVhbicsICdieXRlQWxpZ25lZCBtdXN0IGJlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnYm9vbGVhbicgfHwgb3B0aW9ucy5wcmVmaXggPT09ICdvcHRpb25hbCcsICdwcmVmaXggbXVzdCBiZSBib29sZWFuIG9yIFwib3B0aW9uYWxcIicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2hleCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmUgPSBvcHRpb25zLnByZWZpeCA9PT0gJ29wdGlvbmFsJyA/XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5oZXhSZWdleC53aXRoT3B0aW9uYWxQcmVmaXggOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByZWZpeCA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaGV4UmVnZXgud2l0aFByZWZpeCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaGV4UmVnZXgud2l0aG91dFByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUFsaWduZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaGV4QWxpZ24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaG9zdG5hbWU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaG9zdG5hbWUnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKERvbWFpbi5pc1ZhbGlkKHZhbHVlLCB7IG1pbkRvbWFpblNlZ21lbnRzOiAxIH0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5pcFJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaG9zdG5hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpbnNlbnNpdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlwOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2NpZHInLCAndmVyc2lvbiddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2lkciwgdmVyc2lvbnMsIHJlZ2V4IH0gPSBJcC5yZWdleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uID8gdmVyc2lvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2lwJywgYXJnczogeyBvcHRpb25zOiB7IGNpZHIsIHZlcnNpb24gfSB9LCByZWdleCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXggfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXBWZXJzaW9uJywgeyB2YWx1ZSwgY2lkcjogb3B0aW9ucy5jaWRyLCB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pcCcsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc29EYXRlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0RhdGUnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ3N0cmluZy5pc29EYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRHVyYXRpb246IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaXNvRHVyYXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EdXJhdGlvblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbGVuZ3RoJywgbGltaXQsICc9JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0LCBlbmNvZGluZyB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kaW5nID8gQnVmZmVyICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZykgOiB2YWx1ZS5sZW5ndGg7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKGxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUsIGVuY29kaW5nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbmNvZGluZydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBsb3dlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ2xvd2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWF4JywgbGltaXQsICc8PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdtaW4nLCBsaW1pdCwgJz49JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbGltaXQnLCAnZW5jb2RpbmcnXVxuICAgICAgICB9LFxuXG4gICAgICAgIG5vcm1hbGl6ZToge1xuICAgICAgICAgICAgbWV0aG9kKGZvcm0gPSAnTkZDJykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMuaW5jbHVkZXMoZm9ybSksICdub3JtYWxpemF0aW9uIGZvcm0gbXVzdCBiZSBvbmUgb2YgJyArIGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbm9ybWFsaXplJywgYXJnczogeyBmb3JtIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSwgeyBmb3JtIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUubm9ybWFsaXplKGZvcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ3N0cmluZy5ub3JtYWxpemUnLCB7IHZhbHVlLCBmb3JtIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBhbGlhczogJ3JlZ2V4JyxcbiAgICAgICAgICAgIG1ldGhvZChyZWdleCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocmVnZXggaW5zdGFuY2VvZiBSZWdFeHAsICdyZWdleCBtdXN0IGJlIGEgUmVnRXhwJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFyZWdleC5mbGFncy5pbmNsdWRlcygnZycpICYmICFyZWdleC5mbGFncy5pbmNsdWRlcygneScpLCAncmVnZXggc2hvdWxkIG5vdCB1c2UgZ2xvYmFsIG9yIHN0aWNreSBtb2RlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2ludmVydCcsICduYW1lJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gWydzdHJpbmcucGF0dGVybicsIG9wdGlvbnMuaW52ZXJ0ID8gJy5pbnZlcnQnIDogJycsIG9wdGlvbnMubmFtZSA/ICcubmFtZScgOiAnLmJhc2UnXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAncGF0dGVybicsIGFyZ3M6IHsgcmVnZXgsIG9wdGlvbnMgfSwgZXJyb3JDb2RlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHJlZ2V4LCBvcHRpb25zIH0sIHsgZXJyb3JDb2RlIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5NYXRjaCA9IHJlZ2V4LnRlc3QodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5NYXRjaCBeIG9wdGlvbnMuaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihlcnJvckNvZGUsIHsgbmFtZTogb3B0aW9ucy5uYW1lLCByZWdleCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydyZWdleCcsICdvcHRpb25zJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlcGxhY2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChwYXR0ZXJuLCByZXBsYWNlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChFc2NhcGVSZWdleChwYXR0ZXJuKSwgJ2cnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3BhdHRlcm4gbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnLCAncmVwbGFjZW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzLnB1c2goeyBwYXR0ZXJuLCByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3Rva2VuJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlxcdyskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy50b2tlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaW06IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAndHJpbScsIGFyZ3M6IHsgZW5hYmxlZCB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGVuYWJsZWQgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50cmltKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy50cmltJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHRydW5jYXRlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd0cnVuY2F0ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwcGVyY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzZSgndXBwZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cmk6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dSZWxhdGl2ZScsICdhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMnLCAnZG9tYWluJywgJ3JlbGF0aXZlT25seScsICdzY2hlbWUnXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucy5kb21haW4sIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlZ2V4LCBzY2hlbWUgfSA9IFVyaS5yZWdleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvcHRpb25zLmRvbWFpbiA/IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zLmRvbWFpbikgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd1cmknLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXgsIGRvbWFpbiwgc2NoZW1lIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgZG9tYWluLCBzY2hlbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKFsnaHR0cDovJywgJ2h0dHBzOi8nXS5pbmNsdWRlcyh2YWx1ZSkpIHsgICAgICAgICAgICAvLyBzY2hlbWU6LyBpcyB0ZWNobmljYWxseSB2YWxpZCBidXQgbWFrZXMgbm8gc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5hbGxvd1JlbGF0aXZlIHx8IG1hdGNoZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRG9tYWluLmlzVmFsaWQobWF0Y2hlZCwgZG9tYWluKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicsIHsgdmFsdWU6IG1hdGNoZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVsYXRpdmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpUmVsYXRpdmVPbmx5Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJywgeyBzY2hlbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHBhdHRlcm4sIHJlcGxhY2VtZW50IH0gb2YgZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnc3RyaW5nLmFscGhhbnVtJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuYmFzZTY0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGJhc2U2NCBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmNyZWRpdENhcmQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgY3JlZGl0IGNhcmQnLFxuICAgICAgICAnc3RyaW5nLmRhdGFVcmknOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZGF0YVVyaSBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmRvbWFpbic6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBhIHZhbGlkIGRvbWFpbiBuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5lbWFpbCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBlbWFpbCcsXG4gICAgICAgICdzdHJpbmcuZW1wdHknOiAne3sjbGFiZWx9fSBpcyBub3QgYWxsb3dlZCB0byBiZSBlbXB0eScsXG4gICAgICAgICdzdHJpbmcuZ3VpZCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBHVUlEJyxcbiAgICAgICAgJ3N0cmluZy5oZXgnOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5oZXhBbGlnbic6ICd7eyNsYWJlbH19IGhleCBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG11c3QgYmUgYnl0ZSBhbGlnbmVkJyxcbiAgICAgICAgJ3N0cmluZy5ob3N0bmFtZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBob3N0bmFtZScsXG4gICAgICAgICdzdHJpbmcuaXAnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyB3aXRoIGEge3sjY2lkcn19IENJRFInLFxuICAgICAgICAnc3RyaW5nLmlwVmVyc2lvbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIG9mIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZlcnNpb25zIHt7I3ZlcnNpb259fSB3aXRoIGEge3sjY2lkcn19IENJRFInLFxuICAgICAgICAnc3RyaW5nLmlzb0RhdGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGluIGlzbyBmb3JtYXQnLFxuICAgICAgICAnc3RyaW5nLmlzb0R1cmF0aW9uJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIElTTyA4NjAxIGR1cmF0aW9uJyxcbiAgICAgICAgJ3N0cmluZy5sZW5ndGgnOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubG93ZXJjYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLm1heCc6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubWluJzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUgYXQgbGVhc3Qge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLm5vcm1hbGl6ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgdW5pY29kZSBub3JtYWxpemVkIGluIHRoZSB7eyNmb3JtfX0gZm9ybScsXG4gICAgICAgICdzdHJpbmcudG9rZW4nOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGFuZCB1bmRlcnNjb3JlIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uYmFzZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IGZhaWxzIHRvIG1hdGNoIHRoZSByZXF1aXJlZCBwYXR0ZXJuOiB7eyNyZWdleH19JyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLm5hbWUnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBmYWlscyB0byBtYXRjaCB0aGUge3sjbmFtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uaW52ZXJ0LmJhc2UnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBtYXRjaGVzIHRoZSBpbnZlcnRlZCBwYXR0ZXJuOiB7eyNyZWdleH19JyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmludmVydC5uYW1lJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQge3sjbmFtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnRyaW0nOiAne3sjbGFiZWx9fSBtdXN0IG5vdCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZScsXG4gICAgICAgICdzdHJpbmcudXJpJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHVyaScsXG4gICAgICAgICdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHVyaSB3aXRoIGEgc2NoZW1lIG1hdGNoaW5nIHRoZSB7eyNzY2hlbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgcmVsYXRpdmUgdXJpJyxcbiAgICAgICAgJ3N0cmluZy51cHBlcmNhc2UnOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiB1cHBlcmNhc2UgY2hhcmFjdGVycydcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5hZGRyZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy50bGRzIHx8IG9wdGlvbnM7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgfVxuXG4gICAgLy8gbWluRG9tYWluU2VnbWVudHNcblxuICAgIEFzc2VydChvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cykgJiYgb3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA+IDAsICdtaW5Eb21haW5TZWdtZW50cyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgLy8gbWF4RG9tYWluU2VnbWVudHNcblxuICAgIEFzc2VydChvcHRpb25zLm1heERvbWFpblNlZ21lbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIob3B0aW9ucy5tYXhEb21haW5TZWdtZW50cykgJiYgb3B0aW9ucy5tYXhEb21haW5TZWdtZW50cyA+IDAsICdtYXhEb21haW5TZWdtZW50cyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgLy8gdGxkc1xuXG4gICAgaWYgKG9wdGlvbnMudGxkcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGxkcyA9PT0gdHJ1ZSB8fFxuICAgICAgICBvcHRpb25zLnRsZHMgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnRsZHMgPT09ICdvYmplY3QnLCAndGxkcyBtdXN0IGJlIHRydWUsIGZhbHNlLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLnRsZHMuZGVueTtcbiAgICBpZiAoZGVueSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZW55KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBkZW55OiBuZXcgU2V0KGRlbnkpIH0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQob3B0aW9ucy50bGRzLmRlbnkgaW5zdGFuY2VvZiBTZXQsICd0bGRzLmRlbnkgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy50bGRzLmFsbG93LCAnQ2Fubm90IHNwZWNpZnkgYm90aCB0bGRzLmFsbG93IGFuZCB0bGRzLmRlbnkgbGlzdHMnKTtcbiAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyhvcHRpb25zLnRsZHMuZGVueSwgJ3RsZHMuZGVueScpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBjb25zdCBhbGxvdyA9IG9wdGlvbnMudGxkcy5hbGxvdztcbiAgICBpZiAoIWFsbG93KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChhbGxvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLnRsZHMsICdCdWlsdC1pbiBUTEQgbGlzdCBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgaW50ZXJuYWxzLnRsZHMpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFsbG93KSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bGRzOiB7IGFsbG93OiBuZXcgU2V0KGFsbG93KSB9IH0pO1xuICAgIH1cblxuICAgIEFzc2VydChvcHRpb25zLnRsZHMuYWxsb3cgaW5zdGFuY2VvZiBTZXQsICd0bGRzLmFsbG93IG11c3QgYmUgYW4gYXJyYXksIFNldCwgb3IgYm9vbGVhbicpO1xuICAgIGludGVybmFscy52YWxpZGF0ZVRsZHMob3B0aW9ucy50bGRzLmFsbG93LCAndGxkcy5hbGxvdycpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGVUbGRzID0gZnVuY3Rpb24gKHNldCwgc291cmNlKSB7XG5cbiAgICBmb3IgKGNvbnN0IHRsZCBvZiBzZXQpIHtcbiAgICAgICAgQXNzZXJ0KERvbWFpbi5pc1ZhbGlkKHRsZCwgeyBtaW5Eb21haW5TZWdtZW50czogMSwgbWF4RG9tYWluU2VnbWVudHM6IDEgfSksIGAke3NvdXJjZX0gbXVzdCBjb250YWluIHZhbGlkIHRvcCBsZXZlbCBkb21haW4gbmFtZXNgKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5pc29EYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvLipULipbKy1dXFxkXFxkJC8udGVzdCh2YWx1ZSkpIHsgICAgICAgICAgICAgLy8gQWRkIG1pc3NpbmcgdHJhaWxpbmcgemVyb3MgdG8gdGltZXNoaWZ0XG4gICAgICAgIHZhbHVlICs9ICcwMCc7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG59O1xuXG5cbmludGVybmFscy5sZW5ndGggPSBmdW5jdGlvbiAoc2NoZW1hLCBuYW1lLCBsaW1pdCwgb3BlcmF0b3IsIGVuY29kaW5nKSB7XG5cbiAgICBBc3NlcnQoIWVuY29kaW5nIHx8IEJ1ZmZlciAmJiBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTsgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcblxuICAgIHJldHVybiBzY2hlbWEuJF9hZGRSdWxlKHsgbmFtZSwgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCwgZW5jb2RpbmcgfSwgb3BlcmF0b3IgfSk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLk1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcblxuICAgIHNsaWNlKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLk1hcCh0aGlzKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3ltYm9sJyxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgbWFwOiB7IGluaXQ6IG5ldyBpbnRlcm5hbHMuTWFwKCkgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBzY2hlbWEuJF90ZXJtcy5tYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvb2t1cDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLm9ubHkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLm1hcCcsIHsgbWFwOiBzY2hlbWEuJF90ZXJtcy5tYXAgfSkgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wuYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBtZXRob2QoaXRlcmFibGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVyYWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlcmFibGUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QuZW50cmllcyhpdGVyYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGl0ZXJhYmxlICYmIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0sICdJdGVyYWJsZSBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9yIG9iamVjdCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGVudHJ5ICYmIGVudHJ5W1N5bWJvbC5pdGVyYXRvcl0sICdFbnRyeSBtdXN0IGJlIGFuIGl0ZXJhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBrZXkgIT09ICdzeW1ib2wnLCAnS2V5IG11c3Qgbm90IGJlIG9mIHR5cGUgb2JqZWN0LCBmdW5jdGlvbiwgb3IgU3ltYm9sJyk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnLCAnVmFsdWUgbXVzdCBiZSBhIFN5bWJvbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai52YWxpZCguLi5zeW1ib2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5tYXApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoubWFwKGRlc2MubWFwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnc3ltYm9sLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc3ltYm9sJyxcbiAgICAgICAgJ3N5bWJvbC5tYXAnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9uZSBvZiB7eyNtYXB9fSdcbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdiaW5hcnknLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnc3RyaW5nJywgJ29iamVjdCddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBCdWZmZXIuZnJvbSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5lbmNvZGluZykgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2JpbmFyeS5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2VuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2JpbmFyeS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2JpbmFyeS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZycsXG4gICAgICAgICdiaW5hcnkubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gYnl0ZXMnXG4gICAgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5jb25zdCBNYW5pZmVzdCA9IHJlcXVpcmUoJy4vbWFuaWZlc3QnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi90cmFjZScpO1xuXG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdHlwZXM6IHtcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiByZXF1aXJlKCcuL3R5cGVzL2FsdGVybmF0aXZlcycpLFxuICAgICAgICBhbnk6IHJlcXVpcmUoJy4vdHlwZXMvYW55JyksXG4gICAgICAgIGFycmF5OiByZXF1aXJlKCcuL3R5cGVzL2FycmF5JyksXG4gICAgICAgIGJvb2xlYW46IHJlcXVpcmUoJy4vdHlwZXMvYm9vbGVhbicpLFxuICAgICAgICBkYXRlOiByZXF1aXJlKCcuL3R5cGVzL2RhdGUnKSxcbiAgICAgICAgZnVuY3Rpb246IHJlcXVpcmUoJy4vdHlwZXMvZnVuY3Rpb24nKSxcbiAgICAgICAgbGluazogcmVxdWlyZSgnLi90eXBlcy9saW5rJyksXG4gICAgICAgIG51bWJlcjogcmVxdWlyZSgnLi90eXBlcy9udW1iZXInKSxcbiAgICAgICAgb2JqZWN0OiByZXF1aXJlKCcuL3R5cGVzL29iamVjdCcpLFxuICAgICAgICBzdHJpbmc6IHJlcXVpcmUoJy4vdHlwZXMvc3RyaW5nJyksXG4gICAgICAgIHN5bWJvbDogcmVxdWlyZSgnLi90eXBlcy9zeW1ib2wnKVxuICAgIH0sXG4gICAgYWxpYXNlczoge1xuICAgICAgICBhbHQ6ICdhbHRlcm5hdGl2ZXMnLFxuICAgICAgICBib29sOiAnYm9vbGVhbicsXG4gICAgICAgIGZ1bmM6ICdmdW5jdGlvbidcbiAgICB9XG59O1xuXG5cbmlmIChCdWZmZXIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGludGVybmFscy50eXBlcy5iaW5hcnkgPSByZXF1aXJlKCcuL3R5cGVzL2JpbmFyeScpO1xufVxuXG5cbmludGVybmFscy5yb290ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgcm9vdCA9IHtcbiAgICAgICAgX3R5cGVzOiBuZXcgU2V0KE9iamVjdC5rZXlzKGludGVybmFscy50eXBlcykpXG4gICAgfTtcblxuICAgIC8vIFR5cGVzXG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygcm9vdC5fdHlwZXMpIHtcbiAgICAgICAgcm9vdFt0eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCghYXJncy5sZW5ndGggfHwgWydhbHRlcm5hdGl2ZXMnLCAnbGluaycsICdvYmplY3QnXS5pbmNsdWRlcyh0eXBlKSwgJ1RoZScsIHR5cGUsICd0eXBlIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBpbnRlcm5hbHMudHlwZXNbdHlwZV0sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNob3J0Y3V0c1xuXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgWydhbGxvdycsICdjdXN0b20nLCAnZGlzYWxsb3cnLCAnZXF1YWwnLCAnZXhpc3QnLCAnZm9yYmlkZGVuJywgJ2ludmFsaWQnLCAnbm90JywgJ29ubHknLCAnb3B0aW9uYWwnLCAnb3B0aW9ucycsICdwcmVmcycsICdwcmVmZXJlbmNlcycsICdyZXF1aXJlZCcsICdzdHJpcCcsICd2YWxpZCcsICd3aGVuJ10pIHtcbiAgICAgICAgcm9vdFttZXRob2RdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW55KClbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2RzXG5cbiAgICBPYmplY3QuYXNzaWduKHJvb3QsIGludGVybmFscy5tZXRob2RzKTtcblxuICAgIC8vIEFsaWFzZXNcblxuICAgIGZvciAoY29uc3QgYWxpYXMgaW4gaW50ZXJuYWxzLmFsaWFzZXMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaW50ZXJuYWxzLmFsaWFzZXNbYWxpYXNdO1xuICAgICAgICByb290W2FsaWFzXSA9IHJvb3RbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICByb290LnggPSByb290LmV4cHJlc3Npb247XG5cbiAgICAvLyBUcmFjZVxuXG4gICAgaWYgKFRyYWNlLnNldHVwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIFRyYWNlLnNldHVwKHJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xufTtcblxuXG5pbnRlcm5hbHMubWV0aG9kcyA9IHtcblxuICAgIFZhbGlkYXRpb25FcnJvcjogRXJyb3JzLlZhbGlkYXRpb25FcnJvcixcbiAgICB2ZXJzaW9uOiBDb21tb24udmVyc2lvbixcbiAgICBjYWNoZTogQ2FjaGUucHJvdmlkZXIsXG5cbiAgICBhc3NlcnQodmFsdWUsIHNjaGVtYSwgLi4uYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgIGludGVybmFscy5hc3NlcnQodmFsdWUsIHNjaGVtYSwgdHJ1ZSwgYXJncyk7XG4gICAgfSxcblxuICAgIGF0dGVtcHQodmFsdWUsIHNjaGVtYSwgLi4uYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIGZhbHNlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgYnVpbGQoZGVzYykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgTWFuaWZlc3QuYnVpbGQgPT09ICdmdW5jdGlvbicsICdNYW5pZmVzdCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBNYW5pZmVzdC5idWlsZCh0aGlzLCBkZXNjKTtcbiAgICB9LFxuXG4gICAgY2hlY2tQcmVmZXJlbmNlcyhwcmVmcykge1xuXG4gICAgICAgIENvbW1vbi5jaGVja1ByZWZlcmVuY2VzKHByZWZzKTtcbiAgICB9LFxuXG4gICAgY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5jb21waWxlKHRoaXMsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGRlZmF1bHRzKG1vZGlmaWVyKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RpZmllciA9PT0gJ2Z1bmN0aW9uJywgJ21vZGlmaWVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIGNvbnN0IGpvaSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygam9pLl90eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kaWZpZXIoam9pW3R5cGVdKCkpO1xuICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzY2hlbWEpLCAnbW9kaWZpZXIgbXVzdCByZXR1cm4gYSB2YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIGpvaVt0eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIHNjaGVtYSwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9LFxuXG4gICAgZXhwcmVzc2lvbiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZSguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kKC4uLmV4dGVuc2lvbnMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdChleHRlbnNpb25zLCAnZXh0ZW5kJyk7XG5cbiAgICAgICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICAgICAgQXNzZXJ0KGV4dGVuc2lvbnMubGVuZ3RoLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCBvbmUgZXh0ZW5zaW9uJyk7XG4gICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbnMsIFNjaGVtYXMuZXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gICAgICAgIGpvaS5fdHlwZXMgPSBuZXcgU2V0KGpvaS5fdHlwZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGV4dGVuc2lvbiBvZiBleHRlbnNpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihqb2kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFzc2VydChleHRlbnNpb24sIFNjaGVtYXMuZXh0ZW5zaW9uKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBpbnRlcm5hbHMuZXhwYW5kRXh0ZW5zaW9uKGV4dGVuc2lvbiwgam9pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChqb2lbaXRlbS50eXBlXSA9PT0gdW5kZWZpbmVkIHx8IGpvaS5fdHlwZXMuaGFzKGl0ZW0udHlwZSksICdDYW5ub3Qgb3ZlcnJpZGUgbmFtZScsIGl0ZW0udHlwZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gaXRlbS5iYXNlIHx8IHRoaXMuYW55KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gRXh0ZW5kLnR5cGUoYmFzZSwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBqb2kuX3R5cGVzLmFkZChpdGVtLnR5cGUpO1xuICAgICAgICAgICAgICAgIGpvaVtpdGVtLnR5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIHNjaGVtYSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGlzRXJyb3I6IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IuaXNFcnJvcixcbiAgICBpc0V4cHJlc3Npb246IFRlbXBsYXRlLmlzVGVtcGxhdGUsXG4gICAgaXNSZWY6IFJlZi5pc1JlZixcbiAgICBpc1NjaGVtYTogQ29tbW9uLmlzU2NoZW1hLFxuXG4gICAgaW4oLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuaW4oLi4uYXJncyk7XG4gICAgfSxcblxuICAgIG92ZXJyaWRlOiBDb21tb24uc3ltYm9scy5vdmVycmlkZSxcblxuICAgIHJlZiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlZi5jcmVhdGUoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIHR5cGVzKCkge1xuXG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0aGlzLl90eXBlcykge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSB0aGlzW3R5cGVdKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBpbiBpbnRlcm5hbHMuYWxpYXNlcykge1xuICAgICAgICAgICAgdHlwZXNbdGFyZ2V0XSA9IHRoaXNbdGFyZ2V0XSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbn07XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYXNzZXJ0ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIGFubm90YXRlLCBhcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gYXJnc1swXSBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBudWxsO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXNzYWdlICE9PSBudWxsID8gYXJnc1sxXSA6IGFyZ3NbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLnZhbGlkYXRlKHZhbHVlLCBDb21tb24ucHJlZmVyZW5jZXMoeyBlcnJvcnM6IHsgc3RhY2s6IHRydWUgfSB9LCBvcHRpb25zIHx8IHt9KSk7XG5cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwbGF5ID0gYW5ub3RhdGUgJiYgdHlwZW9mIGVycm9yLmFubm90YXRlID09PSAnZnVuY3Rpb24nID8gZXJyb3IuYW5ub3RhdGUoKSA6IGVycm9yLm1lc3NhZ2U7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yID09PSBmYWxzZSkge1xuICAgICAgICBlcnJvciA9IENsb25lKGVycm9yKTtcbiAgICB9XG5cbiAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZSA/IGAke21lc3NhZ2V9ICR7ZGlzcGxheX1gIDogZGlzcGxheTtcbiAgICB0aHJvdyBlcnJvcjtcbn07XG5cblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHJvb3QsIHNjaGVtYSwgYXJncykge1xuXG4gICAgQXNzZXJ0KHJvb3QsICdNdXN0IGJlIGludm9rZWQgb24gYSBKb2kgaW5zdGFuY2UuJyk7XG5cbiAgICBzY2hlbWEuJF9yb290ID0gcm9vdDtcblxuICAgIGlmICghc2NoZW1hLl9kZWZpbml0aW9uLmFyZ3MgfHxcbiAgICAgICAgIWFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLl9kZWZpbml0aW9uLmFyZ3Moc2NoZW1hLCAuLi5hcmdzKTtcbn07XG5cblxuaW50ZXJuYWxzLmV4cGFuZEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChleHRlbnNpb24sIGpvaSkge1xuXG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuZGVkID0gW107XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGpvaS5fdHlwZXMpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBleHRlbnNpb24pO1xuICAgICAgICAgICAgaXRlbS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIGl0ZW0uYmFzZSA9IGpvaVt0eXBlXSgpO1xuICAgICAgICAgICAgZXh0ZW5kZWQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmRlZDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMucm9vdCgpO1xuIiwgImltcG9ydCB7IGdlbmVyYXRlRXJyb3JSZXNwb25zZXMgfSBmcm9tICcuLi9zY2hlbWFzL2NvbW1vbi5qcydcbmltcG9ydCB7IEpvaSB9IGZyb20gJy4uL3NjaGVtYXMvdmFsaWRhdG9yLmpzJ1xuXG5jb25zdCBkb2N1bWVudGF0aW9uID0ge1xuICBzdW1tYXJ5OiAnSGVsbG8gMScsXG4gIHRhZ3M6IFsnSGVsbG8gT25lIFNlY3Rpb24nXSxcbiAgZGVzY3JpcHRpb246ICdIZWxsbyAxIHRlbXBsYXRlLicsXG4gIG1ldGhvZFJlc3BvbnNlczogW1xuICAgIHtcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogJ0FuIG9iamVjdCByZXR1cm5pbmcgaGVsbG8xOiB0cnVlLicsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnSGVsbG9PbmVTY2hlbWEnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIC4uLmdlbmVyYXRlRXJyb3JSZXNwb25zZXMoWzQwMCwgNDAxLCA0MDQsIDUwMF0sICdnZXR0aW5nIGhlbGxvIDEnKSxcbiAgXSxcbn1cblxuY29uc3Qgc2NoZW1hID0ge1xuICByZXNwb25zZTogSm9pLm9iamVjdCh7XG4gICAgaGVsbG8xOiBKb2kuYm9vbGVhbigpLnJlcXVpcmVkKCksXG4gIH0pLFxufVxuXG5jb25zdCBoYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBoZWxsbzE6IHRydWUsXG4gICAgfSksXG4gIH1cbn1cblxuZXhwb3J0IHsgZG9jdW1lbnRhdGlvbiwgaGFuZGxlciwgc2NoZW1hIH1cbiIsICIvKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGVycm9yIHJlc3BvbnNlcyBmb3IgYW4gZW5kcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyW119IHN0YXR1c0NvZGVzICAtIGxpc3Qgb2YgZXJyb3IgcmVzcG9uc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hlbiAtIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JSZXNwb25zZXMoc3RhdHVzQ29kZXMsIHdoZW4pIHtcbiAgY29uc3QgcmVzcG9uc2VzID0gW11cbiAgY29uc3QgcG9zdFRleHQgPSAnVGhlIGV4YW1wbGVzIHNob3cgYWxsIHBvc3NpYmxlIGBjb2RlYCBhbmQgYG1lc3NhZ2VgIHZhbHVlcywgbm90IGxpbWl0ZWQgdG8gdGhpcyBlbmRwb2ludC4nXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg0MDApKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQW4gZXJyb3IgbWVzc2FnZSB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdFcnJvclJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg0MDEpKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNDAxLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVW5hdXRob3Jpc2VkIHVzZXIgd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnVW5hdXRob3JpemVkUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwMykpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDMsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBGb3JiaWRkZW4gd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnRm9yYmlkZGVuUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwNCkpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDQsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBSZXNvdXJjZSBub3QgZm91bmQgd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnTm90Rm91bmRSZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RhdHVzQ29kZXMuaW5jbHVkZXMoNDI5KSkge1xuICAgIHJlc3BvbnNlcy5wdXNoKHtcbiAgICAgIHN0YXR1c0NvZGU6IDQyOSxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogYFJhdGUgbGltaXRlZCB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdSYXRlTGltaXRlZFJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg1MDApKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQSBzZXJ2ZXIgZXJyb3Igd2hlbiAke3doZW59LiAke3Bvc3RUZXh0fWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnU2VydmVyRXJyb3JSZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2VzXG59XG5cbmV4cG9ydCB7XG4gIGdlbmVyYXRlRXJyb3JSZXNwb25zZXMsXG59XG4iLCAiaW1wb3J0IEpvaURhdGUgZnJvbSAnQGpvaS9kYXRlJ1xuaW1wb3J0IEpvaUJhc2UgZnJvbSAnam9pJ1xuXG4vKiogQHR5cGUgeyBpbXBvcnQoXCJqb2lcIikuUm9vdCB9ICovXG5jb25zdCBKb2kgPSBKb2lCYXNlLmV4dGVuZChKb2lEYXRlKVxuXG5leHBvcnQgeyBKb2kgfVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFPQSxRQUFJLGVBQWUsbUVBQW1FLE1BQU0sRUFB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QUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFLQSxXQUFPLFVBQVUsSUFBSSxJQUFJLFVBQVUsS0FBSyxJQUFJLENBQUMsUUFBUSxJQUFJLFlBQVksQ0FBQyxDQUFDO0FBQUE7QUFBQTs7O0FDMzdDdkU7QUFBQTtBQUFBO0FBQUE7QUFFQSxRQUFNLFNBQVM7QUFDZixRQUFNLFNBQVM7QUFDZixRQUFNLFFBQVE7QUFDZCxRQUFNLEtBQUs7QUFDWCxRQUFNLGNBQWM7QUFDcEIsUUFBTSxPQUFPO0FBQ2IsUUFBTSxNQUFNO0FBRVos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QUFBLE1BQ3RCO0FBQUEsSUFDRjtBQUFBLElBQ0EsR0FBRyx1QkFBdUIsQ0FBQyxLQUFLLEtBQUssS0FBSyxHQUFHLEdBQUcsaUJBQWlCO0FBQUEsRUFDbkU7QUFDRjtBQUVBLElBQU0sU0FBUztBQUFBLEVBQ2IsVUFBVSxJQUFJLE9BQU87QUFBQSxJQUNuQixRQUFRLElBQUksUUFBUSxFQUFFLFNBQVM7QUFBQSxFQUNqQyxDQUFDO0FBQ0g7QUFFQSxJQUFNLFVBQVUsbUNBQVk7QUFDMUIsU0FBTztBQUFBLElBQ0wsWUFBWTtBQUFBLElBQ1osTUFBTSxLQUFLLFVBQVU7QUFBQSxNQUNuQixRQUFRO0FBQUEsSUFDVixDQUFDO0FBQUEsRUFDSDtBQUNGLEdBUGdCOyIsCiAgIm5hbWVzIjogWyJzb3VyY2VGaWxlIiwgIm5lZWRsZSIsICJzZWN0aW9uIiwgInBhdGgiLCAiZm9ybWF0IiwgImxvY2FsZSIsICJ0byIsICJmcm9tIiwgIm5vdyIsICJzaWduIiwgInRva2VuIiwgIm9yZGluYWwiLCAiaSIsICJkaWZmIiwgImxvY2FsZURhdGEiLCAiaG91cnMiLCAibWludXRlcyIsICJ0b2tlbnMiLCAibWVyaWRpZW0iLCAieWVhcnMiLCAibW9udGhzIiwgIndlZWtzIiwgImRheXMiLCAic2Vjb25kcyIsICJtaWxsaXNlY29uZHMiLCAib2Zmc2V0IiwgInRocmVzaG9sZHMiLCAic2NoZW1hIiwgIkpvaSIsICJyZXF1aXJlX2xpYiIsICJtZXNzYWdlIiwgInNjaGVtYSIsICJKb2kiLCAic2NoZW1hIiwgInJ1bGUiLCAic2NoZW1hIiwgInNjaGVtYSIsICJyZXF1aXJlX2xpYiIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgImlkIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9saWIiLCAic2NoZW1hIiwgImNsb25lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9lcnJvcnMiLCAic2NoZW1lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInJlcXVpcmVfbGliIiwgInNjaGVtYSIsICJKb2lCYXNlIiwgIkpvaURhdGUiXQp9Cg==
