import { createRequire as topLevelCreateRequire } from 'node:module';
import { fileURLToPath as rootFileURLToPath, URL as RootURL } from 'node:url';
const require = topLevelCreateRequire(import.meta.url);
const __filename = rootFileURLToPath(import.meta.url);
const __dirname = rootFileURLToPath(new RootURL('.', import.meta.url));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../node_modules/source-map/lib/base64.js"(exports) {
    init_register();
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../node_modules/source-map/lib/base64-vlq.js"(exports) {
    init_register();
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    __name(toVLQSigned, "toVLQSigned");
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    __name(fromVLQSigned, "fromVLQSigned");
    exports.encode = /* @__PURE__ */ __name(function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    }, "base64VLQ_encode");
    exports.decode = /* @__PURE__ */ __name(function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    }, "base64VLQ_decode");
  }
});

// ../node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../node_modules/source-map/lib/util.js"(exports) {
    init_register();
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    __name(getArg, "getArg");
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    __name(urlParse, "urlParse");
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    __name(urlGenerate, "urlGenerate");
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    __name(normalize, "normalize");
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    __name(join, "join");
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    __name(relative, "relative");
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    __name(identity, "identity");
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    __name(toSetString, "toSetString");
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    __name(fromSetString, "fromSetString");
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    __name(isProtoString, "isProtoString");
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByOriginalPositions, "compareByOriginalPositions");
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated");
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    __name(strcmp, "strcmp");
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated");
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    __name(parseSourceMapInput, "parseSourceMapInput");
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    __name(computeSourceURL, "computeSourceURL");
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../node_modules/source-map/lib/array-set.js"(exports) {
    init_register();
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    __name(ArraySet, "ArraySet");
    ArraySet.fromArray = /* @__PURE__ */ __name(function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    }, "ArraySet_fromArray");
    ArraySet.prototype.size = /* @__PURE__ */ __name(function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    }, "ArraySet_size");
    ArraySet.prototype.add = /* @__PURE__ */ __name(function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    }, "ArraySet_add");
    ArraySet.prototype.has = /* @__PURE__ */ __name(function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    }, "ArraySet_has");
    ArraySet.prototype.indexOf = /* @__PURE__ */ __name(function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    }, "ArraySet_indexOf");
    ArraySet.prototype.at = /* @__PURE__ */ __name(function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    }, "ArraySet_at");
    ArraySet.prototype.toArray = /* @__PURE__ */ __name(function ArraySet_toArray() {
      return this._array.slice();
    }, "ArraySet_toArray");
    exports.ArraySet = ArraySet;
  }
});

// ../node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../node_modules/source-map/lib/mapping-list.js"(exports) {
    init_register();
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    __name(generatedPositionAfter, "generatedPositionAfter");
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    __name(MappingList, "MappingList");
    MappingList.prototype.unsortedForEach = /* @__PURE__ */ __name(function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    }, "MappingList_forEach");
    MappingList.prototype.add = /* @__PURE__ */ __name(function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    }, "MappingList_add");
    MappingList.prototype.toArray = /* @__PURE__ */ __name(function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    }, "MappingList_toArray");
    exports.MappingList = MappingList;
  }
});

// ../node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../node_modules/source-map/lib/source-map-generator.js"(exports) {
    init_register();
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    __name(SourceMapGenerator, "SourceMapGenerator");
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = /* @__PURE__ */ __name(function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    }, "SourceMapGenerator_fromSourceMap");
    SourceMapGenerator.prototype.addMapping = /* @__PURE__ */ __name(function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    }, "SourceMapGenerator_addMapping");
    SourceMapGenerator.prototype.setSourceContent = /* @__PURE__ */ __name(function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    }, "SourceMapGenerator_setSourceContent");
    SourceMapGenerator.prototype.applySourceMap = /* @__PURE__ */ __name(function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    }, "SourceMapGenerator_applySourceMap");
    SourceMapGenerator.prototype._validateMapping = /* @__PURE__ */ __name(function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    }, "SourceMapGenerator_validateMapping");
    SourceMapGenerator.prototype._serializeMappings = /* @__PURE__ */ __name(function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    }, "SourceMapGenerator_serializeMappings");
    SourceMapGenerator.prototype._generateSourcesContent = /* @__PURE__ */ __name(function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    }, "SourceMapGenerator_generateSourcesContent");
    SourceMapGenerator.prototype.toJSON = /* @__PURE__ */ __name(function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    }, "SourceMapGenerator_toJSON");
    SourceMapGenerator.prototype.toString = /* @__PURE__ */ __name(function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    }, "SourceMapGenerator_toString");
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../node_modules/source-map/lib/binary-search.js"(exports) {
    init_register();
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    __name(recursiveSearch, "recursiveSearch");
    exports.search = /* @__PURE__ */ __name(function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    }, "search");
  }
});

// ../node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../node_modules/source-map/lib/quick-sort.js"(exports) {
    init_register();
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    __name(swap, "swap");
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    __name(randomIntInRange, "randomIntInRange");
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    __name(doQuickSort, "doQuickSort");
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../node_modules/source-map/lib/source-map-consumer.js"(exports) {
    init_register();
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    __name(SourceMapConsumer, "SourceMapConsumer");
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }, "get")
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }, "get")
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = /* @__PURE__ */ __name(function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    }, "SourceMapConsumer_charIsMappingSeparator");
    SourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    }, "SourceMapConsumer_parseMappings");
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = /* @__PURE__ */ __name(function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    }, "SourceMapConsumer_eachMapping");
    SourceMapConsumer.prototype.allGeneratedPositionsFor = /* @__PURE__ */ __name(function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    }, "SourceMapConsumer_allGeneratedPositionsFor");
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    __name(BasicSourceMapConsumer, "BasicSourceMapConsumer");
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = /* @__PURE__ */ __name(function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    }, "SourceMapConsumer_fromSourceMap");
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: /* @__PURE__ */ __name(function() {
        return this._absoluteSources.slice();
      }, "get")
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    __name(Mapping, "Mapping");
    BasicSourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    }, "SourceMapConsumer_parseMappings");
    BasicSourceMapConsumer.prototype._findMapping = /* @__PURE__ */ __name(function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    }, "SourceMapConsumer_findMapping");
    BasicSourceMapConsumer.prototype.computeColumnSpans = /* @__PURE__ */ __name(function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    }, "SourceMapConsumer_computeColumnSpans");
    BasicSourceMapConsumer.prototype.originalPositionFor = /* @__PURE__ */ __name(function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }, "SourceMapConsumer_originalPositionFor");
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = /* @__PURE__ */ __name(function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    }, "BasicSourceMapConsumer_hasContentsOfAllSources");
    BasicSourceMapConsumer.prototype.sourceContentFor = /* @__PURE__ */ __name(function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    }, "SourceMapConsumer_sourceContentFor");
    BasicSourceMapConsumer.prototype.generatedPositionFor = /* @__PURE__ */ __name(function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }, "SourceMapConsumer_generatedPositionFor");
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    __name(IndexedSourceMapConsumer, "IndexedSourceMapConsumer");
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: /* @__PURE__ */ __name(function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }, "get")
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    }, "IndexedSourceMapConsumer_originalPositionFor");
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    }, "IndexedSourceMapConsumer_hasContentsOfAllSources");
    IndexedSourceMapConsumer.prototype.sourceContentFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    }, "IndexedSourceMapConsumer_sourceContentFor");
    IndexedSourceMapConsumer.prototype.generatedPositionFor = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    }, "IndexedSourceMapConsumer_generatedPositionFor");
    IndexedSourceMapConsumer.prototype._parseMappings = /* @__PURE__ */ __name(function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    }, "IndexedSourceMapConsumer_parseMappings");
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../node_modules/source-map/lib/source-node.js"(exports) {
    init_register();
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    __name(SourceNode, "SourceNode");
    SourceNode.fromStringWithSourceMap = /* @__PURE__ */ __name(function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = /* @__PURE__ */ __name(function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
        __name(getNextLine, "getNextLine");
      }, "shiftNextLine");
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
      __name(addMappingWithCode, "addMappingWithCode");
    }, "SourceNode_fromStringWithSourceMap");
    SourceNode.prototype.add = /* @__PURE__ */ __name(function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    }, "SourceNode_add");
    SourceNode.prototype.prepend = /* @__PURE__ */ __name(function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    }, "SourceNode_prepend");
    SourceNode.prototype.walk = /* @__PURE__ */ __name(function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    }, "SourceNode_walk");
    SourceNode.prototype.join = /* @__PURE__ */ __name(function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    }, "SourceNode_join");
    SourceNode.prototype.replaceRight = /* @__PURE__ */ __name(function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    }, "SourceNode_replaceRight");
    SourceNode.prototype.setSourceContent = /* @__PURE__ */ __name(function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    }, "SourceNode_setSourceContent");
    SourceNode.prototype.walkSourceContents = /* @__PURE__ */ __name(function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    }, "SourceNode_walkSourceContents");
    SourceNode.prototype.toString = /* @__PURE__ */ __name(function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    }, "SourceNode_toString");
    SourceNode.prototype.toStringWithSourceMap = /* @__PURE__ */ __name(function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    }, "SourceNode_toStringWithSourceMap");
    exports.SourceNode = SourceNode;
  }
});

// ../node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../node_modules/source-map/source-map.js"(exports) {
    init_register();
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// ../node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "../node_modules/buffer-from/index.js"(exports, module) {
    init_register();
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    __name(isArrayBuffer, "isArrayBuffer");
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    __name(fromString, "fromString");
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    __name(bufferFrom, "bufferFrom");
    module.exports = bufferFrom;
  }
});

// ../node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "../node_modules/source-map-support/source-map-support.js"(exports, module) {
    init_register();
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var path = __require("path");
    var fs;
    try {
      fs = __require("fs");
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    __name(dynamicRequire, "dynamicRequire");
    var errorFormatterInstalled = false;
    var uncaughtShimInstalled = false;
    var emptyCacheBetweenOperations = false;
    var environment = "auto";
    var fileContentsCache = {};
    var sourceMapCache = {};
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    var retrieveFileHandlers = [];
    var retrieveMapHandlers = [];
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    __name(isInBrowser, "isInBrowser");
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    __name(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter");
    function globalProcessVersion() {
      if (typeof process === "object" && process !== null) {
        return process.version;
      } else {
        return "";
      }
    }
    __name(globalProcessVersion, "globalProcessVersion");
    function globalProcessStderr() {
      if (typeof process === "object" && process !== null) {
        return process.stderr;
      }
    }
    __name(globalProcessStderr, "globalProcessStderr");
    function globalProcessExit(code) {
      if (typeof process === "object" && process !== null && typeof process.exit === "function") {
        return process.exit(code);
      }
    }
    __name(globalProcessExit, "globalProcessExit");
    function handlerExec(list) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    __name(handlerExec, "handlerExec");
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      path2 = path2.trim();
      if (/^file:/.test(path2)) {
        path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : (
            // file:///C:/dir/file -> C:/dir/file
            "/"
          );
        });
      }
      if (path2 in fileContentsCache) {
        return fileContentsCache[path2];
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            false
          );
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path2)) {
          contents = fs.readFileSync(path2, "utf8");
        }
      } catch (er) {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file) return url;
      var dir = path.dirname(file);
      var match = /^\w+:\/\/[^\/]*/.exec(dir);
      var protocol = match ? match[0] : "";
      var startPath = dir.slice(protocol.length);
      if (protocol && /^\/\w\:/.test(startPath)) {
        protocol += "/";
        return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/");
      }
      return protocol + path.resolve(dir.slice(protocol.length), url);
    }
    __name(supportRelativeURL, "supportRelativeURL");
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(source);
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match;
      while (match = re.exec(fileData)) lastMatch = match;
      if (!lastMatch) return null;
      return lastMatch[1];
    }
    __name(retrieveSourceMapURL, "retrieveSourceMapURL");
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL) return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          };
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.sources.forEach(function(source, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                var url = supportRelativeURL(sourceMap.url, source);
                fileContentsCache[url] = contents;
              }
            });
          }
        } else {
          sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
        }
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null) {
          originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          );
          return originalPosition;
        }
      }
      return position;
    }
    __name(mapSourcePosition, "mapSourcePosition");
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match) {
        return "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")";
      }
      return origin;
    }
    __name(mapEvalOrigin, "mapEvalOrigin");
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    __name(CallSiteToString, "CallSiteToString");
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    __name(cloneCallSite, "cloneCallSite");
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    __name(wrapCallSite, "wrapCallSite");
    function prepareStackTrace(error, stack) {
      if (emptyCacheBetweenOperations) {
        fileContentsCache = {};
        sourceMapCache = {};
      }
      var name = error.name || "Error";
      var message = error.message || "";
      var errorString = name + ": " + message;
      var state = { nextPosition: null, curPosition: null };
      var processedStack = [];
      for (var i = stack.length - 1; i >= 0; i--) {
        processedStack.push("\n    at " + wrapCallSite(stack[i], state));
        state.nextPosition = state.curPosition;
      }
      state.curPosition = state.nextPosition = null;
      return errorString + processedStack.reverse().join("");
    }
    __name(prepareStackTrace, "prepareStackTrace");
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1];
        var line = +match[2];
        var column = +match[3];
        var contents = fileContentsCache[source];
        if (!contents && fs && fs.existsSync(source)) {
          try {
            contents = fs.readFileSync(source, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    __name(getErrorSource, "getErrorSource");
    function printErrorAndExit(error) {
      var source = getErrorSource(error);
      var stderr = globalProcessStderr();
      if (stderr && stderr._handle && stderr._handle.setBlocking) {
        stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error();
        console.error(source);
      }
      console.error(error.stack);
      globalProcessExit(1);
    }
    __name(printErrorAndExit, "printErrorAndExit");
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack;
          var hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners) {
            return printErrorAndExit(arguments[1]);
          }
        }
        return origEmit.apply(this, arguments);
      };
    }
    __name(shimEmitUncaughtException, "shimEmitUncaughtException");
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          retrieveFileHandlers.length = 0;
        }
        retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          retrieveMapHandlers.length = 0;
        }
        retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module, "module");
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            fileContentsCache[filename] = content;
            sourceMapCache[filename] = void 0;
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!emptyCacheBetweenOperations) {
        emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!errorFormatterInstalled) {
        errorFormatterInstalled = true;
        Error.prepareStackTrace = prepareStackTrace;
      }
      if (!uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          uncaughtShimInstalled = true;
          shimEmitUncaughtException();
        }
      }
    };
    exports.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0;
      retrieveMapHandlers.length = 0;
      retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
      retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);
      retrieveSourceMap = handlerExec(retrieveMapHandlers);
      retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// ../node_modules/source-map-support/register.js
var init_register = __esm({
  "../node_modules/source-map-support/register.js"() {
    require_source_map_support().install();
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module) {
    init_register();
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      __name(hooks, "hooks");
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      __name(setHookCallback, "setHookCallback");
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      __name(isArray, "isArray");
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      __name(isObject, "isObject");
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      __name(hasOwnProp, "hasOwnProp");
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      __name(isObjectEmpty, "isObjectEmpty");
      function isUndefined(input) {
        return input === void 0;
      }
      __name(isUndefined, "isUndefined");
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      __name(isNumber, "isNumber");
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      __name(isDate, "isDate");
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      __name(map, "map");
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      __name(extend, "extend");
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      __name(createUTC, "createUTC");
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      __name(defaultParsingFlags, "defaultParsingFlags");
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      __name(getParsingFlags, "getParsingFlags");
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = /* @__PURE__ */ __name(function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        }, "some");
      }
      function isValid(m) {
        var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m);
          parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m._isValid;
      }
      __name(isValid, "isValid");
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      __name(createInvalid, "createInvalid");
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      __name(copyConfig, "copyConfig");
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      __name(Moment, "Moment");
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      __name(isMoment, "isMoment");
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      __name(warn, "warn");
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      __name(deprecate, "deprecate");
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      __name(deprecateSimple, "deprecateSimple");
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      __name(isFunction, "isFunction");
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      __name(set, "set");
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      __name(mergeConfigs, "mergeConfigs");
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      __name(Locale, "Locale");
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = /* @__PURE__ */ __name(function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        }, "keys");
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      __name(calendar, "calendar");
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      __name(zeroFill, "zeroFill");
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = /* @__PURE__ */ __name(function() {
            return this[callback]();
          }, "func");
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      __name(addFormatToken, "addFormatToken");
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      __name(removeFormattingTokens, "removeFormattingTokens");
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      __name(makeFormatFunction, "makeFormatFunction");
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      __name(formatMoment, "formatMoment");
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        __name(replaceLongDateFormatTokens, "replaceLongDateFormatTokens");
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      __name(expandFormat, "expandFormat");
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      __name(longDateFormat, "longDateFormat");
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      __name(invalidDate, "invalidDate");
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      __name(ordinal, "ordinal");
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      __name(relativeTime, "relativeTime");
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      __name(pastFuture, "pastFuture");
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      __name(normalizeUnits, "normalizeUnits");
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      __name(normalizeObjectUnits, "normalizeObjectUnits");
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      __name(getPrioritizedUnits, "getPrioritizedUnits");
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      __name(addRegexToken, "addRegexToken");
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      __name(getParseRegexForToken, "getParseRegexForToken");
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      __name(unescapeFormat, "unescapeFormat");
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      __name(regexEscape, "regexEscape");
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      __name(absFloor, "absFloor");
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      __name(toInt, "toInt");
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = /* @__PURE__ */ __name(function(input, array) {
            array[callback] = toInt(input);
          }, "func");
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      __name(addParseToken, "addParseToken");
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      __name(addWeekParseToken, "addWeekParseToken");
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      __name(addTimeToArrayFromToken, "addTimeToArrayFromToken");
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      __name(isLeapYear, "isLeapYear");
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      __name(daysInYear, "daysInYear");
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      __name(getIsLeapYear, "getIsLeapYear");
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      __name(makeGetSet, "makeGetSet");
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case "Seconds":
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case "Minutes":
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case "Hours":
            return isUTC ? d.getUTCHours() : d.getHours();
          case "Date":
            return isUTC ? d.getUTCDate() : d.getDate();
          case "Day":
            return isUTC ? d.getUTCDay() : d.getDay();
          case "Month":
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case "FullYear":
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
        }
      }
      __name(get, "get");
      function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case "Hours":
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case "Date":
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          case "FullYear":
            break;
          default:
            return;
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
      }
      __name(set$1, "set$1");
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      __name(stringGet, "stringGet");
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      __name(stringSet, "stringSet");
      function mod(n, x) {
        return (n % x + x) % x;
      }
      __name(mod, "mod");
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = /* @__PURE__ */ __name(function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        }, "indexOf");
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      __name(daysInMonth, "daysInMonth");
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonths, "localeMonths");
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      __name(localeMonthsShort, "localeMonthsShort");
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse, "handleStrictParse");
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      __name(localeMonthsParse, "localeMonthsParse");
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        var month = value, date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      __name(setMonth, "setMonth");
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      __name(getSetMonth, "getSetMonth");
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      __name(getDaysInMonth, "getDaysInMonth");
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      __name(monthsShortRegex, "monthsShortRegex");
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      __name(monthsRegex, "monthsRegex");
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeMonthsParse, "computeMonthsParse");
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      __name(createDate, "createDate");
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      __name(createUTCDate, "createUTCDate");
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      __name(firstWeekOffset, "firstWeekOffset");
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      __name(dayOfYearFromWeeks, "dayOfYearFromWeeks");
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      __name(weekOfYear, "weekOfYear");
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      __name(weeksInYear, "weeksInYear");
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      __name(localeWeek, "localeWeek");
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      __name(localeFirstDayOfWeek, "localeFirstDayOfWeek");
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      __name(localeFirstDayOfYear, "localeFirstDayOfYear");
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetWeek, "getSetWeek");
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      __name(getSetISOWeek, "getSetISOWeek");
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      __name(parseWeekday, "parseWeekday");
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      __name(parseIsoWeekday, "parseIsoWeekday");
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      __name(shiftWeekdays, "shiftWeekdays");
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      __name(localeWeekdays, "localeWeekdays");
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      __name(localeWeekdaysShort, "localeWeekdaysShort");
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      __name(localeWeekdaysMin, "localeWeekdaysMin");
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      __name(handleStrictParse$1, "handleStrictParse$1");
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      __name(localeWeekdaysParse, "localeWeekdaysParse");
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      __name(getSetDayOfWeek, "getSetDayOfWeek");
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      __name(getSetLocaleDayOfWeek, "getSetLocaleDayOfWeek");
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      __name(getSetISODayOfWeek, "getSetISODayOfWeek");
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      __name(weekdaysRegex, "weekdaysRegex");
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      __name(weekdaysShortRegex, "weekdaysShortRegex");
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      __name(weekdaysMinRegex, "weekdaysMinRegex");
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        __name(cmpLenRev, "cmpLenRev");
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeWeekdaysParse, "computeWeekdaysParse");
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      __name(hFormat, "hFormat");
      function kFormat() {
        return this.hours() || 24;
      }
      __name(kFormat, "kFormat");
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      __name(meridiem, "meridiem");
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      __name(matchMeridiem, "matchMeridiem");
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      __name(localeIsPM, "localeIsPM");
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      __name(localeMeridiem, "localeMeridiem");
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      __name(commonPrefix, "commonPrefix");
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      __name(normalizeLocale, "normalizeLocale");
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      __name(chooseLocale, "chooseLocale");
      function isLocaleNameSane(name) {
        return !!(name && name.match("^[^/\\\\]*$"));
      }
      __name(isLocaleNameSane, "isLocaleNameSane");
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = __require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      __name(loadLocale, "loadLocale");
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      __name(getSetGlobalLocale, "getSetGlobalLocale");
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      __name(defineLocale, "defineLocale");
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      __name(updateLocale, "updateLocale");
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      __name(getLocale, "getLocale");
      function listLocales() {
        return keys(locales);
      }
      __name(listLocales, "listLocales");
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      __name(checkOverflow, "checkOverflow");
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      __name(configFromISO, "configFromISO");
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      __name(extractFromRFC2822Strings, "extractFromRFC2822Strings");
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      __name(untruncateYear, "untruncateYear");
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      __name(preprocessRFC2822, "preprocessRFC2822");
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      __name(checkWeekday, "checkWeekday");
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      __name(calculateOffset, "calculateOffset");
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      __name(configFromRFC2822, "configFromRFC2822");
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromString, "configFromString");
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      __name(defaults, "defaults");
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      __name(currentDateArray, "currentDateArray");
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      __name(configFromArray, "configFromArray");
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      __name(dayOfYearFromWeekInfo, "dayOfYearFromWeekInfo");
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      __name(configFromStringAndFormat, "configFromStringAndFormat");
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      __name(meridiemFixWrap, "meridiemFixWrap");
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      __name(configFromStringAndArray, "configFromStringAndArray");
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      __name(configFromObject, "configFromObject");
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      __name(createFromConfig, "createFromConfig");
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      __name(prepareConfig, "prepareConfig");
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      __name(configFromInput, "configFromInput");
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      __name(createLocalOrUTC, "createLocalOrUTC");
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      __name(createLocal, "createLocal");
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      __name(pickBy, "pickBy");
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      __name(min, "min");
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      __name(max, "max");
      var now = /* @__PURE__ */ __name(function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      }, "now");
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      __name(isDurationValid, "isDurationValid");
      function isValid$1() {
        return this._isValid;
      }
      __name(isValid$1, "isValid$1");
      function createInvalid$1() {
        return createDuration(NaN);
      }
      __name(createInvalid$1, "createInvalid$1");
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      __name(Duration, "Duration");
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      __name(isDuration, "isDuration");
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      __name(absRound, "absRound");
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      __name(compareArrays, "compareArrays");
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      __name(offset, "offset");
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      __name(offsetFromString, "offsetFromString");
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      __name(cloneWithOffset, "cloneWithOffset");
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      __name(getDateOffset, "getDateOffset");
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      __name(getSetOffset, "getSetOffset");
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      __name(getSetZone, "getSetZone");
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      __name(setOffsetToUTC, "setOffsetToUTC");
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      __name(setOffsetToLocal, "setOffsetToLocal");
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      __name(setOffsetToParsedOffset, "setOffsetToParsedOffset");
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      __name(hasAlignedHourOffset, "hasAlignedHourOffset");
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      __name(isDaylightSavingTime, "isDaylightSavingTime");
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      __name(isDaylightSavingTimeShifted, "isDaylightSavingTimeShifted");
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      __name(isLocal, "isLocal");
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      __name(isUtcOffset, "isUtcOffset");
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      __name(isUtc, "isUtc");
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      __name(createDuration, "createDuration");
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      __name(parseIso, "parseIso");
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      __name(positiveMomentsDifference, "positiveMomentsDifference");
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      __name(momentsDifference, "momentsDifference");
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      __name(createAdder, "createAdder");
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      __name(addSubtract, "addSubtract");
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      __name(isString, "isString");
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      __name(isMomentInput, "isMomentInput");
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isMomentInputObject, "isMomentInputObject");
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      __name(isNumberOrStringArray, "isNumberOrStringArray");
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      __name(isCalendarSpec, "isCalendarSpec");
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      __name(getCalendarFormat, "getCalendarFormat");
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      __name(calendar$1, "calendar$1");
      function clone() {
        return new Moment(this);
      }
      __name(clone, "clone");
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      __name(isAfter, "isAfter");
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      __name(isBefore, "isBefore");
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      __name(isBetween, "isBetween");
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      __name(isSame, "isSame");
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      __name(isSameOrAfter, "isSameOrAfter");
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      __name(isSameOrBefore, "isSameOrBefore");
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      __name(diff, "diff");
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      __name(monthDiff, "monthDiff");
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      __name(toString, "toString");
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      __name(toISOString, "toISOString");
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      __name(inspect, "inspect");
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      __name(format, "format");
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(from, "from");
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      __name(fromNow, "fromNow");
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      __name(to, "to");
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      __name(toNow, "toNow");
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      __name(locale, "locale");
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      __name(localeData, "localeData");
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      __name(mod$1, "mod$1");
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      __name(localStartOfDate, "localStartOfDate");
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      __name(utcStartOfDate, "utcStartOfDate");
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(startOf, "startOf");
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      __name(endOf, "endOf");
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      __name(valueOf, "valueOf");
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      __name(unix, "unix");
      function toDate() {
        return new Date(this.valueOf());
      }
      __name(toDate, "toDate");
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      __name(toArray, "toArray");
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      __name(toObject, "toObject");
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      __name(toJSON, "toJSON");
      function isValid$2() {
        return isValid(this);
      }
      __name(isValid$2, "isValid$2");
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      __name(parsingFlags, "parsingFlags");
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      __name(invalidAt, "invalidAt");
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      __name(creationData, "creationData");
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      __name(localeEras, "localeEras");
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      __name(localeErasParse, "localeErasParse");
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      __name(localeErasConvertYear, "localeErasConvertYear");
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      __name(getEraName, "getEraName");
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      __name(getEraNarrow, "getEraNarrow");
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      __name(getEraAbbr, "getEraAbbr");
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      __name(getEraYear, "getEraYear");
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      __name(erasNameRegex, "erasNameRegex");
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      __name(erasAbbrRegex, "erasAbbrRegex");
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      __name(erasNarrowRegex, "erasNarrowRegex");
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      __name(matchEraAbbr, "matchEraAbbr");
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      __name(matchEraName, "matchEraName");
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      __name(matchEraNarrow, "matchEraNarrow");
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      __name(matchEraYearOrdinal, "matchEraYearOrdinal");
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      __name(computeErasParse, "computeErasParse");
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      __name(addWeekYearFormatToken, "addWeekYearFormatToken");
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      __name(getSetWeekYear, "getSetWeekYear");
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      __name(getSetISOWeekYear, "getSetISOWeekYear");
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      __name(getISOWeeksInYear, "getISOWeeksInYear");
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      __name(getISOWeeksInISOWeekYear, "getISOWeeksInISOWeekYear");
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInYear, "getWeeksInYear");
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      __name(getWeeksInWeekYear, "getWeeksInWeekYear");
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      __name(getSetWeekYearHelper, "getSetWeekYearHelper");
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      __name(setWeekAll, "setWeekAll");
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      __name(getSetQuarter, "getSetQuarter");
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      __name(getSetDayOfYear, "getSetDayOfYear");
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      __name(parseMs, "parseMs");
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      __name(getZoneAbbr, "getZoneAbbr");
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      __name(getZoneName, "getZoneName");
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      __name(createUnix, "createUnix");
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      __name(createInZone, "createInZone");
      function preParsePostFormat(string) {
        return string;
      }
      __name(preParsePostFormat, "preParsePostFormat");
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      __name(get$1, "get$1");
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      __name(listMonthsImpl, "listMonthsImpl");
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      __name(listWeekdaysImpl, "listWeekdaysImpl");
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      __name(listMonths, "listMonths");
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      __name(listMonthsShort, "listMonthsShort");
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      __name(listWeekdays, "listWeekdays");
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      __name(listWeekdaysShort, "listWeekdaysShort");
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      __name(listWeekdaysMin, "listWeekdaysMin");
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: /* @__PURE__ */ __name(function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }, "ordinal")
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      __name(abs, "abs");
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      __name(addSubtract$1, "addSubtract$1");
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      __name(add$1, "add$1");
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      __name(subtract$1, "subtract$1");
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      __name(absCeil, "absCeil");
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      __name(bubble, "bubble");
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      __name(daysToMonths, "daysToMonths");
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      __name(monthsToDays, "monthsToDays");
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      __name(as, "as");
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      __name(makeAs, "makeAs");
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      __name(clone$1, "clone$1");
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      __name(get$2, "get$2");
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      __name(makeGetter, "makeGetter");
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      __name(weeks, "weeks");
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      __name(substituteTimeAgo, "substituteTimeAgo");
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      __name(relativeTime$1, "relativeTime$1");
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      __name(getSetRelativeTimeRounding, "getSetRelativeTimeRounding");
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      __name(getSetRelativeTimeThreshold, "getSetRelativeTimeThreshold");
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      __name(humanize, "humanize");
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      __name(sign, "sign");
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      __name(toISOString$1, "toISOString$1");
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/@joi/date/lib/index.js
var require_lib = __commonJS({
  "node_modules/@joi/date/lib/index.js"(exports, module) {
    "use strict";
    init_register();
    var Moment = require_moment();
    module.exports = (joi) => {
      const args = {
        format: joi.alternatives([
          joi.string(),
          joi.array().items(joi.string().invalid("iso", "javascript", "unix"))
        ])
      };
      return {
        type: "date",
        base: joi.date(),
        coerce: {
          from: "string",
          method: /* @__PURE__ */ __name(function(value, { schema: schema2 }) {
            const format = schema2.$_getFlag("format");
            if (!format) {
              return;
            }
            const date = schema2.$_getFlag("utc") ? Moment.utc(value, format, true) : Moment(value, format, true);
            if (date.isValid()) {
              return { value: date.toDate() };
            }
          }, "method")
        },
        rules: {
          utc: {
            method: /* @__PURE__ */ __name(function(enabled = true) {
              return this.$_setFlag("utc", enabled);
            }, "method")
          }
        },
        overrides: {
          format: /* @__PURE__ */ __name(function(format) {
            joi.attempt(format, args.format, "Invalid format");
            if (["iso", "javascript", "unix"].includes(format)) {
              return this.$_super.format(format);
            }
            return this.$_setFlag("format", format);
          }, "format")
        }
      };
    };
    module.exports.default = module.exports;
  }
});

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@hapi/hoek/lib/stringify.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/error.js
var require_error = __commonJS({
  "node_modules/@hapi/hoek/lib/error.js"(exports, module) {
    "use strict";
    init_register();
    var Stringify = require_stringify();
    module.exports = class extends Error {
      constructor(args) {
        const msgs = args.filter((arg) => arg !== "").map((arg) => {
          return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });
        super(msgs.join(" ") || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, exports.assert);
        }
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS({
  "node_modules/@hapi/hoek/lib/assert.js"(exports, module) {
    "use strict";
    init_register();
    var AssertError = require_error();
    module.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      throw new AssertError(args);
    };
  }
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS({
  "node_modules/@hapi/hoek/lib/reach.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var internals = {};
    module.exports = function(obj, chain, options) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number = Number(key);
          if (Number.isInteger(number)) {
            key = number < 0 ? ref.length + number : number;
          }
        }
        if (!ref || typeof ref === "function" && options.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS({
  "node_modules/@hapi/hoek/lib/types.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    exports = module.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports.error],
      ["[object Map]", exports.map],
      ["[object Promise]", exports.promise],
      ["[object Set]", exports.set],
      ["[object WeakMap]", exports.weakMap],
      ["[object WeakSet]", exports.weakSet]
    ]);
    exports.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports.buffer;
      }
      if (obj instanceof Date) {
        return exports.date;
      }
      if (obj instanceof RegExp) {
        return exports.regex;
      }
      if (obj instanceof Error) {
        return exports.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports.generic;
    };
  }
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@hapi/hoek/lib/utils.js"(exports) {
    "use strict";
    init_register();
    exports.keys = function(obj, options = {}) {
      return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS({
  "node_modules/@hapi/hoek/lib/clone.js"(exports, module) {
    "use strict";
    init_register();
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
    };
    module.exports = internals.clone = function(obj, options = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone = internals.clone;
      let seen = _seen;
      if (options.shallow) {
        if (options.shallow !== true) {
          return internals.cloneWithShallow(obj, options);
        }
        clone = /* @__PURE__ */ __name((value) => value, "clone");
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);
      }
      if (baseProto === Types.date) {
        return new Date(obj.getTime());
      }
      if (baseProto === Types.regex) {
        return new RegExp(obj);
      }
      const newObj = internals.base(obj, baseProto, options);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone(value, options, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone(value, options, seen));
        }
      }
      const keys = Utils.keys(obj, options);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone(obj[key], options, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone(obj[key], options, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options) {
      const keys = options.shallow;
      options = Object.assign({}, options);
      options.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options, seen);
    };
    internals.base = function(obj, baseProto, options) {
      if (options.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto = Object.getPrototypeOf(obj);
      if (proto && proto.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      return Object.create(proto);
    };
  }
});

// node_modules/joi/package.json
var require_package = __commonJS({
  "node_modules/joi/package.json"(exports, module) {
    module.exports = {
      name: "joi",
      description: "Object schema validation",
      version: "17.13.1",
      repository: "git://github.com/hapijs/joi",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/hoek": "^9.3.0",
        "@hapi/topo": "^5.1.0",
        "@sideway/address": "^4.1.5",
        "@sideway/formula": "^3.0.1",
        "@sideway/pinpoint": "^2.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "2.x.x",
        "@hapi/code": "8.x.x",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
        "@hapi/lab": "^25.1.3",
        "@types/node": "^14.18.63",
        typescript: "4.3.x"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L -Y",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/joi/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/joi/lib/schemas.js"(exports) {
    "use strict";
    init_register();
    var Joi2 = require_lib5();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      artifacts: Joi2.boolean(),
      cache: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      debug: Joi2.boolean(),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap,
          string: internals.wrap
        }
      },
      externals: Joi2.boolean(),
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi2.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi2.object({
      alias: Joi2.array().items(Joi2.string().pattern(internals.nameRx)).single(),
      args: Joi2.array().items(
        Joi2.string(),
        Joi2.object({
          name: Joi2.string().pattern(internals.nameRx).required(),
          ref: Joi2.boolean(),
          assert: Joi2.alternatives([
            Joi2.function(),
            Joi2.object().schema()
          ]).conditional("ref", { is: true, then: Joi2.required() }),
          normalize: Joi2.function(),
          message: Joi2.string().when("assert", { is: Joi2.function(), then: Joi2.required() })
        })
      ),
      convert: Joi2.boolean(),
      manifest: Joi2.boolean(),
      method: Joi2.function().allow(false),
      multi: Joi2.boolean(),
      validate: Joi2.function()
    });
    exports.extension = Joi2.object({
      type: Joi2.alternatives([
        Joi2.string(),
        Joi2.object().regex()
      ]).required(),
      args: Joi2.function(),
      cast: Joi2.object().pattern(internals.nameRx, Joi2.object({
        from: Joi2.function().maxArity(1).required(),
        to: Joi2.function().minArity(1).maxArity(2).required()
      })),
      base: Joi2.object().schema().when("type", { is: Joi2.object().regex(), then: Joi2.forbidden() }),
      coerce: [
        Joi2.function().maxArity(3),
        Joi2.object({ method: Joi2.function().maxArity(3).required(), from: Joi2.array().items(Joi2.string()).single() })
      ],
      flags: Joi2.object().pattern(internals.nameRx, Joi2.object({
        setter: Joi2.string(),
        default: Joi2.any()
      })),
      manifest: {
        build: Joi2.function().arity(2)
      },
      messages: [Joi2.object(), Joi2.string()],
      modifiers: Joi2.object().pattern(internals.nameRx, Joi2.function().minArity(1).maxArity(2)),
      overrides: Joi2.object().pattern(internals.nameRx, Joi2.function()),
      prepare: Joi2.function().maxArity(3),
      rebuild: Joi2.function().arity(1),
      rules: Joi2.object().pattern(internals.nameRx, internals.rule),
      terms: Joi2.object().pattern(internals.nameRx, Joi2.object({
        init: Joi2.array().allow(null).required(),
        manifest: Joi2.object().pattern(/.+/, [
          Joi2.valid("schema", "single"),
          Joi2.object({
            mapped: Joi2.object({
              from: Joi2.string().required(),
              to: Joi2.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi2.function().maxArity(3)
    }).strict();
    exports.extensions = Joi2.array().items(Joi2.object(), Joi2.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi2.object({
        buffer: Joi2.string()
      }),
      func: Joi2.object({
        function: Joi2.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi2.object({
        override: true
      }),
      ref: Joi2.object({
        ref: Joi2.object({
          type: Joi2.valid("value", "global", "local"),
          path: Joi2.array().required(),
          separator: Joi2.string().length(1).allow(false),
          ancestor: Joi2.number().min(0).integer().allow("root"),
          map: Joi2.array().items(Joi2.array().length(2)).min(1),
          adjust: Joi2.function(),
          iterables: Joi2.boolean(),
          in: Joi2.boolean(),
          render: Joi2.boolean()
        }).required()
      }),
      regex: Joi2.object({
        regex: Joi2.string().min(3)
      }),
      special: Joi2.object({
        special: Joi2.valid("deep").required()
      }),
      template: Joi2.object({
        template: Joi2.string().required(),
        options: Joi2.object()
      }),
      value: Joi2.object({
        value: Joi2.alternatives([Joi2.object(), Joi2.array()]).required()
      })
    };
    internals.desc.entity = Joi2.alternatives([
      Joi2.array().items(Joi2.link("...")),
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number(),
      Joi2.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi2.link("/")
    ]);
    internals.desc.values = Joi2.array().items(
      null,
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number().allow(Infinity, -Infinity),
      Joi2.string().allow(""),
      Joi2.symbol(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.override,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.template,
      internals.desc.value
    );
    internals.desc.messages = Joi2.object().pattern(/.+/, [
      Joi2.string(),
      internals.desc.template,
      Joi2.object().pattern(/.+/, [Joi2.string(), internals.desc.template])
    ]);
    exports.description = Joi2.object({
      type: Joi2.string().required(),
      flags: Joi2.object({
        cast: Joi2.string(),
        default: Joi2.any(),
        description: Joi2.string(),
        empty: Joi2.link("/"),
        failover: internals.desc.entity,
        id: Joi2.string(),
        label: Joi2.string(),
        only: true,
        presence: ["optional", "required", "forbidden"],
        result: ["raw", "strip"],
        strip: Joi2.boolean(),
        unit: Joi2.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi2.boolean(),
        abortEarly: Joi2.boolean(),
        artifacts: Joi2.boolean(),
        cache: Joi2.boolean(),
        convert: Joi2.boolean(),
        dateFormat: ["date", "iso", "string", "time", "utc"],
        errors: {
          escapeHtml: Joi2.boolean(),
          label: ["path", "key"],
          language: [
            Joi2.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi2.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi2.boolean(),
        nonEnumerables: Joi2.boolean(),
        presence: ["required", "optional", "forbidden"],
        skipFunctions: Joi2.boolean(),
        stripUnknown: Joi2.object({
          arrays: Joi2.boolean(),
          objects: Joi2.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi2.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi2.array().min(1).items({
        name: Joi2.string().required(),
        args: Joi2.object().min(1),
        keep: Joi2.boolean(),
        message: [
          Joi2.string(),
          internals.desc.messages
        ],
        warn: Joi2.boolean()
      }),
      // Terms
      keys: Joi2.object().pattern(/.*/, Joi2.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi2.any());
  }
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeHtml.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    module.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || // a-z
        i >= 65 && i <= 90 || // A-Z
        i >= 48 && i <= 57 || // 0-9
        i === 32 || // space
        i === 46 || // .
        i === 44 || // ,
        i === 45 || // -
        i === 58 || // :
        i === 95) {
          safe.add(i);
        }
      }
      return safe;
    }();
  }
});

// node_modules/@sideway/formula/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@sideway/formula/lib/index.js"(exports) {
    "use strict";
    init_register();
    var internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports.Parser = class {
      constructor(string, options = {}) {
        if (!options[internals.settings] && options.constants) {
          for (const constant in options.constants) {
            const value = options.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;
        this._parts = null;
        this._parse(string);
      }
      _parse(string) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = /* @__PURE__ */ __name((inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        }, "flush");
        for (const c of string) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i) => {
          if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = /* @__PURE__ */ __name(() => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
            }
            args.push(current);
            current = "";
          }, "flush");
          for (let i = 0; i < string.length; ++i) {
            const c = string[i];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i = parts.length - 2; i >= 0; --i) {
          const part = parts[i];
          if (part && part.type === "operator") {
            const current = parts[i + 1];
            parts.splice(i + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i = 1; i < parts.length - 1; ) {
            if (set.includes(parts[i])) {
              const operator = parts[i];
              const left = internals.evaluate(parts[i - 1], context);
              const right = internals.evaluate(parts[i + 1], context);
              parts.splice(i, 2);
              const result = internals.calculate(operator, left, right);
              parts[i - 1] = result === 0 ? 0 : result;
            } else {
              i += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});

// node_modules/joi/lib/annotate.js
var require_annotate = __commonJS({
  "node_modules/joi/lib/annotate.js"(exports) {
    "use strict";
    init_register();
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = /* @__PURE__ */ __name((key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      }, "cycleReplacer");
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/joi/lib/errors.js
var require_errors = __commonJS({
  "node_modules/joi/lib/errors.js"(exports) {
    "use strict";
    init_register();
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports.Report = class {
      constructor(code, value, local, flags, messages, state, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code) {
        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
      }
    };
    exports.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports.template = function(value, messages, code, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang]) {
        if (messages[lang][code] !== void 0) {
          return messages[lang][code];
        }
        if (messages[lang]["*"] !== void 0) {
          return messages[lang]["*"];
        }
      }
      if (!messages[code]) {
        return messages["*"];
      }
      return messages[code];
    };
    exports.label = function(flags, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      if (flags.label) {
        return flags.label;
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports.path(path);
      if (normalized) {
        return normalized;
      }
      return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
    };
    exports.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports.details = function(errors, options = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports.ValidationError;
      }
    };
    exports.ValidationError.prototype.isJoi = true;
    exports.ValidationError.prototype.name = "ValidationError";
    exports.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/joi/lib/ref.js
var require_ref = __commonJS({
  "node_modules/joi/lib/ref.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports.in = function(key, options = {}) {
      return exports.create(key, { ...options, in: true });
    };
    exports.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
      }
      _resolve(target, state, options) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = { path: this.path };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [...this.map];
        }
        for (const key of ["adjust", "iterables", "render"]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return { ref };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports.toSibling = 0;
    exports.toParent = 1;
    exports.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || require_template();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/joi/lib/template.js
var require_template = __commonJS({
  "node_modules/joi/lib/template.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Formula = require_lib2();
    var Common = require_common();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module.exports = exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options) {
          const { functions, ...opts } = options;
          this._settings = Object.keys(opts).length ? Clone(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date);
      }
      describe(options = {}) {
        if (!this._settings && options.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state, prefs, local);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state,
              prefs,
              local,
              options
              /*] */
            );
            const string = internals.stringify(rendered, value, state, prefs, local, options);
            if (string !== void 0) {
              const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = /* @__PURE__ */ __name((variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => {
            const resolved = ref.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        }, "reference");
        try {
          const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
          var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref = refs[0];
            return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string) {
      return string.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string) {
      return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string.length; ++i) {
        const char = string[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string.length && string[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state, prefs, local, options = {}) {
      const type = typeof value;
      const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
      }
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return internals.wrap(value, options.arrayItems && wrap.string);
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values = [];
      for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
      }
      return internals.wrap(values.join(", "), !skipWrap && wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code) {
        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local, options);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});

// node_modules/joi/lib/messages.js
var require_messages = __commonJS({
  "node_modules/joi/lib/messages.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports.decompile = function(messages) {
      const target = {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code] = message.describe({ compact: true });
          continue;
        }
        const language = code;
        target[language] = {};
        for (code in message) {
          const localized = message[code];
          if (code === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports.merge = function(base, extended) {
      if (!base) {
        return exports.compile(extended);
      }
      if (!extended) {
        return base;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/common.js
var require_common = __commonJS({
  "node_modules/joi/lib/common.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var AssertError = require_error();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports.version = Pkg.version;
    exports.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports.assertOptions = function(options, keys, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports.isIsoDate = function(date) {
      return internals.isoDate.test(date);
    };
    exports.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports.symbols.ref] || obj[exports.symbols.template];
    };
    exports.isSchema = function(schema2, options = {}) {
      const any = schema2 && schema2[exports.symbols.any];
      if (!any) {
        return false;
      }
      Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports.isValues = function(obj) {
      return obj[exports.symbols.values];
    };
    exports.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports.symbols.prefs];
      return merged;
    };
    exports.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports.validateArg = function(value, label, { assert, message }) {
      if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/joi/lib/cache.js
var require_cache = __commonJS({
  "node_modules/joi/lib/cache.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
    };
    exports.provider = {
      provision(options) {
        return new internals.Cache(options);
      }
    };
    internals.Cache = class {
      constructor(options = {}) {
        Common.assertOptions(options, ["max"]);
        Assert(options.max === void 0 || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
        this._max = options.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return Clone(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});

// node_modules/joi/lib/compile.js
var require_compile = __commonJS({
  "node_modules/joi/lib/compile.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.schema = function(Joi2, config, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config, options) {
      Assert(config !== void 0, "Invalid undefined schema");
      if (Array.isArray(config)) {
        Assert(config.length, "Invalid empty array schema");
        if (config.length === 1) {
          config = config[0];
        }
      }
      const valid = /* @__PURE__ */ __name((base, ...values) => {
        if (options.override !== false) {
          return base.valid(Joi2.override, ...values);
        }
        return base.valid(...values);
      }, "valid");
      if (internals.simple(config)) {
        return valid(Joi2, config);
      }
      if (typeof config === "function") {
        return Joi2.custom(config);
      }
      Assert(typeof config === "object", "Invalid schema content:", typeof config);
      if (Common.isResolvable(config)) {
        return valid(Joi2, config);
      }
      if (Common.isSchema(config)) {
        return config;
      }
      if (Array.isArray(config)) {
        for (const item of config) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config);
          }
        }
        return valid(Joi2, ...config);
      }
      if (config instanceof RegExp) {
        return Joi2.string().regex(config);
      }
      if (config instanceof Date) {
        return valid(Joi2.date(), config);
      }
      Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config);
    };
    exports.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports.compile = function(root, schema2, options = {}) {
      Common.assertOptions(options, ["legacy"]);
      const any = schema2 && schema2[Common.symbols.any];
      if (any) {
        Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema2;
      }
      if (typeof schema2 !== "object" || !options.legacy) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      const compiler = internals.walk(schema2);
      if (!compiler) {
        return exports.schema(root, schema2, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema2);
    };
    internals.walk = function(schema2) {
      if (typeof schema2 !== "object") {
        return null;
      }
      if (Array.isArray(schema2)) {
        for (const item of schema2) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any = schema2[Common.symbols.any];
      if (any) {
        return { root: schema2[any.root], compile: any.compile };
      }
      Assert(Object.getPrototypeOf(schema2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema2) {
        const compiler = internals.walk(schema2[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports.when = function(schema2, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema2, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema2.$_compile(rule2.is) : schema2.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema2, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema2.$_compile(test.is),
          then: schema2.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema2.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema2, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema2.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/joi/lib/extend.js
var require_extend = __commonJS({
  "node_modules/joi/lib/extend.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var internals = {};
    exports.type = function(from, options) {
      const base = Object.getPrototypeOf(from);
      const prototype = Clone(base);
      const schema2 = from._assign(Object.create(prototype));
      const def = Object.assign({}, options);
      delete def.base;
      prototype._definition = def;
      const parent = base._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema2.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema2.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema2.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = /* @__PURE__ */ __name(function() {
              return this.$_addRule(name);
            }, "method");
          }
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = /* @__PURE__ */ __name(function(arg) {
            return this.rule({ [name]: arg });
          }, "method");
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base;
        schema2.$_super = {};
        for (const override in def.overrides) {
          Assert(base[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base[override];
          schema2.$_super[override] = base[override].bind(schema2);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest = Object.assign({}, parent.manifest, def.manifest);
      manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema2;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema2) {
        parent(schema2);
        child(schema2);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});

// node_modules/joi/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/joi/lib/manifest.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    var Ref = require_ref();
    var Template = require_template();
    var Schemas;
    var internals = {};
    exports.describe = function(schema2) {
      const def = schema2._definition;
      const desc = {
        type: schema2.type,
        flags: {},
        rules: []
      };
      for (const flag in schema2._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema2._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema2._preferences) {
        desc.preferences = Clone(schema2._preferences, { shallow: ["messages"] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema2._valids) {
        desc.allow = schema2._valids.describe();
      }
      if (schema2._invalids) {
        desc.invalid = schema2._invalids.describe();
      }
      for (const rule of schema2._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = { name: rule.name };
        for (const custom in def.modifiers) {
          if (rule[custom] !== void 0) {
            item[custom] = internals.describe(rule[custom]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, { assign: key });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema2.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema2.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [...items.entries()];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        Assert(def.terms[term], "Term", term, "missing configuration");
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from, to } = manifest.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from];
          }
          continue;
        }
        if (manifest === "single") {
          Assert(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema2.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return { special: "deep" };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options.assign === "options") {
        return Clone(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return { buffer: item.toString("binary") };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options.assign === "regex") {
          return item.toString();
        }
        return { regex: item.toString() };
      }
      if (item[Common.symbols.literal]) {
        return { function: item.literal };
      }
      if (typeof item.describe === "function") {
        if (options.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, { assign: key });
      }
      return normalized;
    };
    exports.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema2 = this.joi[desc.type]()._bare();
        const def = schema2._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            Assert(typeof schema2[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema2 = schema2[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema2 = schema2.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema2 = schema2.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema2 = schema2.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            Assert(typeof schema2[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], { assign: key });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema2 = schema2[rule.name](...args);
            const options = {};
            for (const custom in def.modifiers) {
              if (rule[custom] !== void 0) {
                options[custom] = this.build(rule[custom]);
              }
            }
            if (Object.keys(options).length) {
              schema2 = schema2.rule(options);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
            continue;
          }
          Assert(def.terms[key], "Term", key, "missing configuration");
          const manifest = def.terms[key].manifest;
          if (manifest === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema2 = def.manifest.build(schema2, terms);
        schema2.$_temp.ruleset = false;
        return schema2;
      }
      build(desc, options = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options.assign === "options") {
          return Clone(desc);
        }
        if (options.assign === "regex") {
          return internals.regex(desc);
        }
        if (options.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            Assert(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return { [Common.symbols.literal]: true, literal: desc.function };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return Clone(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], { assign: key });
        }
        return normalized;
      }
    };
    internals.regex = function(string) {
      const end = string.lastIndexOf("/");
      const exp = string.slice(1, end);
      const flags = string.slice(end + 1);
      return new RegExp(exp, flags);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas();
      joi.assert(desc, Schemas.description);
    };
  }
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS({
  "node_modules/@hapi/hoek/lib/deepEqual.js"(exports, module) {
    "use strict";
    init_register();
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module.exports = function(obj, ref, options) {
      options = Object.assign({ prototype: true }, options);
      return !!internals.isDeepEqual(obj, ref, options, []);
    };
    internals.isDeepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
          return obj === ref;
        case Types.regex:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i = 0; i < obj.length; ++i) {
            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options.skip && options.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      if (!options.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options.skip || !options.skip.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});

// node_modules/@sideway/pinpoint/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@sideway/pinpoint/lib/index.js"(exports) {
    "use strict";
    init_register();
    exports.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});

// node_modules/joi/lib/trace.js
var require_trace = __commonJS({
  "node_modules/joi/lib/trace.js"(exports) {
    "use strict";
    init_register();
    var DeepEqual = require_deepEqual();
    var Pinpoint = require_lib3();
    var Errors = require_errors();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports.setup = function(root) {
      const trace = /* @__PURE__ */ __name(function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      }, "trace");
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports.location = function(schema2) {
      return schema2.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema2) {
        const existing = this._schemas.get(schema2);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema2);
        const { filename, line } = schema2._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema2, { filename, line, store });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file && file !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema2, log] of store._sources.entries()) {
            if (internals.sub(log.paths, skipped)) {
              continue;
            }
            if (!log.entry) {
              missing.push({
                status: "never reached",
                paths: [...log.paths]
              });
              skipped.push(...log.paths);
              continue;
            }
            for (const type of ["valid", "invalid"]) {
              const set = schema2[`_${type}s`];
              if (!set) {
                continue;
              }
              const values = new Set(set._values);
              const refs = new Set(set._refs);
              for (const { value, ref } of log[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [...values, ...[...refs].map((ref) => ref.display)],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema2._rules.map((rule) => rule.name);
            for (const type of ["default", "failover"]) {
              if (schema2._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log.rule[name] || 0];
              if (status) {
                const report = { rule: name, status };
                if (log.paths.size) {
                  report.paths = [...log.paths];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema2) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema2);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
      }
      entry(schema2, state) {
        internals.debug(state, { type: "entry" });
        this._record(schema2, (log) => {
          log.entry = true;
        });
      }
      filter(schema2, state, source, value) {
        internals.debug(state, { type: source, ...value });
        this._record(schema2, (log) => {
          log[source].add(value);
        });
      }
      log(schema2, state, source, name, result) {
        internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
        this._record(schema2, (log) => {
          log[source][name] = log[source][name] || 0;
          log[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log = { type: "resolve", ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
      }
      value(state, by, from, to, name) {
        if (!state.mainstay.debug || DeepEqual(from, to)) {
          return;
        }
        const log = { type: "value", by, from, to, path: state.path };
        if (name) {
          log.name = name;
        }
        state.mainstay.debug.push(log);
      }
      _record(schema2, each) {
        const log = this._sources.get(schema2);
        if (log) {
          each(log);
          return;
        }
        const sources = this._combos.get(schema2);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema2, _path) {
        const path = _path || [];
        let log = this._sources.get(schema2);
        if (!log) {
          log = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema2, log);
        }
        if (path.length) {
          log.paths.add(path);
        }
        const each = /* @__PURE__ */ __name((sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path.concat(subId));
        }, "each");
        schema2.$_modify({ each, ref: false });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema2, { source, name, path, key }) {
      if (schema2._flags.id) {
        return schema2._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [name, path[Math.min(path.length - 1, 1)]];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path of paths) {
        for (const skip of skipped) {
          if (DeepEqual(path.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS({
  "node_modules/@hapi/hoek/lib/merge.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module.exports = internals.merge = function(target, source, options) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options.mergeArrays) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(Clone(source[i], { symbols: options.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options.symbols });
          } else {
            internals.merge(target[key], value, options);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/joi/lib/modify.js
var require_modify = __commonJS({
  "node_modules/joi/lib/modify.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        if (!node) {
          return [...behind, ...path].join(".");
        }
        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema2, { key } = {}) {
        if (!schema2 || !Common.isSchema(schema2)) {
          return;
        }
        if (schema2.$_property("schemaChain") || schema2._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema2._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema2, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema: schema2, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema: schema2, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        nodes = [node, ...nodes];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema2, id, replacement) {
      const each = /* @__PURE__ */ __name((item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      }, "each");
      const obj = exports.schema(schema2, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema2;
    };
    exports.schema = function(schema2, options) {
      let obj;
      for (const name in schema2._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema2._rules.length; ++i) {
        const rule = schema2._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          const clone = Object.assign({}, rule);
          clone.args = result;
          obj._rules[i] = clone;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone);
          }
        }
      }
      for (const name in schema2.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema2.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema2.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.source === "terms" && source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone = clone || item.slice();
            clone[i] = result;
          }
        }
        return clone;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone = clone || Object.assign({}, item);
          clone[key] = result;
        }
      }
      return clone;
    };
  }
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS({
  "node_modules/@hapi/hoek/lib/ignore.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function() {
    };
  }
});

// node_modules/joi/lib/state.js
var require_state = __commonJS({
  "node_modules/joi/lib/state.js"(exports, module) {
    "use strict";
    init_register();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path, ancestors = null, schema2 = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema2 && state.schemas) {
          state.schemas = [internals.schemas(schema2), ...state.schemas];
        }
        return state;
      }
      nest(schema2, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema2), ...state.schemas];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
        this.mainstay.snapshot();
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.restore();
      }
      commit() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.commit();
      }
    };
    internals.schemas = function(schema2) {
      if (Common.isSchema(schema2)) {
        return { schema: schema2 };
      }
      return schema2;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
          const segment = path[i];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, { iterables: true });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/joi/lib/validator.js
var require_validator = __commonJS({
  "node_modules/joi/lib/validator.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Ignore = require_ignore();
    var Reach = require_reach();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports.entry = function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        Assert(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        Assert(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports.entryAsync = async function(value, schema2, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema2, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
          const path = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node = root;
          let key;
          let parent;
          const ancestors = path.length ? [root] : [];
          const original = path.length ? Reach(value, path) : value;
          if (path.length) {
            key = path[path.length - 1];
            let current = root;
            for (const segment of path.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node = parent[key];
          }
          try {
            const createError = /* @__PURE__ */ __name((code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings), "createError");
            const output = await external.method(node, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: /* @__PURE__ */ __name((code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)), "warn"),
              message: /* @__PURE__ */ __name((messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages }), "message")
            });
            if (output === void 0 || output === node) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors.length) {
          result.error = Errors.process(errors, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema2, prefs) {
      const { tracer, cleanup } = internals.tracer(schema2, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema2._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas = schema2._ids._schemaChain ? [{ schema: schema2 }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports.validate(value, schema2, state, prefs);
      if (cleanup) {
        schema2.$_root.untrace();
      }
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    internals.tracer = function(schema2, prefs) {
      if (schema2.$_root._tracer) {
        return { tracer: schema2.$_root._tracer._register(schema2) };
      }
      if (prefs.debug) {
        Assert(schema2.$_root.trace, "Debug mode not supported");
        return { tracer: schema2.$_root.trace()._register(schema2), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports.validate = function(value, schema2, state, prefs, overrides = {}) {
      if (schema2.$_terms.whens) {
        schema2 = schema2._generate(value, state, prefs).schema;
      }
      if (schema2._preferences) {
        prefs = internals.prefs(schema2, prefs);
      }
      if (schema2._cache && prefs.cache) {
        const result = schema2._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = /* @__PURE__ */ __name((code, local, localState) => schema2.$_createError(code, value, local, localState || state, prefs), "createError");
      const helpers = {
        original: value,
        prefs,
        schema: schema2,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: /* @__PURE__ */ __name((code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)), "warn"),
        message: /* @__PURE__ */ __name((messages, local) => schema2.$_createError("custom", value, local, state, prefs, { messages }), "message")
      };
      state.mainstay.tracer.entry(schema2, state);
      const def = schema2._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty = schema2._flags.empty;
      if (empty && empty.$_match(internals.trim(value, schema2), state.nest(empty), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema2._flags.presence || (schema2._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema2.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema2._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema2.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema2._valids) {
        const match = schema2._valids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema2, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema2._flags.only) {
          const report = schema2.$_createError("any.only", value, { valids: schema2._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema2._invalids) {
        const match = schema2._invalids.get(value, state, prefs, schema2._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema2, state, "invalid", match);
          const report = schema2.$_createError("any.invalid", value, { invalids: schema2._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
          state.mainstay.tracer.value(state, "base", value, base.value);
          value = base.value;
          if (base.errors) {
            if (!Array.isArray(base.errors)) {
              errors.push(base.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base.errors.length) {
              errors.push(...base.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema2._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      for (const rule of schema2._rules) {
        const definition = schema2._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema2.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema2, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema: schema2, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema2._flags.error) {
        if (typeof schema2._flags.error === "function") {
          errors = schema2._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema2._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema2._flags.cast && value !== void 0) {
        const caster = schema2._definition.cast[schema2._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema2._flags.cast);
          value = casted;
        }
      }
      if (schema2.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema2.$_terms.externals) {
          state.mainstay.externals.push({ method, schema: schema2, state, label: Errors.label(schema2._flags, state, prefs) });
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema2._flags.result) {
        result.value = schema2._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.mainstay.tracer.value(state, schema2._flags.result, value, result.value);
        state.shadow(value, schema2._flags.result);
      }
      if (schema2._cache && prefs.cache !== false && !schema2._refs.length) {
        schema2._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema2._flags.artifact !== void 0) {
        state.mainstay.artifacts = state.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state.mainstay.artifacts.has(schema2._flags.artifact)) {
          state.mainstay.artifacts.set(schema2._flags.artifact, []);
        }
        state.mainstay.artifacts.get(schema2._flags.artifact).push(state.path);
      }
      return result;
    };
    internals.prefs = function(schema2, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema2._preferences[Common.symbols.prefs]) {
        return schema2._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema2._preferences);
      if (isDefaultOptions) {
        schema2._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema: schema2, state, prefs } = helpers;
      const source = schema2._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema2, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema2.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema2) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema2.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: Ignore,
      entry: Ignore,
      filter: Ignore,
      log: Ignore,
      resolve: Ignore,
      value: Ignore
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/joi/lib/values.js
var require_values = __commonJS({
  "node_modules/joi/lib/values.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options) {
        if (options && options.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({ override: true });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? { value } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from) {
      const map = /* @__PURE__ */ new Map();
      if (from) {
        for (const value of from) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});

// node_modules/joi/lib/base.js
var require_base = __commonJS({
  "node_modules/joi/lib/base.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Trace = require_trace();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._reset();
      }
      _reset() {
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          // Runtime state (not cloned)
          ruleset: null,
          // null: use last, false: error, number: start position
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Manifest
      describe() {
        Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({ target, adjuster });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      artifact(id) {
        Assert(id !== void 0, "Artifact cannot be undefined");
        Assert(!this._cache, "Cannot set an artifact with a rule cache");
        return this.$_setFlag("artifact", id);
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options) {
        return this._default("default", value, options);
      }
      description(desc) {
        Assert(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema2) {
        const obj = this.clone();
        if (schema2 !== void 0) {
          schema2 = obj.$_compile(schema2, { override: false });
        }
        return obj.$_setFlag("empty", schema2, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options = {}) {
        Assert(example !== void 0, "Missing example");
        Common.assertOptions(options, ["override"]);
        return this._inner("examples", example, { single: true, override: options.override });
      }
      external(method, description) {
        if (typeof method === "object") {
          Assert(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        Assert(typeof method === "function", "Method must be a function");
        Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", { method, description }, { single: true });
      }
      failover(value, options) {
        return this._default("failover", value, options);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        Assert(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        Assert(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, { single: true });
      }
      note(...notes) {
        Assert(notes.length, "Missing notes");
        for (const note of notes) {
          Assert(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Assert(prefs.externals === void 0, "Cannot override externals");
        Assert(prefs.warnings === void 0, "Cannot override warnings");
        Assert(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled = true) {
        return this.$_setFlag("result", enabled ? "raw" : void 0);
      }
      result(mode) {
        Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled) {
        const obj = this.clone();
        const convert = enabled === void 0 ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled = true) {
        return this.$_setFlag("result", enabled ? "strip" : void 0);
      }
      tag(...tags) {
        Assert(tags.length, "Missing tags");
        for (const tag of tags) {
          Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        Assert(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      cache(cache) {
        Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
        Assert(!this._cache, "Cannot override schema cache");
        Assert(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, source]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options) {
        Assert(!options.base, "Cannot extend type with another base");
        return Extend.type(this, options);
      }
      extract(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.reach(path);
      }
      fork(paths, adjuster) {
        Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path of [].concat(paths)) {
          path = Array.isArray(path) ? path : path.split(".");
          obj = obj._ids.fork(path, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      rule(options) {
        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));
        Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i = start; i < obj._rules.length; ++i) {
          const original = obj._rules[i];
          const rule = Clone(original);
          for (const name in options) {
            def.modifiers[name](rule, options[name]);
            Assert(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({ each: /* @__PURE__ */ __name((item) => item.tailor(targets), "each"), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options) {
        return Validator.entry(value, this, options);
      }
      validateAsync(value, options) {
        return Validator.entryAsync(value, this, options);
      }
      // Extensions
      $_addRule(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        Assert(options && typeof options === "object", "Invalid options");
        Assert(options.name && typeof options.name === "string", "Invalid rule name");
        for (const key in options) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, { clone: false });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema2, options) {
        return Compile.schema(this.$_root, schema2, options);
      }
      $_createError(code, value, local, state, prefs, options = {}) {
        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.labels(path);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options) {
        Common.assertOptions(options, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options) || this;
      }
      $_mutateRebuild() {
        Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = /* @__PURE__ */ __name((item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        }, "each");
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema2, { family, key } = {}) {
        this._refs.register(schema2, family);
        this._ids.register(schema2, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options = {}) {
        Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _bare() {
        const obj = this.clone();
        obj._reset();
        const terms = obj._definition.terms;
        for (const name in terms) {
          const term = terms[name];
          obj.$_terms[name] = term.init;
        }
        return obj.$_mutateRebuild();
      }
      _default(flag, value, options = {}) {
        Common.assertOptions(options, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
        if (typeof value === "function" && options.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
          const when = this.$_terms.whens[i];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return { schema: this };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, ...whens]);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _inner(type, values, options = {}) {
        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options.override) {
          obj.$_terms[type] = [];
        }
        if (options.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
          const test = obj._rules[i];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module.exports = new internals.Base();
  }
});

// node_modules/joi/lib/types/any.js
var require_any = __commonJS({
  "node_modules/joi/lib/types/any.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    var Messages = require_messages();
    module.exports = Base.extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema2) {
            Assert(Common.isSchema(schema2) && schema2._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema2);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        warning: {
          method(code, local) {
            Assert(code && typeof code === "string", "Invalid warning code");
            return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
          },
          validate(value, helpers, { code, local }) {
            return helpers.error(code, local);
          },
          args: ["code", "local"],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled = true) {
          rule.keep = enabled;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled = true) {
          rule.warn = enabled;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat } = value;
                if (concat) {
                  obj = obj.concat(concat);
                } else if (ref) {
                  obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                } else {
                  obj = obj.when(is, { then, otherwise, break: value.break });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/joi/lib/types/alternatives.js
var require_alternatives = __commonJS({
  "node_modules/joi/lib/types/alternatives.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Merge = require_merge();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema2, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema2.try(...schemas[0]);
          }
        }
        return schema2.try(...schemas);
      },
      validate(value, helpers) {
        const { schema: schema2, error, state, prefs } = helpers;
        if (schema2._flags.match) {
          const matched = [];
          const failed = [];
          for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
            const item = schema2.$_terms.matches[i];
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              matched.push(result.value);
              localState.commit();
            } else {
              failed.push(result.errors);
              localState.restore();
            }
          }
          if (matched.length === 0) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.any", context) };
          }
          if (schema2._flags.match === "one") {
            return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
          }
          if (matched.length !== schema2.$_terms.matches.length) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.all", context) };
          }
          const isAnyObj = /* @__PURE__ */ __name((alternative) => {
            return alternative.$_terms.matches.some((v) => {
              return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
            });
          }, "isAnyObj");
          return isAnyObj(schema2) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }
        const errors = [];
        for (let i = 0; i < schema2.$_terms.matches.length; ++i) {
          const item = schema2.$_terms.matches[i];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              localState.commit();
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema2 of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema2) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_parent("label", name);
          const each = /* @__PURE__ */ __name((item, source) => {
            return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
          }, "each");
          return obj.$_modify({ each, ref: false });
        }
      },
      rebuild(schema2) {
        const each = /* @__PURE__ */ __name((item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema2.$_setFlag("_arrayItems", true, { clone: false });
          }
        }, "each");
        schema2.$_modify({ each });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema: schema2, ref, is, not, then, otherwise } = match;
              if (schema2) {
                obj = obj.try(schema2);
              } else if (ref) {
                obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
              } else {
                obj = obj.conditional(is, { then, otherwise });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema: schema2 } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema2.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code] = report.code.split(".");
        if (code !== "base") {
          complex.push({ type: schema2.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});

// node_modules/joi/lib/types/array.js
var require_array = __commonJS({
  "node_modules/joi/lib/types/array.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module.exports = Any.extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [], manifest: "schema" },
        ordered: { init: [], manifest: "schema" },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema: schema2, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema2.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema2, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema: schema2, error }) {
        if (!Array.isArray(value)) {
          if (schema2._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema2.$_getRule("items") && !schema2.$_terms.externals) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema2) {
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema: schema2 } });
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has }) {
            const ancestors = [value, ...state.ancestors];
            for (let i = 0; i < value.length; ++i) {
              const localState = state.localize([...state.path, i], ancestors, has);
              if (has.$_match(value[i], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has._flags.label;
            if (patternLabel) {
              return error("array.hasKnown", { patternLabel });
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema: schema2, error, state, prefs, errorsArray }) {
            const requireds = schema2.$_terms._requireds.slice();
            const ordereds = schema2.$_terms.ordered.slice();
            const inclusions = [...schema2.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i = 0; i < il; ++i) {
              const item = value[i];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i : new Number(i);
              const path = [...state.path, key];
              if (!schema2._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema2.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema2.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema2.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i, limit: schema2.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  localState.commit();
                  value[i] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema2._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    localState.commit();
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema2._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if ((schema2.$_terms._inclusions.length || schema2.$_terms._requireds.length) && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema2, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema2, errors, ordereds, value, state, prefs);
              if (!errors.length) {
                internals.fillDefault(ordereds, value, state, prefs);
              }
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options = {}) {
            Common.assertOptions(options, ["by", "order"]);
            const settings = {
              order: options.order || "ascending"
            };
            if (options.by) {
              settings.by = Compile.ref(options.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema: schema2 }, { options }) {
            const { value: sorted, errors } = internals.sort(schema2, value, options, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i = 0; i < value.length; ++i) {
              if (value[i] !== sorted[i]) {
                return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema: schema2 }, { comparator: raw, options }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              bigint: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options.ignoreUndefined;
            for (let i = 0; i < value.length; ++i) {
              const item = path ? Reach(value[i], path) : value[i];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema2) {
        schema2.$_terms._inclusions = [];
        schema2.$_terms._exclusions = [];
        schema2.$_terms._requireds = [];
        for (const type of schema2.$_terms.items) {
          internals.validateSingle(type, schema2);
          if (type._flags.presence === "required") {
            schema2.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema2.$_terms._exclusions.push(type);
          } else {
            schema2.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema2.$_terms.ordered) {
          internals.validateSingle(type, schema2);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema2, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema2.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
        } else {
          errors.push(schema2.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
        }
      } else {
        errors.push(schema2.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema2, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema2, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fillDefault = function(ordereds, value, state, prefs) {
      const overrides = [];
      let trailingUndefined = true;
      for (let i = ordereds.length - 1; i >= 0; --i) {
        const ordered = ordereds[i];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(void 0, state.localize(state.path, ancestors, ordered), prefs).value;
        if (trailingUndefined) {
          if (override === void 0) {
            continue;
          }
          trailingUndefined = false;
        }
        overrides.unshift(override);
      }
      if (overrides.length) {
        value.push(...overrides);
      }
    };
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema2, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = /* @__PURE__ */ __name((a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema2.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema2.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      }, "sort");
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/joi/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/joi/lib/types/boolean.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema: schema2 }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema2._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema2.$_terms.truthy && schema2.$_terms.truthy.has(value, null, null, !schema2._flags.sensitive) || (schema2.$_terms.falsy && schema2.$_terms.falsy.has(value, null, null, !schema2._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled = true) {
            return this.$_setFlag("sensitive", enabled);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/joi/lib/types/date.js
var require_date = __commonJS({
  "node_modules/joi/lib/types/date.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module.exports = Any.extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema: schema2 }) {
          return { value: internals.parse(value, schema2._flags.format) || value };
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format = schema2._flags.format;
        if (!prefs.convert || !format || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date }, { name, operator, args }) {
            const to = date === "now" ? Date.now() : date.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: /* @__PURE__ */ __name((date) => {
                return date === "now" ? date : internals.parse(date);
              }, "normalize"),
              assert: /* @__PURE__ */ __name((date) => date !== null, "assert"),
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format) {
            Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
            return this.$_setFlag("format", format);
          }
        },
        greater: {
          method(date) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date) {
            return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
          }
        },
        max: {
          method(date) {
            return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
          }
        },
        min: {
          method(date) {
            return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
        // Messages used in date.format
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format) {
        if (format === "javascript") {
          return internals.date(1 * value);
        }
        if (format === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date;
      }
      return null;
    };
  }
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS({
  "node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module.exports = function(defaults, source, options = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
      }
      const copy = Clone(defaults);
      if (source === true) {
        return copy;
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options) {
      const keys = options.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge && Reach(source, key) || ref);
        } else if (merge) {
          merge.add(key);
        }
      }
      const copy = Clone(defaults, {}, seen);
      if (!merge) {
        return copy;
      }
      for (const key of merge) {
        internals.reachCopy(copy, source, key);
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src, path) {
      for (const segment of path) {
        if (!(segment in src)) {
          return;
        }
        const val = src[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src = val;
      }
      const value = src;
      let ref = dst;
      for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path[path.length - 1]] = value;
    };
  }
});

// node_modules/@hapi/topo/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@hapi/topo/lib/index.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var internals = {};
    exports.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options) {
        options = options || {};
        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || "?";
        const sort = options.sort || 0;
        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes("?"), "Item cannot come before unassociated items");
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options.manual) {
          const valid = this._sort();
          Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [others];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
          this._items[i].seq = i;
        }
        const valid = this._sort();
        Assert(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        Assert(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] || [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] || [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] || [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] || [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i = 0; i < this._items.length; ++i) {
          let next = i;
          if (ancestors[i]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// node_modules/joi/lib/types/keys.js
var require_keys = __commonJS({
  "node_modules/joi/lib/types/keys.js"(exports, module) {
    "use strict";
    init_register();
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib4();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var Template = require_template();
    var internals = {
      renameDefaults: {
        alias: false,
        // Keep old value in place
        multiple: false,
        // Allow renaming multiple keys into the same target
        override: false
        // Overrides an existing key
      }
    };
    module.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema2, keys) {
        return schema2.keys(keys);
      },
      validate(value, { schema: schema2, error, state, prefs }) {
        if (!value || typeof value !== schema2.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema2.$_property("typeof") }) };
        }
        if (!schema2.$_terms.renames && !schema2.$_terms.dependencies && !schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema2.$_terms.renames && !internals.rename(schema2, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema2.$_terms.keys && // null allows any keys
        !schema2.$_terms.patterns && !schema2.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema2.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema2.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              if (result.value !== void 0) {
                value[key] = result.value;
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema2._flags._hasPatternMatch) {
          const early = internals.unknown(schema2, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema2.$_terms.dependencies) {
          for (const dep of schema2.$_terms.dependencies) {
            if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema2, dep, value, state, prefs);
            if (failed) {
              const report = schema2.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema2) {
            if (schema2 === null || schema2 === void 0 || Object.keys(schema2).length === 0) {
              return this;
            }
            return this.keys(schema2);
          }
        },
        assert: {
          method(subject, schema2, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema: schema2, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema2);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema: schema2, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema2.$_match(about, state.localize(path, [value, ...state.ancestors], schema2), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema2) {
            Assert(schema2 === void 0 || typeof schema2 === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema2), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema2) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema2).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema2.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema2) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema2[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema2, options = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema2 !== void 0, "Invalid rule");
            Common.assertOptions(options, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema2 = this.$_compile(schema2, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema2 };
            if (options.matches) {
              config.matches = this.$_compile(options.matches);
              if (config.matches.type !== "array") {
                config.matches = config.matches.$_root.array().items(config.matches);
              }
              obj.$_mutateRegister(config.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options.fallthrough) {
              config.fallthrough = true;
            }
            obj.$_terms.patterns.push(config);
            obj.$_mutateRegister(schema2);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from, to, options = {}) {
            Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            Assert(to !== from, "Cannot rename key to same name:", from);
            Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "with", key, peers, options);
          }
        },
        without: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "without", key, peers, options);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options);
        }
      },
      rebuild(schema2) {
        if (schema2.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema2.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema2.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema: schema2, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema2, rule, { fallthrough, matches });
            }
          }
          if (desc.renames) {
            for (const { from, to, options } of desc.renames) {
              obj = obj.rename(from, to, options);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone2 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone2, value);
        return clone2;
      }
      const clone = /* @__PURE__ */ __name(function(...args) {
        return value.apply(this, args);
      }, "clone");
      clone.prototype = Clone(value.prototype);
      Object.defineProperty(clone, "name", { value: value.name, writable: false });
      Object.defineProperty(clone, "length", { value: value.length, writable: false });
      Object.assign(clone, value);
      return clone;
    };
    internals.dependency = function(schema2, rel, key, peers, options) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options, ["separator", "isPresent"]);
      peers = [].concat(peers);
      const separator = Common.default(options.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be strings");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema2.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
      return obj;
    };
    internals.dependencies = {
      and(schema2, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema2, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema2, missing)
            }
          };
        }
      },
      nand(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema2, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema2, values)
          }
        };
      },
      or(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema2, dep.paths)
          }
        };
      },
      oxor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.oxor", context };
      },
      with(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      without(schema2, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema2, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema2, peer.key)
              }
            };
          }
        }
      },
      xor(schema2, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema2, dep.paths) };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema2, present);
        return { code: "object.xor", context };
      }
    };
    internals.keysToLabels = function(schema2, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema2.$_mapLabels(key));
      }
      return schema2.$_mapLabels(keys);
    };
    internals.isPresent = function(options) {
      return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== void 0;
    };
    internals.rename = function(schema2, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema2.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from in value) {
            if (value[from] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from === rename.to) {
              continue;
            }
            const match = rename.from.exec(from);
            if (!match) {
              continue;
            }
            matches.push({ from, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema2.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema2.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema2, value, unprocessed, errors, state, prefs) {
      if (schema2.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema2.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [...state.path, key];
          for (let i = 0; i < schema2.$_terms.patterns.length; ++i) {
            const pattern = schema2.$_terms.patterns[i];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i = 0; i < matches.length; ++i) {
            const match = matches[i];
            if (!match) {
              continue;
            }
            const stpm = schema2.$_terms.patterns[i].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema2.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema2.$_terms.keys && !schema2.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema2._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema2._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema2.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths, options) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = { ...desc.options, separator: this.peers[0].separator };
        }
        if (this.options.isPresent) {
          desc.options = { ...desc.options, isPresent: this.options.isPresent };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i = 0; i < result.length; ++i) {
          keys.set(result[i].key, i);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/joi/lib/types/function.js
var require_function = __commonJS({
  "node_modules/joi/lib/types/function.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/joi/lib/types/link.js
var require_link = __commonJS({
  "node_modules/joi/lib/types/link.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, manifest: "single", register: false }
      },
      args(schema2, ref) {
        return schema2.ref(ref);
      },
      validate(value, { schema: schema2, state, prefs }) {
        Assert(schema2.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema2, value, state, prefs);
        const ref = schema2.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema2, value, state, prefs) {
        return internals.generate(schema2, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled = true) {
            return this.$_setFlag("relative", enabled);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          Assert(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema2, value, state, prefs) {
      let linked = state.mainstay.links.get(schema2);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema2.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema2, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema2, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema2, state, prefs);
      if (!schema2._flags.relative) {
        state.mainstay.links.set(schema2, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema: schema2, key } of state.schemas) {
          const id = schema2._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema2, path: ref.path.slice(1) };
          }
          if (schema2.$_terms.shared) {
            for (const shared of schema2.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema2, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema2._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/joi/lib/types/number.js
var require_number = __commonJS({
  "node_modules/joi/lib/types/number.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
      exponentialPartRegex: /[eE][+-]?\d+$/,
      leadingSignAndZerosRegex: /^[+-]?(0*)?/,
      dotRegex: /\./,
      trailingZerosRegex: /0+$/,
      decimalPlaces(value) {
        const str = value.toString();
        const dindex = str.indexOf(".");
        const eindex = str.indexOf("e");
        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
      }
    };
    module.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema2._flags.unsafe) {
            if (value.match(/e/i)) {
              if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string = result.value.toString();
              if (string.match(/e/i)) {
                return result;
              }
              if (string !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema: schema2, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema2.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema2._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base) {
            const baseDecimalPlace = typeof base === "number" ? internals.decimalPlaces(base) : null;
            const pfactor = Math.pow(10, baseDecimalPlace);
            return this.$_addRule({
              name: "multiple",
              args: {
                base,
                baseDecimalPlace,
                pfactor
              }
            });
          },
          validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {
            const valueDecimalPlace = internals.decimalPlaces(value);
            if (valueDecimalPlace > baseDecimalPlace) {
              return helpers.error("number.multiple", { multiple: options.args.base, value });
            }
            return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ? value : helpers.error("number.multiple", { multiple: options.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: /* @__PURE__ */ __name((value) => typeof value === "number" && isFinite(value) && value > 0, "assert"),
              message: "must be a positive number"
            },
            "baseDecimalPlace",
            "pfactor"
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign) {
            Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
            return this.$_addRule({ name: "sign", args: { sign } });
          },
          validate(value, helpers, { sign }) {
            if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign}`);
          }
        },
        unsafe: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled);
          }
        }
      },
      cast: {
        string: {
          from: /* @__PURE__ */ __name((value) => typeof value === "number", "from"),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.extractSignificantDigits = function(value) {
      return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/joi/lib/types/object.js
var require_object = __commonJS({
  "node_modules/joi/lib/types/object.js"(exports, module) {
    "use strict";
    init_register();
    var Keys = require_keys();
    module.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: /* @__PURE__ */ __name((value) => value && typeof value === "object", "from"),
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/@sideway/address/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/@sideway/address/lib/errors.js"(exports) {
    "use strict";
    init_register();
    exports.codes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    exports.code = function(code) {
      return { code, error: exports.codes[code] };
    };
  }
});

// node_modules/@sideway/address/lib/domain.js
var require_domain = __commonJS({
  "node_modules/@sideway/address/lib/domain.js"(exports) {
    "use strict";
    init_register();
    var Url = __require("url");
    var Errors = require_errors2();
    var internals = {
      minDomainSegments: 2,
      nonAsciiRx: /[^\x00-\x7f]/,
      domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
      // Control + space + separators
      tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      URL: Url.URL || URL
      // $lab:coverage:ignore$
    };
    exports.analyze = function(domain, options = {}) {
      if (!domain) {
        return Errors.code("DOMAIN_NON_EMPTY_STRING");
      }
      if (typeof domain !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (domain.length > 256) {
        return Errors.code("DOMAIN_TOO_LONG");
      }
      const ascii = !internals.nonAsciiRx.test(domain);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain = domain.normalize("NFC");
      }
      if (internals.domainControlRx.test(domain)) {
        return Errors.code("DOMAIN_INVALID_CHARS");
      }
      domain = internals.punycode(domain);
      if (options.allowFullyQualified && domain[domain.length - 1] === ".") {
        domain = domain.slice(0, -1);
      }
      const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
      const segments = domain.split(".");
      if (segments.length < minDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT");
      }
      if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
          return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds = options.tlds;
      if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
          return Errors.code("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return Errors.code("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return Errors.code("DOMAIN_LONG_SEGMENT");
        }
        if (i < segments.length - 1) {
          if (!internals.domainSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_CHARS");
          }
        } else {
          if (!internals.tldSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    };
    exports.isValid = function(domain, options) {
      return !exports.analyze(domain, options);
    };
    internals.punycode = function(domain) {
      if (domain.includes("%")) {
        domain = domain.replace(/%/g, "%25");
      }
      try {
        return new internals.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});

// node_modules/@sideway/address/lib/email.js
var require_email = __commonJS({
  "node_modules/@sideway/address/lib/email.js"(exports) {
    "use strict";
    init_register();
    var Util = __require("util");
    var Domain = require_domain();
    var Errors = require_errors2();
    var internals = {
      nonAsciiRx: /[^\x00-\x7f]/,
      encoder: new (Util.TextEncoder || TextEncoder)()
      // $lab:coverage:ignore$
    };
    exports.analyze = function(email, options) {
      return internals.email(email, options);
    };
    exports.isValid = function(email, options) {
      return !internals.email(email, options);
    };
    internals.email = function(email, options = {}) {
      if (typeof email !== "string") {
        throw new Error("Invalid input: email must be a string");
      }
      if (!email) {
        return Errors.code("EMPTY_STRING");
      }
      const ascii = !internals.nonAsciiRx.test(email);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("FORBIDDEN_UNICODE");
        }
        email = email.normalize("NFC");
      }
      const parts = email.split("@");
      if (parts.length !== 2) {
        return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
      }
      const [local, domain] = parts;
      if (!local) {
        return Errors.code("EMPTY_LOCAL");
      }
      if (!options.ignoreLength) {
        if (email.length > 254) {
          return Errors.code("ADDRESS_TOO_LONG");
        }
        if (internals.encoder.encode(local).length > 64) {
          return Errors.code("LOCAL_TOO_LONG");
        }
      }
      return internals.local(local, ascii) || Domain.analyze(domain, options);
    };
    internals.local = function(local, ascii) {
      const segments = local.split(".");
      for (const segment of segments) {
        if (!segment.length) {
          return Errors.code("EMPTY_LOCAL_SEGMENT");
        }
        if (ascii) {
          if (!internals.atextRx.test(segment)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
          continue;
        }
        for (const char of segment) {
          if (internals.atextRx.test(char)) {
            continue;
          }
          const binary = internals.binary(char);
          if (!internals.atomRx.test(binary)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
        }
      }
    };
    internals.binary = function(char) {
      return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
    };
    internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    internals.atomRx = new RegExp([
      //  %xC2-DF UTF8-tail
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeRegex.js"(exports, module) {
    "use strict";
    init_register();
    module.exports = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});

// node_modules/@sideway/address/lib/uri.js
var require_uri = __commonJS({
  "node_modules/@sideway/address/lib/uri.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var internals = {};
    internals.generate = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
      rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
      const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
      const port = "\\d*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
      rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
      rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
      rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
      rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      return rfc3986;
    };
    internals.rfc3986 = internals.generate();
    exports.ip = {
      v4Cidr: internals.rfc3986.ipv4Cidr,
      v6Cidr: internals.rfc3986.ipv6Cidr,
      ipv4: internals.rfc3986.ipv4address,
      ipv6: internals.rfc3986.ipv6address,
      ipvfuture: internals.rfc3986.ipvFuture
    };
    internals.createRegex = function(options) {
      const rfc = internals.rfc3986;
      const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
      const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
      const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
      if (options.relativeOnly) {
        return internals.wrap(relative + suffix);
      }
      let customScheme = "";
      if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
          const scheme2 = schemes[i];
          Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
          if (scheme2 instanceof RegExp) {
            selections.push(scheme2.source.toString());
          } else {
            Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
            selections.push(EscapeRegex(scheme2));
          }
        }
        customScheme = selections.join("|");
      }
      const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
      const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
      const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
      return internals.wrap(prefix + suffix, customScheme);
    };
    internals.wrap = function(raw, scheme) {
      raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
      return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
      };
    };
    internals.uriRegex = internals.createRegex({});
    exports.regex = function(options = {}) {
      if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
        return internals.createRegex(options);
      }
      return internals.uriRegex;
    };
  }
});

// node_modules/@sideway/address/lib/ip.js
var require_ip = __commonJS({
  "node_modules/@sideway/address/lib/ip.js"(exports) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Uri = require_uri();
    exports.regex = function(options = {}) {
      Assert(options.cidr === void 0 || typeof options.cidr === "string", "options.cidr must be a string");
      const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
      Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
      Assert(options.version === void 0 || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
      let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      Assert(versions.length >= 1, "options.version must have at least 1 version specified");
      for (let i = 0; i < versions.length; ++i) {
        Assert(typeof versions[i] === "string", "options.version must only contain strings");
        versions[i] = versions[i].toLowerCase();
        Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
      }
      versions = Array.from(new Set(versions));
      const parts = versions.map((version) => {
        if (cidr === "forbidden") {
          return Uri.ip[version];
        }
        const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
        if (cidr === "required") {
          return `${Uri.ip[version]}${cidrpart}`;
        }
        return `${Uri.ip[version]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      const regex = new RegExp(`^${raw}$`);
      return { cidr, versions, regex, raw };
    };
  }
});

// node_modules/@sideway/address/lib/tlds.js
var require_tlds = __commonJS({
  "node_modules/@sideway/address/lib/tlds.js"(exports, module) {
    "use strict";
    init_register();
    var internals = {};
    internals.tlds = [
      "AAA",
      "AARP",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMAZON",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AVIANCA",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BENTLEY",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CASA",
      "CASE",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CC",
      "CD",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMCAST",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CPA",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DABUR",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ET",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUARDIAN",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYLOGISTICS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIDS",
      "KIM",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LAMBORGHINI",
      "LAMER",
      "LANCASTER",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINK",
      "LIPSY",
      "LIVE",
      "LIVING",
      "LK",
      "LLC",
      "LLP",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUSIC",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NAGOYA",
      "NAME",
      "NATURA",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAMERICA",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "RACING",
      "RADIO",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDSTONE",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIL",
      "RIO",
      "RIP",
      "RO",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHAW",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPA",
      "SPACE",
      "SPORT",
      "SPOT",
      "SR",
      "SRL",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XFINITY",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4DBRK0CE",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CCKWCXETD",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ480N2RG",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBCPQ6GPA1A",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q7CE6A",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
    module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
  }
});

// node_modules/joi/lib/types/string.js
var require_string = __commonJS({
  "node_modules/joi/lib/types/string.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Domain = require_domain();
    var Email = require_email();
    var Ip = require_ip();
    var EscapeRegex = require_escapeRegex();
    var Tlds = require_tlds();
    var Uri = require_uri();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
      // $lab:coverage:ignore$
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: {
        withPrefix: /^0x[0-9a-f]+$/i,
        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
        withoutPrefix: /^[0-9a-f]+$/i
      },
      ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5",
        uuidv6: "6",
        uuidv7: "7",
        uuidv8: "8"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    module.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema: schema2, state, prefs }) {
          const normalize = schema2.$_getRule("normalize");
          if (normalize) {
            value = value.normalize(normalize.args.form);
          }
          const casing = schema2.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema2.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema2.$_terms.replacements) {
            for (const replacement of schema2.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema2.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema2.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema2._flags.truncate) {
            const rule = schema2.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema2.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { schema: schema2, error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          const min = schema2.$_getRule("min");
          if (min && min.args.limit === 0) {
            return;
          }
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
            options = { urlSafe: false, paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options } });
          },
          validate(value, helpers, { options }) {
            const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i = value.length;
            let sum = 0;
            let mul = 1;
            while (i--) {
              const char = value.charAt(i) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired"]);
            options = { paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options } });
          },
          validate(value, helpers, { options }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options) {
            if (options) {
              Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const address = internals.addressOptions(options);
            return this.$_addRule({ name: "domain", args: { options }, address });
          },
          validate(value, helpers, args, { address }) {
            if (Domain.isValid(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options = {}) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
            Assert(options.multiple === void 0 || typeof options.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options);
            const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
            return this.$_addRule({ name: "email", args: { options }, regex, address });
          },
          validate(value, helpers, { options }, { regex, address }) {
            const emails = options.multiple ? value.split(regex) : [value];
            const invalids = [];
            for (const email of emails) {
              if (!Email.isValid(email, address)) {
                invalids.push(email);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", { value, invalids });
          }
        },
        guid: {
          alias: "uuid",
          method(options = {}) {
            Common.assertOptions(options, ["version", "separator"]);
            let versionNumbers = "";
            if (options.version) {
              const versions = [].concat(options.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i = 0; i < versions.length; ++i) {
                const version = versions[i];
                Assert(typeof version === "string", "version at position " + i + " must be a string");
                const versionNumber = internals.guidVersions[version.toLowerCase()];
                Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options.separator === void 0 ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options = {}) {
            Common.assertOptions(options, ["byteAligned", "prefix"]);
            options = { byteAligned: false, prefix: false, ...options };
            Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
            Assert(typeof options.prefix === "boolean" || options.prefix === "optional", 'prefix must be boolean or "optional"');
            return this.$_addRule({ name: "hex", args: { options } });
          },
          validate(value, helpers, { options }) {
            const re = options.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
            if (!re.test(value)) {
              return helpers.error("string.hex");
            }
            if (options.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options = {}) {
            Common.assertOptions(options, ["cidr", "version"]);
            const { cidr, versions, regex } = Ip.regex(options);
            const version = options.version ? versions : void 0;
            return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
          },
          validate(value, helpers, { options }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options.version) {
              return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
            }
            return helpers.error("string.ip", { value, cidr: options.cidr });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options === "string") {
              options = { name: options };
            }
            Common.assertOptions(options, ["invert", "name"]);
            const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
          },
          validate(value, helpers, { regex, options }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled } });
          },
          validate(value, helpers, { enabled }) {
            if (!enabled || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options = {}) {
            Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]);
            if (options.domain) {
              Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const { regex, scheme } = Uri.regex(options);
            const domain = options.domain ? internals.addressOptions(options.domain) : null;
            return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
          },
          validate(value, helpers, { options }, { regex, domain, scheme }) {
            if (["http:/", "https:/"].includes(value)) {
              return helpers.error("string.uri");
            }
            let match = regex.exec(value);
            if (!match && helpers.prefs.convert && options.encodeUri) {
              const encoded = encodeURI(value);
              match = regex.exec(encoded);
              if (match) {
                value = encoded;
              }
            }
            if (match) {
              const matched = match[1] || match[2];
              if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {
                return helpers.error("string.domain", { value: matched });
              }
              return value;
            }
            if (options.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options.scheme) {
              return helpers.error("string.uriCustomScheme", { scheme, value });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options) {
      if (!options) {
        return internals.tlds || options;
      }
      Assert(options.minDomainSegments === void 0 || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      Assert(options.maxDomainSegments === void 0 || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
      if (options.tlds === false) {
        return options;
      }
      if (options.tlds === true || options.tlds === void 0) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
      const deny = options.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }
        Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        internals.validateTlds(options.tlds.deny, "tlds.deny");
        return options;
      }
      const allow = options.tlds.allow;
      if (!allow) {
        return options;
      }
      if (allow === true) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
      }
      Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      internals.validateTlds(options.tlds.allow, "tlds.allow");
      return options;
    };
    internals.validateTlds = function(set, source) {
      for (const tld of set) {
        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
      }
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      if (/.*T.*[+-]\d\d$/.test(value)) {
        value += "00";
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date.toISOString();
    };
    internals.length = function(schema2, name, limit, operator, encoding) {
      Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema2.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
  }
});

// node_modules/joi/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/joi/lib/types/symbol.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module.exports = Any.extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema: schema2, error }) {
          const lookup = schema2.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema2._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema2.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols.push(value);
            }
            return obj.valid(...symbols);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/joi/lib/types/binary.js
var require_binary = __commonJS({
  "node_modules/joi/lib/types/binary.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module.exports = Any.extend({
      type: "binary",
      coerce: {
        from: ["string", "object"],
        method(value, { schema: schema2 }) {
          if (typeof value === "string" || value !== null && value.type === "Buffer") {
            try {
              return { value: Buffer.from(value, schema2._flags.encoding) };
            } catch (ignoreErr) {
            }
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: /* @__PURE__ */ __name((value) => Buffer.isBuffer(value), "from"),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/joi/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/joi/lib/index.js"(exports, module) {
    "use strict";
    init_register();
    var Assert = require_assert();
    var Clone = require_clone();
    var Cache = require_cache();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Manifest = require_manifest();
    var Ref = require_ref();
    var Template = require_template();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema2, ...args) {
        internals.assert(value, schema2, true, args);
      },
      attempt(value, schema2, ...args) {
        return internals.assert(value, schema2, false, args);
      },
      build(desc) {
        Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema2, options) {
        return Compile.compile(this, schema2, options);
      },
      defaults(modifier) {
        Assert(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema2 = modifier(joi[type]());
          Assert(Common.isSchema(schema2), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema2, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas();
        Assert(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            Assert(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base = item.base || this.any();
            const schema2 = Extend.type(base, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema2, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema2, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options = message !== null ? args[1] : args[0];
      const result = schema2.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema2, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema2.$_root = root;
      if (!schema2._definition.args || !args.length) {
        return schema2;
      }
      return schema2._definition.args(schema2, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [extension];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module.exports = internals.root();
  }
});

// src/handlers/hello3.js
init_register();

// src/schemas/common.js
init_register();
function generateErrorResponses(statusCodes, when) {
  const responses = [];
  const postText = "The examples show all possible `code` and `message` values, not limited to this endpoint.";
  if (statusCodes.includes(400)) {
    responses.push({
      statusCode: 400,
      responseBody: {
        description: `An error message when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ErrorResponse"
      }
    });
  }
  if (statusCodes.includes(401)) {
    responses.push({
      statusCode: 401,
      responseBody: {
        description: `Unauthorised user when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "UnauthorizedResponse"
      }
    });
  }
  if (statusCodes.includes(403)) {
    responses.push({
      statusCode: 403,
      responseBody: {
        description: `Forbidden when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ForbiddenResponse"
      }
    });
  }
  if (statusCodes.includes(404)) {
    responses.push({
      statusCode: 404,
      responseBody: {
        description: `Resource not found when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "NotFoundResponse"
      }
    });
  }
  if (statusCodes.includes(429)) {
    responses.push({
      statusCode: 429,
      responseBody: {
        description: `Rate limited when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "RateLimitedResponse"
      }
    });
  }
  if (statusCodes.includes(500)) {
    responses.push({
      statusCode: 500,
      responseBody: {
        description: `A server error when ${when}. ${postText}`
      },
      responseModels: {
        "application/json": "ServerErrorResponse"
      }
    });
  }
  return responses;
}
__name(generateErrorResponses, "generateErrorResponses");

// src/schemas/validator.js
init_register();
var import_date = __toESM(require_lib(), 1);
var import_joi = __toESM(require_lib5(), 1);
var Joi = import_joi.default.extend(import_date.default);

// src/handlers/hello3.js
var documentation = {
  summary: "Hello 3",
  tags: ["Hello Two Section"],
  description: "Hello 3 template.",
  methodResponses: [
    {
      statusCode: 200,
      responseBody: {
        description: "An object returning hello3 response body.",
        content: {
          "application/json": {
            examples: {
              ResponseExample1: {
                summary: "Response Example 1",
                value: {
                  hello3: "response-example-1"
                }
              },
              ResponseExample2: {
                summary: "Response Example 2",
                value: {
                  hello3: "response-example-2"
                }
              }
            }
          }
        }
      },
      responseModels: {
        "application/json": "HelloThreeSchema"
      }
    },
    ...generateErrorResponses([400, 401, 404, 500], "getting getting hello 3")
  ],
  requestBody: {
    description: "Hello 3 request body",
    content: {
      "application/json": {
        examples: {
          RequestExample1: {
            summary: "RequestExample 1",
            value: {
              hello3: "request-example-1"
            }
          },
          RequestExample2: {
            summary: "Request Example 2",
            value: {
              hello3: "request-example-2"
            }
          }
        }
      }
    }
  }
};
var schema = {
  response: Joi.object({
    hello3: Joi.string().required()
  }),
  body: Joi.object({
    hello3: Joi.string().required()
  })
};
var handler = /* @__PURE__ */ __name(async (event) => {
  return {
    statusCode: 200,
    body: JSON.stringify({
      hello3: event.body.hello3
    })
  };
}, "handler");
export {
  documentation,
  handler,
  schema
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCAiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwgIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3NvdXJjZS1tYXAtc3VwcG9ydC5qcyIsICIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aam9pL2RhdGUvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9zdHJpbmdpZnkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Vycm9yLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hc3NlcnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3JlYWNoLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi90eXBlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Nsb25lLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvcGFja2FnZS5qc29uIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZUh0bWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2Zvcm11bGEvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Fubm90YXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Vycm9ycy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9yZWYuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdGVtcGxhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWVzc2FnZXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NhY2hlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbXBpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXh0ZW5kLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL21hbmlmZXN0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L3BpbnBvaW50L2xpYi9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90cmFjZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvbWVyZ2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbW9kaWZ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9pZ25vcmUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvc3RhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdmFsaWRhdG9yLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3ZhbHVlcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FueS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYXJyYXkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYm9vbGVhbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL3RvcG8vbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2tleXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvbGluay5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9udW1iZXIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvb2JqZWN0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi9lcnJvcnMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2RvbWFpbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi91cmkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2lwLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi90bGRzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N0cmluZy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zeW1ib2wuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYmluYXJ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qb2kvbGliL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9oYW5kbGVycy9oZWxsbzMuanMiLCAiLi4vLi4vLi4vLi4vc3JjL3NjaGVtYXMvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9zY2hlbWFzL3ZhbGlkYXRvci5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICBcdTIwMUNzb3VyY2VzXHUyMDFEIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIFx1MjAxQ3NvdXJjZVx1MjAxRCBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAgXHUyMDFDc291cmNlUm9vdFx1MjAxRCwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwgIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgc291cmNlUmVsYXRpdmUgPSBzb3VyY2VGaWxlO1xuICAgICAgaWYgKHNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc291cmNlUmVsYXRpdmUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKSB7XG4gICAgICAgIGdlbmVyYXRvci5fc291cmNlcy5hZGQoc291cmNlUmVsYXRpdmUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIC8vIFdoZW4gYU9yaWdpbmFsIGlzIHRydXRoeSBidXQgaGFzIGVtcHR5IHZhbHVlcyBmb3IgLmxpbmUgYW5kIC5jb2x1bW4sXG4gICAgLy8gaXQgaXMgbW9zdCBsaWtlbHkgYSBwcm9ncmFtbWVyIGVycm9yLiBJbiB0aGlzIGNhc2Ugd2UgdGhyb3cgYSB2ZXJ5XG4gICAgLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyLWJ1bmRsZXIvcHVsbC81MTlcbiAgICBpZiAoYU9yaWdpbmFsICYmIHR5cGVvZiBhT3JpZ2luYWwubGluZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcgK1xuICAgICAgICAgICAgJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnICtcbiAgICAgICAgICAgICdudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuIiwgIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCAiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsICIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCAiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsICIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxudmFyIGlzTW9kZXJuID0gKFxuICB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nXG4pXG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKGlucHV0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGlucHV0KS5zbGljZSg4LCAtMSkgPT09ICdBcnJheUJ1ZmZlcidcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBieXRlT2Zmc2V0ID4+Pj0gMFxuXG4gIHZhciBtYXhMZW5ndGggPSBvYmouYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXRcblxuICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID4+Pj0gMFxuXG4gICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpXG4gICAgOiBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KG9iai5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSkpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKVxuICAgIDogbmV3IEJ1ZmZlcihzdHJpbmcsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBidWZmZXJGcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgIDogbmV3IEJ1ZmZlcih2YWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWZmZXJGcm9tXG4iLCAidmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcENvbnN1bWVyO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmcztcbnRyeSB7XG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jIHx8ICFmcy5yZWFkRmlsZVN5bmMpIHtcbiAgICAvLyBmcyBkb2Vzbid0IGhhdmUgYWxsIG1ldGhvZHMgd2UgbmVlZFxuICAgIGZzID0gbnVsbDtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIG5vcCAqL1xufVxuXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJyk7XG5cbi8qKlxuICogUmVxdWlyZXMgYSBtb2R1bGUgd2hpY2ggaXMgcHJvdGVjdGVkIGFnYWluc3QgYnVuZGxlciBtaW5pZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtOb2RlTW9kdWxlfSBtb2RcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWNSZXF1aXJlKG1vZCwgcmVxdWVzdCkge1xuICByZXR1cm4gbW9kLnJlcXVpcmUocmVxdWVzdCk7XG59XG5cbi8vIE9ubHkgaW5zdGFsbCBvbmNlIGlmIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xudmFyIGVycm9yRm9ybWF0dGVySW5zdGFsbGVkID0gZmFsc2U7XG52YXIgdW5jYXVnaHRTaGltSW5zdGFsbGVkID0gZmFsc2U7XG5cbi8vIElmIHRydWUsIHRoZSBjYWNoZXMgYXJlIHJlc2V0IGJlZm9yZSBhIHN0YWNrIHRyYWNlIGZvcm1hdHRpbmcgb3BlcmF0aW9uXG52YXIgZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zID0gZmFsc2U7XG5cbi8vIFN1cHBvcnRzIHticm93c2VyLCBub2RlLCBhdXRvfVxudmFyIGVudmlyb25tZW50ID0gXCJhdXRvXCI7XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSBjb250ZW50c1xudmFyIGZpbGVDb250ZW50c0NhY2hlID0ge307XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzb3VyY2UgbWFwIGZvciB0aGF0IGZpbGVcbnZhciBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuXG4vLyBSZWdleCBmb3IgZGV0ZWN0aW5nIHNvdXJjZSBtYXBzXG52YXIgcmVTb3VyY2VNYXAgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uW14sXStiYXNlNjQsLztcblxuLy8gUHJpb3JpdHkgbGlzdCBvZiByZXRyaWV2ZSBoYW5kbGVyc1xudmFyIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gW107XG52YXIgcmV0cmlldmVNYXBIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBpc0luQnJvd3NlcigpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcImJyb3dzZXJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcIm5vZGVcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSAmJiAhKHdpbmRvdy5yZXF1aXJlICYmIHdpbmRvdy5tb2R1bGUgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiKSk7XG59XG5cbmZ1bmN0aW9uIGhhc0dsb2JhbFByb2Nlc3NFdmVudEVtaXR0ZXIoKSB7XG4gIHJldHVybiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gJ2Z1bmN0aW9uJykpO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxQcm9jZXNzVmVyc2lvbigpIHtcbiAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIChwcm9jZXNzICE9PSBudWxsKSkge1xuICAgIHJldHVybiBwcm9jZXNzLnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdsb2JhbFByb2Nlc3NTdGRlcnIoKSB7XG4gIGlmICgodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKSAmJiAocHJvY2VzcyAhPT0gbnVsbCkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2xvYmFsUHJvY2Vzc0V4aXQoY29kZSkge1xuICBpZiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5leGl0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHJldHVybiBwcm9jZXNzLmV4aXQoY29kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlckV4ZWMobGlzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gbGlzdFtpXShhcmcpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcblxucmV0cmlldmVGaWxlSGFuZGxlcnMucHVzaChmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFRyaW0gdGhlIHBhdGggdG8gbWFrZSBzdXJlIHRoZXJlIGlzIG5vIGV4dHJhIHdoaXRlc3BhY2UuXG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgaWYgKC9eZmlsZTovLnRlc3QocGF0aCkpIHtcbiAgICAvLyBleGlzdHNTeW5jL3JlYWRGaWxlU3luYyBjYW4ndCBoYW5kbGUgZmlsZSBwcm90b2NvbCwgYnV0IG9uY2Ugc3RyaXBwZWQsIGl0IHdvcmtzXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvZmlsZTpcXC9cXC9cXC8oXFx3Oik/LywgZnVuY3Rpb24ocHJvdG9jb2wsIGRyaXZlKSB7XG4gICAgICByZXR1cm4gZHJpdmUgP1xuICAgICAgICAnJyA6IC8vIGZpbGU6Ly8vQzovZGlyL2ZpbGUgLT4gQzovZGlyL2ZpbGVcbiAgICAgICAgJy8nOyAvLyBmaWxlOi8vL3Jvb3QtZGlyL2ZpbGUgLT4gL3Jvb3QtZGlyL2ZpbGVcbiAgICB9KTtcbiAgfVxuICBpZiAocGF0aCBpbiBmaWxlQ29udGVudHNDYWNoZSkge1xuICAgIHJldHVybiBmaWxlQ29udGVudHNDYWNoZVtwYXRoXTtcbiAgfVxuXG4gIHZhciBjb250ZW50cyA9ICcnO1xuICB0cnkge1xuICAgIGlmICghZnMpIHtcbiAgICAgIC8vIFVzZSBTSkFYIGlmIHdlIGFyZSBpbiB0aGUgYnJvd3NlclxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIC8qKiBhc3luYyAqLyBmYWxzZSk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29udGVudHMgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4Jyk7XG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIC8qIGlnbm9yZSBhbnkgZXJyb3JzICovXG4gIH1cblxuICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF0gPSBjb250ZW50cztcbn0pO1xuXG4vLyBTdXBwb3J0IFVSTHMgcmVsYXRpdmUgdG8gYSBkaXJlY3RvcnksIGJ1dCBiZSBjYXJlZnVsIGFib3V0IGEgcHJvdG9jb2wgcHJlZml4XG4vLyBpbiBjYXNlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciAoaS5lLiBkaXJlY3RvcmllcyBtYXkgc3RhcnQgd2l0aCBcImh0dHA6Ly9cIiBvciBcImZpbGU6Ly8vXCIpXG5mdW5jdGlvbiBzdXBwb3J0UmVsYXRpdmVVUkwoZmlsZSwgdXJsKSB7XG4gIGlmICghZmlsZSkgcmV0dXJuIHVybDtcbiAgdmFyIGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgdmFyIG1hdGNoID0gL15cXHcrOlxcL1xcL1teXFwvXSovLmV4ZWMoZGlyKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICB2YXIgc3RhcnRQYXRoID0gZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCk7XG4gIGlmIChwcm90b2NvbCAmJiAvXlxcL1xcd1xcOi8udGVzdChzdGFydFBhdGgpKSB7XG4gICAgLy8gaGFuZGxlIGZpbGU6Ly8vQzovIHBhdGhzXG4gICAgcHJvdG9jb2wgKz0gJy8nO1xuICAgIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cbiAgcmV0dXJuIHByb3RvY29sICsgcGF0aC5yZXNvbHZlKGRpci5zbGljZShwcm90b2NvbC5sZW5ndGgpLCB1cmwpO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpIHtcbiAgdmFyIGZpbGVEYXRhO1xuXG4gIGlmIChpc0luQnJvd3NlcigpKSB7XG4gICAgIHRyeSB7XG4gICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgIHhoci5vcGVuKCdHRVQnLCBzb3VyY2UsIGZhbHNlKTtcbiAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICBmaWxlRGF0YSA9IHhoci5yZWFkeVN0YXRlID09PSA0ID8geGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG5cbiAgICAgICAvLyBTdXBwb3J0IHByb3ZpZGluZyBhIHNvdXJjZU1hcHBpbmdVUkwgdmlhIHRoZSBTb3VyY2VNYXAgaGVhZGVyXG4gICAgICAgdmFyIHNvdXJjZU1hcEhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIlNvdXJjZU1hcFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJYLVNvdXJjZU1hcFwiKTtcbiAgICAgICBpZiAoc291cmNlTWFwSGVhZGVyKSB7XG4gICAgICAgICByZXR1cm4gc291cmNlTWFwSGVhZGVyO1xuICAgICAgIH1cbiAgICAgfSBjYXRjaCAoZSkge1xuICAgICB9XG4gIH1cblxuICAvLyBHZXQgdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBmaWxlRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2UpO1xuICB2YXIgcmUgPSAvKD86XFwvXFwvW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspW1xcc10qJCl8KD86XFwvXFwqW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzKidcIl0rKVtcXHNdKig/OlxcKlxcLylbXFxzXSokKS9tZztcbiAgLy8gS2VlcCBleGVjdXRpbmcgdGhlIHNlYXJjaCB0byBmaW5kIHRoZSAqbGFzdCogc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZFxuICAvLyBwaWNraW5nIHVwIHNvdXJjZU1hcHBpbmdVUkxzIGZyb20gY29tbWVudHMsIHN0cmluZ3MsIGV0Yy5cbiAgdmFyIGxhc3RNYXRjaCwgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZmlsZURhdGEpKSBsYXN0TWF0Y2ggPSBtYXRjaDtcbiAgaWYgKCFsYXN0TWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4gbGFzdE1hdGNoWzFdO1xufTtcblxuLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHJldHJpZXZlU291cmNlTWFwIG9wdGlvbiB0byBpbnN0YWxsLiBUYWtlcyBhXG4vLyBnZW5lcmF0ZWQgc291cmNlIGZpbGVuYW1lOyByZXR1cm5zIGEge21hcCwgb3B0aW9uYWwgdXJsfSBvYmplY3QsIG9yIG51bGwgaWZcbi8vIHRoZXJlIGlzIG5vIHNvdXJjZSBtYXAuICBUaGUgbWFwIGZpZWxkIG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgdGhlIHBhcnNlZFxuLy8gSlNPTiBvYmplY3QgKGllLCBpdCBtdXN0IGJlIGEgdmFsaWQgYXJndW1lbnQgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyXG4vLyBjb25zdHJ1Y3RvcikuXG52YXIgcmV0cmlldmVTb3VyY2VNYXAgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZU1hcEhhbmRsZXJzKTtcbnJldHJpZXZlTWFwSGFuZGxlcnMucHVzaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZU1hcHBpbmdVUkwgPSByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpO1xuICBpZiAoIXNvdXJjZU1hcHBpbmdVUkwpIHJldHVybiBudWxsO1xuXG4gIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzb3VyY2UgbWFwXG4gIHZhciBzb3VyY2VNYXBEYXRhO1xuICBpZiAocmVTb3VyY2VNYXAudGVzdChzb3VyY2VNYXBwaW5nVVJMKSkge1xuICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkwgYXMgYSBkYXRhIHVybFxuICAgIHZhciByYXdEYXRhID0gc291cmNlTWFwcGluZ1VSTC5zbGljZShzb3VyY2VNYXBwaW5nVVJMLmluZGV4T2YoJywnKSArIDEpO1xuICAgIHNvdXJjZU1hcERhdGEgPSBidWZmZXJGcm9tKHJhd0RhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgc291cmNlTWFwcGluZ1VSTCA9IHNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMcyByZWxhdGl2ZSB0byB0aGUgc291cmNlIFVSTFxuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzdXBwb3J0UmVsYXRpdmVVUkwoc291cmNlLCBzb3VyY2VNYXBwaW5nVVJMKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gcmV0cmlldmVGaWxlKHNvdXJjZU1hcHBpbmdVUkwpO1xuICB9XG5cbiAgaWYgKCFzb3VyY2VNYXBEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVybDogc291cmNlTWFwcGluZ1VSTCxcbiAgICBtYXA6IHNvdXJjZU1hcERhdGFcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBtYXBTb3VyY2VQb3NpdGlvbihwb3NpdGlvbikge1xuICB2YXIgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXTtcbiAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAvLyBDYWxsIHRoZSAob3ZlcnJpZGVhYmxlKSByZXRyaWV2ZVNvdXJjZU1hcCBmdW5jdGlvbiB0byBnZXQgdGhlIHNvdXJjZSBtYXAuXG4gICAgdmFyIHVybEFuZE1hcCA9IHJldHJpZXZlU291cmNlTWFwKHBvc2l0aW9uLnNvdXJjZSk7XG4gICAgaWYgKHVybEFuZE1hcCkge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiB1cmxBbmRNYXAudXJsLFxuICAgICAgICBtYXA6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1cmxBbmRNYXAubWFwKVxuICAgICAgfTtcblxuICAgICAgLy8gTG9hZCBhbGwgc291cmNlcyBzdG9yZWQgaW5saW5lIHdpdGggdGhlIHNvdXJjZSBtYXAgaW50byB0aGUgZmlsZSBjYWNoZVxuICAgICAgLy8gdG8gcHJldGVuZCBsaWtlIHRoZXkgYXJlIGFscmVhZHkgbG9hZGVkLiBUaGV5IG1heSBub3QgZXhpc3Qgb24gZGlzay5cbiAgICAgIGlmIChzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHNvdXJjZU1hcC5tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSwgaSkge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHNvdXJjZU1hcC5tYXAuc291cmNlc0NvbnRlbnRbaV07XG4gICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZU1hcC51cmwsIHNvdXJjZSk7XG4gICAgICAgICAgICBmaWxlQ29udGVudHNDYWNoZVt1cmxdID0gY29udGVudHM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBtYXA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgc291cmNlIFVSTCByZWxhdGl2ZSB0byB0aGUgVVJMIG9mIHRoZSBzb3VyY2UgbWFwXG4gIGlmIChzb3VyY2VNYXAgJiYgc291cmNlTWFwLm1hcCAmJiB0eXBlb2Ygc291cmNlTWFwLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG9yaWdpbmFsUG9zaXRpb24gPSBzb3VyY2VNYXAubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IocG9zaXRpb24pO1xuXG4gICAgLy8gT25seSByZXR1cm4gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlmIGEgbWF0Y2hpbmcgbGluZSB3YXMgZm91bmQuIElmIG5vXG4gICAgLy8gbWF0Y2hpbmcgbGluZSBpcyBmb3VuZCB0aGVuIHdlIHJldHVybiBwb3NpdGlvbiBpbnN0ZWFkLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIHRvIHByaW50IHRoZSBwYXRoIGFuZCBsaW5lIGZvciB0aGUgY29tcGlsZWQgZmlsZS4gSXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSBhIHByZWNpc2UgbG9jYXRpb24gaW4gdGhlIGNvbXBpbGVkIGZpbGUgdGhhbiBhIHZhZ3VlXG4gICAgLy8gbG9jYXRpb24gaW4gdGhlIG9yaWdpbmFsIGZpbGUuXG4gICAgaWYgKG9yaWdpbmFsUG9zaXRpb24uc291cmNlICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9IHN1cHBvcnRSZWxhdGl2ZVVSTChcbiAgICAgICAgc291cmNlTWFwLnVybCwgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UpO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vLyBQYXJzZXMgY29kZSBnZW5lcmF0ZWQgYnkgRm9ybWF0RXZhbE9yaWdpbigpLCBhIGZ1bmN0aW9uIGluc2lkZSBWODpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanNcbmZ1bmN0aW9uIG1hcEV2YWxPcmlnaW4ob3JpZ2luKSB7XG4gIC8vIE1vc3QgZXZhbCgpIGNhbGxzIGFyZSBpbiB0aGlzIGZvcm1hdFxuICB2YXIgbWF0Y2ggPSAvXmV2YWwgYXQgKFteKF0rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogbWF0Y2hbMl0sXG4gICAgICBsaW5lOiArbWF0Y2hbM10sXG4gICAgICBjb2x1bW46IG1hdGNoWzRdIC0gMVxuICAgIH0pO1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgcG9zaXRpb24uc291cmNlICsgJzonICtcbiAgICAgIHBvc2l0aW9uLmxpbmUgKyAnOicgKyAocG9zaXRpb24uY29sdW1uICsgMSkgKyAnKSc7XG4gIH1cblxuICAvLyBQYXJzZSBuZXN0ZWQgZXZhbCgpIGNhbGxzIHVzaW5nIHJlY3Vyc2lvblxuICBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgbWFwRXZhbE9yaWdpbihtYXRjaFsyXSkgKyAnKSc7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHVzZWZ1bCBpbmZvcm1hdGlvbiBpZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyBUaGlzIGlzIGNvcGllZCBhbG1vc3QgdmVyYmF0aW0gZnJvbSB0aGUgVjggc291cmNlIGNvZGUgYXRcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanMuIFRoZVxuLy8gaW1wbGVtZW50YXRpb24gb2Ygd3JhcENhbGxTaXRlKCkgdXNlZCB0byBqdXN0IGZvcndhcmQgdG8gdGhlIGFjdHVhbCBzb3VyY2Vcbi8vIGNvZGUgb2YgQ2FsbFNpdGUucHJvdG90eXBlLnRvU3RyaW5nIGJ1dCB1bmZvcnR1bmF0ZWx5IGEgbmV3IHJlbGVhc2Ugb2YgVjhcbi8vIGRpZCBzb21ldGhpbmcgdG8gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgYnJva2UgdGhlIHNoaW0uIFRoZSBvbmx5IGZpeCBJXG4vLyBjb3VsZCBmaW5kIHdhcyBjb3B5L3Bhc3RlLlxuZnVuY3Rpb24gQ2FsbFNpdGVUb1N0cmluZygpIHtcbiAgdmFyIGZpbGVOYW1lO1xuICB2YXIgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOYXRpdmUoKSkge1xuICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSB0aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICAgIGlmICghZmlsZU5hbWUgJiYgdGhpcy5pc0V2YWwoKSkge1xuICAgICAgZmlsZUxvY2F0aW9uID0gdGhpcy5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgfVxuXG4gICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXG4gICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCk7XG4gICAgaWYgKGxpbmVOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgbGluZU51bWJlcjtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpO1xuICAgICAgaWYgKGNvbHVtbk51bWJlcikge1xuICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpbmUgPSBcIlwiO1xuICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgdmFyIGFkZFN1ZmZpeCA9IHRydWU7XG4gIHZhciBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc0NvbnN0cnVjdG9yKCk7XG4gIHZhciBpc01ldGhvZENhbGwgPSAhKHRoaXMuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xuICBpZiAoaXNNZXRob2RDYWxsKSB7XG4gICAgdmFyIHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZSgpO1xuICAgIC8vIEZpeGVzIHNoaW0gdG8gYmUgYmFja3dhcmQgY29tcGF0YWJsZSB3aXRoIE5vZGUgdjAgdG8gdjRcbiAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgIHR5cGVOYW1lID0gXCJudWxsXCI7XG4gICAgfVxuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5nZXRNZXRob2ROYW1lKCk7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPSAwKSB7XG4gICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPSBmdW5jdGlvbk5hbWUubGVuZ3RoIC0gbWV0aG9kTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmUgKz0gXCIgW2FzIFwiICsgbWV0aG9kTmFtZSArIFwiXVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCIgKyAobWV0aG9kTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgbGluZSArPSBcIm5ldyBcIiArIChmdW5jdGlvbk5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lICs9IGZpbGVMb2NhdGlvbjtcbiAgICBhZGRTdWZmaXggPSBmYWxzZTtcbiAgfVxuICBpZiAoYWRkU3VmZml4KSB7XG4gICAgbGluZSArPSBcIiAoXCIgKyBmaWxlTG9jYXRpb24gKyBcIilcIjtcbiAgfVxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDYWxsU2l0ZShmcmFtZSkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihmcmFtZSkpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIG9iamVjdFtuYW1lXSA9IC9eKD86aXN8Z2V0KS8udGVzdChuYW1lKSA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVbbmFtZV0uY2FsbChmcmFtZSk7IH0gOiBmcmFtZVtuYW1lXTtcbiAgfSk7XG4gIG9iamVjdC50b1N0cmluZyA9IENhbGxTaXRlVG9TdHJpbmc7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHdyYXBDYWxsU2l0ZShmcmFtZSwgc3RhdGUpIHtcbiAgLy8gcHJvdmlkZXMgaW50ZXJmYWNlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZSA9IHsgbmV4dFBvc2l0aW9uOiBudWxsLCBjdXJQb3NpdGlvbjogbnVsbCB9XG4gIH1cbiAgaWYoZnJhbWUuaXNOYXRpdmUoKSkge1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gbnVsbDtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgdmFyIHNvdXJjZSA9IGZyYW1lLmdldEZpbGVOYW1lKCkgfHwgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgbGluZSA9IGZyYW1lLmdldExpbmVOdW1iZXIoKTtcbiAgICB2YXIgY29sdW1uID0gZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCkgLSAxO1xuXG4gICAgLy8gRml4IHBvc2l0aW9uIGluIE5vZGUgd2hlcmUgc29tZSAoaW50ZXJuYWwpIGNvZGUgaXMgcHJlcGVuZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgLy8gSGVhZGVyIHJlbW92ZWQgaW4gbm9kZSBhdCBeMTAuMTYgfHwgPj0xMS4xMS4wXG4gICAgLy8gdjExIGlzIG5vdCBhbiBMVFMgY2FuZGlkYXRlLCB3ZSBjYW4ganVzdCB0ZXN0IHRoZSBvbmUgdmVyc2lvbiB3aXRoIGl0LlxuICAgIC8vIFRlc3Qgbm9kZSB2ZXJzaW9ucyBmb3I6IDEwLjE2LTE5LCAxMC4yMCssIDEyLTE5LCAyMC05OSwgMTAwKywgb3IgMTEuMTFcbiAgICB2YXIgbm9IZWFkZXIgPSAvXnYoMTBcXC4xWzYtOV18MTBcXC5bMi05XVswLTldfDEwXFwuWzAtOV17Myx9fDFbMi05XVxcZCp8WzItOV1cXGR8XFxkezMsfXwxMVxcLjExKS87XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IG5vSGVhZGVyLnRlc3QoZ2xvYmFsUHJvY2Vzc1ZlcnNpb24oKSkgPyAwIDogNjI7XG4gICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoICYmICFpc0luQnJvd3NlcigpICYmICFmcmFtZS5pc0V2YWwoKSkge1xuICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2x1bW46IGNvbHVtblxuICAgIH0pO1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICB2YXIgb3JpZ2luYWxGdW5jdGlvbk5hbWUgPSBmcmFtZS5nZXRGdW5jdGlvbk5hbWU7XG4gICAgZnJhbWUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhdGUubmV4dFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25OYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubmV4dFBvc2l0aW9uLm5hbWUgfHwgb3JpZ2luYWxGdW5jdGlvbk5hbWUoKTtcbiAgICB9O1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgdmFyIGVycm9yU3RyaW5nID0gbmFtZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cbiAgdmFyIHN0YXRlID0geyBuZXh0UG9zaXRpb246IG51bGwsIGN1clBvc2l0aW9uOiBudWxsIH07XG4gIHZhciBwcm9jZXNzZWRTdGFjayA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwcm9jZXNzZWRTdGFjay5wdXNoKCdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShzdGFja1tpXSwgc3RhdGUpKTtcbiAgICBzdGF0ZS5uZXh0UG9zaXRpb24gPSBzdGF0ZS5jdXJQb3NpdGlvbjtcbiAgfVxuICBzdGF0ZS5jdXJQb3NpdGlvbiA9IHN0YXRlLm5leHRQb3NpdGlvbiA9IG51bGw7XG4gIHJldHVybiBlcnJvclN0cmluZyArIHByb2Nlc3NlZFN0YWNrLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgICBhdCBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICAvLyBFbnN1cmUgZXJyb3IgaXMgcHJpbnRlZCBzeW5jaHJvbm91c2x5IGFuZCBub3QgdHJ1bmNhdGVkXG4gIHZhciBzdGRlcnIgPSBnbG9iYWxQcm9jZXNzU3RkZXJyKCk7XG4gIGlmIChzdGRlcnIgJiYgc3RkZXJyLl9oYW5kbGUgJiYgc3RkZXJyLl9oYW5kbGUuc2V0QmxvY2tpbmcpIHtcbiAgICBzdGRlcnIuX2hhbmRsZS5zZXRCbG9ja2luZyh0cnVlKTtcbiAgfVxuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcihzb3VyY2UpO1xuICB9XG5cbiAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XG4gIGdsb2JhbFByb2Nlc3NFeGl0KDEpO1xufVxuXG5mdW5jdGlvbiBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uICgpIHtcbiAgdmFyIG9yaWdFbWl0ID0gcHJvY2Vzcy5lbWl0O1xuXG4gIHByb2Nlc3MuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICAgIHZhciBoYXNTdGFjayA9IChhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnN0YWNrKTtcbiAgICAgIHZhciBoYXNMaXN0ZW5lcnMgPSAodGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoID4gMCk7XG5cbiAgICAgIGlmIChoYXNTdGFjayAmJiAhaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBwcmludEVycm9yQW5kRXhpdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycyA9IHJldHJpZXZlRmlsZUhhbmRsZXJzLnNsaWNlKDApO1xudmFyIG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycyA9IHJldHJpZXZlTWFwSGFuZGxlcnMuc2xpY2UoMCk7XG5cbmV4cG9ydHMud3JhcENhbGxTaXRlID0gd3JhcENhbGxTaXRlO1xuZXhwb3J0cy5nZXRFcnJvclNvdXJjZSA9IGdldEVycm9yU291cmNlO1xuZXhwb3J0cy5tYXBTb3VyY2VQb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uO1xuZXhwb3J0cy5yZXRyaWV2ZVNvdXJjZU1hcCA9IHJldHJpZXZlU291cmNlTWFwO1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgIGlmIChbXCJub2RlXCIsIFwiYnJvd3NlclwiLCBcImF1dG9cIl0uaW5kZXhPZihlbnZpcm9ubWVudCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBcIiArIGVudmlyb25tZW50ICsgXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cIilcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2VzIHRvIGJlIGZvdW5kIGJ5IG1ldGhvZHMgb3RoZXIgdGhhbiByZWFkaW5nIHRoZSBmaWxlc1xuICAvLyBkaXJlY3RseSBmcm9tIGRpc2suXG4gIGlmIChvcHRpb25zLnJldHJpZXZlRmlsZSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVGaWxlKSB7XG4gICAgICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZUZpbGUpO1xuICB9XG5cbiAgLy8gQWxsb3cgc291cmNlIG1hcHMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJldHJpZXZlU291cmNlTWFwKSB7XG4gICAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVNYXBIYW5kbGVycy51bnNoaWZ0KG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBydW50aW1lIHRyYW5zcGlsZXJzIHRoYXQgaW5jbHVkZSBpbmxpbmUgc291cmNlIG1hcHNcbiAgaWYgKG9wdGlvbnMuaG9va1JlcXVpcmUgJiYgIWlzSW5Ccm93c2VyKCkpIHtcbiAgICAvLyBVc2UgZHluYW1pY1JlcXVpcmUgdG8gYXZvaWQgaW5jbHVkaW5nIGluIGJyb3dzZXIgYnVuZGxlc1xuICAgIHZhciBNb2R1bGUgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdtb2R1bGUnKTtcbiAgICB2YXIgJGNvbXBpbGUgPSBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlO1xuXG4gICAgaWYgKCEkY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQpIHtcbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihjb250ZW50LCBmaWxlbmFtZSkge1xuICAgICAgICBmaWxlQ29udGVudHNDYWNoZVtmaWxlbmFtZV0gPSBjb250ZW50O1xuICAgICAgICBzb3VyY2VNYXBDYWNoZVtmaWxlbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAkY29tcGlsZS5jYWxsKHRoaXMsIGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmUgb3B0aW9uc1xuICBpZiAoIWVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9ICdlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5lbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIEluc3RhbGwgdGhlIGVycm9yIHJlZm9ybWF0dGVyXG4gIGlmICghZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQpIHtcbiAgICBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IHRydWU7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGlmICghdW5jYXVnaHRTaGltSW5zdGFsbGVkKSB7XG4gICAgdmFyIGluc3RhbGxIYW5kbGVyID0gJ2hhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucyA6IHRydWU7XG5cbiAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgJ3VuY2F1Z2h0RXhjZXB0aW9uJyB3aXRoIG91ciBvd24gaGFuZGxlciBpbiBOb2RlLmpzXG4gICAgLy8gV29ya2VyIHRocmVhZHMuIFdvcmtlcnMgcGFzcyB0aGUgZXJyb3IgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGFuIGV2ZW50LFxuICAgIC8vIHJhdGhlciB0aGFuIHByaW50aW5nIHNvbWV0aGluZyB0byBzdGRlcnIgYW5kIGV4aXRpbmcuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGBkeW5hbWljUmVxdWlyZWAgYmVjYXVzZSBgcmVxdWlyZWAgb24gaXQncyBvd24gd2lsbCBiZSBvcHRpbWl6ZWQgYnkgV2ViUGFjay9Ccm93c2VyaWZ5LlxuICAgICAgdmFyIHdvcmtlcl90aHJlYWRzID0gZHluYW1pY1JlcXVpcmUobW9kdWxlLCAnd29ya2VyX3RocmVhZHMnKTtcbiAgICAgIGlmICh3b3JrZXJfdGhyZWFkcy5pc01haW5UaHJlYWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc3RhbGxIYW5kbGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7fVxuXG4gICAgLy8gUHJvdmlkZSB0aGUgb3B0aW9uIHRvIG5vdCBpbnN0YWxsIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlci4gVGhpcyBpc1xuICAgIC8vIHRvIHN1cHBvcnQgb3RoZXIgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJzIChpbiB0ZXN0IGZyYW1ld29ya3MsIGZvclxuICAgIC8vIGV4YW1wbGUpLiBJZiB0aGlzIGhhbmRsZXIgaXMgbm90IGluc3RhbGxlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuY2F1Z2h0XG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgY2F1Z2h0IGJ5IG5vZGUncyBidWlsdC1pblxuICAgIC8vIGV4Y2VwdGlvbiBoYW5kbGVyIGFuZCB0aGUgcHJvY2VzcyB3aWxsIHN0aWxsIGJlIHRlcm1pbmF0ZWQuIEhvd2V2ZXIsIHRoZVxuICAgIC8vIGdlbmVyYXRlZCBKYXZhU2NyaXB0IGNvZGUgd2lsbCBiZSBzaG93biBhYm92ZSB0aGUgc3RhY2sgdHJhY2UgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICBpZiAoaW5zdGFsbEhhbmRsZXIgJiYgaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpKSB7XG4gICAgICB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5yZXNldFJldHJpZXZlSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0cmlldmVGaWxlSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgcmV0cmlldmVNYXBIYW5kbGVycy5sZW5ndGggPSAwO1xuXG4gIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycy5zbGljZSgwKTtcbiAgcmV0cmlldmVNYXBIYW5kbGVycyA9IG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycy5zbGljZSgwKTtcblxuICByZXRyaWV2ZVNvdXJjZU1hcCA9IGhhbmRsZXJFeGVjKHJldHJpZXZlTWFwSGFuZGxlcnMpO1xuICByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG59XG4iLCAicmVxdWlyZSgnLi8nKS5pbnN0YWxsKCk7XG4iLCAiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjMwLjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcygpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnM6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlcjogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkRXJhOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXG4gICAgICAgICAgICBlcmE6IG51bGwsXG4gICAgICAgICAgICBtZXJpZGllbTogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjI6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIHZhciBmbGFncyA9IG51bGwsXG4gICAgICAgICAgICBwYXJzZWRQYXJ0cyA9IGZhbHNlLFxuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IG0uX2QgJiYgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKGlzTm93VmFsaWQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBtb21lbnRQcm9wZXJ0aWVzTGVuID0gbW9tZW50UHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgICAgICAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHtcbiAgICAgICAgRDogJ2RhdGUnLFxuICAgICAgICBkYXRlczogJ2RhdGUnLFxuICAgICAgICBkYXRlOiAnZGF0ZScsXG4gICAgICAgIGQ6ICdkYXknLFxuICAgICAgICBkYXlzOiAnZGF5JyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgZTogJ3dlZWtkYXknLFxuICAgICAgICB3ZWVrZGF5czogJ3dlZWtkYXknLFxuICAgICAgICB3ZWVrZGF5OiAnd2Vla2RheScsXG4gICAgICAgIEU6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgaXNvd2Vla2RheXM6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgaXNvd2Vla2RheTogJ2lzb1dlZWtkYXknLFxuICAgICAgICBEREQ6ICdkYXlPZlllYXInLFxuICAgICAgICBkYXlvZnllYXJzOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgZGF5b2Z5ZWFyOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgaDogJ2hvdXInLFxuICAgICAgICBob3VyczogJ2hvdXInLFxuICAgICAgICBob3VyOiAnaG91cicsXG4gICAgICAgIG1zOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICBtaWxsaXNlY29uZHM6ICdtaWxsaXNlY29uZCcsXG4gICAgICAgIG1pbGxpc2Vjb25kOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICBtOiAnbWludXRlJyxcbiAgICAgICAgbWludXRlczogJ21pbnV0ZScsXG4gICAgICAgIG1pbnV0ZTogJ21pbnV0ZScsXG4gICAgICAgIE06ICdtb250aCcsXG4gICAgICAgIG1vbnRoczogJ21vbnRoJyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIFE6ICdxdWFydGVyJyxcbiAgICAgICAgcXVhcnRlcnM6ICdxdWFydGVyJyxcbiAgICAgICAgcXVhcnRlcjogJ3F1YXJ0ZXInLFxuICAgICAgICBzOiAnc2Vjb25kJyxcbiAgICAgICAgc2Vjb25kczogJ3NlY29uZCcsXG4gICAgICAgIHNlY29uZDogJ3NlY29uZCcsXG4gICAgICAgIGdnOiAnd2Vla1llYXInLFxuICAgICAgICB3ZWVreWVhcnM6ICd3ZWVrWWVhcicsXG4gICAgICAgIHdlZWt5ZWFyOiAnd2Vla1llYXInLFxuICAgICAgICBHRzogJ2lzb1dlZWtZZWFyJyxcbiAgICAgICAgaXNvd2Vla3llYXJzOiAnaXNvV2Vla1llYXInLFxuICAgICAgICBpc293ZWVreWVhcjogJ2lzb1dlZWtZZWFyJyxcbiAgICAgICAgdzogJ3dlZWsnLFxuICAgICAgICB3ZWVrczogJ3dlZWsnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIFc6ICdpc29XZWVrJyxcbiAgICAgICAgaXNvd2Vla3M6ICdpc29XZWVrJyxcbiAgICAgICAgaXNvd2VlazogJ2lzb1dlZWsnLFxuICAgICAgICB5OiAneWVhcicsXG4gICAgICAgIHllYXJzOiAneWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7XG4gICAgICAgIGRhdGU6IDksXG4gICAgICAgIGRheTogMTEsXG4gICAgICAgIHdlZWtkYXk6IDExLFxuICAgICAgICBpc29XZWVrZGF5OiAxMSxcbiAgICAgICAgZGF5T2ZZZWFyOiA0LFxuICAgICAgICBob3VyOiAxMyxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDE2LFxuICAgICAgICBtaW51dGU6IDE0LFxuICAgICAgICBtb250aDogOCxcbiAgICAgICAgcXVhcnRlcjogNyxcbiAgICAgICAgc2Vjb25kOiAxNSxcbiAgICAgICAgd2Vla1llYXI6IDEsXG4gICAgICAgIGlzb1dlZWtZZWFyOiAxLFxuICAgICAgICB3ZWVrOiA1LFxuICAgICAgICBpc29XZWVrOiA1LFxuICAgICAgICB5ZWFyOiAxLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgPSAvXFxkLywgLy8gICAgICAgMCAtIDlcbiAgICAgICAgbWF0Y2gyID0gL1xcZFxcZC8sIC8vICAgICAgMDAgLSA5OVxuICAgICAgICBtYXRjaDMgPSAvXFxkezN9LywgLy8gICAgIDAwMCAtIDk5OVxuICAgICAgICBtYXRjaDQgPSAvXFxkezR9LywgLy8gICAgMDAwMCAtIDk5OTlcbiAgICAgICAgbWF0Y2g2ID0gL1srLV0/XFxkezZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzIgPSAvXFxkXFxkPy8sIC8vICAgICAgIDAgLSA5OVxuICAgICAgICBtYXRjaDN0bzQgPSAvXFxkXFxkXFxkXFxkPy8sIC8vICAgICA5OTkgLSA5OTk5XG4gICAgICAgIG1hdGNoNXRvNiA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LywgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzMgPSAvXFxkezEsM30vLCAvLyAgICAgICAwIC0gOTk5XG4gICAgICAgIG1hdGNoMXRvNCA9IC9cXGR7MSw0fS8sIC8vICAgICAgIDAgLSA5OTk5XG4gICAgICAgIG1hdGNoMXRvNiA9IC9bKy1dP1xcZHsxLDZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaFVuc2lnbmVkID0gL1xcZCsvLCAvLyAgICAgICAwIC0gaW5mXG4gICAgICAgIG1hdGNoU2lnbmVkID0gL1srLV0/XFxkKy8sIC8vICAgIC1pbmYgLSBpbmZcbiAgICAgICAgbWF0Y2hPZmZzZXQgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2ksIC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcbiAgICAgICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICAgICAgbWF0Y2hXb3JkID1cbiAgICAgICAgICAgIC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pLFxuICAgICAgICBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvID0gL15bMS05XVxcZD8vLCAvLyAgICAgICAgIDEtOTlcbiAgICAgICAgbWF0Y2gxdG8ySGFzWmVybyA9IC9eKFsxLTldXFxkfFxcZCkvLCAvLyAgICAgICAgICAgMC05OVxuICAgICAgICByZWdleGVzO1xuXG4gICAgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbih0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleClcbiAgICAgICAgICAgID8gcmVnZXhcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXggPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUoXG4gICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGZ1bmMgPSBjYWxsYmFjayxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbkxlbiA9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IG1vbS5fZCxcbiAgICAgICAgICAgIGlzVVRDID0gbW9tLl9pc1VUQztcblxuICAgICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ01pbGxpc2Vjb25kcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBjYXNlICdTZWNvbmRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ1NlY29uZHMoKSA6IGQuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgY2FzZSAnTWludXRlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENNaW51dGVzKCkgOiBkLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIGNhc2UgJ0hvdXJzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0hvdXJzKCkgOiBkLmdldEhvdXJzKCk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0RhdGUoKSA6IGQuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgY2FzZSAnRGF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ0RheSgpIDogZC5nZXREYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ01vbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNVVEMgPyBkLmdldFVUQ01vbnRoKCkgOiBkLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBjYXNlICdGdWxsWWVhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVVRDID8gZC5nZXRVVENGdWxsWWVhcigpIDogZC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOOyAvLyBKdXN0IGluIGNhc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGQsIGlzVVRDLCB5ZWFyLCBtb250aCwgZGF0ZTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkID0gbW9tLl9kO1xuICAgICAgICBpc1VUQyA9IG1vbS5faXNVVEM7XG5cbiAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICBjYXNlICdNaWxsaXNlY29uZHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChpc1VUQ1xuICAgICAgICAgICAgICAgICAgICA/IGQuc2V0VVRDTWlsbGlzZWNvbmRzKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGQuc2V0TWlsbGlzZWNvbmRzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdTZWNvbmRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ1NlY29uZHModmFsdWUpIDogZC5zZXRTZWNvbmRzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdNaW51dGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ01pbnV0ZXModmFsdWUpIDogZC5zZXRNaW51dGVzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdIb3Vycyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKGlzVVRDID8gZC5zZXRVVENIb3Vycyh2YWx1ZSkgOiBkLnNldEhvdXJzKHZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAoaXNVVEMgPyBkLnNldFVUQ0RhdGUodmFsdWUpIDogZC5zZXREYXRlKHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBjYXNlICdEYXknOiAvLyBOb3QgcmVhbFxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZvaWQgKGlzVVRDID8gZC5zZXRVVENEYXkodmFsdWUpIDogZC5zZXREYXkodmFsdWUpKTtcbiAgICAgICAgICAgIC8vIGNhc2UgJ01vbnRoJzogLy8gTm90IHVzZWQgYmVjYXVzZSB3ZSBuZWVkIHRvIHBhc3MgdHdvIHZhcmlhYmxlc1xuICAgICAgICAgICAgLy8gICAgIHJldHVybiB2b2lkIChpc1VUQyA/IGQuc2V0VVRDTW9udGgodmFsdWUpIDogZC5zZXRNb250aCh2YWx1ZSkpO1xuICAgICAgICAgICAgY2FzZSAnRnVsbFllYXInOlxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBTZWUgYmVsb3cgLi4uXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSnVzdCBpbiBjYXNlXG4gICAgICAgIH1cblxuICAgICAgICB5ZWFyID0gdmFsdWU7XG4gICAgICAgIG1vbnRoID0gbW9tLm1vbnRoKCk7XG4gICAgICAgIGRhdGUgPSBtb20uZGF0ZSgpO1xuICAgICAgICBkYXRlID0gZGF0ZSA9PT0gMjkgJiYgbW9udGggPT09IDEgJiYgIWlzTGVhcFllYXIoeWVhcikgPyAyOCA6IGRhdGU7XG4gICAgICAgIHZvaWQgKGlzVVRDXG4gICAgICAgICAgICA/IGQuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRhdGUpXG4gICAgICAgICAgICA6IGQuc2V0RnVsbFllYXIoeWVhciwgbW9udGgsIGRhdGUpKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHByaW9yaXRpemVkTGVuID0gcHJpb3JpdGl6ZWQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIsIG1hdGNoMXRvMk5vTGVhZGluZ1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPVxuICAgICAgICAgICAgJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KFxuICAgICAgICAgICAgICAgICdfJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID1cbiAgICAgICAgICAgICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LyxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyhtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzW1xuICAgICAgICAgICAgICAgICAgKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbXG4gICAgICAgICAgICAgICAgICBNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGgobW9tLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9udGggPSB2YWx1ZSxcbiAgICAgICAgICAgIGRhdGUgPSBtb20uZGF0ZSgpO1xuXG4gICAgICAgIGRhdGUgPSBkYXRlIDwgMjkgPyBkYXRlIDogTWF0aC5taW4oZGF0ZSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgbW9udGgpKTtcbiAgICAgICAgdm9pZCAobW9tLl9pc1VUQ1xuICAgICAgICAgICAgPyBtb20uX2Quc2V0VVRDTW9udGgobW9udGgsIGRhdGUpXG4gICAgICAgICAgICA6IG1vbS5fZC5zZXRNb250aChtb250aCwgZGF0ZSkpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBzaG9ydFAsXG4gICAgICAgICAgICBsb25nUDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFAgPSByZWdleEVzY2FwZSh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQID0gcmVnZXhFc2NhcGUodGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydFApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdQKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ1ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydFApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSArIDQwMCwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUoeSkge1xuICAgICAgICB2YXIgZGF0ZSwgYXJncztcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhcixcbiAgICAgICAgICAgIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssXG4gICAgICAgICAgICByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9XG4gICAgICAgICAgICAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cylcbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNcbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNbXG4gICAgICAgICAgICAgICAgICBtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF07XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV1cbiAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzKG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXkgPSBnZXQodGhpcywgJ0RheScpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJIYXNaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJOb0xlYWRpbmdaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgLy8gRW5zdXJlIG5hbWUgaXMgYXZhaWxhYmxlIGFuZCBmdW5jdGlvbiByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgcmV0dXJuICEhKG5hbWUgJiYgbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbCxcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBtb2R1bGUgJiZcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgICAgICAgICBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayBhcyBub3QgZm91bmQgdG8gYXZvaWQgcmVwZWF0aW5nIGV4cGVuc2l2ZSBmaWxlIHJlcXVpcmUgY2FsbCBjYXVzaW5nIGhpZ2ggQ1BVXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gZmluZCBlbi1VUywgZW5fVVMsIGVuLXVzIGZvciBldmVyeSBmb3JtYXQgY2FsbFxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBudWxsOyAvLyBudWxsIG1lYW5zIG5vdCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICdMb2NhbGUgJyArIGtleSArICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PydcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwgJiYgbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjaGlsZCBsb2NhbGUgaW4tcGxhY2UgdG8gYXZvaWQgbWVtb3J5LWxlYWtzXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQobWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUxvY2FsZSBpcyBjYWxsZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWJiciBzbyBpdCB3aWxsIGhhdmUgYSBuYW1lIChnZXR0ZXJzIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgb3RoZXJ3aXNlKS5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGdldFNldEdsb2JhbExvY2FsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZShrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3csXG4gICAgICAgICAgICBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gPCAwIHx8IGFbTU9OVEhdID4gMTFcbiAgICAgICAgICAgICAgICAgICAgPyBNT05USFxuICAgICAgICAgICAgICAgICAgICA6IGFbREFURV0gPCAxIHx8IGFbREFURV0gPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSlcbiAgICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSAhPT0gMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsyXVxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCksXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxuICAgICAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIDEpIEFTUC5ORVQsIDIpIElTTywgMykgUkZDIDI4MjIgZm9ybWF0cywgb3IgNCkgb3B0aW9uYWwgZmFsbGJhY2sgaWYgcGFyc2luZyBpc24ndCBzdHJpY3RcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgICAgICdkaXNjb3VyYWdlZC4gUGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWRXZWVrZGF5LFxuICAgICAgICAgICAgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID1cbiAgICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPT0gbnVsbCA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcbiAgICAgICAgICAgIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB3LkdHLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSxcbiAgICAgICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGVyYSxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcbiAgICAgICAgICAgICAgICBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBoYW5kbGUgZXJhXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcbiAgICAgICAgaWYgKGVyYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUsXG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kLFxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ2ZMZW4gPSBjb25maWcuX2YubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjb25maWdmTGVuID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnZkxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG9yZGVyTGVuID0gb3JkZXJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICsgcXVhcnRlcnMgKiAzICsgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNpZ24gK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn5vZmZzZXQgJSA2MCwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICBwYXJ0cyA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID1cbiAgICAgICAgICAgICAgICAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgb3RoZXI7XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKTooXFxkKykoPzo6KFxcZCspKFxcLlxcZCopPyk/JC8sXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgICBpc29SZWdleCA9XG4gICAgICAgICAgICAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5TGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICAgIDogZGlmZiA8IDBcbiAgICAgICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICAgICAgICAgIDogZGlmZiA8IDdcbiAgICAgICAgICAgICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFxuICAgICAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgdmFyIGVyYSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRSZWdleFRva2VuKCd5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneW8nLCBtYXRjaEVyYVllYXJPcmRpbmFsKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWyd5byddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLl9lcmFzIHx8IGdldExvY2FsZSgnZW4nKS5fZXJhcztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0uc2luY2UgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnVudGlsKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc1BhcnNlKGVyYU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmJyLFxuICAgICAgICAgICAgbmFycm93O1xuICAgICAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGVyYXNbaV0ubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbmFycm93ID0gZXJhc1tpXS5uYXJyb3cudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJiciA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hcnJvdyA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbbmFtZSwgYWJiciwgbmFycm93XS5pbmRleE9mKGVyYU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICAgICAgdmFyIGRpciA9IGVyYS5zaW5jZSA8PSBlcmEudW50aWwgPyArMSA6IC0xO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFtZSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhWWVhcigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB8fFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFtZVJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFtZVJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc0FiYnJSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc0FiYnJSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzQWJiclJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4IHx8IG1hdGNoVW5zaWduZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICAgICAgdmFyIGFiYnJQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhc05hbWUsXG4gICAgICAgICAgICBlcmFzQWJicixcbiAgICAgICAgICAgIGVyYXNOYXJyb3csXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBlcmFzTmFtZSA9IHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSk7XG4gICAgICAgICAgICBlcmFzQWJiciA9IHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicik7XG4gICAgICAgICAgICBlcmFzTmFycm93ID0gcmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpO1xuXG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2goZXJhc05hbWUpO1xuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKGVyYXNBYmJyKTtcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKGVyYXNOYXJyb3cpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChlcmFzTmFtZSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGVyYXNBYmJyKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goZXJhc05hcnJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lcmFzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFycm93UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCkgKyB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMiwgbWF0Y2gxdG8yTm9MZWFkaW5nWmVybyk7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPVxuICAgICAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNVxuICAgICAgICAgICAgKSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoaW5wdXQgLSBkYXlPZlllYXIsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCBtYXRjaDF0bzIsIG1hdGNoMXRvMkhhc1plcm8pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgbWF0Y2gxdG8yLCBtYXRjaDF0bzJIYXNaZXJvKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICduZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyksXG4gICAgICAgIGFzU2Vjb25kcyA9IG1ha2VBcygncycpLFxuICAgICAgICBhc01pbnV0ZXMgPSBtYWtlQXMoJ20nKSxcbiAgICAgICAgYXNIb3VycyA9IG1ha2VBcygnaCcpLFxuICAgICAgICBhc0RheXMgPSBtYWtlQXMoJ2QnKSxcbiAgICAgICAgYXNXZWVrcyA9IG1ha2VBcygndycpLFxuICAgICAgICBhc01vbnRocyA9IG1ha2VBcygnTScpLFxuICAgICAgICBhc1F1YXJ0ZXJzID0gbWFrZUFzKCdRJyksXG4gICAgICAgIGFzWWVhcnMgPSBtYWtlQXMoJ3knKSxcbiAgICAgICAgdmFsdWVPZiQxID0gYXNNaWxsaXNlY29uZHM7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMzAuMSc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGpvaSkgPT4ge1xuXG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgZm9ybWF0OiBqb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgIGpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGpvaS5hcnJheSgpLml0ZW1zKGpvaS5zdHJpbmcoKS5pbnZhbGlkKCdpc28nLCAnamF2YXNjcmlwdCcsICd1bml4JykpXG4gICAgICAgIF0pXG4gICAgfTtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICBiYXNlOiBqb2kuZGF0ZSgpLFxuXG4gICAgICAgIGNvZXJjZToge1xuICAgICAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLiRfZ2V0RmxhZygnZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBzY2hlbWEuJF9nZXRGbGFnKCd1dGMnKSA/IE1vbWVudC51dGModmFsdWUsIGZvcm1hdCwgdHJ1ZSkgOiBNb21lbnQodmFsdWUsIGZvcm1hdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBkYXRlLnRvRGF0ZSgpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgICB1dGM6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndXRjJywgZW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBqb2kuYXR0ZW1wdChmb3JtYXQsIGFyZ3MuZm9ybWF0LCAnSW52YWxpZCBmb3JtYXQnKTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc3VwZXIuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBUeXBlU2NyaXB0IG1vZHVsZSBpbnRlcm9wXG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gJ1tDYW5ub3QgZGlzcGxheSBvYmplY3Q6ICcgKyBlcnIubWVzc2FnZSArICddJztcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoYXJncykge1xuXG4gICAgICAgIGNvbnN0IG1zZ3MgPSBhcmdzXG4gICAgICAgICAgICAuZmlsdGVyKChhcmcpID0+IGFyZyAhPT0gJycpXG4gICAgICAgICAgICAubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6IGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLm1lc3NhZ2UgOiBTdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykgeyAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZXhwb3J0cy5hc3NlcnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgLi4uYXJncykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuXG4gICAgICAgIHRocm93IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKGFyZ3MpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBjaGFpbiwgb3B0aW9ucykge1xuXG4gICAgaWYgKGNoYWluID09PSBmYWxzZSB8fFxuICAgICAgICBjaGFpbiA9PT0gbnVsbCB8fFxuICAgICAgICBjaGFpbiA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHNlcGFyYXRvcjogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGNvbnN0IGlzQ2hhaW5BcnJheSA9IEFycmF5LmlzQXJyYXkoY2hhaW4pO1xuXG4gICAgQXNzZXJ0KCFpc0NoYWluQXJyYXkgfHwgIW9wdGlvbnMuc2VwYXJhdG9yLCAnU2VwYXJhdG9yIG9wdGlvbiBpcyBub3QgdmFsaWQgZm9yIGFycmF5LWJhc2VkIGNoYWluJyk7XG5cbiAgICBjb25zdCBwYXRoID0gaXNDaGFpbkFycmF5ID8gY2hhaW4gOiBjaGFpbi5zcGxpdChvcHRpb25zLnNlcGFyYXRvciB8fCAnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBrZXkgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5pdGVyYWJsZXMgJiYgaW50ZXJuYWxzLml0ZXJhYmxlcyhyZWYpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bWJlciA8IDAgPyByZWYubGVuZ3RoICsgbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWYgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5mdW5jdGlvbnMgPT09IGZhbHNlIHx8ICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgIXR5cGUgJiYgcmVmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBBc3NlcnQoIW9wdGlvbnMuc3RyaWN0IHx8IGkgKyAxID09PSBwYXRoLmxlbmd0aCwgJ01pc3Npbmcgc2VnbWVudCcsIGtleSwgJ2luIHJlYWNoIHBhdGggJywgY2hhaW4pO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuZnVuY3Rpb25zID09PSB0cnVlIHx8IHR5cGVvZiByZWYgIT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIHJlZiA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZWYgPSByZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2V0Jykge1xuICAgICAgICAgICAgcmVmID0gWy4uLnJlZl1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgIC8vIHR5cGUgPT09ICdtYXAnXG4gICAgICAgICAgICByZWYgPSByZWYuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmO1xufTtcblxuXG5pbnRlcm5hbHMuaXRlcmFibGVzID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gJ3NldCc7XG4gICAgfVxuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gJ21hcCc7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheTogQXJyYXkucHJvdG90eXBlLFxuICAgIGJ1ZmZlcjogQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUsICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGRhdGU6IERhdGUucHJvdG90eXBlLFxuICAgIGVycm9yOiBFcnJvci5wcm90b3R5cGUsXG4gICAgZ2VuZXJpYzogT2JqZWN0LnByb3RvdHlwZSxcbiAgICBtYXA6IE1hcC5wcm90b3R5cGUsXG4gICAgcHJvbWlzZTogUHJvbWlzZS5wcm90b3R5cGUsXG4gICAgcmVnZXg6IFJlZ0V4cC5wcm90b3R5cGUsXG4gICAgc2V0OiBTZXQucHJvdG90eXBlLFxuICAgIHdlYWtNYXA6IFdlYWtNYXAucHJvdG90eXBlLFxuICAgIHdlYWtTZXQ6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG5cbmludGVybmFscy50eXBlTWFwID0gbmV3IE1hcChbXG4gICAgWydbb2JqZWN0IEVycm9yXScsIGV4cG9ydHMuZXJyb3JdLFxuICAgIFsnW29iamVjdCBNYXBdJywgZXhwb3J0cy5tYXBdLFxuICAgIFsnW29iamVjdCBQcm9taXNlXScsIGV4cG9ydHMucHJvbWlzZV0sXG4gICAgWydbb2JqZWN0IFNldF0nLCBleHBvcnRzLnNldF0sXG4gICAgWydbb2JqZWN0IFdlYWtNYXBdJywgZXhwb3J0cy53ZWFrTWFwXSxcbiAgICBbJ1tvYmplY3QgV2Vha1NldF0nLCBleHBvcnRzLndlYWtTZXRdXG5dKTtcblxuXG5leHBvcnRzLmdldEludGVybmFsUHJvdG8gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFycmF5O1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQnVmZmVyKSB7ICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICByZXR1cm4gZXhwb3J0cy5idWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlZ2V4O1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgcmV0dXJuIGludGVybmFscy50eXBlTWFwLmdldChvYmpOYW1lKSB8fCBleHBvcnRzLmdlbmVyaWM7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5zeW1ib2xzICE9PSBmYWxzZSA/IFJlZmxlY3Qub3duS2V5cyhvYmopIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTsgIC8vIERlZmF1bHRzIHRvIHRydWVcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJy4vcmVhY2gnKTtcbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5lZWRzUHJvdG9IYWNrOiBuZXcgU2V0KFtUeXBlcy5zZXQsIFR5cGVzLm1hcCwgVHlwZXMud2Vha1NldCwgVHlwZXMud2Vha01hcF0pXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLmNsb25lID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9LCBfc2VlbiA9IG51bGwpIHtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxldCBjbG9uZSA9IGludGVybmFscy5jbG9uZTtcbiAgICBsZXQgc2VlbiA9IF9zZWVuO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFsbG93ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb25lV2l0aFNoYWxsb3cob2JqLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2Vlbikge1xuICAgICAgICBjb25zdCBsb29rdXAgPSBzZWVuLmdldChvYmopO1xuICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWx0LWluIG9iamVjdCB0eXBlc1xuXG4gICAgY29uc3QgYmFzZVByb3RvID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKG9iaik7ICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5kYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5yZWdleCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmopO1xuICAgIH1cblxuICAgIC8vIEdlbmVyaWMgb2JqZWN0c1xuXG4gICAgY29uc3QgbmV3T2JqID0gaW50ZXJuYWxzLmJhc2Uob2JqLCBiYXNlUHJvdG8sIG9wdGlvbnMpO1xuICAgIGlmIChuZXdPYmogPT09IG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4uc2V0KG9iaiwgbmV3T2JqKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2Vlbiwgc2luY2Ugb2JqIGNvdWxkIHJlY3Vyc2VcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5hZGQoY2xvbmUodmFsdWUsIG9wdGlvbnMsIHNlZW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLm1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5zZXQoa2V5LCBjbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IFV0aWxzLmtleXMob2JqLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ICYmXG4gICAgICAgICAgICBrZXkgPT09ICdsZW5ndGgnKSB7XG5cbiAgICAgICAgICAgIG5ld09iai5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCkge1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBzZWVuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqO1xufTtcblxuXG5pbnRlcm5hbHMuY2xvbmVXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gUmVhY2goc291cmNlLCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgc2Vlbi5zZXQocmVmLCByZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5jbG9uZShzb3VyY2UsIG9wdGlvbnMsIHNlZW4pO1xufTtcblxuXG5pbnRlcm5hbHMuYmFzZSA9IGZ1bmN0aW9uIChvYmosIGJhc2VQcm90bywgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMucHJvdG90eXBlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNlUHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ID8gW10gOiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIGlmIChwcm90byAmJlxuICAgICAgICBwcm90by5pc0ltbXV0YWJsZSkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gW107XG4gICAgICAgIGlmIChwcm90byAhPT0gYmFzZVByb3RvKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3T2JqLCBwcm90byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbHMubmVlZHNQcm90b0hhY2suaGFzKGJhc2VQcm90bykpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gbmV3IHByb3RvLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChwcm90byAhPT0gYmFzZVByb3RvKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3T2JqLCBwcm90byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbn07XG4iLCAie1xuICAgIFwibmFtZVwiOiBcImpvaVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPYmplY3Qgc2NoZW1hIHZhbGlkYXRpb25cIixcbiAgICBcInZlcnNpb25cIjogXCIxNy4xMy4xXCIsXG4gICAgXCJyZXBvc2l0b3J5XCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9oYXBpanMvam9pXCIsXG4gICAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gICAgXCJ0eXBlc1wiOiBcImxpYi9pbmRleC5kLnRzXCIsXG4gICAgXCJicm93c2VyXCI6IFwiZGlzdC9qb2ktYnJvd3Nlci5taW4uanNcIixcbiAgICBcImZpbGVzXCI6IFtcbiAgICAgICAgXCJsaWIvKiovKlwiLFxuICAgICAgICBcImRpc3QvKlwiXG4gICAgXSxcbiAgICBcImtleXdvcmRzXCI6IFtcbiAgICAgICAgXCJzY2hlbWFcIixcbiAgICAgICAgXCJ2YWxpZGF0aW9uXCJcbiAgICBdLFxuICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgXCJAaGFwaS9ob2VrXCI6IFwiXjkuMy4wXCIsXG4gICAgICAgIFwiQGhhcGkvdG9wb1wiOiBcIl41LjEuMFwiLFxuICAgICAgICBcIkBzaWRld2F5L2FkZHJlc3NcIjogXCJeNC4xLjVcIixcbiAgICAgICAgXCJAc2lkZXdheS9mb3JtdWxhXCI6IFwiXjMuMC4xXCIsXG4gICAgICAgIFwiQHNpZGV3YXkvcGlucG9pbnRcIjogXCJeMi4wLjBcIlxuICAgIH0sXG4gICAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICBcIkBoYXBpL2JvdXJuZVwiOiBcIjIueC54XCIsXG4gICAgICAgIFwiQGhhcGkvY29kZVwiOiBcIjgueC54XCIsXG4gICAgICAgIFwiQGhhcGkvam9pLWxlZ2FjeS10ZXN0XCI6IFwibnBtOkBoYXBpL2pvaUAxNS54LnhcIixcbiAgICAgICAgXCJAaGFwaS9sYWJcIjogXCJeMjUuMS4zXCIsXG4gICAgICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMTQuMTguNjNcIixcbiAgICAgICAgXCJ0eXBlc2NyaXB0XCI6IFwiNC4zLnhcIlxuICAgIH0sXG4gICAgXCJzY3JpcHRzXCI6IHtcbiAgICAgICAgXCJwcmVwdWJsaXNoT25seVwiOiBcImNkIGJyb3dzZXIgJiYgbnBtIGluc3RhbGwgJiYgbnBtIHJ1biBidWlsZFwiLFxuICAgICAgICBcInRlc3RcIjogXCJsYWIgLXQgMTAwIC1hIEBoYXBpL2NvZGUgLUwgLVlcIixcbiAgICAgICAgXCJ0ZXN0LWNvdi1odG1sXCI6IFwibGFiIC1yIGh0bWwgLW8gY292ZXJhZ2UuaHRtbCAtYSBAaGFwaS9jb2RlXCJcbiAgICB9LFxuICAgIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gUHJlZmVyZW5jZXNcblxuaW50ZXJuYWxzLndyYXAgPSBKb2kuc3RyaW5nKClcbiAgICAubWluKDEpXG4gICAgLm1heCgyKVxuICAgIC5hbGxvdyhmYWxzZSk7XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IEpvaS5vYmplY3Qoe1xuICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGFydGlmYWN0czogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBzdHJpbmc6IGludGVybmFscy53cmFwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICBtZXNzYWdlczogSm9pLm9iamVjdCgpLFxuICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgbm9uRW51bWVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgcHJlc2VuY2U6IEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJyksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IEpvaS5vYmplY3Qoe1xuICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICB9KVxuICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICB3YXJuaW5nczogSm9pLmJvb2xlYW4oKVxufSlcbiAgICAuc3RyaWN0KCk7XG5cblxuLy8gRXh0ZW5zaW9uc1xuXG5pbnRlcm5hbHMubmFtZVJ4ID0gL15bYS16QS1aMC05XVxcdyokLztcblxuXG5pbnRlcm5hbHMucnVsZSA9IEpvaS5vYmplY3Qoe1xuICAgIGFsaWFzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KSkuc2luZ2xlKCksXG4gICAgYXJnczogSm9pLmFycmF5KCkuaXRlbXMoXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgcmVmOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgYXNzZXJ0OiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLmNvbmRpdGlvbmFsKCdyZWYnLCB7IGlzOiB0cnVlLCB0aGVuOiBKb2kucmVxdWlyZWQoKSB9KSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBKb2kuc3RyaW5nKCkud2hlbignYXNzZXJ0JywgeyBpczogSm9pLmZ1bmN0aW9uKCksIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pXG4gICAgICAgIH0pXG4gICAgKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1hbmlmZXN0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkuYWxsb3coZmFsc2UpLFxuICAgIG11bHRpOiBKb2kuYm9vbGVhbigpLFxuICAgIHZhbGlkYXRlOiBKb2kuZnVuY3Rpb24oKVxufSk7XG5cblxuZXhwb3J0cy5leHRlbnNpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KCkucmVnZXgoKVxuICAgIF0pXG4gICAgICAgIC5yZXF1aXJlZCgpLFxuICAgIGFyZ3M6IEpvaS5mdW5jdGlvbigpLFxuICAgIGNhc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBmcm9tOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgxKS5yZXF1aXJlZCgpLFxuICAgICAgICB0bzogSm9pLmZ1bmN0aW9uKCkubWluQXJpdHkoMSkubWF4QXJpdHkoMikucmVxdWlyZWQoKVxuICAgIH0pKSxcbiAgICBiYXNlOiBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgLndoZW4oJ3R5cGUnLCB7IGlzOiBKb2kub2JqZWN0KCkucmVnZXgoKSwgdGhlbjogSm9pLmZvcmJpZGRlbigpIH0pLFxuICAgIGNvZXJjZTogW1xuICAgICAgICBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICAgICAgSm9pLm9iamVjdCh7IG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMykucmVxdWlyZWQoKSwgZnJvbTogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSB9KVxuICAgIF0sXG4gICAgZmxhZ3M6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBzZXR0ZXI6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpXG4gICAgfSkpLFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICAgIGJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgyKVxuICAgIH0sXG4gICAgbWVzc2FnZXM6IFtKb2kub2JqZWN0KCksIEpvaS5zdHJpbmcoKV0sXG4gICAgbW9kaWZpZXJzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKSksXG4gICAgb3ZlcnJpZGVzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKSksXG4gICAgcHJlcGFyZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMyksXG4gICAgcmVidWlsZDogSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIGludGVybmFscy5ydWxlKSxcbiAgICB0ZXJtczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGluaXQ6IEpvaS5hcnJheSgpLmFsbG93KG51bGwpLnJlcXVpcmVkKCksXG4gICAgICAgIG1hbmlmZXN0OiBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NjaGVtYScsICdzaW5nbGUnKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1hcHBlZDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB0bzogSm9pLnN0cmluZygpLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICB9KSksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kub2JqZWN0KCksIEpvaS5mdW5jdGlvbigpLmFyaXR5KDEpKS5zdHJpY3QoKTtcblxuXG4vLyBNYW5pZmVzdFxuXG5pbnRlcm5hbHMuZGVzYyA9IHtcblxuICAgIGJ1ZmZlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGJ1ZmZlcjogSm9pLnN0cmluZygpXG4gICAgfSksXG5cbiAgICBmdW5jOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZnVuY3Rpb246IEpvaS5mdW5jdGlvbigpLnJlcXVpcmVkKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3ZlcnJpZGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdmVycmlkZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IEpvaS52YWxpZCgndmFsdWUnLCAnZ2xvYmFsJywgJ2xvY2FsJyksXG4gICAgICAgICAgICBwYXRoOiBKb2kuYXJyYXkoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiBKb2kuc3RyaW5nKCkubGVuZ3RoKDEpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgICAgIGFuY2VzdG9yOiBKb2kubnVtYmVyKCkubWluKDApLmludGVnZXIoKS5hbGxvdygncm9vdCcpLFxuICAgICAgICAgICAgbWFwOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuYXJyYXkoKS5sZW5ndGgoMikpLm1pbigxKSxcbiAgICAgICAgICAgIGFkanVzdDogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBpdGVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBpbjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHJlZ2V4OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVnZXg6IEpvaS5zdHJpbmcoKS5taW4oMylcbiAgICB9KSxcblxuICAgIHNwZWNpYWw6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzcGVjaWFsOiBKb2kudmFsaWQoJ2RlZXAnKS5yZXF1aXJlZCgpXG4gICAgfSksXG5cbiAgICB0ZW1wbGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHRlbXBsYXRlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgfSksXG5cbiAgICB2YWx1ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHZhbHVlOiBKb2kuYWx0ZXJuYXRpdmVzKFtKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpXSkucmVxdWlyZWQoKVxuICAgIH0pXG59O1xuXG5cbmludGVybmFscy5kZXNjLmVudGl0eSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5saW5rKCcuLi4nKSksXG4gICAgSm9pLmJvb2xlYW4oKSxcbiAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICBKb2kubnVtYmVyKCksXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICBpbnRlcm5hbHMuZGVzYy5zcGVjaWFsLFxuICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgIGludGVybmFscy5kZXNjLnZhbHVlLFxuICAgIEpvaS5saW5rKCcvJylcbl0pO1xuXG5cbmludGVybmFscy5kZXNjLnZhbHVlcyA9IEpvaS5hcnJheSgpXG4gICAgLml0ZW1zKFxuICAgICAgICBudWxsLFxuICAgICAgICBKb2kuYm9vbGVhbigpLFxuICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgSm9pLm51bWJlcigpLmFsbG93KEluZmluaXR5LCAtSW5maW5pdHkpLFxuICAgICAgICBKb2kuc3RyaW5nKCkuYWxsb3coJycpLFxuICAgICAgICBKb2kuc3ltYm9sKCksXG4gICAgICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuZnVuYyxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2Mub3ZlcnJpZGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVnZXgsXG4gICAgICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy52YWx1ZVxuICAgICk7XG5cblxuaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMgPSBKb2kub2JqZWN0KClcbiAgICAucGF0dGVybigvLisvLCBbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtKb2kuc3RyaW5nKCksIGludGVybmFscy5kZXNjLnRlbXBsYXRlXSlcbiAgICBdKTtcblxuXG5leHBvcnRzLmRlc2NyaXB0aW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgZmxhZ3M6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjYXN0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGRlZmF1bHQ6IEpvaS5hbnkoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZW1wdHk6IEpvaS5saW5rKCcvJyksXG4gICAgICAgIGZhaWxvdmVyOiBpbnRlcm5hbHMuZGVzYy5lbnRpdHksXG4gICAgICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGxhYmVsOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG9ubHk6IHRydWUsXG4gICAgICAgIHByZXNlbmNlOiBbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLFxuICAgICAgICByZXN1bHQ6IFsncmF3JywgJ3N0cmlwJ10sXG4gICAgICAgIHN0cmlwOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB1bml0OiBKb2kuc3RyaW5nKClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgZGF0ZUZvcm1hdDogWydkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnXSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgbGFiZWw6IFsncGF0aCcsICdrZXknXSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5kZXNjLnJlZlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGludGVybmFscy53cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZXM6IGludGVybmFscy5kZXNjLm1lc3NhZ2VzLFxuICAgICAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJlc2VuY2U6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBhbGxvdzogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIGludmFsaWQ6IGludGVybmFscy5kZXNjLnZhbHVlcyxcbiAgICBydWxlczogSm9pLmFycmF5KCkubWluKDEpLml0ZW1zKHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgIGFyZ3M6IEpvaS5vYmplY3QoKS5taW4oMSksXG4gICAgICAgIGtlZXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGludGVybmFscy5kZXNjLm1lc3NhZ2VzXG4gICAgICAgIF0sXG4gICAgICAgIHdhcm46IEpvaS5ib29sZWFuKClcbiAgICB9KSxcblxuICAgIC8vIFRlcm1zXG5cbiAgICBrZXlzOiBKb2kub2JqZWN0KCkucGF0dGVybigvLiovLCBKb2kubGluaygnLycpKSxcbiAgICBsaW5rOiBpbnRlcm5hbHMuZGVzYy5yZWZcbn0pXG4gICAgLnBhdHRlcm4oL15bYS16XVxcdyokLywgSm9pLmFueSgpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICBjb25zdCBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWwuZ2V0KGNoYXJDb2RlKTtcbiAgICBpZiAobmFtZWRFc2NhcGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkRXNjYXBlO1xuICAgIH1cblxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyBjaGFyQ29kZSArICc7JztcbiAgICB9XG5cbiAgICBjb25zdCBoZXhWYWx1ZSA9IGNoYXJDb2RlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIHJldHVybiBgJiN4JHtoZXhWYWx1ZX07YDtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5zYWZlQ2hhckNvZGVzLmhhcyhjaGFyQ29kZSk7XG59O1xuXG5cbmludGVybmFscy5uYW1lZEh0bWwgPSBuZXcgTWFwKFtcbiAgICBbMzgsICcmYW1wOyddLFxuICAgIFs2MCwgJyZsdDsnXSxcbiAgICBbNjIsICcmZ3Q7J10sXG4gICAgWzM0LCAnJnF1b3Q7J10sXG4gICAgWzE2MCwgJyZuYnNwOyddLFxuICAgIFsxNjIsICcmY2VudDsnXSxcbiAgICBbMTYzLCAnJnBvdW5kOyddLFxuICAgIFsxNjQsICcmY3VycmVuOyddLFxuICAgIFsxNjksICcmY29weTsnXSxcbiAgICBbMTc0LCAnJnJlZzsnXVxuXSk7XG5cblxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgc2FmZSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8IDEyMzsgKytpKSB7XG5cbiAgICAgICAgaWYgKChpID49IDk3KSB8fCAgICAgICAgICAgICAgICAgICAgLy8gYS16XG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgIC8vIEEtWlxuICAgICAgICAgICAgKGkgPj0gNDggJiYgaSA8PSA1NykgfHwgICAgICAgICAvLyAwLTlcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLlxuICAgICAgICAgICAgaSA9PT0gNDQgfHwgICAgICAgICAgICAgICAgICAgICAvLyAsXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgIC8vIC1cbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gOlxuICAgICAgICAgICAgaSA9PT0gOTUpIHsgICAgICAgICAgICAgICAgICAgICAvLyBfXG5cbiAgICAgICAgICAgIHNhZmUuYWRkKGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhZmU7XG59KCkpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG9wZXJhdG9yczogWychJywgJ14nLCAnKicsICcvJywgJyUnLCAnKycsICctJywgJzwnLCAnPD0nLCAnPicsICc+PScsICc9PScsICchPScsICcmJicsICd8fCcsICc/PyddLFxuICAgIG9wZXJhdG9yQ2hhcmFjdGVyczogWychJywgJ14nLCAnKicsICcvJywgJyUnLCAnKycsICctJywgJzwnLCAnPScsICc+JywgJyYnLCAnfCcsICc/J10sXG4gICAgb3BlcmF0b3JzT3JkZXI6IFtbJ14nXSwgWycqJywgJy8nLCAnJSddLCBbJysnLCAnLSddLCBbJzwnLCAnPD0nLCAnPicsICc+PSddLCBbJz09JywgJyE9J10sIFsnJiYnXSwgWyd8fCcsICc/PyddXSxcbiAgICBvcGVyYXRvcnNQcmVmaXg6IFsnIScsICduJ10sXG5cbiAgICBsaXRlcmFsczoge1xuICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAnYCc6ICdgJyxcbiAgICAgICAgJ1xcJyc6ICdcXCcnLFxuICAgICAgICAnWyc6ICddJ1xuICAgIH0sXG5cbiAgICBudW1iZXJSeDogL14oPzpbMC05XSooXFwuWzAtOV0qKT8pezF9JC8sXG4gICAgdG9rZW5SeDogL15bXFx3XFwkXFwjXFwuXFxAXFw6XFx7XFx9XSskLyxcblxuICAgIHN5bWJvbDogU3ltYm9sKCdmb3JtdWxhJyksXG4gICAgc2V0dGluZ3M6IFN5bWJvbCgnc2V0dGluZ3MnKVxufTtcblxuXG5leHBvcnRzLlBhcnNlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zW2ludGVybmFscy5zZXR0aW5nc10gJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29uc3RhbnRzKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uc3RhbnQgaW4gb3B0aW9ucy5jb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuY29uc3RhbnRzW2NvbnN0YW50XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIVsnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb25zdGFudCAke2NvbnN0YW50fSBjb250YWlucyBpbnZhbGlkICR7dHlwZW9mIHZhbHVlfSB2YWx1ZSB0eXBlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHsgW2ludGVybmFscy5zZXR0aW5nc106IHRydWUsIGNvbnN0YW50czoge30sIGZ1bmN0aW9uczoge30gfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2luZ2xlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcnNlKHN0cmluZyk7XG4gICAgfVxuXG4gICAgX3BhcnNlKHN0cmluZykge1xuXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGZsdXNoID0gKGlubmVyKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBtaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhcnRzLmxlbmd0aCA/IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFsaXRlcmFsICYmXG4gICAgICAgICAgICAgICAgIWN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAhaW5uZXIpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPT09ICdyZWZlcmVuY2UnICYmXG4gICAgICAgICAgICAgICAgaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvblxuXG4gICAgICAgICAgICAgICAgbGFzdC50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBsYXN0LnZhbHVlID0gdGhpcy5fc3ViRm9ybXVsYShjdXJyZW50LCBsYXN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWdtZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gbmV3IGV4cG9ydHMuUGFyc2VyKGN1cnJlbnQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnc2VnbWVudCcsIHZhbHVlOiBzdWIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwgPT09ICddJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdyZWZlcmVuY2UnLCB2YWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6IGN1cnJlbnQgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXRlcmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRvclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ29wZXJhdG9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzLmluY2x1ZGVzKGxhc3QudmFsdWUgKyBjdXJyZW50KSkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gMiBjaGFyYWN0ZXJzIG9wZXJhdG9yXG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdC52YWx1ZSArPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnY29uc3RhbnQnLCB2YWx1ZTogcGFyc2VGbG9hdChjdXJyZW50KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiB0aGlzLnNldHRpbmdzLmNvbnN0YW50c1tjdXJyZW50XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5tYXRjaChpbnRlcm5hbHMudG9rZW5SeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgdG9rZW46ICR7Y3VycmVudH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHN0cmluZykge1xuICAgICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLm9wZXJhdG9yQ2hhcmFjdGVycy5pbmNsdWRlcyhjKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgcHJlZml4IC0gdG8gaW50ZXJuYWwgbmVnYXRpdmUgb3BlcmF0b3JcblxuICAgICAgICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCwgaSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlICE9PSAnb3BlcmF0b3InIHx8XG4gICAgICAgICAgICAgICAgcGFydC52YWx1ZSAhPT0gJy0nIHx8XG4gICAgICAgICAgICAgICAgaSAmJiBwYXJ0c1tpIC0gMV0udHlwZSAhPT0gJ29wZXJhdG9yJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnbicgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdG9rZW5zIG9yZGVyXG5cbiAgICAgICAgbGV0IG9wZXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIGNvbnRhaW5zIGFuIG9wZXJhdG9yIGluIGludmFsaWQgcG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGFuIHVua25vd24gb3BlcmF0b3IgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0b3IgPSAhb3BlcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgaW52YWxpZCB0cmFpbGluZyBvcGVyYXRvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWRlbnRpZnkgc2luZ2xlIHBhcnRcblxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBbJ3JlZmVyZW5jZScsICdsaXRlcmFsJywgJ2NvbnN0YW50J10uaW5jbHVkZXMocGFydHNbMF0udHlwZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5zaW5nbGUgPSB7IHR5cGU6IHBhcnRzWzBdLnR5cGUgPT09ICdyZWZlcmVuY2UnID8gJ3JlZmVyZW5jZScgOiAndmFsdWUnLCB2YWx1ZTogcGFydHNbMF0udmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBPcGVyYXRvcnNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpID8gcGFydCA6IHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpdGVyYWxzLCBjb25zdGFudHMsIHNlZ21lbnRzXG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudG9rZW5SeCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnNldHRpbmdzLnRva2VuUngudGVzdChwYXJ0LnZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgcmVmZXJlbmNlICR7cGFydC52YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZmVyZW5jZShwYXJ0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3N1YkZvcm11bGEoc3RyaW5nLCBuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5zZXR0aW5ncy5mdW5jdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgdW5rbm93biBmdW5jdGlvbiAke25hbWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgbGV0IHBhcmVudGhlc2lzID0gMDtcbiAgICAgICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBmdW5jdGlvbiAke25hbWV9IHdpdGggaW52YWxpZCBhcmd1bWVudHMgJHtzdHJpbmd9YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnLCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzID0gYXJncy5tYXAoKGFyZykgPT4gbmV3IGV4cG9ydHMuUGFyc2VyKGFyZywgdGhpcy5zZXR0aW5ncykpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgICAgICBjb25zdCBpbm5lclZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWVzLnB1c2goYXJnLmV2YWx1YXRlKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNvbnRleHQsIC4uLmlubmVyVmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9wYXJ0cy5zbGljZSgpO1xuXG4gICAgICAgIC8vIFByZWZpeCBvcGVyYXRvcnNcblxuICAgICAgICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICYmXG4gICAgICAgICAgICAgICAgcGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnRlcm5hbHMuZXZhbHVhdGUoY3VycmVudCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBpbnRlcm5hbHMuc2luZ2xlKHBhcnQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExlZnQtcmlnaHQgb3BlcmF0b3JzXG5cbiAgICAgICAgaW50ZXJuYWxzLm9wZXJhdG9yc09yZGVyLmZvckVhY2goKHNldCkgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5pbmNsdWRlcyhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpIC0gMV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpICsgMV0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmNhbGN1bGF0ZShvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpIC0gMV0gPSByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IC0wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzWzBdLCBjb250ZXh0KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuUGFyc2VyLnByb3RvdHlwZVtpbnRlcm5hbHMuc3ltYm9sXSA9IHRydWU7XG5cblxuaW50ZXJuYWxzLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcblxuICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0W25hbWVdICE9PSB1bmRlZmluZWQgPyBjb250ZXh0W25hbWVdIDogbnVsbDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuZXZhbHVhdGUgPSBmdW5jdGlvbiAocGFydCwgY29udGV4dCkge1xuXG4gICAgaWYgKHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwYXJ0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0W2ludGVybmFscy5zeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0O1xufTtcblxuXG5pbnRlcm5hbHMuc2luZ2xlID0gZnVuY3Rpb24gKG9wZXJhdG9yLCB2YWx1ZSkge1xuXG4gICAgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIC8vIG9wZXJhdG9yID09PSAnbidcblxuICAgIGNvbnN0IG5lZ2F0aXZlID0gLXZhbHVlO1xuICAgIGlmIChuZWdhdGl2ZSA9PT0gMCkgeyAgICAgICAvLyBPdmVycmlkZSAtMFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVnYXRpdmU7XG59O1xuXG5cbmludGVybmFscy5jYWxjdWxhdGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICc/PycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnKycpIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnRlcm5hbHMuZXhpc3RzKGxlZnQpID8gbGVmdCA6ICcnO1xuICAgICAgICAgICAgcmlnaHQgPSBpbnRlcm5hbHMuZXhpc3RzKHJpZ2h0KSA/IHJpZ2h0IDogJyc7XG4gICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICdeJzogcmV0dXJuIE1hdGgucG93KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBsZWZ0IDw9IHJpZ2h0O1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgY2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICBjYXNlICcmJic6IHJldHVybiBsZWZ0ICYmIHJpZ2h0O1xuICAgICAgICBjYXNlICd8fCc6IHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuZXhpc3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFubm90YXRpb25zOiBTeW1ib2woJ2Fubm90YXRpb25zJylcbn07XG5cblxuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uIChzdHJpcENvbG9yQ29kZXMpIHtcblxuICAgIGlmICghdGhpcy5fb3JpZ2luYWwgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuX29yaWdpbmFsICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICBjb25zdCByZWRCZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbNDFtJztcbiAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgY29uc3Qgb2JqID0gQ2xvbmUodGhpcy5fb3JpZ2luYWwpO1xuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZGV0YWlscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciB0byBwcm9jZXNzIGRlZXBlc3QgY2hpbGQgZmlyc3RcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5kZXRhaWxzW2ldO1xuICAgICAgICBjb25zdCBwYXRoID0gZXJyb3IucGF0aDtcbiAgICAgICAgbGV0IG5vZGUgPSBvYmo7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyA7ICsraikge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gcGF0aFtqXTtcblxuICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShub2RlKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gam9pIHNjaGVtYXMgYXJlIG5vdCBjbG9uZWQgYnkgaG9laywgd2UgaGF2ZSB0byB0YWtlIHRoaXMgZXh0cmEgc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaiArIDEgPCBwYXRoLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtzZWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmQW5ub3RhdGlvbnMgPSBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gfHwgeyBlcnJvcnM6IHt9LCBtaXNzaW5nOiB7fSB9O1xuICAgICAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSA9IHJlZkFubm90YXRpb25zO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzZWcgfHwgZXJyb3IuY29udGV4dC5rZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZVtzZWddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgIGtleTogL19cXCRrZXlcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIvZyxcbiAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICBzcGVjaWFsczogL1wiXFxbKE5hTnxTeW1ib2wuKnwtP0luZmluaXR5fGZ1bmN0aW9uLip8XFwoLiopXVwiL2dcbiAgICB9O1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5rZXksICgkMCwgJDEpID0+IGBcIiAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5zcGVjaWFscywgKCQwLCAkMSkgPT4gJDEpO1xuXG4gICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSArIGVuZENvbG9yO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5cbi8vIEluc3BpcmVkIGJ5IGpzb24tc3RyaW5naWZ5LXNhZmVcblxuaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBzcGFjZXMpIHtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGludGVybmFscy5zZXJpYWxpemVyKCksIHNwYWNlcyk7XG59O1xuXG5cbmludGVybmFscy5zZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG5cbiAgICBjb25zdCBjeWNsZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcblxuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+LicgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgKyAnXSc7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmICh+dGhpc1Bvcykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5c1t0aGlzUG9zXSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN5Y2xlUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHZhbHVlW2ludGVybmFscy5hbm5vdGF0aW9uc107XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGVkID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmVycm9yc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKGBfJGlkeCRfJHthbm5vdGF0aW9ucy5lcnJvcnNbaV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFubm90YXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3JLZXkgaW4gYW5ub3RhdGlvbnMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgJHtlcnJvcktleX1fJGtleSRfJHthbm5vdGF0aW9ucy5lcnJvcnNbZXJyb3JLZXldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gXSA9IHZhbHVlW2Vycm9yS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Vycm9yS2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlzc2luZ0tleSBpbiBhbm5vdGF0aW9ucy5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgXyRtaXNzJF8ke21pc3NpbmdLZXl9fCR7YW5ub3RhdGlvbnMubWlzc2luZ1ttaXNzaW5nS2V5XX1fJGVuZCRfYF0gPSAnX19taXNzaW5nX18nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSB8fFxuICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAnWycgKyB2YWx1ZS50b1N0cmluZygpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQW5ub3RhdGUgPSByZXF1aXJlKCcuL2Fubm90YXRlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5SZXBvcnQgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIGZsYWdzLCBtZXNzYWdlcywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMucGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIHRoaXMucHJlZnMgPSBwcmVmcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IHt9O1xuICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gZXhwb3J0cy5sYWJlbCh0aGlzLmZsYWdzLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzLCB0aGlzLm1lc3NhZ2VzKTtcblxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhdGhpcy5sb2NhbC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuXG4gICAgICAgICAgICB0aGlzLmxvY2FsLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbC5rZXkgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmxhYmVsICYmXG4gICAgICAgICAgICB0aGlzLnBhdGgubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUsICdyb290Jyk7XG4gICAgICAgICAgICBpZiAobG9jYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbC5sYWJlbCA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuXG4gICAgICAgIGlmICghdGhpcy5wcmVmcy5lcnJvcnMucmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5wcmVmcy5tZXNzYWdlcykgfHxcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlKHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNvZGUgXCIke2NvZGV9XCIgaXMgbm90IGRlZmluZWQsIHlvdXIgY3VzdG9tIHR5cGUgaXMgbWlzc2luZyB0aGUgY29ycmVjdCBtZXNzYWdlcyBkZWZpbml0aW9uYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciBhbmQgY2FjaGUgcmVzdWx0XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGVtcGxhdGUucmVuZGVyKHRoaXMudmFsdWUsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubG9jYWwsIHsgZXJyb3JzOiB0aGlzLnByZWZzLmVycm9ycywgbWVzc2FnZXM6IFt0aGlzLnByZWZzLm1lc3NhZ2VzLCB0aGlzLm1lc3NhZ2VzXSB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlLnJlcGxhY2UoL15cIlwiIC8sICcnKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cblxuICAgIF90ZW1wbGF0ZShtZXNzYWdlcywgY29kZSkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLnRlbXBsYXRlKHRoaXMudmFsdWUsIG1lc3NhZ2VzLCBjb2RlIHx8IHRoaXMuY29kZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcyk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgbGV0IGxhYmVsID0gJyc7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnb2JqZWN0JykgeyAgICAgICAgICAvLyBFeGNsdWRlIGFycmF5IHNpbmdsZSBwYXRoIHNlZ21lbnRcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgKz0gJy4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYWJlbCArPSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgKz0gYFske3NlZ21lbnR9XWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWw7XG59O1xuXG5cbmV4cG9ydHMudGVtcGxhdGUgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2VzKSkge1xuICAgICAgICByZXR1cm4gY29kZSAhPT0gJ3Jvb3QnID8gbWVzc2FnZXMgOiBudWxsO1xuICAgIH1cblxuICAgIGxldCBsYW5nID0gcHJlZnMuZXJyb3JzLmxhbmd1YWdlO1xuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGxhbmcpKSB7XG4gICAgICAgIGxhbmcgPSBsYW5nLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaWYgKGxhbmcgJiZcbiAgICAgICAgbWVzc2FnZXNbbGFuZ10pIHtcblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bY29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddW2NvZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2VzW2xhbmddWycqJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddWycqJ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1lc3NhZ2VzW2NvZGVdKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlc1snKiddO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlc1tjb2RlXTtcbn07XG5cblxuZXhwb3J0cy5sYWJlbCA9IGZ1bmN0aW9uIChmbGFncywgc3RhdGUsIHByZWZzLCBtZXNzYWdlcykge1xuXG4gICAgaWYgKCFwcmVmcy5lcnJvcnMubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmIChmbGFncy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gZmxhZ3MubGFiZWw7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBzdGF0ZS5wYXRoO1xuICAgIGlmIChwcmVmcy5lcnJvcnMubGFiZWwgPT09ICdrZXknICYmXG4gICAgICAgIHN0YXRlLnBhdGgubGVuZ3RoID4gMSkge1xuXG4gICAgICAgIHBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKC0xKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gZXhwb3J0cy5wYXRoKHBhdGgpO1xuICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIHByZWZzLm1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgbWVzc2FnZXMgJiYgZXhwb3J0cy50ZW1wbGF0ZShudWxsLCBtZXNzYWdlcywgJ3Jvb3QnLCBzdGF0ZSwgcHJlZnMpIHx8XG4gICAgICAgICd2YWx1ZSc7XG59O1xuXG5cbmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9yaWdpbmFsLCBwcmVmcykge1xuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvdmVycmlkZSwgbWVzc2FnZSwgZGV0YWlscyB9ID0gZXhwb3J0cy5kZXRhaWxzKGVycm9ycyk7XG4gICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuZXJyb3JzLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGRldGFpbHMsIG9yaWdpbmFsKTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yO1xufTtcblxuXG5leHBvcnRzLmRldGFpbHMgPSBmdW5jdGlvbiAoZXJyb3JzLCBvcHRpb25zID0ge30pIHtcblxuICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBlcnJvcnMpIHtcblxuICAgICAgICAvLyBPdmVycmlkZVxuXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG92ZXJyaWRlOiBpdGVtIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogJ292ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7IGVycm9yOiBpdGVtIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcG9ydFxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGguZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiAhPT0gJ29iamVjdCcpLFxuICAgICAgICAgICAgdHlwZTogaXRlbS5jb2RlLFxuICAgICAgICAgICAgY29udGV4dDogaXRlbS5sb2NhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtZXNzYWdlcyA9IFsuLi5uZXcgU2V0KG1lc3NhZ2VzKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZXMuam9pbignLiAnKSwgZGV0YWlscyB9O1xufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpIHtcblxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWwgPSBvcmlnaW5hbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNFcnJvcihlcnIpIHtcblxuICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3I7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaXNKb2kgPSB0cnVlO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuYW5ub3RhdGUgPSBBbm5vdGF0ZS5lcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5sZXQgVGVtcGxhdGU7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCdyZWYnKSwgICAgICAvLyBVc2VkIHRvIGludGVybmFsbHkgaWRlbnRpZnkgcmVmZXJlbmNlcyAoc2hhcmVkIHdpdGggb3RoZXIgam9pIHZlcnNpb25zKVxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGFkanVzdDogbnVsbCxcbiAgICAgICAgaW46IGZhbHNlLFxuICAgICAgICBpdGVyYWJsZXM6IG51bGwsXG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgc2VwYXJhdG9yOiAnLicsXG4gICAgICAgIHR5cGU6ICd2YWx1ZSdcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQodHlwZW9mIGtleSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJlZmVyZW5jZSBrZXk6Jywga2V5KTtcbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3ByZWZpeCcsICdyZW5kZXInLCAnc2VwYXJhdG9yJ10pO1xuICAgIEFzc2VydCghb3B0aW9ucy5wcmVmaXggfHwgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnb2JqZWN0JywgJ29wdGlvbnMucHJlZml4IG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcblxuICAgIGNvbnN0IHJlZiA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgZGVsZXRlIHJlZi5wcmVmaXg7XG5cbiAgICBjb25zdCBzZXBhcmF0b3IgPSByZWYuc2VwYXJhdG9yO1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnRlcm5hbHMuY29udGV4dChrZXksIHNlcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIHJlZi50eXBlID0gY29udGV4dC50eXBlO1xuICAgIGtleSA9IGNvbnRleHQua2V5O1xuXG4gICAgaWYgKHJlZi50eXBlID09PSAndmFsdWUnKSB7XG4gICAgICAgIGlmIChjb250ZXh0LnJvb3QpIHtcbiAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IHNwZWNpZnkgcmVsYXRpdmUgcGF0aCB3aXRoIHJvb3QgcHJlZml4Jyk7XG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSAncm9vdCc7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBzZXBhcmF0b3IgPT09IGtleSkge1xuXG4gICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWYuYW5jZXN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8ICFrZXkgfHwga2V5WzBdICE9PSBzZXBhcmF0b3IsICdDYW5ub3QgY29tYmluZSBwcmVmaXggd2l0aCBhbmNlc3RvciBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFthbmNlc3Rvciwgc2xpY2VdID0gaW50ZXJuYWxzLmFuY2VzdG9yKGtleSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWYuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5wYXRoID0gc2VwYXJhdG9yID8gKGtleSA9PT0gbnVsbCA/IFtdIDoga2V5LnNwbGl0KHNlcGFyYXRvcikpIDogW2tleV07XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYocmVmKTtcbn07XG5cblxuZXhwb3J0cy5pbiA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuY3JlYXRlKGtleSwgeyAuLi5vcHRpb25zLCBpbjogdHJ1ZSB9KTtcbn07XG5cblxuZXhwb3J0cy5pc1JlZiA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgIHJldHVybiByZWYgPyAhIXJlZltDb21tb24uc3ltYm9scy5yZWZdIDogZmFsc2U7XG59O1xuXG5cbmludGVybmFscy5SZWYgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcmVmZXJlbmNlIGNvbnN0cnVjdGlvbicpO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbXG4gICAgICAgICAgICAnYWRqdXN0JywgJ2FuY2VzdG9yJywgJ2luJywgJ2l0ZXJhYmxlcycsICdtYXAnLCAncGF0aCcsICdyZW5kZXInLCAnc2VwYXJhdG9yJywgJ3R5cGUnLCAgLy8gQ29waWVkXG4gICAgICAgICAgICAnZGVwdGgnLCAna2V5JywgJ3Jvb3QnLCAnZGlzcGxheScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGRlblxuICAgICAgICBdKTtcblxuICAgICAgICBBc3NlcnQoW2ZhbHNlLCB1bmRlZmluZWRdLmluY2x1ZGVzKG9wdGlvbnMuc2VwYXJhdG9yKSB8fCB0eXBlb2Ygb3B0aW9ucy5zZXBhcmF0b3IgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuc2VwYXJhdG9yLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgc2VwYXJhdG9yJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5hZGp1c3QgfHwgdHlwZW9mIG9wdGlvbnMuYWRqdXN0ID09PSAnZnVuY3Rpb24nLCAnb3B0aW9ucy5hZGp1c3QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcCksICdvcHRpb25zLm1hcCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgIW9wdGlvbnMuYWRqdXN0LCAnQ2Fubm90IHNldCBib3RoIG1hcCBhbmQgYWRqdXN0IG9wdGlvbnMnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyB8fCB0aGlzLmFuY2VzdG9yID09PSB1bmRlZmluZWQsICdOb24tdmFsdWUgcmVmZXJlbmNlcyBjYW5ub3QgcmVmZXJlbmNlIGFuY2VzdG9ycycpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWFwKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKHRoaXMubWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLnBhdGgubGVuZ3RoO1xuICAgICAgICB0aGlzLmtleSA9IHRoaXMucGF0aC5sZW5ndGggPyB0aGlzLnBhdGguam9pbih0aGlzLnNlcGFyYXRvcikgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhdGhbMF07XG5cbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLmluIHx8IG9wdGlvbnMuaW4sICdJbnZhbGlkIGluKCkgcmVmZXJlbmNlIHVzYWdlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHByZWZzLmNvbnRleHQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKGxvY2FsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShzdGF0ZS5hbmNlc3RvcnNbc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCAtIDFdLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodGhpcy5hbmNlc3RvciA8PSBzdGF0ZS5hbmNlc3RvcnMubGVuZ3RoLCAnSW52YWxpZCByZWZlcmVuY2UgZXhjZWVkcyB0aGUgc2NoZW1hIHJvb3Q6JywgdGhpcy5kaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3RoaXMuYW5jZXN0b3IgLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9yZXNvbHZlKHRhcmdldCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgcmVzb2x2ZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuc2hhZG93ICYmXG4gICAgICAgICAgICBvcHRpb25zLnNoYWRvdyAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBzdGF0ZS5tYWluc3RheS5zaGFkb3cuZ2V0KHRoaXMuYWJzb2x1dGUoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IFJlYWNoKHRhcmdldCwgdGhpcy5wYXRoLCB7IGl0ZXJhYmxlczogdGhpcy5pdGVyYWJsZXMsIGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFkanVzdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0aGlzLmFkanVzdChyZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRoaXMubWFwLmdldChyZXNvbHZlZCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IG1hcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5tYWluc3RheSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnJlc29sdmUoc3RhdGUsIHRoaXMsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5O1xuICAgIH1cblxuICAgIGFic29sdXRlKHN0YXRlKSB7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZS5wYXRoLnNsaWNlKDAsIC10aGlzLmFuY2VzdG9yKSwgLi4udGhpcy5wYXRoXTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYodGhpcyk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgcmVmID0geyBwYXRoOiB0aGlzLnBhdGggfTtcblxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICByZWYudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICByZWYuc2VwYXJhdG9yID0gdGhpcy5zZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9yICE9PSAxKSB7XG5cbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IHRoaXMuYW5jZXN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHJlZi5tYXAgPSBbLi4udGhpcy5tYXBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydhZGp1c3QnLCAnaXRlcmFibGVzJywgJ3JlbmRlciddKSB7XG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHJlZltrZXldID0gdGhpc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZWYuaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVmIH07XG4gICAgfVxuXG4gICAgdXBkYXRlRGlzcGxheSgpIHtcblxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleSAhPT0gbnVsbCA/IHRoaXMua2V5IDogJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHt0aGlzLnR5cGV9OiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHt0aGlzLnNlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjpyb290OiR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleSB8fCAnLi4nfWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZWFkID0gbmV3IEFycmF5KHRoaXMuYW5jZXN0b3IgKyAxKS5maWxsKHRoaXMuc2VwYXJhdG9yKS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2xlYWR9JHtrZXkgfHwgJyd9YDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5SZWYucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnJlZl0gPSB0cnVlO1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoZGVzYykge1xuXG4gICAgZGVzYyA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFscy5kZWZhdWx0cywgZGVzYyk7XG4gICAgaWYgKGRlc2MudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICBkZXNjLmFuY2VzdG9yID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBkZXNjLmFuY2VzdG9yID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5jb250ZXh0ID0gZnVuY3Rpb24gKGtleSwgc2VwYXJhdG9yLCBwcmVmaXggPSB7fSkge1xuXG4gICAga2V5ID0ga2V5LnRyaW0oKTtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscCA9IHByZWZpeC5nbG9iYWwgPT09IHVuZGVmaW5lZCA/ICckJyA6IHByZWZpeC5nbG9iYWw7XG4gICAgICAgIGlmIChnbG9iYWxwICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGdsb2JhbHApKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGdsb2JhbHAubGVuZ3RoKSwgdHlwZTogJ2dsb2JhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvY2FsID0gcHJlZml4LmxvY2FsID09PSB1bmRlZmluZWQgPyAnIycgOiBwcmVmaXgubG9jYWw7XG4gICAgICAgIGlmIChsb2NhbCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChsb2NhbCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2UobG9jYWwubGVuZ3RoKSwgdHlwZTogJ2xvY2FsJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm9vdCA9IHByZWZpeC5yb290ID09PSB1bmRlZmluZWQgPyAnLycgOiBwcmVmaXgucm9vdDtcbiAgICAgICAgaWYgKHJvb3QgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgocm9vdCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2Uocm9vdC5sZW5ndGgpLCB0eXBlOiAndmFsdWUnLCByb290OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBrZXksIHR5cGU6ICd2YWx1ZScgfTtcbn07XG5cblxuaW50ZXJuYWxzLmFuY2VzdG9yID0gZnVuY3Rpb24gKGtleSwgc2VwYXJhdG9yKSB7XG5cbiAgICBpZiAoIXNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gWzEsIDBdOyAgICAgICAgICAgICAgLy8gJ2FfYicgLT4gMSAocGFyZW50KVxuICAgIH1cblxuICAgIGlmIChrZXlbMF0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJ2EuYicgLT4gMSAocGFyZW50KVxuICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgIH1cblxuICAgIGlmIChrZXlbMV0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJy5hLmInIC0+IDAgKHNlbGYpXG4gICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgfVxuXG4gICAgbGV0IGkgPSAyO1xuICAgIHdoaWxlIChrZXlbaV0gPT09IHNlcGFyYXRvcikge1xuICAgICAgICArK2k7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpIC0gMSwgaV07ICAgICAgICAgICAgICAvLyAnLi4uYS5iLicgLT4gMiAoZ3JhbmRwYXJlbnQpXG59O1xuXG5cbmV4cG9ydHMudG9TaWJsaW5nID0gMDtcblxuZXhwb3J0cy50b1BhcmVudCA9IDE7XG5cblxuZXhwb3J0cy5NYW5hZ2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107ICAgICAgICAgICAgICAgICAgICAgLy8gMDogW3NlbGYgcmVmc10sIDE6IFtwYXJlbnQgcmVmc10sIDI6IFtncmFuZHBhcmVudCByZWZzXSwgLi4uXG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc291cmNlLCB0YXJnZXQpIHtcblxuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBleHBvcnRzLnRvUGFyZW50IDogdGFyZ2V0O1xuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2Ygc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjaGVtYVxuXG4gICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZS5fcmVmcy5yZWZzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYW5jZXN0b3IgLSB0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnMucHVzaCh7IGFuY2VzdG9yOiBpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBpdGVtLnJvb3QgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoZXhwb3J0cy5pc1JlZihzb3VyY2UpICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcblxuICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3Rvcjogc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBzb3VyY2Uucm9vdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBsYXRlXG5cbiAgICAgICAgVGVtcGxhdGUgPSBUZW1wbGF0ZSB8fCByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihzb3VyY2UucmVmcygpLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IGV4cG9ydHMuTWFuYWdlcigpO1xuICAgICAgICBjb3B5LnJlZnMgPSBDbG9uZSh0aGlzLnJlZnMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLnJlZnMgPSBbXTtcbiAgICB9XG5cbiAgICByb290cygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmZpbHRlcigocmVmKSA9PiAhcmVmLmFuY2VzdG9yKS5tYXAoKHJlZikgPT4gcmVmLnJvb3QpO1xuICAgIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IEVzY2FwZUh0bWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sJyk7XG5jb25zdCBGb3JtdWxhID0gcmVxdWlyZSgnQHNpZGV3YXkvZm9ybXVsYScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuXG4gICAgb3BlbnM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAwJyksXG4gICAgY2xvc2VzOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMScpLFxuXG4gICAgZGF0ZUZvcm1hdDoge1xuICAgICAgICBkYXRlOiBEYXRlLnByb3RvdHlwZS50b0RhdGVTdHJpbmcsXG4gICAgICAgIGlzbzogRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcsXG4gICAgICAgIHN0cmluZzogRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIHRpbWU6IERhdGUucHJvdG90eXBlLnRvVGltZVN0cmluZyxcbiAgICAgICAgdXRjOiBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZ1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gaW50ZXJuYWxzLlRlbXBsYXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnVGVtcGxhdGUgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDAnKSAmJiAhc291cmNlLmluY2x1ZGVzKCdcXHUwMDAxJyksICdUZW1wbGF0ZSBzb3VyY2UgY2Fubm90IGNvbnRhaW4gcmVzZXJ2ZWQgY29udHJvbCBjaGFyYWN0ZXJzJyk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBzb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9ucywgLi4ub3B0cyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID8gQ2xvbmUob3B0cykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX2Z1bmN0aW9ucykuZXZlcnkoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpLCAnRnVuY3Rpb25zIGtleXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC52YWx1ZXModGhpcy5fZnVuY3Rpb25zKS5ldmVyeSgoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSwgJ0Z1bmN0aW9ucyB2YWx1ZXMgbXVzdCBiZSBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IHBhcnQuc2xpY2UocmF3ID8gMCA6IDEsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdmFyaWFibGVbMF0gPT09ICc6JztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgeyByYXcsIHdyYXBwZWQgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGRlc2MuZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMgfHwgZGVzYy5mdW5jdGlvbnMgPyB7IC4uLmRlc2Mub3B0aW9ucywgZnVuY3Rpb25zOiBkZXNjLmZ1bmN0aW9ucyB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVybmFscy53cmFwKHJlc3VsdCwgcGFydC53cmFwcGVkICYmIHByZWZzLmVycm9ycy53cmFwLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgeyByYXcsIHdyYXBwZWQgfSkge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZWQgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zID8geyAuLi5pbnRlcm5hbHMuZnVuY3Rpb25zLCAuLi50aGlzLl9mdW5jdGlvbnMgfSA6IGludGVybmFscy5mdW5jdGlvbnM7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhLlBhcnNlcihjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWYsIHJhdywgcmVmcywgd3JhcHBlZDogd3JhcHBlZCB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJyAmJiByZWYua2V5ID09PSAnbGFiZWwnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc3RyaW5naWZ5KGZvcm11bGEuc2luZ2xlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZvcm11bGEsIHJhdywgcmVmcyB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdID0gdHJ1ZTtcbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx7KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZW5zLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcfSspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9zZXMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSk7XG59O1xuXG5cbmludGVybmFscy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICd7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDEvZywgJ30nKTtcbn07XG5cblxuaW50ZXJuYWxzLnNwbGl0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcblxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgc3RyaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICd7Jykge1xuXG4gICAgICAgICAgICAgICAgbmV4dCArPSAneyc7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgIHJldHVybiBwYXJ0cztcbn07XG5cblxuaW50ZXJuYWxzLndyYXAgPSBmdW5jdGlvbiAodmFsdWUsIGVuZHMpIHtcblxuICAgIGlmICghZW5kcykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmRzfSR7dmFsdWV9JHtlbmRzfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2VuZHNbMF19JHt2YWx1ZX0ke2VuZHNbMV19YDtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjb25zdCB3cmFwID0gcHJlZnMgJiYgcHJlZnMuZXJyb3JzICYmIHByZWZzLmVycm9ycy53cmFwIHx8IHt9O1xuXG4gICAgbGV0IHNraXBXcmFwID0gZmFsc2U7XG4gICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUucmVuZGVyKSB7XG5cbiAgICAgICAgc2tpcFdyYXAgPSB2YWx1ZS5pbjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNvbHZlKG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCB7IGluOiB2YWx1ZS5pbiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHZhbHVlLCBvcHRpb25zLmFycmF5SXRlbXMgJiYgd3JhcC5zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLlRlbXBsYXRlLmRhdGUodmFsdWUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzeW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChgJHtrZXkudG9TdHJpbmcoKX0gLT4gJHtzeW0udG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcGFpcnM7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goaW50ZXJuYWxzLnN0cmluZ2lmeShpdGVtLCBvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgeyBhcnJheUl0ZW1zOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAodmFsdWVzLmpvaW4oJywgJyksICFza2lwV3JhcCAmJiB3cmFwLmFycmF5KTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnN0YW50cyA9IHtcblxuICAgIHRydWU6IHRydWUsXG4gICAgZmFsc2U6IGZhbHNlLFxuICAgIG51bGw6IG51bGwsXG5cbiAgICBzZWNvbmQ6IDEwMDAsXG4gICAgbWludXRlOiA2MCAqIDEwMDAsXG4gICAgaG91cjogNjAgKiA2MCAqIDEwMDAsXG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG5cbmludGVybmFscy5mdW5jdGlvbnMgPSB7XG5cbiAgICBpZihjb25kaXRpb24sIHRoZW4sIG90aGVyd2lzZSkge1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGgoaXRlbSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIHRhcmdldCkge1xuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZyAoJ3BsYWluIGVycm9yIG1lc3NhZ2UnLCAndGVtcGxhdGUge2Vycm9yfSBtZXNzYWdlJylcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShtZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHRlbXBsYXRlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSwgJ0ludmFsaWQgbWVzc2FnZSBvcHRpb25zJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgPyBDbG9uZSh0YXJnZXQpIDoge307XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0YXJnZXQucm9vdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV0ucm9vdCA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZC5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGJhc2UsIGV4dGVuZGVkKSB7XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcGlsZShleHRlbmRlZCk7XG4gICAgfVxuXG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nXG5cbiAgICBpZiAodHlwZW9mIGV4dGVuZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKGV4dGVuZGVkKSkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBDbG9uZShiYXNlKTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gZXh0ZW5kZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4dGVuZGVkW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBBc3NlcnRFcnJvciA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Vycm9yJyk7XG5cbmNvbnN0IFBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5sZXQgTWVzc2FnZXM7XG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgaXNvRGF0ZTogL14oPzpbLStdXFxkezJ9KT8oPzpcXGR7NH0oPyFcXGR7Mn1cXGIpKSg/OigtPykoPzooPzowWzEtOV18MVswLTJdKSg/OlxcMSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoPzpbMC00XVxcZHw1WzAtMl0pKD86LT9bMS03XSk/fCg/OjAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18Myg/OlswLTVdXFxkfDZbMS02XSkpKSg/IVtUXSR8W1RdW1xcZF0rWiQpKD86W1RcXHNdKD86KD86KD86WzAxXVxcZHwyWzAtM10pKD86KDo/KVswLTVdXFxkKT98MjRcXDo/MDApKD86Wy4sXVxcZCsoPyE6KSk/KSg/OlxcMlswLTVdXFxkKD86Wy4sXVxcZCspPyk/KD86W1pdfCg/OlsrLV0pKD86WzAxXVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KT8pPyk/JC9cbn07XG5cblxuZXhwb3J0cy52ZXJzaW9uID0gUGtnLnZlcnNpb247XG5cblxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgIGFsbG93VW5rbm93bjogZmFsc2UsXG4gICAgYXJ0aWZhY3RzOiBmYWxzZSxcbiAgICBjYWNoZTogdHJ1ZSxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgZGF0ZUZvcm1hdDogJ2lzbycsXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IGZhbHNlLFxuICAgICAgICBsYWJlbDogJ3BhdGgnLFxuICAgICAgICBsYW5ndWFnZTogbnVsbCxcbiAgICAgICAgcmVuZGVyOiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UsXG4gICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnXCInLFxuICAgICAgICAgICAgYXJyYXk6ICdbXSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiB0cnVlLFxuICAgIG1lc3NhZ2VzOiB7fSxcbiAgICBub25FbnVtZXJhYmxlczogZmFsc2UsXG4gICAgbm9EZWZhdWx0czogZmFsc2UsXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXG4gICAgc2tpcEZ1bmN0aW9uczogZmFsc2UsXG4gICAgc3RyaXBVbmtub3duOiBmYWxzZSxcbiAgICB3YXJuaW5nczogZmFsc2Vcbn07XG5cblxuZXhwb3J0cy5zeW1ib2xzID0ge1xuICAgIGFueTogU3ltYm9sLmZvcignQGhhcGkvam9pL3NjaGVtYScpLCAgICAgICAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSBhbnktYmFzZWQgdHlwZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBhcnJheVNpbmdsZTogU3ltYm9sKCdhcnJheVNpbmdsZScpLFxuICAgIGRlZXBEZWZhdWx0OiBTeW1ib2woJ2RlZXBEZWZhdWx0JyksXG4gICAgZXJyb3JzOiBTeW1ib2woJ2Vycm9ycycpLFxuICAgIGxpdGVyYWw6IFN5bWJvbCgnbGl0ZXJhbCcpLFxuICAgIG92ZXJyaWRlOiBTeW1ib2woJ292ZXJyaWRlJyksXG4gICAgcGFyZW50OiBTeW1ib2woJ3BhcmVudCcpLFxuICAgIHByZWZzOiBTeW1ib2woJ3ByZWZzJyksXG4gICAgcmVmOiBTeW1ib2woJ3JlZicpLFxuICAgIHRlbXBsYXRlOiBTeW1ib2woJ3RlbXBsYXRlJyksXG4gICAgdmFsdWVzOiBTeW1ib2woJ3ZhbHVlcycpXG59O1xuXG5cbmV4cG9ydHMuYXNzZXJ0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXlzLCBuYW1lID0gJ09wdGlvbnMnKSB7XG5cbiAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucyksICdPcHRpb25zIG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcbiAgICBjb25zdCB1bmtub3duS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoaykgPT4gIWtleXMuaW5jbHVkZXMoaykpO1xuICAgIEFzc2VydCh1bmtub3duS2V5cy5sZW5ndGggPT09IDAsIGAke25hbWV9IGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25LZXlzfWApO1xufTtcblxuXG5leHBvcnRzLmNoZWNrUHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAocHJlZnMpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gU2NoZW1hcy5wcmVmZXJlbmNlcy52YWxpZGF0ZShwcmVmcyk7XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRFcnJvcihbcmVzdWx0LmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZV0pO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIG9wZXJhdG9yKSB7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz0nOiByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgY2FzZSAnPic6IHJldHVybiBhID4gYjtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBhIDwgYjtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gYSA+PSBiO1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBhIDw9IGI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn07XG5cblxuZXhwb3J0cy5pc0lzb0RhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5pc29EYXRlLnRlc3QoZGF0ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZXNvbHZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnJlZl0gfHwgb2JqW2V4cG9ydHMuc3ltYm9scy50ZW1wbGF0ZV07XG59O1xuXG5cbmV4cG9ydHMuaXNTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYSAmJiBzY2hlbWFbZXhwb3J0cy5zeW1ib2xzLmFueV07XG4gICAgaWYgKCFhbnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIEFzc2VydChvcHRpb25zLmxlZ2FjeSB8fCBhbnkudmVyc2lvbiA9PT0gZXhwb3J0cy52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXMnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnZhbHVlc107XG59O1xuXG5cbmV4cG9ydHMubGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbn07XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXG4gICAgTWVzc2FnZXMgPSBNZXNzYWdlcyB8fCByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgc291cmNlID0gc291cmNlIHx8IHt9O1xuXG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UuZXJyb3JzICYmXG4gICAgICAgIHRhcmdldC5lcnJvcnMpIHtcblxuICAgICAgICBtZXJnZWQuZXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LmVycm9ycywgc291cmNlLmVycm9ycyk7XG4gICAgICAgIG1lcmdlZC5lcnJvcnMud3JhcCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMud3JhcCwgc291cmNlLmVycm9ycy53cmFwKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm1lc3NhZ2VzKSB7XG4gICAgICAgIG1lcmdlZC5tZXNzYWdlcyA9IE1lc3NhZ2VzLmNvbXBpbGUoc291cmNlLm1lc3NhZ2VzLCB0YXJnZXQubWVzc2FnZXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBtZXJnZWRbZXhwb3J0cy5zeW1ib2xzLnByZWZzXTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufTtcblxuXG5leHBvcnRzLnRyeVdpdGhQYXRoID0gZnVuY3Rpb24gKGZuLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5ICsgJy4nICsgZXJyLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlQXJnID0gZnVuY3Rpb24gKHZhbHVlLCBsYWJlbCwgeyBhc3NlcnQsIG1lc3NhZ2UgfSkge1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTY2hlbWEoYXNzZXJ0KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhc3NlcnQudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYXNzZXJ0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGFiZWwgPyBgJHtsYWJlbH0gJHttZXNzYWdlfWAgOiBtZXNzYWdlO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52ZXJpZnlGbGF0ID0gZnVuY3Rpb24gKGFyZ3MsIG1ldGhvZCkge1xuXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBBc3NlcnQoIUFycmF5LmlzQXJyYXkoYXJnKSwgJ01ldGhvZCBubyBsb25nZXIgYWNjZXB0cyBhcnJheSBhcmd1bWVudHM6JywgbWV0aG9kKTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1heDogMTAwMCxcbiAgICBzdXBwb3J0ZWQ6IG5ldyBTZXQoWyd1bmRlZmluZWQnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10pXG59O1xuXG5cbmV4cG9ydHMucHJvdmlkZXIgPSB7XG5cbiAgICBwcm92aXNpb24ob3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkNhY2hlKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuLy8gTGVhc3QgUmVjZW50bHkgVXNlZCAoTFJVKSBDYWNoZVxuXG5pbnRlcm5hbHMuQ2FjaGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ21heCddKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubWF4ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXggJiYgb3B0aW9ucy5tYXggPiAwICYmIGlzRmluaXRlKG9wdGlvbnMubWF4KSwgJ0ludmFsaWQgbWF4IGNhY2hlIHNpemUnKTtcblxuICAgICAgICB0aGlzLl9tYXggPSBvcHRpb25zLm1heCB8fCBpbnRlcm5hbHMubWF4O1xuXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCBvZiBub2RlcyBieSBrZXlcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBpbnRlcm5hbHMuTGlzdCgpOyAgICAgICAgICAgICAgLy8gTGlzdCBvZiBub2RlcyAobW9zdCByZWNlbnRseSB1c2VkIGluIGhlYWQpXG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gICAgfVxuXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoa2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnN1cHBvcnRlZC5oYXModHlwZW9mIGtleSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHRoaXMuX2xpc3QudW5zaGlmdCh7IGtleSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBub2RlKTtcbiAgICAgICAgdGhpcy5fY29tcGFjdCgpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb21wYWN0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXAuc2l6ZSA+IHRoaXMuX21heCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2xpc3QucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkxpc3QgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIH1cblxuICAgIHVuc2hpZnQobm9kZSkge1xuXG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgIG5vZGUucHJldiA9IHRoaXMuaGVhZDtcblxuICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQubmV4dCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZmlyc3Qobm9kZSkge1xuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcbiAgICAgICAgdGhpcy51bnNoaWZ0KG5vZGUpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKHRoaXMudGFpbCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZShub2RlKSB7XG5cbiAgICAgICAgY29uc3QgeyBuZXh0LCBwcmV2IH0gPSBub2RlO1xuXG4gICAgICAgIG5leHQucHJldiA9IHByZXY7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYXBwZW5kUGF0aCcsICdvdmVycmlkZSddKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2NoZW1hKEpvaSwgY29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAob3B0aW9ucy5hcHBlbmRQYXRoICYmXG4gICAgICAgICAgICBlcnIucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5wYXRofSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGNvbmZpZyAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCB1bmRlZmluZWQgc2NoZW1hJyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIEFzc2VydChjb25maWcubGVuZ3RoLCAnSW52YWxpZCBlbXB0eSBhcnJheSBzY2hlbWEnKTtcblxuICAgICAgICBpZiAoY29uZmlnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSAoYmFzZSwgLi4udmFsdWVzKSA9PiB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS52YWxpZChKb2kub3ZlcnJpZGUsIC4uLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZS52YWxpZCguLi52YWx1ZXMpO1xuICAgIH07XG5cbiAgICBpZiAoaW50ZXJuYWxzLnNpbXBsZShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIEpvaS5jdXN0b20oY29uZmlnKTtcbiAgICB9XG5cbiAgICBBc3NlcnQodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNjaGVtYSBjb250ZW50OicsIHR5cGVvZiBjb25maWcpO1xuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuc2ltcGxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpvaS5hbHRlcm5hdGl2ZXMoKS50cnkoLi4uY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIC4uLmNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnJlZ2V4KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaS5kYXRlKCksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25maWcpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pLCAnU2NoZW1hIGNhbiBvbmx5IGNvbnRhaW4gcGxhaW4gb2JqZWN0cycpO1xuXG4gICAgcmV0dXJuIEpvaS5vYmplY3QoKS5rZXlzKGNvbmZpZyk7XG59O1xuXG5cbmV4cG9ydHMucmVmID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gUmVmLmlzUmVmKGlkKSA/IGlkIDogUmVmLmNyZWF0ZShpZCwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChyb290LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydsZWdhY3knXSk7XG5cbiAgICAvLyBDb21waWxlZCBieSBhbnkgc3VwcG9ydGVkIHZlcnNpb25cblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYSAmJiBzY2hlbWFbQ29tbW9uLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoYW55KSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmxlZ2FjeSB8fCBhbnkudmVyc2lvbiA9PT0gQ29tbW9uLnZlcnNpb24sICdDYW5ub3QgbWl4IGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBqb2kgc2NoZW1hczonLCBhbnkudmVyc2lvbiwgQ29tbW9uLnZlcnNpb24pO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFVuY29tcGlsZWQgcm9vdFxuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICFvcHRpb25zLmxlZ2FjeSkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLnNjaGVtYShyb290LCBzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTsgICAgICAgICAgLy8gV2lsbCBlcnJvciBpZiBzY2hlbWEgY29udGFpbnMgb3RoZXIgdmVyc2lvbnNcbiAgICB9XG5cbiAgICAvLyBTY2FuIHNjaGVtYSBmb3IgY29tcGlsZWQgcGFydHNcblxuICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoc2NoZW1hKTtcbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnNjaGVtYShyb290LCBzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGlsZXIuY29tcGlsZShjb21waWxlci5yb290LCBzY2hlbWEpO1xufTtcblxuXG5pbnRlcm5hbHMud2FsayA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoaXRlbSk7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWFbQ29tbW9uLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoYW55KSB7XG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHNjaGVtYVthbnkucm9vdF0sIGNvbXBpbGU6IGFueS5jb21waWxlIH07XG4gICAgfVxuXG4gICAgQXNzZXJ0KE9iamVjdC5nZXRQcm90b3R5cGVPZihzY2hlbWEpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pLCAnU2NoZW1hIGNhbiBvbmx5IGNvbnRhaW4gcGxhaW4gb2JqZWN0cycpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVyID0gaW50ZXJuYWxzLndhbGsoc2NoZW1hW2tleV0pO1xuICAgICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuc2ltcGxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgWydib29sZWFuJywgJ3N0cmluZycsICdudW1iZXInXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpO1xufTtcblxuXG5leHBvcnRzLndoZW4gPSBmdW5jdGlvbiAoc2NoZW1hLCBjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQXNzZXJ0KGNvbmRpdGlvbiAmJiB0eXBlb2YgY29uZGl0aW9uID09PSAnb2JqZWN0JywgJ01pc3Npbmcgb3B0aW9ucycpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBjb25kaXRpb247XG4gICAgICAgIGNvbmRpdGlvbiA9IFJlZi5jcmVhdGUoJy4nKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBzd2l0Y2g6IG9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lzJywgJ25vdCcsICd0aGVuJywgJ290aGVyd2lzZScsICdzd2l0Y2gnLCAnYnJlYWsnXSk7XG5cbiAgICAvLyBTY2hlbWEgY29uZGl0aW9uXG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmRpdGlvbikpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ1wiaXNcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQsICdcIm5vdFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5zd2l0Y2ggPT09IHVuZGVmaW5lZCwgJ1wic3dpdGNoXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jb25kaXRpb24oc2NoZW1hLCB7IGlzOiBjb25kaXRpb24sIHRoZW46IG9wdGlvbnMudGhlbiwgb3RoZXJ3aXNlOiBvcHRpb25zLm90aGVyd2lzZSwgYnJlYWs6IG9wdGlvbnMuYnJlYWsgfSk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbmRpdGlvblxuXG4gICAgQXNzZXJ0KFJlZi5pc1JlZihjb25kaXRpb24pIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnLCAnSW52YWxpZCBjb25kaXRpb246JywgY29uZGl0aW9uKTtcbiAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcImlzXCIgd2l0aCBcIm5vdFwiJyk7XG5cbiAgICBpZiAob3B0aW9ucy5zd2l0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcnVsZSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm5vdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydWxlID0geyBpczogb3B0aW9ucy5ub3QsIHRoZW46IG9wdGlvbnMub3RoZXJ3aXNlLCBvdGhlcndpc2U6IG9wdGlvbnMudGhlbiwgYnJlYWs6IG9wdGlvbnMuYnJlYWsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpcyA9IHJ1bGUuaXMgIT09IHVuZGVmaW5lZCA/IHNjaGVtYS4kX2NvbXBpbGUocnVsZS5pcykgOiBzY2hlbWEuJF9yb290LmludmFsaWQobnVsbCwgZmFsc2UsIDAsICcnKS5yZXF1aXJlZCgpO1xuICAgICAgICBBc3NlcnQocnVsZS50aGVuICE9PSB1bmRlZmluZWQgfHwgcnVsZS5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCwgJ29wdGlvbnMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBcInRoZW5cIiwgXCJvdGhlcndpc2VcIiwgb3IgXCJzd2l0Y2hcIicpO1xuICAgICAgICBBc3NlcnQocnVsZS5icmVhayA9PT0gdW5kZWZpbmVkIHx8IHJ1bGUudGhlbiA9PT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSB0aGVuLCBvdGhlcndpc2UsIGFuZCBicmVhayBhbGwgdG9nZXRoZXInKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5pcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhUmVmLmlzUmVmKG9wdGlvbnMuaXMpICYmXG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKG9wdGlvbnMuaXMpKSB7XG5cbiAgICAgICAgICAgIGlzID0gaXMucmVxdWlyZWQoKTsgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWZcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyByZWY6IGV4cG9ydHMucmVmKGNvbmRpdGlvbiksIGlzLCB0aGVuOiBydWxlLnRoZW4sIG90aGVyd2lzZTogcnVsZS5vdGhlcndpc2UsIGJyZWFrOiBydWxlLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCBzdGF0ZW1lbnRcblxuICAgIEFzc2VydChBcnJheS5pc0FycmF5KG9wdGlvbnMuc3dpdGNoKSwgJ1wic3dpdGNoXCIgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJpc1wiJyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJub3RcIicpO1xuICAgIEFzc2VydChvcHRpb25zLnRoZW4gPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcInRoZW5cIicpO1xuXG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLFxuICAgICAgICBzd2l0Y2g6IFtdLFxuICAgICAgICBicmVhazogb3B0aW9ucy5icmVha1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuc3dpdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRlc3QgPSBvcHRpb25zLnN3aXRjaFtpXTtcbiAgICAgICAgY29uc3QgbGFzdCA9IGkgPT09IG9wdGlvbnMuc3dpdGNoLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnModGVzdCwgbGFzdCA/IFsnaXMnLCAndGhlbicsICdvdGhlcndpc2UnXSA6IFsnaXMnLCAndGhlbiddKTtcblxuICAgICAgICBBc3NlcnQodGVzdC5pcyAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwiaXNcIicpO1xuICAgICAgICBBc3NlcnQodGVzdC50aGVuICE9PSB1bmRlZmluZWQsICdTd2l0Y2ggc3RhdGVtZW50IG1pc3NpbmcgXCJ0aGVuXCInKTtcblxuICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgaXM6IHNjaGVtYS4kX2NvbXBpbGUodGVzdC5pcyksXG4gICAgICAgICAgICB0aGVuOiBzY2hlbWEuJF9jb21waWxlKHRlc3QudGhlbilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIVJlZi5pc1JlZih0ZXN0LmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYSh0ZXN0LmlzKSkge1xuXG4gICAgICAgICAgICBpdGVtLmlzID0gaXRlbS5pcy5yZXF1aXJlZCgpOyAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMub3RoZXJ3aXNlID09PSB1bmRlZmluZWQgfHwgdGVzdC5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IFwib3RoZXJ3aXNlXCIgaW5zaWRlIGFuZCBvdXRzaWRlIGEgXCJzd2l0Y2hcIicpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gb3B0aW9ucy5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3RoZXJ3aXNlIDogdGVzdC5vdGhlcndpc2U7XG4gICAgICAgICAgICBpZiAob3RoZXJ3aXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgYm90aCBvdGhlcndpc2UgYW5kIGJyZWFrJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UgPSBzY2hlbWEuJF9jb21waWxlKG90aGVyd2lzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydWxlLnN3aXRjaC5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlO1xufTtcblxuXG5pbnRlcm5hbHMuY29uZGl0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uKSB7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ3RoZW4nLCAnb3RoZXJ3aXNlJ10pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25kaXRpb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbltrZXldID0gc2NoZW1hLiRfY29tcGlsZShjb25kaXRpb25ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uZGl0aW9uO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKGZyb20sIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG4gICAgY29uc3QgcHJvdG90eXBlID0gQ2xvbmUoYmFzZSk7XG4gICAgY29uc3Qgc2NoZW1hID0gZnJvbS5fYXNzaWduKE9iamVjdC5jcmVhdGUocHJvdG90eXBlKSk7XG4gICAgY29uc3QgZGVmID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICBkZWxldGUgZGVmLmJhc2U7XG5cbiAgICBwcm90b3R5cGUuX2RlZmluaXRpb24gPSBkZWY7XG5cbiAgICBjb25zdCBwYXJlbnQgPSBiYXNlLl9kZWZpbml0aW9uIHx8IHt9O1xuICAgIGRlZi5tZXNzYWdlcyA9IE1lc3NhZ2VzLm1lcmdlKHBhcmVudC5tZXNzYWdlcywgZGVmLm1lc3NhZ2VzKTtcbiAgICBkZWYucHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5wcm9wZXJ0aWVzLCBkZWYucHJvcGVydGllcyk7XG5cbiAgICAvLyBUeXBlXG5cbiAgICBzY2hlbWEudHlwZSA9IGRlZi50eXBlO1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGRlZi5mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5mbGFncywgZGVmLmZsYWdzKTtcblxuICAgIC8vIFRlcm1zXG5cbiAgICBjb25zdCB0ZXJtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC50ZXJtcyk7XG4gICAgaWYgKGRlZi50ZXJtcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnRlcm1zKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgb3duIHRlcm1zXG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gZGVmLnRlcm1zW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Rlcm1zW25hbWVdID09PSB1bmRlZmluZWQsICdJbnZhbGlkIHRlcm0gb3ZlcnJpZGUgZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXNbbmFtZV0gPSB0ZXJtLmluaXQ7XG4gICAgICAgICAgICB0ZXJtc1tuYW1lXSA9IHRlcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYudGVybXMgPSB0ZXJtcztcblxuICAgIC8vIENvbnN0cnVjdG9yIGFyZ3VtZW50c1xuXG4gICAgaWYgKCFkZWYuYXJncykge1xuICAgICAgICBkZWYuYXJncyA9IHBhcmVudC5hcmdzO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmVcblxuICAgIGRlZi5wcmVwYXJlID0gaW50ZXJuYWxzLnByZXBhcmUoZGVmLnByZXBhcmUsIHBhcmVudC5wcmVwYXJlKTtcblxuICAgIC8vIENvZXJjZVxuXG4gICAgaWYgKGRlZi5jb2VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWYuY29lcmNlLmZyb20gJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGRlZi5jb2VyY2UuZnJvbSkpIHtcblxuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlLm1ldGhvZCwgZnJvbTogW10uY29uY2F0KGRlZi5jb2VyY2UuZnJvbSkgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5jb2VyY2UgPSBpbnRlcm5hbHMuY29lcmNlKGRlZi5jb2VyY2UsIHBhcmVudC5jb2VyY2UpO1xuXG4gICAgLy8gVmFsaWRhdGVcblxuICAgIGRlZi52YWxpZGF0ZSA9IGludGVybmFscy52YWxpZGF0ZShkZWYudmFsaWRhdGUsIHBhcmVudC52YWxpZGF0ZSk7XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgY29uc3QgcnVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucnVsZXMpO1xuICAgIGlmIChkZWYucnVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IGRlZi5ydWxlc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcnVsZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJ1bGUgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGxldCBtZXRob2QgPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCghcnVsZXNbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgcnVsZXNbbmFtZV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAocnVsZS5hbGlhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXS5jb25jYXQocnVsZS5hbGlhcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVthbGlhc10gPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzID0gcnVsZS5hcmdzLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB7IG5hbWU6IGFyZyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFydWxlLmFyZ3NCeU5hbWUuaGFzKGFyZy5uYW1lKSwgJ0R1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZScsIGFyZy5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGFyZy5hc3NlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcuYXNzZXJ0ID0gYXJnLmFzc2VydC5zdHJpY3QoKS5sYWJlbChhcmcubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUuc2V0KGFyZy5uYW1lLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnJ1bGVzID0gcnVsZXM7XG5cbiAgICAvLyBNb2RpZmllcnNcblxuICAgIGNvbnN0IG1vZGlmaWVycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tb2RpZmllcnMpO1xuICAgIGlmIChkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gZGVmLm1vZGlmaWVyc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIG1vZGlmaWVyIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoYXJnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlKHsgW25hbWVdOiBhcmcgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICBtb2RpZmllcnNbbmFtZV0gPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG5cbiAgICAvLyBPdmVycmlkZXNcblxuICAgIGlmIChkZWYub3ZlcnJpZGVzKSB7XG4gICAgICAgIHByb3RvdHlwZS5fc3VwZXIgPSBiYXNlO1xuICAgICAgICBzY2hlbWEuJF9zdXBlciA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgaW4gZGVmLm92ZXJyaWRlcykge1xuICAgICAgICAgICAgQXNzZXJ0KGJhc2Vbb3ZlcnJpZGVdLCAnQ2Fubm90IG92ZXJyaWRlIG1pc3NpbmcnLCBvdmVycmlkZSk7XG4gICAgICAgICAgICBkZWYub3ZlcnJpZGVzW292ZXJyaWRlXVtDb21tb24uc3ltYm9scy5wYXJlbnRdID0gYmFzZVtvdmVycmlkZV07XG4gICAgICAgICAgICBzY2hlbWEuJF9zdXBlcltvdmVycmlkZV0gPSBiYXNlW292ZXJyaWRlXS5iaW5kKHNjaGVtYSk7ICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLCBkZWYub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0c1xuXG4gICAgZGVmLmNhc3QgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQuY2FzdCwgZGVmLmNhc3QpO1xuXG4gICAgLy8gTWFuaWZlc3RcblxuICAgIGNvbnN0IG1hbmlmZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50Lm1hbmlmZXN0LCBkZWYubWFuaWZlc3QpO1xuICAgIG1hbmlmZXN0LmJ1aWxkID0gaW50ZXJuYWxzLmJ1aWxkKGRlZi5tYW5pZmVzdCAmJiBkZWYubWFuaWZlc3QuYnVpbGQsIHBhcmVudC5tYW5pZmVzdCAmJiBwYXJlbnQubWFuaWZlc3QuYnVpbGQpO1xuICAgIGRlZi5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuXG4gICAgLy8gUmVidWlsZFxuXG4gICAgZGVmLnJlYnVpbGQgPSBpbnRlcm5hbHMucmVidWlsZChkZWYucmVidWlsZCwgcGFyZW50LnJlYnVpbGQpO1xuXG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYnVpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVzYykge1xuXG4gICAgICAgIHJldHVybiBwYXJlbnQoY2hpbGQob2JqLCBkZXNjKSwgZGVzYyk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLmNvZXJjZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGNoaWxkLmZyb20gJiYgcGFyZW50LmZyb20gPyBbLi4ubmV3IFNldChbLi4uY2hpbGQuZnJvbSwgLi4ucGFyZW50LmZyb21dKV0gOiBudWxsLFxuICAgICAgICBtZXRob2QodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvZXJjZWQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50LmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29lcmNlZCA9IHBhcmVudC5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkLmVycm9ycyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29lcmNlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgY2hpbGQuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvd24gPSBjaGlsZC5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG93bjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnByZXBhcmUgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBjaGlsZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkLmVycm9ycyB8fFxuICAgICAgICAgICAgICAgIHByZXBhcmVkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBwcmVwYXJlZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnQodmFsdWUsIGhlbHBlcnMpIHx8IHByZXBhcmVkO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5yZWJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgICAgICBwYXJlbnQoc2NoZW1hKTtcbiAgICAgICAgY2hpbGQoc2NoZW1hKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyZW50KHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAoIUFycmF5LmlzQXJyYXkocmVzdWx0LmVycm9ycykgfHwgcmVzdWx0LmVycm9ycy5sZW5ndGgpKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZCh2YWx1ZSwgaGVscGVycykgfHwgcmVzdWx0O1xuICAgIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5kZXNjcmliZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgIC8vIFR5cGVcblxuICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS50eXBlLFxuICAgICAgICBmbGFnczoge30sXG4gICAgICAgIHJ1bGVzOiBbXVxuICAgIH07XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZm9yIChjb25zdCBmbGFnIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgZGVzYy5mbGFnc1tmbGFnXSA9IGludGVybmFscy5kZXNjcmliZShzY2hlbWEuX2ZsYWdzW2ZsYWddKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmtleXMoZGVzYy5mbGFncykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLmZsYWdzO1xuICAgIH1cblxuICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICBpZiAoc2NoZW1hLl9wcmVmZXJlbmNlcykge1xuICAgICAgICBkZXNjLnByZWZlcmVuY2VzID0gQ2xvbmUoc2NoZW1hLl9wcmVmZXJlbmNlcywgeyBzaGFsbG93OiBbJ21lc3NhZ2VzJ10gfSk7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXTtcbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMgPSBNZXNzYWdlcy5kZWNvbXBpbGUoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBkZXNjLmFsbG93ID0gc2NoZW1hLl92YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBkZXNjLmludmFsaWQgPSBzY2hlbWEuX2ludmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVEZWYgPSBkZWYucnVsZXNbcnVsZS5uYW1lXTtcbiAgICAgICAgaWYgKHJ1bGVEZWYubWFuaWZlc3QgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpdGVtID0geyBuYW1lOiBydWxlLm5hbWUgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtW2N1c3RvbV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgIGl0ZW0uYXJncyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gcnVsZS5hcmdzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29wdGlvbnMnICYmXG4gICAgICAgICAgICAgICAgICAgICFPYmplY3Qua2V5cyhhcmcpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uYXJnc1trZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKGFyZywgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhpdGVtLmFyZ3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLmFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjLnJ1bGVzLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5ydWxlcztcbiAgICB9XG5cbiAgICAvLyBUZXJtcyAobXVzdCBiZSBsYXN0IHRvIHZlcmlmeSBubyBuYW1lIGNvbmZsaWN0cylcblxuICAgIGZvciAoY29uc3QgdGVybSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAodGVybVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCghZGVzY1t0ZXJtXSwgJ0Nhbm5vdCBkZXNjcmliZSBzY2hlbWEgZHVlIHRvIGludGVybmFsIG5hbWUgY29uZmxpY3Qgd2l0aCcsIHRlcm0pO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLiRfdGVybXNbdGVybV07XG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV0gPSBbLi4uaXRlbXMuZW50cmllcygpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tbW9uLmlzVmFsdWVzKGl0ZW1zKSkge1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IGl0ZW1zLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChkZWYudGVybXNbdGVybV0sICdUZXJtJywgdGVybSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1t0ZXJtXS5tYW5pZmVzdDtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0JztcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFtYXBwZWQpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGludGVybmFscy5kZXNjcmliZShpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXBwZWRcblxuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBtYW5pZmVzdC5tYXBwZWQ7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV1baXRlbVt0b11dID0gaXRlbVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGVcblxuICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBBc3NlcnQobm9ybWFsaXplZC5sZW5ndGggPT09IDEsICdUZXJtJywgdGVybSwgJ2NvbnRhaW5zIG1vcmUgdGhhbiBvbmUgaXRlbScpO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWRbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlKHNjaGVtYS4kX3Jvb3QsIGRlc2MpO1xuICAgIHJldHVybiBkZXNjO1xufTtcblxuXG5pbnRlcm5hbHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbS5tYXAoaW50ZXJuYWxzLmRlc2NyaWJlKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSA9PT0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3BlY2lhbDogJ2RlZXAnIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBpdGVtID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgcmV0dXJuIENsb25lKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgcmV0dXJuIHsgYnVmZmVyOiBpdGVtLnRvU3RyaW5nKCdiaW5hcnknKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVnZXg6IGl0ZW0udG9TdHJpbmcoKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiB7IGZ1bmN0aW9uOiBpdGVtLmxpdGVyYWwgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uZGVzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKS5yZWY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUodmFsdWUsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGludGVybmFscy5CdWlsZGVyKGpvaSk7XG4gICAgcmV0dXJuIGJ1aWxkZXIucGFyc2UoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5CdWlsZGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioam9pKSB7XG5cbiAgICAgICAgdGhpcy5qb2kgPSBqb2k7XG4gICAgfVxuXG4gICAgcGFyc2UoZGVzYykge1xuXG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZSh0aGlzLmpvaSwgZGVzYyk7XG5cbiAgICAgICAgLy8gVHlwZVxuXG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmpvaVtkZXNjLnR5cGVdKCkuX2JhcmUoKTtcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGVyID0gZGVmLmZsYWdzW2ZsYWddICYmIGRlZi5mbGFnc1tmbGFnXS5zZXR0ZXIgfHwgZmxhZztcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtzZXR0ZXJdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBmbGFnJywgZmxhZywgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbc2V0dGVyXSh0aGlzLmJ1aWxkKGRlc2MuZmxhZ3NbZmxhZ10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5wcmVmZXJlbmNlcyh0aGlzLmJ1aWxkKGRlc2MucHJlZmVyZW5jZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgICAgIGlmIChkZXNjLmFsbG93KSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuYWxsb3coLi4udGhpcy5idWlsZChkZXNjLmFsbG93KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5pbnZhbGlkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuaW52YWxpZCguLi50aGlzLmJ1aWxkKGRlc2MuaW52YWxpZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBpZiAoZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtydWxlLm5hbWVdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBydWxlJywgcnVsZS5uYW1lLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVpbHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsdFtrZXldID0gdGhpcy5idWlsZChydWxlLmFyZ3Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhidWlsdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkZWYucnVsZXNbcnVsZS5uYW1lXS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoIDw9IGRlZmluaXRpb24ubGVuZ3RoLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvJywgZGVmaW5pdGlvbi5sZW5ndGgsICcsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSB9IG9mIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoID09PSAxLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvIDEsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRba2V5c1swXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHlcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtydWxlLm5hbWVdKC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZXNldFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2N1c3RvbV0gPSB0aGlzLmJ1aWxkKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5ydWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgY29uc3QgdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgaWYgKFsnYWxsb3cnLCAnZmxhZ3MnLCAnaW52YWxpZCcsICd3aGVucycsICdwcmVmZXJlbmNlcycsICdydWxlcycsICd0eXBlJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW2tleV0sICdUZXJtJywga2V5LCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1trZXldLm1hbmlmZXN0O1xuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMucGFyc2UoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICd2YWx1ZXMnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlc2Nba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2Nba2V5XVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdGVybXNba2V5XVtuYW1lXSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2Mud2hlbnMpIHtcbiAgICAgICAgICAgIHRlcm1zLndoZW5zID0gZGVzYy53aGVucy5tYXAoKHdoZW4pID0+IHRoaXMuYnVpbGQod2hlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1hID0gZGVmLm1hbmlmZXN0LmJ1aWxkKHNjaGVtYSwgdGVybXMpO1xuICAgICAgICBzY2hlbWEuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICBidWlsZChkZXNjLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoZGVzYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXNjKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZXNjKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChkZXNjLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIsICdCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIuZnJvbShkZXNjLmJ1ZmZlciwgJ2JpbmFyeScpOyAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLCBsaXRlcmFsOiBkZXNjLmZ1bmN0aW9uIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MucmVmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVnZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MucmVnZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5zcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnZGVlcCddLmluY2x1ZGVzKGRlc2Muc3BlY2lhbCksICdVbmtub3duIHNwZWNpYWwgdmFsdWUnLCBkZXNjLnNwZWNpYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICBjb25zdCBlbmQgPSBzdHJpbmcubGFzdEluZGV4T2YoJy8nKTtcbiAgICBjb25zdCBleHAgPSBzdHJpbmcuc2xpY2UoMSwgZW5kKTtcbiAgICBjb25zdCBmbGFncyA9IHN0cmluZy5zbGljZShlbmQgKyAxKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChleHAsIGZsYWdzKTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBqb2kuYXNzZXJ0KGRlc2MsIFNjaGVtYXMuZGVzY3JpcHRpb24pO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaXNtYXRjaGVkOiBudWxsXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByb3RvdHlwZTogdHJ1ZSB9LCBvcHRpb25zKTtcblxuICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbChvYmosIHJlZiwgb3B0aW9ucywgW10pO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGlmIChvYmogPT09IHJlZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcGllZCBmcm9tIERlZXAtZXFsLCBjb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIsIGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbSwgTUlUIExpY2Vuc2VkLCBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsXG4gICAgICAgIHJldHVybiBvYmogIT09IDAgfHwgMSAvIG9iaiA9PT0gMSAvIHJlZjtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iajtcblxuICAgIGlmICh0eXBlICE9PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHJlZiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZGVlcEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBvYmoudG9TdHJpbmcoKSAhPT0gcmVmLnRvU3RyaW5nKCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGludWUgYXMgb2JqZWN0XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IG9iaiAmJiByZWYgIT09IHJlZjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFOXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUob2JqLCByZWYsICEhb3B0aW9ucy5wcm90b3R5cGUpO1xuICAgIHN3aXRjaCAoaW5zdGFuY2VUeXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZXMuYnVmZmVyOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIucHJvdG90eXBlLmVxdWFscy5jYWxsKG9iaiwgcmVmKTsgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBjYXNlIFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICByZXR1cm4gb2JqID09PSByZWY7XG4gICAgICAgIGNhc2UgVHlwZXMucmVnZXg6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkgPT09IHJlZi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIGludGVybmFscy5taXNtYXRjaGVkOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzZWVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChzZWVuW2ldLmlzU2FtZShvYmosIHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBjb21wYXJpc29uIGZhaWxlZCwgaXQgd291bGQgaGF2ZSBzdG9wcGVkIGV4ZWN1dGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5wdXNoKG5ldyBpbnRlcm5hbHMuU2VlbkVudHJ5KG9iaiwgcmVmKSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmooaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzZWVuLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUgPSBmdW5jdGlvbiAob2JqLCByZWYsIGNoZWNrUHJvdG90eXBlKSB7XG5cbiAgICBpZiAoY2hlY2tQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmICh0eXBlICE9PSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuXG5pbnRlcm5hbHMudmFsdWVPZiA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGNvbnN0IG9ialZhbHVlT2YgPSBvYmoudmFsdWVPZjtcbiAgICBpZiAob2JqVmFsdWVPZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9ialZhbHVlT2YuY2FsbChvYmopO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaGFzT3duRW51bWVyYWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYpIHtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChvYmopKSB7XG4gICAgICAgIGlmICghU2V0LnByb3RvdHlwZS5oYXMuY2FsbChyZWYsIGVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy5pc0RlZXBFcXVhbE9iaiA9IGZ1bmN0aW9uIChpbnN0YW5jZVR5cGUsIG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKSB7XG5cbiAgICBjb25zdCB7IGlzRGVlcEVxdWFsLCB2YWx1ZU9mLCBoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkgfSA9IGludGVybmFscztcbiAgICBjb25zdCB7IGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyB9ID0gT2JqZWN0O1xuXG4gICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFydCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgaW5kZXggbWF0Y2ggYW55IG90aGVyIGluZGV4XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqVmFsdWUgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZWYWx1ZSBvZiByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKG9ialZhbHVlLCByZWZWYWx1ZSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHJlZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpbaV0sIHJlZltpXSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuaXNTZXRTaW1wbGVFcXVhbChvYmosIHJlZikpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlZXAgZXF1YWxpdHlcblxuICAgICAgICAgICAgY29uc3QgcmVmMiA9IG5ldyBTZXQoU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChyZWYpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqRW50cnkgb2YgU2V0LnByb3RvdHlwZS52YWx1ZXMuY2FsbChvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZjIuZGVsZXRlKG9iakVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZkVudHJ5IG9mIHJlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKG9iakVudHJ5LCByZWZFbnRyeSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjIuZGVsZXRlKHJlZkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMubWFwKSB7XG4gICAgICAgIGlmIChvYmouc2l6ZSAhPT0gcmVmLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE1hcC5wcm90b3R5cGUuZW50cmllcy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICFNYXAucHJvdG90eXBlLmhhcy5jYWxsKHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbCh2YWx1ZSwgTWFwLnByb3RvdHlwZS5nZXQuY2FsbChyZWYsIGtleSksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuZXJyb3IpIHtcblxuICAgICAgICAvLyBBbHdheXMgY2hlY2sgbmFtZSBhbmQgbWVzc2FnZVxuXG4gICAgICAgIGlmIChvYmoubmFtZSAhPT0gcmVmLm5hbWUgfHxcbiAgICAgICAgICAgIG9iai5tZXNzYWdlICE9PSByZWYubWVzc2FnZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayAudmFsdWVPZigpXG5cbiAgICBjb25zdCB2YWx1ZU9mT2JqID0gdmFsdWVPZihvYmopO1xuICAgIGNvbnN0IHZhbHVlT2ZSZWYgPSB2YWx1ZU9mKHJlZik7XG4gICAgaWYgKChvYmogIT09IHZhbHVlT2ZPYmogfHwgcmVmICE9PSB2YWx1ZU9mUmVmKSAmJlxuICAgICAgICAhaXNEZWVwRXF1YWwodmFsdWVPZk9iaiwgdmFsdWVPZlJlZiwgb3B0aW9ucywgc2VlbikpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcHJvcGVydGllc1xuXG4gICAgY29uc3Qgb2JqS2V5cyA9IGtleXMob2JqKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAhPT0ga2V5cyhyZWYpLmxlbmd0aCAmJlxuICAgICAgICAhb3B0aW9ucy5za2lwKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBza2lwcGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmpLZXlzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXAgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcC5pbmNsdWRlcyhrZXkpKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWZba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKytza2lwcGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAtIHNraXBwZWQgIT09IGtleXMocmVmKS5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc3ltYm9sc1xuXG4gICAgaWYgKG9wdGlvbnMuc3ltYm9scyAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgY29uc3Qgb2JqU3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuICAgICAgICBjb25zdCByZWZTeW1ib2xzID0gbmV3IFNldChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocmVmKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb2JqU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNraXAgfHxcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5za2lwLmluY2x1ZGVzKGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWZTeW1ib2xzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVmU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLlNlZW5FbnRyeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGlzU2FtZShvYmosIHJlZikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9iaiA9PT0gb2JqICYmIHRoaXMucmVmID09PSByZWY7XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMubG9jYXRpb24gPSBmdW5jdGlvbiAoZGVwdGggPSAwKSB7XG5cbiAgICBjb25zdCBvcmlnID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoaWdub3JlLCBzdGFjaykgPT4gc3RhY2s7XG5cbiAgICBjb25zdCBjYXB0dXJlID0ge307XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgdGhpcyk7XG4gICAgY29uc3QgbGluZSA9IGNhcHR1cmUuc3RhY2tbZGVwdGggKyAxXTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVuYW1lOiBsaW5lLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGxpbmU6IGxpbmUuZ2V0TGluZU51bWJlcigpXG4gICAgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IFBpbnBvaW50ID0gcmVxdWlyZSgnQHNpZGV3YXkvcGlucG9pbnQnKTtcblxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgY29kZXM6IHtcbiAgICAgICAgZXJyb3I6IDEsXG4gICAgICAgIHBhc3M6IDIsXG4gICAgICAgIGZ1bGw6IDNcbiAgICB9LFxuICAgIGxhYmVsczoge1xuICAgICAgICAwOiAnbmV2ZXIgdXNlZCcsXG4gICAgICAgIDE6ICdhbHdheXMgZXJyb3InLFxuICAgICAgICAyOiAnYWx3YXlzIHBhc3MnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLnNldHVwID0gZnVuY3Rpb24gKHJvb3QpIHtcblxuICAgIGNvbnN0IHRyYWNlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJvb3QuX3RyYWNlciA9IHJvb3QuX3RyYWNlciB8fCBuZXcgaW50ZXJuYWxzLlRyYWNlcigpO1xuICAgICAgICByZXR1cm4gcm9vdC5fdHJhY2VyO1xuICAgIH07XG5cbiAgICByb290LnRyYWNlID0gdHJhY2U7XG4gICAgcm9vdFtTeW1ib2wuZm9yKCdAaGFwaS9sYWIvY292ZXJhZ2UvaW5pdGlhbGl6ZScpXSA9IHRyYWNlO1xuXG4gICAgcm9vdC51bnRyYWNlID0gKCkgPT4ge1xuXG4gICAgICAgIHJvb3QuX3RyYWNlciA9IG51bGw7XG4gICAgfTtcbn07XG5cblxuZXhwb3J0cy5sb2NhdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIHJldHVybiBzY2hlbWEuJF9zZXRGbGFnKCdfdHJhY2VyTG9jYXRpb24nLCBQaW5wb2ludC5sb2NhdGlvbigyKSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlLnRyYWNlcigpLCBjYWxsZXJcbn07XG5cblxuaW50ZXJuYWxzLlRyYWNlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdKb2knO1xuICAgICAgICB0aGlzLl9zY2hlbWFzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIF9yZWdpc3RlcihzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX3NjaGVtYXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nLnN0b3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBuZXcgaW50ZXJuYWxzLlN0b3JlKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHsgZmlsZW5hbWUsIGxpbmUgfSA9IHNjaGVtYS5fZmxhZ3MuX3RyYWNlckxvY2F0aW9uIHx8IFBpbnBvaW50LmxvY2F0aW9uKDUpOyAgIC8vIGludGVybmFscy50cmFjZXIoKSwgaW50ZXJuYWxzLmVudHJ5KCksIGV4cG9ydHMuZW50cnkoKSwgdmFsaWRhdGUoKSwgY2FsbGVyXG4gICAgICAgIHRoaXMuX3NjaGVtYXMuc2V0KHNjaGVtYSwgeyBmaWxlbmFtZSwgbGluZSwgc3RvcmUgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG5cbiAgICBfY29tYmluZShtZXJnZWQsIHNvdXJjZXMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHsgc3RvcmUgfSBvZiB0aGlzLl9zY2hlbWFzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzdG9yZS5fY29tYmluZShtZXJnZWQsIHNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwb3J0KGZpbGUpIHtcblxuICAgICAgICBjb25zdCBjb3ZlcmFnZSA9IFtdO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCByZWdpc3RlcmVkIHNjaGVtYVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBmaWxlbmFtZSwgbGluZSwgc3RvcmUgfSBvZiB0aGlzLl9zY2hlbWFzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSAmJlxuICAgICAgICAgICAgICAgIGZpbGUgIT09IGZpbGVuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBzdWIgc2NoZW1hcyBvZiB0aGUgcmVnaXN0ZXJlZCByb290XG5cbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBbc2NoZW1hLCBsb2ddIG9mIHN0b3JlLl9zb3VyY2VzLmVudHJpZXMoKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3ViIHNjaGVtYSBwYXJlbnQgc2tpcHBlZFxuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5zdWIobG9nLnBhdGhzLCBza2lwcGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHJlYWNoZWRcblxuICAgICAgICAgICAgICAgIGlmICghbG9nLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICduZXZlciByZWFjaGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzOiBbLi4ubG9nLnBhdGhzXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goLi4ubG9nLnBhdGhzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdmFsdWVzXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgWyd2YWxpZCcsICdpbnZhbGlkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gc2NoZW1hW2BfJHt0eXBlfXNgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChzZXQuX3ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnMgPSBuZXcgU2V0KHNldC5fcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgcmVmIH0gb2YgbG9nW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLnNpemUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnMuc2l6ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogWy4uLnZhbHVlcywgLi4uWy4uLnJlZnNdLm1hcCgocmVmKSA9PiByZWYuZGlzcGxheSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAke3R5cGV9c2BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgcnVsZXMgc3RhdHVzXG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlcyA9IHNjaGVtYS5fcnVsZXMubWFwKChydWxlKSA9PiBydWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ2RlZmF1bHQnLCAnZmFpbG92ZXInXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFnc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGludGVybmFscy5sYWJlbHNbbG9nLnJ1bGVbbmFtZV0gfHwgMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHsgcnVsZTogbmFtZSwgc3RhdHVzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLnBhdGhzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQucGF0aHMgPSBbLi4ubG9nLnBhdGhzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvdmVyYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTY2hlbWEgbWlzc2luZyB0ZXN0cyBmb3IgJHttaXNzaW5nLm1hcChpbnRlcm5hbHMubWVzc2FnZSkuam9pbignLCAnKX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY292ZXJhZ2UubGVuZ3RoID8gY292ZXJhZ2UgOiBudWxsO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlN0b3JlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG5cbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zb3VyY2VzID0gbmV3IE1hcCgpOyAgICAgICAgICAvLyBzY2hlbWEgLT4geyBwYXRocywgZW50cnksIHJ1bGUsIHZhbGlkLCBpbnZhbGlkIH1cbiAgICAgICAgdGhpcy5fY29tYm9zID0gbmV3IE1hcCgpOyAgICAgICAgICAgLy8gbWVyZ2VkIC0+IFtzb3VyY2VzXVxuICAgICAgICB0aGlzLl9zY2FuKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgZGVidWcoc3RhdGUsIHNvdXJjZSwgbmFtZSwgcmVzdWx0KSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcgJiYgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaCh7IHR5cGU6IHNvdXJjZSwgbmFtZSwgcmVzdWx0LCBwYXRoOiBzdGF0ZS5wYXRoIH0pO1xuICAgIH1cblxuICAgIGVudHJ5KHNjaGVtYSwgc3RhdGUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogJ2VudHJ5JyB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZy5lbnRyeSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZpbHRlcihzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIHZhbHVlKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmRlYnVnKHN0YXRlLCB7IHR5cGU6IHNvdXJjZSwgLi4udmFsdWUgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXS5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2coc2NoZW1hLCBzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQ6IHJlc3VsdCA9PT0gJ2Z1bGwnID8gJ3Bhc3MnIDogcmVzdWx0IH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nW3NvdXJjZV1bbmFtZV0gPSBsb2dbc291cmNlXVtuYW1lXSB8fCAwO1xuICAgICAgICAgICAgbG9nW3NvdXJjZV1bbmFtZV0gfD0gaW50ZXJuYWxzLmNvZGVzW3Jlc3VsdF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc29sdmUoc3RhdGUsIHJlZiwgdG8pIHtcblxuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2cgPSB7IHR5cGU6ICdyZXNvbHZlJywgcmVmOiByZWYuZGlzcGxheSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaChsb2cpO1xuICAgIH1cblxuICAgIHZhbHVlKHN0YXRlLCBieSwgZnJvbSwgdG8sIG5hbWUpIHtcblxuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LmRlYnVnIHx8XG4gICAgICAgICAgICBEZWVwRXF1YWwoZnJvbSwgdG8pKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3ZhbHVlJywgYnksIGZyb20sIHRvLCBwYXRoOiBzdGF0ZS5wYXRoIH07XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBsb2cubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgX3JlY29yZChzY2hlbWEsIGVhY2gpIHtcblxuICAgICAgICBjb25zdCBsb2cgPSB0aGlzLl9zb3VyY2VzLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBlYWNoKGxvZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3VyY2VzID0gdGhpcy5fY29tYm9zLmdldChzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmQoc291cmNlLCBlYWNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zY2FuKHNjaGVtYSwgX3BhdGgpIHtcblxuICAgICAgICBjb25zdCBwYXRoID0gX3BhdGggfHwgW107XG5cbiAgICAgICAgbGV0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmICghbG9nKSB7XG4gICAgICAgICAgICBsb2cgPSB7XG4gICAgICAgICAgICAgICAgcGF0aHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBlbnRyeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVsZToge30sXG4gICAgICAgICAgICAgICAgdmFsaWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXMuc2V0KHNjaGVtYSwgbG9nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nLnBhdGhzLmFkZChwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoc3ViLCBzb3VyY2UpID0+IHtcblxuICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSBpbnRlcm5hbHMuaWQoc3ViLCBzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5fc2NhbihzdWIsIHBhdGguY29uY2F0KHN1YklkKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBfY29tYmluZShtZXJnZWQsIHNvdXJjZXMpIHtcblxuICAgICAgICB0aGlzLl9jb21ib3Muc2V0KG1lcmdlZCwgc291cmNlcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubWVzc2FnZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICBjb25zdCBwYXRoID0gaXRlbS5wYXRocyA/IEVycm9ycy5wYXRoKGl0ZW0ucGF0aHNbMF0pICsgKGl0ZW0ucnVsZSA/ICc6JyA6ICcnKSA6ICcnO1xuICAgIHJldHVybiBgJHtwYXRofSR7aXRlbS5ydWxlIHx8ICcnfSAoJHtpdGVtLnN0YXR1c30pYDtcbn07XG5cblxuaW50ZXJuYWxzLmlkID0gZnVuY3Rpb24gKHNjaGVtYSwgeyBzb3VyY2UsIG5hbWUsIHBhdGgsIGtleSB9KSB7XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5pZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLl9mbGFncy5pZDtcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgbmFtZSA9IGBAJHtuYW1lfWA7XG5cbiAgICBpZiAoc291cmNlID09PSAndGVybXMnKSB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgcGF0aFtNYXRoLm1pbihwYXRoLmxlbmd0aCAtIDEsIDEpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5cbmludGVybmFscy5zdWIgPSBmdW5jdGlvbiAocGF0aHMsIHNraXBwZWQpIHtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBmb3IgKGNvbnN0IHNraXAgb2Ygc2tpcHBlZCkge1xuICAgICAgICAgICAgaWYgKERlZXBFcXVhbChwYXRoLnNsaWNlKDAsIHNraXAubGVuZ3RoKSwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlYnVnID0gZnVuY3Rpb24gKHN0YXRlLCBldmVudCkge1xuXG4gICAgaWYgKHN0YXRlLm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIGV2ZW50LnBhdGggPSBzdGF0ZS5kZWJ1ZyA/IFsuLi5zdGF0ZS5wYXRoLCBzdGF0ZS5kZWJ1Z10gOiBzdGF0ZS5wYXRoO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGV2ZW50KTtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBBc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBudWxsT3ZlcnJpZGU6IHRydWUsIG1lcmdlQXJyYXlzOiB0cnVlIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBBc3NlcnQoQXJyYXkuaXNBcnJheSh0YXJnZXQpLCAnQ2Fubm90IG1lcmdlIGFycmF5IG9udG8gYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXJnZUFycmF5cykge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IGNoYW5nZSB0YXJnZXQgYXNzaWdubWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKENsb25lKHNvdXJjZVtpXSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4gb2NjdXIgZm9yIHNoYWxsb3cgbWVyZ2VzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgICAgICAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHx8ICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gQ2xvbmUodmFsdWUsIHsgc3ltYm9sczogb3B0aW9ucy5zeW1ib2xzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLm1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubnVsbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cblxuZXhwb3J0cy5JZHMgPSBpbnRlcm5hbHMuSWRzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgaW50ZXJuYWxzLklkcygpO1xuICAgICAgICBjbG9uZS5fYnlJZCA9IG5ldyBNYXAodGhpcy5fYnlJZCk7XG4gICAgICAgIGNsb25lLl9ieUtleSA9IG5ldyBNYXAodGhpcy5fYnlLZXkpO1xuICAgICAgICBjbG9uZS5fc2NoZW1hQ2hhaW4gPSB0aGlzLl9zY2hlbWFDaGFpbjtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBpZiAoc291cmNlLl9zY2hlbWFDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHZhbHVlXSBvZiBzb3VyY2UuX2J5SWQuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzb3VyY2UuX2J5S2V5LmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yayhwYXRoLCBhZGp1c3Rlciwgcm9vdCkge1xuXG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fY29sbGVjdChwYXRoKTtcbiAgICAgICAgY2hhaW4ucHVzaCh7IHNjaGVtYTogcm9vdCB9KTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGNoYWluLnNoaWZ0KCk7XG4gICAgICAgIGxldCBhZGp1c3RlZCA9IHsgaWQ6IHRhaWwuaWQsIHNjaGVtYTogYWRqdXN0ZXIodGFpbC5zY2hlbWEpIH07XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShhZGp1c3RlZC5zY2hlbWEpLCAnYWRqdXN0ZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJldHVybiBhIGpvaSBzY2hlbWEgdHlwZScpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGFpbikge1xuICAgICAgICAgICAgYWRqdXN0ZWQgPSB7IGlkOiBub2RlLmlkLCBzY2hlbWE6IGludGVybmFscy5mb3JrKG5vZGUuc2NoZW1hLCBhZGp1c3RlZC5pZCwgYWRqdXN0ZWQuc2NoZW1hKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkanVzdGVkLnNjaGVtYTtcbiAgICB9XG5cbiAgICBsYWJlbHMocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGJlaGluZCA9IFsuLi5iZWhpbmQsIG5vZGUuc2NoZW1hLl9mbGFncy5sYWJlbCB8fCBjdXJyZW50XTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlaGluZC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5sYWJlbHMoZm9yd2FyZCwgYmVoaW5kKTtcbiAgICB9XG5cbiAgICByZWFjaChwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5yZWFjaChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc2NoZW1hLCB7IGtleSB9ID0ge30pIHtcblxuICAgICAgICBpZiAoIXNjaGVtYSB8fFxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuJF9wcm9wZXJ0eSgnc2NoZW1hQ2hhaW4nKSB8fFxuICAgICAgICAgICAgc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX2J5SWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghZXhpc3RpbmcgfHwgZXhpc3Rpbmcuc2NoZW1hID09PSBzY2hlbWEsICdDYW5ub3QgYWRkIGRpZmZlcmVudCBzY2hlbWFzIHdpdGggdGhlIHNhbWUgaWQ6JywgaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB7IHNjaGVtYSwgaWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhrZXkpLCAnU2NoZW1hIGFscmVhZHkgY29udGFpbnMga2V5OicsIGtleSk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHsgc2NoZW1hLCBpZDoga2V5IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2NvbGxlY3QocGF0aCwgYmVoaW5kID0gW10sIG5vZGVzID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBub2RlcyA9IFtub2RlLCAuLi5ub2Rlc107XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLl9jb2xsZWN0KGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgX2dldChpZCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ieUlkLmdldChpZCkgfHwgdGhpcy5fYnlLZXkuZ2V0KGlkKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mb3JrID0gZnVuY3Rpb24gKHNjaGVtYSwgaWQsIHJlcGxhY2VtZW50KSB7XG5cbiAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHsga2V5IH0pID0+IHtcblxuICAgICAgICBpZiAoaWQgPT09IChpdGVtLl9mbGFncy5pZCB8fCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb2JqID0gZXhwb3J0cy5zY2hlbWEoc2NoZW1hLCB7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgcmV0dXJuIG9iaiA/IG9iai4kX211dGF0ZVJlYnVpbGQoKSA6IHNjaGVtYTtcbn07XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICBsZXQgb2JqO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuX2ZsYWdzW25hbWVdLCB7IHNvdXJjZTogJ2ZsYWdzJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuX3J1bGVzW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihydWxlLmFyZ3MsIHsgc291cmNlOiAncnVsZXMnLCBuYW1lOiBydWxlLm5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBydWxlKTtcbiAgICAgICAgICAgIGNsb25lLmFyZ3MgPSByZXN1bHQ7XG4gICAgICAgICAgICBvYmouX3J1bGVzW2ldID0gY2xvbmU7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVW5pcXVlID0gb2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1VuaXF1ZSA9PT0gcnVsZSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLiRfdGVybXNbbmFtZV0sIHsgc291cmNlOiAndGVybXMnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnNjYW4gPSBmdW5jdGlvbiAoaXRlbSwgc291cmNlLCBvcHRpb25zLCBfcGF0aCwgX2tleSkge1xuXG4gICAgY29uc3QgcGF0aCA9IF9wYXRoIHx8IFtdO1xuXG4gICAgaWYgKGl0ZW0gPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbG9uZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gc291cmNlLnNvdXJjZSA9PT0gJ3Rlcm1zJyAmJiBzb3VyY2UubmFtZSA9PT0gJ2tleXMnICYmIGl0ZW1baV0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtpXSwgc291cmNlLCBvcHRpb25zLCBbaSwgLi4ucGF0aF0sIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IGl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWEgIT09IGZhbHNlICYmIENvbW1vbi5pc1NjaGVtYShpdGVtKSB8fFxuICAgICAgICBvcHRpb25zLnJlZiAhPT0gZmFsc2UgJiYgUmVmLmlzUmVmKGl0ZW0pKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9ucy5lYWNoKGl0ZW0sIHsgLi4uc291cmNlLCBwYXRoLCBrZXk6IF9rZXkgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtrZXldLCBzb3VyY2UsIG9wdGlvbnMsIFtrZXksIC4uLnBhdGhdLCBfa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgfTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdmFsdWU6IFN5bWJvbCgndmFsdWUnKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5TdGF0ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGFuY2VzdG9ycywgc3RhdGUpIHtcblxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmFuY2VzdG9ycyA9IGFuY2VzdG9yczsgICAgICAgICAgICAgICAgIC8vIFtwYXJlbnQsIC4uLiwgcm9vdF1cblxuICAgICAgICB0aGlzLm1haW5zdGF5ID0gc3RhdGUubWFpbnN0YXk7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXM7ICAgICAgICAgICAgICAgLy8gW2N1cnJlbnQsIC4uLiwgcm9vdF1cbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG51bGw7XG4gICAgfVxuXG4gICAgbG9jYWxpemUocGF0aCwgYW5jZXN0b3JzID0gbnVsbCwgc2NoZW1hID0gbnVsbCkge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZShwYXRoLCBhbmNlc3RvcnMsIHRoaXMpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgJiZcbiAgICAgICAgICAgIHN0YXRlLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcyA9IFtpbnRlcm5hbHMuc2NoZW1hcyhzY2hlbWEpLCAuLi5zdGF0ZS5zY2hlbWFzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBuZXN0KHNjaGVtYSwgZGVidWcpIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBpbnRlcm5hbHMuU3RhdGUodGhpcy5wYXRoLCB0aGlzLmFuY2VzdG9ycywgdGhpcyk7XG4gICAgICAgIHN0YXRlLnNjaGVtYXMgPSBzdGF0ZS5zY2hlbWFzICYmIFtpbnRlcm5hbHMuc2NoZW1hcyhzY2hlbWEpLCAuLi5zdGF0ZS5zY2hlbWFzXTtcbiAgICAgICAgc3RhdGUuZGVidWcgPSBkZWJ1ZztcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHNoYWRvdyh2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cgPSB0aGlzLm1haW5zdGF5LnNoYWRvdyB8fCBuZXcgaW50ZXJuYWxzLlNoYWRvdygpO1xuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdy5zZXQodGhpcy5wYXRoLCB2YWx1ZSwgcmVhc29uKTtcbiAgICB9XG5cbiAgICBzbmFwc2hvdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gQ2xvbmUodGhpcy5tYWluc3RheS5zaGFkb3cubm9kZSh0aGlzLnBhdGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuc25hcHNob3QoKTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cub3ZlcnJpZGUodGhpcy5wYXRoLCB0aGlzLl9zbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGNvbW1pdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1haW5zdGF5LmNvbW1pdCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYXMgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cblxuaW50ZXJuYWxzLlNoYWRvdyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc2V0KHBhdGgsIHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc3RvcmUgcm9vdCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gJ3N0cmlwJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHsgICAgICAgIC8vIENhbm5vdCBzdG9yZSBzdHJpcHBlZCBhcnJheSB2YWx1ZXMgKGR1ZSB0byBzaGlmdClcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdGhpcy5fdmFsdWVzIHx8IG5ldyBNYXAoKTtcblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5nZXQoc2VnbWVudCk7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0KHNlZ21lbnQsIG5leHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVbaW50ZXJuYWxzLnZhbHVlXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldChwYXRoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZShwYXRoKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW2ludGVybmFscy52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlKHBhdGgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWNoKHRoaXMuX3ZhbHVlcywgcGF0aCwgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUocGF0aCwgbm9kZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnRzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IG93biA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gUmVhY2godGhpcy5fdmFsdWVzLCBwYXJlbnRzLCB7IGl0ZXJhYmxlczogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnNldChvd24sIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZShvd24pO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsIG9mIG1haW5zdGF5LmV4dGVybmFscykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV4dGVybmFsLnN0YXRlLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBleHRlcm5hbC5zY2hlbWEudHlwZSA9PT0gJ2xpbmsnID8gbWFpbnN0YXkubGlua3MuZ2V0KGV4dGVybmFsLnNjaGVtYSkgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByb290O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHBhdGgubGVuZ3RoID8gW3Jvb3RdIDogW107XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHBhdGgubGVuZ3RoID8gUmVhY2godmFsdWUsIHBhdGgpIDogdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc2VnbWVudF07XG4gICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFuY2VzdG9yc1swXTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKGNvZGUsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGV4dGVybmFsLm1ldGhvZChub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXh0ZXJuYWwuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBsaW5rZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBleHRlcm5hbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZnMsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc0FycmF5OiBpbnRlcm5hbHMuZXJyb3JzQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCkgPT4gbWFpbnN0YXkud2FybmluZ3MucHVzaCgobGlua2VkIHx8IGV4dGVybmFsLnNjaGVtYSkuJF9jcmVhdGVFcnJvcihjb2RlLCBub2RlLCBsb2NhbCwgZXh0ZXJuYWwuc3RhdGUsIHNldHRpbmdzKSksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKCdleHRlcm5hbCcsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MsIHsgbWVzc2FnZXMgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IG5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLm91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgbm9kZSwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgcm9vdCwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArPSBgICgkeyhleHRlcm5hbC5sYWJlbCl9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IEVycm9ycy5wcm9jZXNzKGVycm9ycywgdmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKG1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3Mud2FybmluZ3MgJiZcbiAgICAgICAgIXNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICFzZXR0aW5ncy5hcnRpZmFjdHMpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSBtYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5NYWluc3RheSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHRyYWNlciwgZGVidWcsIGxpbmtzKSB7XG5cbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cyA9IFtdO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cy5wdXNoKHtcbiAgICAgICAgICAgIGV4dGVybmFsczogdGhpcy5leHRlcm5hbHMuc2xpY2UoKSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuX3NuYXBzaG90cy5wb3AoKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBzbmFwc2hvdC5leHRlcm5hbHM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBzbmFwc2hvdC53YXJuaW5ncztcbiAgICB9XG5cbiAgICBjb21taXQoKSB7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICAvLyBQcmVwYXJlIHN0YXRlXG5cbiAgICBjb25zdCB7IHRyYWNlciwgY2xlYW51cCB9ID0gaW50ZXJuYWxzLnRyYWNlcihzY2hlbWEsIHByZWZzKTtcbiAgICBjb25zdCBkZWJ1ZyA9IHByZWZzLmRlYnVnID8gW10gOiBudWxsO1xuICAgIGNvbnN0IGxpbmtzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gbmV3IE1hcCgpIDogbnVsbDtcbiAgICBjb25zdCBtYWluc3RheSA9IG5ldyBpbnRlcm5hbHMuTWFpbnN0YXkodHJhY2VyLCBkZWJ1ZywgbGlua3MpO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBbeyBzY2hlbWEgfV0gOiBudWxsO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKFtdLCBbXSwgeyBtYWluc3RheSwgc2NoZW1hcyB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHZhbHVlXG5cbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAvLyBQcm9jZXNzIHZhbHVlIGFuZCBlcnJvcnNcblxuICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgIHNjaGVtYS4kX3Jvb3QudW50cmFjZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUsIHByZWZzKTtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBlcnJvciwgbWFpbnN0YXkgfTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYWNlciA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC5fdHJhY2VyLl9yZWdpc3RlcihzY2hlbWEpIH07XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmRlYnVnKSB7XG4gICAgICAgIEFzc2VydChzY2hlbWEuJF9yb290LnRyYWNlLCAnRGVidWcgbW9kZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC50cmFjZSgpLl9yZWdpc3RlcihzY2hlbWEpLCBjbGVhbnVwOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhY2VyOiBpbnRlcm5hbHMuaWdub3JlIH07XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMgPSB7fSkge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHN0YXRlIGFuZCBzZXR0aW5nc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcHJlZnMgPSBpbnRlcm5hbHMucHJlZnMoc2NoZW1hLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9jYWNoZS5nZXQodmFsdWUpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICd2YWxpZGF0ZScsICdjYWNoZWQnLCAhIXJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBsb2NhbFN0YXRlIHx8IHN0YXRlLCBwcmVmcyk7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICBwcmVmcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yLFxuICAgICAgICBlcnJvcnNBcnJheTogaW50ZXJuYWxzLmVycm9yc0FycmF5LFxuICAgICAgICB3YXJuOiAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goY3JlYXRlRXJyb3IoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpKSxcbiAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2N1c3RvbScsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCB7IG1lc3NhZ2VzIH0pXG4gICAgfTtcblxuICAgIC8vIFByZXBhcmVcblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5lbnRyeShzY2hlbWEsIHN0YXRlKTtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmLnByZXBhcmUgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBkZWYucHJlcGFyZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncHJlcGFyZScsIHZhbHVlLCBwcmVwYXJlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShwcmVwYXJlZC52YWx1ZSwgW10uY29uY2F0KHByZXBhcmVkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgIC8vIFByZXBhcmUgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBjb2VyY2lvblxuXG4gICAgaWYgKGRlZi5jb2VyY2UgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0ICYmXG4gICAgICAgICghZGVmLmNvZXJjZS5mcm9tIHx8IGRlZi5jb2VyY2UuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSkge1xuXG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBkZWYuY29lcmNlLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjb2VyY2VkJywgdmFsdWUsIGNvZXJjZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShjb2VyY2VkLnZhbHVlLCBbXS5jb25jYXQoY29lcmNlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAgIC8vIENvZXJjZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHZhbHVlXG5cbiAgICBjb25zdCBlbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgaWYgKGVtcHR5ICYmXG4gICAgICAgIGVtcHR5LiRfbWF0Y2goaW50ZXJuYWxzLnRyaW0odmFsdWUsIHNjaGVtYSksIHN0YXRlLm5lc3QoZW1wdHkpLCBDb21tb24uZGVmYXVsdHMpKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZW1wdHknLCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUHJlc2VuY2UgcmVxdWlyZW1lbnRzIChyZXF1aXJlZCwgb3B0aW9uYWwsIGZvcmJpZGRlbilcblxuICAgIGNvbnN0IHByZXNlbmNlID0gb3ZlcnJpZGVzLnByZXNlbmNlIHx8IHNjaGVtYS5fZmxhZ3MucHJlc2VuY2UgfHwgKHNjaGVtYS5fZmxhZ3MuX2VuZGVkU3dpdGNoID8gbnVsbCA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIHJldFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgc2NoZW1hLCBzdGF0ZSwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIEFydGlmYWN0c1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5hcnRpZmFjdCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzID0gc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuaGFzKHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuc2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5nZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkucHVzaChzdGF0ZS5wYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIGhlbHBlcnNdIDogW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoYGFueS4ke2ZsYWd9YCwgbnVsbCwgeyBlcnJvcjogZXJyIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpdGVyYWw7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsb25lKHNvdXJjZSk7XG59O1xuXG5cbmludGVybmFscy50cmltID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgIGlmICghdHJpbSB8fFxuICAgICAgICAhdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbn07XG5cblxuaW50ZXJuYWxzLmlnbm9yZSA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBJZ25vcmUsXG4gICAgZW50cnk6IElnbm9yZSxcbiAgICBmaWx0ZXI6IElnbm9yZSxcbiAgICBsb2c6IElnbm9yZSxcbiAgICByZXNvbHZlOiBJZ25vcmUsXG4gICAgdmFsdWU6IElnbm9yZVxufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnNbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlZhbHVlcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcywgcmVmcykge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgIHRoaXMuX2xvd2VyY2FzZSA9IGludGVybmFscy5sb3dlcmNhc2VzKHZhbHVlcyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuc2l6ZSArIHRoaXMuX3JlZnMuc2l6ZTtcbiAgICB9XG5cbiAgICBhZGQodmFsdWUsIHJlZnMpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVmcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZnMpIHsgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwcGVkIGluIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUsIG51bGwsIG51bGwsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHJlbW92ZSkge1xuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgaW50ZXJuYWxzLlZhbHVlcygpO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnNvdXJjZS5fdmFsdWVzLCAuLi5zb3VyY2UuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4ucmVtb3ZlLl92YWx1ZXMsIC4uLnJlbW92ZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiBudWxsO1xuICAgIH1cblxuICAgIHJlbW92ZSh2YWx1ZSkge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVmcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICB0aGlzLl92YWx1ZXMuZGVsZXRlKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLmRlbGV0ZSh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhcyh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBtYXRjaFxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9sb3dlcmNhc2UuZ2V0KHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3JlZnMuc2l6ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXMuX3JlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgaW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSAhcmVmLmluIHx8IHR5cGVvZiByZXNvbHZlZCAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBbcmVzb2x2ZWRdXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShyZXNvbHZlZCkgPyByZXNvbHZlZCA6IE9iamVjdC5rZXlzKHJlc29sdmVkKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZW5zaXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvdmVycmlkZSgpIHtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5kaXNwbGF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyh0aGlzLl92YWx1ZXMsIHRoaXMuX3JlZnMpO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydCghc291cmNlLl9vdmVycmlkZSwgJ0Nhbm5vdCBjb25jYXQgb3ZlcnJpZGUgc2V0IG9mIHZhbHVlcycpO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKFsuLi50aGlzLl92YWx1ZXMsIC4uLnNvdXJjZS5fdmFsdWVzXSwgWy4uLnRoaXMuX3JlZnMsIC4uLnNvdXJjZS5fcmVmc10pO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHsgb3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3ZhbHVlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB7IHZhbHVlIH0gOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3JlZnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZS5kZXNjcmliZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudmFsdWVzXSA9IHRydWU7XG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5zbGljZSA9IGludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLmNsb25lO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmxvd2VyY2FzZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBNb2RpZnkgPSByZXF1aXJlKCcuL21vZGlmeScpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi90cmFjZScpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkJhc2UgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG5cbiAgICAgICAgLy8gTmFtaW5nOiBwdWJsaWMsIF9wcml2YXRlLCAkX2V4dGVuc2lvbiwgJF9tdXRhdGV7YWN0aW9ufVxuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgdGhpcy4kX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0ge307XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfVxuXG4gICAgX3Jlc2V0KCkge1xuXG4gICAgICAgIHRoaXMuX2lkcyA9IG5ldyBNb2RpZnkuSWRzKCk7XG4gICAgICAgIHRoaXMuX3ByZWZlcmVuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBSZWYuTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdmFsaWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW52YWxpZHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ZsYWdzID0ge307XG4gICAgICAgIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIHRoaXMuX3NpbmdsZVJ1bGVzID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgLy8gVGhlIHJ1bGUgb3B0aW9ucyBwYXNzZWQgZm9yIG5vbi1tdWx0aSBydWxlc1xuXG4gICAgICAgIHRoaXMuJF90ZXJtcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzaCBvZiBhcnJheXMgb2YgaW1tdXRhYmxlIG9iamVjdHMgKGV4dGVuZGVkIGJ5IG90aGVyIHR5cGVzKVxuXG4gICAgICAgIHRoaXMuJF90ZW1wID0geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBzdGF0ZSAobm90IGNsb25lZClcbiAgICAgICAgICAgIHJ1bGVzZXQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsOiB1c2UgbGFzdCwgZmFsc2U6IGVycm9yLCBudW1iZXI6IHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICB3aGVuczoge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBjYWNoZSBvZiBnZW5lcmF0ZWQgd2hlbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5kZXNjcmliZSA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmRlc2NyaWJlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBhbGxvdyguLi52YWx1ZXMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICdhbGxvdycpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKHZhbHVlcywgJ192YWxpZHMnKTtcbiAgICB9XG5cbiAgICBhbHRlcih0YXJnZXRzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhcmdldHMgJiYgdHlwZW9mIHRhcmdldHMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRhcmdldHMpLCAnSW52YWxpZCB0YXJnZXRzIGFyZ3VtZW50Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGFsdGVyYXRpb25zIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zID0gb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVyID0gdGFyZ2V0c1t0YXJnZXRdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBhZGp1c3RlciA9PT0gJ2Z1bmN0aW9uJywgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucy5wdXNoKHsgdGFyZ2V0LCBhZGp1c3RlciB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGFydGlmYWN0KGlkKSB7XG5cbiAgICAgICAgQXNzZXJ0KGlkICE9PSB1bmRlZmluZWQsICdBcnRpZmFjdCBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgc2V0IGFuIGFydGlmYWN0IHdpdGggYSBydWxlIGNhY2hlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdhcnRpZmFjdCcsIGlkKTtcbiAgICB9XG5cbiAgICBjYXN0KHRvKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRvID09PSBmYWxzZSB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnLCAnSW52YWxpZCB0byB2YWx1ZScpO1xuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHRoaXMuX2RlZmluaXRpb24uY2FzdFt0b10sICdUeXBlJywgdGhpcy50eXBlLCAnZG9lcyBub3Qgc3VwcG9ydCBjYXN0aW5nIHRvJywgdG8pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnY2FzdCcsIHRvID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0KHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQoJ2RlZmF1bHQnLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZGVzY3JpcHRpb24oZGVzYykge1xuXG4gICAgICAgIEFzc2VydChkZXNjICYmIHR5cGVvZiBkZXNjID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdkZXNjcmlwdGlvbicsIGRlc2MpO1xuICAgIH1cblxuICAgIGVtcHR5KHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IG9iai4kX2NvbXBpbGUoc2NoZW1hLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdlbXB0eScsIHNjaGVtYSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgZXJyb3IoZXJyKSB7XG5cbiAgICAgICAgQXNzZXJ0KGVyciwgJ01pc3NpbmcgZXJyb3InKTtcbiAgICAgICAgQXNzZXJ0KGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicsICdNdXN0IHByb3ZpZGUgYSB2YWxpZCBFcnJvciBvYmplY3Qgb3IgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZXJyb3InLCBlcnIpO1xuICAgIH1cblxuICAgIGV4YW1wbGUoZXhhbXBsZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KGV4YW1wbGUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcgZXhhbXBsZScpO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ292ZXJyaWRlJ10pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignZXhhbXBsZXMnLCBleGFtcGxlLCB7IHNpbmdsZTogdHJ1ZSwgb3ZlcnJpZGU6IG9wdGlvbnMub3ZlcnJpZGUgfSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwobWV0aG9kLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgQXNzZXJ0KCFkZXNjcmlwdGlvbiwgJ0Nhbm5vdCBjb21iaW5lIG9wdGlvbnMgd2l0aCBkZXNjcmlwdGlvbicpO1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBtZXRob2QuZGVzY3JpcHRpb247XG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2QubWV0aG9kO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignZXh0ZXJuYWxzJywgeyBtZXRob2QsIGRlc2NyaXB0aW9uIH0sIHsgc2luZ2xlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZhaWxvdmVyKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQoJ2ZhaWxvdmVyJywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvcmJpZGRlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnZm9yYmlkZGVuJyk7XG4gICAgfVxuXG4gICAgaWQoaWQpIHtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2lkJywgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgaWQgPT09ICdzdHJpbmcnLCAnaWQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KC9eW15cXC5dKyQvLnRlc3QoaWQpLCAnaWQgY2Fubm90IGNvbnRhaW4gcGVyaW9kIGNoYXJhY3RlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCBpZCk7XG4gICAgfVxuXG4gICAgaW52YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKHZhbHVlcywgJ19pbnZhbGlkcycpO1xuICAgIH1cblxuICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdMYWJlbCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdsYWJlbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIG1ldGEobWV0YSkge1xuXG4gICAgICAgIEFzc2VydChtZXRhICE9PSB1bmRlZmluZWQsICdNZXRhIGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ21ldGFzJywgbWV0YSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgbm90ZSguLi5ub3Rlcykge1xuXG4gICAgICAgIEFzc2VydChub3Rlcy5sZW5ndGgsICdNaXNzaW5nIG5vdGVzJyk7XG4gICAgICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xuICAgICAgICAgICAgQXNzZXJ0KG5vdGUgJiYgdHlwZW9mIG5vdGUgPT09ICdzdHJpbmcnLCAnTm90ZXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdub3RlcycsIG5vdGVzKTtcbiAgICB9XG5cbiAgICBvbmx5KG1vZGUgPSB0cnVlKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RlID09PSAnYm9vbGVhbicsICdJbnZhbGlkIG1vZGU6JywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdvbmx5JywgbW9kZSk7XG4gICAgfVxuXG4gICAgb3B0aW9uYWwoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ29wdGlvbmFsJyk7XG4gICAgfVxuXG4gICAgcHJlZnMocHJlZnMpIHtcblxuICAgICAgICBBc3NlcnQocHJlZnMsICdNaXNzaW5nIHByZWZlcmVuY2VzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5jb250ZXh0ID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgY29udGV4dCcpO1xuICAgICAgICBBc3NlcnQocHJlZnMuZXh0ZXJuYWxzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZXh0ZXJuYWxzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzJyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5kZWJ1ZyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGRlYnVnJyk7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCBwcmVmcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcHJlc2VuY2UobW9kZSkge1xuXG4gICAgICAgIEFzc2VydChbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLmluY2x1ZGVzKG1vZGUpLCAnVW5rbm93biBwcmVzZW5jZSBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdwcmVzZW5jZScsIG1vZGUpO1xuICAgIH1cblxuICAgIHJhdyhlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgZW5hYmxlZCA/ICdyYXcnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXN1bHQobW9kZSkge1xuXG4gICAgICAgIEFzc2VydChbJ3JhdycsICdzdHJpcCddLmluY2x1ZGVzKG1vZGUpLCAnVW5rbm93biByZXN1bHQgbW9kZScsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmVxdWlyZWQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ3JlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgc3RyaWN0KGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3QgY29udmVydCA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogIWVuYWJsZWQ7XG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgeyBjb252ZXJ0IH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0cmlwKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3N0cmlwJyA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdGFnKC4uLnRhZ3MpIHtcblxuICAgICAgICBBc3NlcnQodGFncy5sZW5ndGgsICdNaXNzaW5nIHRhZ3MnKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgQXNzZXJ0KHRhZyAmJiB0eXBlb2YgdGFnID09PSAnc3RyaW5nJywgJ1RhZ3MgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCd0YWdzJywgdGFncyk7XG4gICAgfVxuXG4gICAgdW5pdChuYW1lKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnVW5pdCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bml0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAndmFsaWQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmFsbG93KC4uLnZhbHVlcyk7XG4gICAgICAgIG9iai4kX3NldEZsYWcoJ29ubHknLCAhIW9iai5fdmFsaWRzLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB3aGVuKGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2hlbiA9IENvbXBpbGUud2hlbihvYmosIGNvbmRpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghWydhbnknLCAnbGluayddLmluY2x1ZGVzKG9iai50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFpdGVtLnRoZW4gfHwgaXRlbS50aGVuLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0udGhlbi50eXBlID09PSBvYmoudHlwZSwgJ0Nhbm5vdCBjb21iaW5lJywgb2JqLnR5cGUsICd3aXRoJywgaXRlbS50aGVuICYmIGl0ZW0udGhlbi50eXBlKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0ub3RoZXJ3aXNlIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLm90aGVyd2lzZSAmJiBpdGVtLm90aGVyd2lzZS50eXBlKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVybXMud2hlbnMucHVzaCh3aGVuKTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjYWNoZShjYWNoZSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGNhY2hpbmcgaW5zaWRlIGEgcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2NhY2hlLCAnQ2Fubm90IG92ZXJyaWRlIHNjaGVtYSBjYWNoZScpO1xuICAgICAgICBBc3NlcnQodGhpcy5fZmxhZ3MuYXJ0aWZhY3QgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWNoZSBhIHJ1bGUgd2l0aCBhbiBhcnRpZmFjdCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9jYWNoZSA9IGNhY2hlIHx8IENhY2hlLnByb3ZpZGVyLnByb3Zpc2lvbigpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob2JqKTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzb3VyY2UpLCAnSW52YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSAnYW55JyB8fCBzb3VyY2UudHlwZSA9PT0gdGhpcy50eXBlLCAnQ2Fubm90IG1lcmdlIHR5cGUnLCB0aGlzLnR5cGUsICd3aXRoIGFub3RoZXIgdHlwZTonLCBzb3VyY2UudHlwZSk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgb250byBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgYSBzY2hlbWEgd2l0aCBvcGVuIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdhbnknICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSAhPT0gJ2FueScpIHtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIG9iaiB0byBtYXRjaCBzb3VyY2UgdHlwZVxuXG4gICAgICAgICAgICBjb25zdCB0bXBPYmogPSBzb3VyY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wT2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iaiA9IHRtcE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5faWRzLmNvbmNhdChzb3VyY2UuX2lkcyk7XG4gICAgICAgIG9iai5fcmVmcy5yZWdpc3Rlcihzb3VyY2UsIFJlZi50b1NpYmxpbmcpO1xuXG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBvYmouX3ByZWZlcmVuY2VzID8gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHNvdXJjZS5fcHJlZmVyZW5jZXMpIDogc291cmNlLl9wcmVmZXJlbmNlcztcbiAgICAgICAgb2JqLl92YWxpZHMgPSBWYWx1ZXMubWVyZ2Uob2JqLl92YWxpZHMsIHNvdXJjZS5fdmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzKTtcbiAgICAgICAgb2JqLl9pbnZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX2ludmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzLCBzb3VyY2UuX3ZhbGlkcyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuaXF1ZSBydWxlcyBwcmVzZW50IGluIHNvdXJjZVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3VyY2UuX3NpbmdsZVJ1bGVzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKG9iai5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9ydWxlcyA9IG9iai5fcnVsZXMuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC5rZWVwIHx8IHRhcmdldC5uYW1lICE9PSBuYW1lKTtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHNvdXJjZS5fcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlLl9kZWZpbml0aW9uLnJ1bGVzW3Rlc3QubWV0aG9kXS5tdWx0aSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHRlc3QubmFtZSwgdGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXMucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKG9iai5fZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgIHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcblxuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IG9iai5fZmxhZ3MuZW1wdHkuY29uY2F0KHNvdXJjZS5fZmxhZ3MuZW1wdHkpO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2UuX2ZsYWdzLmVtcHR5KSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gc291cmNlLl9mbGFncy5lbXB0eTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLl9mbGFncyk7XG4gICAgICAgICAgICBkZWxldGUgZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlLiRfdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gc291cmNlLiRfdGVybXNba2V5XTtcbiAgICAgICAgICAgIGlmICghdGVybXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IHRlcm1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IG9iai4kX3Rlcm1zW2tleV0uY29uY2F0KHRlcm1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNpbmdcblxuICAgICAgICBpZiAodGhpcy4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICAgICAgdGhpcy4kX3Jvb3QuX3RyYWNlci5fY29tYmluZShvYmosIFt0aGlzLCBzb3VyY2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlYnVpbGRcblxuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIGV4dGVuZChvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLmJhc2UsICdDYW5ub3QgZXh0ZW5kIHR5cGUgd2l0aCBhbm90aGVyIGJhc2UnKTtcblxuICAgICAgICByZXR1cm4gRXh0ZW5kLnR5cGUodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZXh0cmFjdChwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgIGZvcmsocGF0aHMsIGFkanVzdGVyKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBmb3JrIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIFtdLmNvbmNhdChwYXRocykpIHtcbiAgICAgICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5faWRzLmZvcmsocGF0aCwgYWRqdXN0ZXIsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBydWxlKG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBPYmplY3Qua2V5cyhkZWYubW9kaWZpZXJzKSk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlLCAnQ2Fubm90IGFwcGx5IHJ1bGVzIHRvIGVtcHR5IHJ1bGVzZXQgb3IgdGhlIGxhc3QgcnVsZSBhZGRlZCBkb2VzIG5vdCBzdXBwb3J0IHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuJF90ZW1wLnJ1bGVzZXQgPT09IG51bGwgPyB0aGlzLl9ydWxlcy5sZW5ndGggLSAxIDogdGhpcy4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgQXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLl9ydWxlcy5sZW5ndGgsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBvYmouX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBjb25zdCBydWxlID0gQ2xvbmUob3JpZ2luYWwpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGRlZi5tb2RpZmllcnNbbmFtZV0ocnVsZSwgb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUubmFtZSA9PT0gb3JpZ2luYWwubmFtZSwgJ0Nhbm5vdCBjaGFuZ2UgcnVsZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKSA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJ1bGVzZXQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzdGFydCBhIG5ldyBydWxlc2V0IHdpdGhvdXQgY2xvc2luZyB0aGUgcHJldmlvdXMgb25lJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBvYmouX3J1bGVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBnZXQgJCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlc2V0O1xuICAgIH1cblxuICAgIHRhaWxvcih0YXJnZXRzKSB7XG5cbiAgICAgICAgdGFyZ2V0cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHRhaWxvciBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgICAgIGlmICh0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdGhpcy4kX3Rlcm1zLmFsdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBhZGp1c3RlcihvYmopO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKG9iaiksICdBbHRlcmF0aW9uIGFkanVzdGVyIGZvcicsIHRhcmdldCwgJ2ZhaWxlZCB0byByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqLiRfbW9kaWZ5KHsgZWFjaDogKGl0ZW0pID0+IGl0ZW0udGFpbG9yKHRhcmdldHMpLCByZWY6IGZhbHNlIH0pO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICB0cmFjZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIFRyYWNlLmxvY2F0aW9uID8gVHJhY2UubG9jYXRpb24odGhpcykgOiB0aGlzOyAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnkodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlQXN5bmModmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmVudHJ5QXN5bmModmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEV4dGVuc2lvbnNcblxuICAgICRfYWRkUnVsZShvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHJ1bGVcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubmFtZSAmJiB0eXBlb2Ygb3B0aW9ucy5uYW1lID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcnVsZSBuYW1lJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgQXNzZXJ0KGtleVswXSAhPT0gJ18nLCAnQ2Fubm90IHNldCBwcml2YXRlIHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcnVsZSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcnVsZS5fcmVzb2x2ZSA9IFtdO1xuICAgICAgICBydWxlLm1ldGhvZCA9IHJ1bGUubWV0aG9kIHx8IHJ1bGUubmFtZTtcblxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm1ldGhvZF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBydWxlLmFyZ3M7XG5cbiAgICAgICAgQXNzZXJ0KGRlZmluaXRpb24sICdVbmtub3duIHJ1bGUnLCBydWxlLm1ldGhvZCk7XG5cbiAgICAgICAgLy8gQXJnc1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gMSB8fCBPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IHRoaXMuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5uYW1lXS5hcmdzLmxlbmd0aCwgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIHRoaXMudHlwZSwgcnVsZS5uYW1lKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5hcmdzQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5yZWYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5pc1Jlc29sdmFibGUoYXJnKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLl9yZXNvbHZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gcmVzb2x2ZXIubm9ybWFsaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIuYXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBDb21tb24udmFsaWRhdGVBcmcoYXJnLCBrZXksIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIWVycm9yLCBlcnJvciwgJ29yIHJlZmVyZW5jZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuaXF1ZSBydWxlc1xuXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5tdWx0aSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlUmVtb3ZlKHJ1bGUubmFtZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai4kX3RlbXAucnVsZXNldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5wcmlvcml0eSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy51bnNoaWZ0KHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX2NvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuc2NoZW1hKHRoaXMuJF9yb290LCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgICRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBzdGF0ZSwgcHJlZnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5mbGFncyAhPT0gZmFsc2UgPyB0aGlzLl9mbGFncyA6IHt9O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXMgPyBNZXNzYWdlcy5tZXJnZSh0aGlzLl9kZWZpbml0aW9uLm1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzKSA6IHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXM7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JzLlJlcG9ydChjb2RlLCB2YWx1ZSwgbG9jYWwsIGZsYWdzLCBtZXNzYWdlcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAkX2dldEZsYWcobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFnc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX2dldFJ1bGUobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVSdWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgJF9tYXBMYWJlbHMocGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5sYWJlbHMocGF0aCk7XG4gICAgfVxuXG4gICAgJF9tYXRjaCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMpIHtcblxuICAgICAgICBwcmVmcyA9IE9iamVjdC5hc3NpZ24oe30sIHByZWZzKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcHJlZnMuYWJvcnRFYXJseSA9IHRydWU7XG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgPSBmYWxzZTtcblxuICAgICAgICBzdGF0ZS5zbmFwc2hvdCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAhVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykuZXJyb3JzO1xuICAgICAgICBzdGF0ZS5yZXN0b3JlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAkX21vZGlmeShvcHRpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydlYWNoJywgJ29uY2UnLCAncmVmJywgJ3NjaGVtYSddKTtcbiAgICAgICAgcmV0dXJuIE1vZGlmeS5zY2hlbWEodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlYnVpbGQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBhZGQgdGhpcyBydWxlIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2lkcy5yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBzb3VyY2UsIG5hbWUsIHBhdGgsIGtleSB9KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZhbWlseSA9IHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXSAmJiB0aGlzLl9kZWZpbml0aW9uW3NvdXJjZV1bbmFtZV0ucmVnaXN0ZXI7XG4gICAgICAgICAgICBpZiAoZmFtaWx5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9tdXRhdGVSZWdpc3RlcihpdGVtLCB7IGZhbWlseSwga2V5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJF9tb2RpZnkoeyBlYWNoIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLnJlYnVpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEsIHsgZmFtaWx5LCBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy5fcmVmcy5yZWdpc3RlcihzY2hlbWEsIGZhbWlseSk7XG4gICAgICAgIHRoaXMuX2lkcy5yZWdpc3RlcihzY2hlbWEsIHsga2V5IH0pO1xuICAgIH1cblxuICAgICRfcHJvcGVydHkobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uLnByb3BlcnRpZXNbbmFtZV07XG4gICAgfVxuXG4gICAgJF9yZWFjaChwYXRoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5yZWFjaChwYXRoKTtcbiAgICB9XG5cbiAgICAkX3Jvb3RSZWZlcmVuY2VzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZzLnJvb3RzKCk7XG4gICAgfVxuXG4gICAgJF9zZXRGbGFnKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQobmFtZVswXSA9PT0gJ18nIHx8ICF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgZmxhZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuX2RlZmluaXRpb24uZmxhZ3NbbmFtZV0gfHwge307XG4gICAgICAgIGlmIChEZWVwRXF1YWwodmFsdWUsIGZsYWcuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgdGhpcy5fZmxhZ3NbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9iai5fZmxhZ3NbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgJF9wYXJlbnQobWV0aG9kLCAuLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXVtDb21tb24uc3ltYm9scy5wYXJlbnRdLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfVxuXG4gICAgJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSwgdGhpcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbHNcblxuICAgIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICAgICAgdGFyZ2V0LnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgdGFyZ2V0LiRfcm9vdCA9IHRoaXMuJF9yb290O1xuXG4gICAgICAgIHRhcmdldC4kX3RlbXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfdGVtcCk7XG4gICAgICAgIHRhcmdldC4kX3RlbXAud2hlbnMgPSB7fTtcblxuICAgICAgICB0YXJnZXQuX2lkcyA9IHRoaXMuX2lkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3ByZWZlcmVuY2VzID0gdGhpcy5fcHJlZmVyZW5jZXM7XG4gICAgICAgIHRhcmdldC5fdmFsaWRzID0gdGhpcy5fdmFsaWRzICYmIHRoaXMuX3ZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX2ludmFsaWRzID0gdGhpcy5faW52YWxpZHMgJiYgdGhpcy5faW52YWxpZHMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9ydWxlcyA9IHRoaXMuX3J1bGVzLnNsaWNlKCk7XG4gICAgICAgIHRhcmdldC5fc2luZ2xlUnVsZXMgPSBDbG9uZSh0aGlzLl9zaW5nbGVSdWxlcywgeyBzaGFsbG93OiB0cnVlIH0pO1xuICAgICAgICB0YXJnZXQuX3JlZnMgPSB0aGlzLl9yZWZzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mbGFncyk7XG4gICAgICAgIHRhcmdldC5fY2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHRhcmdldC4kX3Rlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJF90ZXJtcykge1xuICAgICAgICAgICAgdGFyZ2V0LiRfdGVybXNba2V5XSA9IHRoaXMuJF90ZXJtc1trZXldID8gdGhpcy4kX3Rlcm1zW2tleV0uc2xpY2UoKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgICAgIHRhcmdldC4kX3N1cGVyID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgaW4gdGhpcy4kX3N1cGVyKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF9zdXBlcltvdmVycmlkZV0gPSB0aGlzLl9zdXBlcltvdmVycmlkZV0uYmluZCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBfYmFyZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fcmVzZXQoKTtcblxuICAgICAgICBjb25zdCB0ZXJtcyA9IG9iai5fZGVmaW5pdGlvbi50ZXJtcztcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRlcm1zKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gdGVybXNbbmFtZV07XG4gICAgICAgICAgICBvYmouJF90ZXJtc1tuYW1lXSA9IHRlcm0uaW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgX2RlZmF1bHQoZmxhZywgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsICdsaXRlcmFsJyk7XG5cbiAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nJywgZmxhZywgJ3ZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgIW9wdGlvbnMubGl0ZXJhbCwgJ09ubHkgZnVuY3Rpb24gdmFsdWUgc3VwcG9ydHMgbGl0ZXJhbCBvcHRpb24nKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRpb25zLmxpdGVyYWwpIHtcblxuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpdGVyYWw6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3NldEZsYWcoZmxhZywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdCBtYXRjaGluZyB3aGVuc1xuXG4gICAgICAgIGNvbnN0IHdoZW5zID0gW107XG4gICAgICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuJF90ZXJtcy53aGVucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgd2hlbiA9IHRoaXMuJF90ZXJtcy53aGVuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHdoZW4uY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgd2hlbnMucHVzaCh3aGVuLmNvbmNhdCk7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7aX0uY29uY2F0YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gd2hlbi5yZWYgPyB3aGVuLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGlkcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3RzW2pdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUlkID0gYCR7aX0ke3doZW4uc3dpdGNoID8gJy4nICsgaiA6ICcnfWA7XG4gICAgICAgICAgICAgICAgaWYgKGlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2Jhc2VJZH0uaXNgKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0udGhlbmBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWE6IGdlbmVyYXRlZCwgaWQgfSA9IHRoZW4uX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtiYXNlSWR9LnRoZW4ke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlcndpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBgJHtiYXNlSWR9Lm90aGVyd2lzZWBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gb3RoZXJ3aXNlLl9nZW5lcmF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0ub3RoZXJ3aXNlJHtpZCA/IGAoJHtpZH0pYCA6ICcnfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3aGVuLmJyZWFrICYmXG4gICAgICAgICAgICAgICAgaWRzLmxlbmd0aCA+IGJlZm9yZSkgeyAgICAgICAgICAvLyBTb21ldGhpbmcgbWF0Y2hlZFxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjYWNoZVxuXG4gICAgICAgIGNvbnN0IGlkID0gaWRzLmpvaW4oJywgJyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCAnd2hlbicsIGlkKTtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHRoaXMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkudHJhY2VyLmFjdGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy4kX3RlbXAud2hlbnNbaWRdKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcy4kX3RlbXAud2hlbnNbaWRdLCBpZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgZHluYW1pYyBzY2hlbWFcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSkge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSh0aGlzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IHdoZW5zXG5cbiAgICAgICAgZm9yIChjb25zdCB3aGVuIG9mIHdoZW5zKSB7XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KHdoZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIC4uLndoZW5zXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0gPSBvYmo7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogb2JqLCBpZCB9O1xuICAgIH1cblxuICAgIF9pbm5lcih0eXBlLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksIGBDYW5ub3Qgc2V0ICR7dHlwZX0gaW5zaWRlIGEgcnVsZXNldGApO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKCFvYmouJF90ZXJtc1t0eXBlXSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5vdmVycmlkZSkge1xuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2luZ2xlKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfaW5SdWxlc2V0KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBudWxsICYmIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIF9ydWxlUmVtb3ZlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBvYmouX3J1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRlc3QubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICF0ZXN0LmtlZXApIHtcblxuICAgICAgICAgICAgICAgIGlmIChvYmouX2luUnVsZXNldCgpICYmXG4gICAgICAgICAgICAgICAgICAgIGkgPCBvYmouJF90ZW1wLnJ1bGVzZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAtLW9iai4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fcnVsZXMgPSBmaWx0ZXJlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfdmFsdWVzKHZhbHVlcywga2V5KSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCBrZXkuc2xpY2UoMSwgLTEpKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSB2YWx1ZXNbMF0gPT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0gJiZcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgb2JqW2tleV0gPSBuZXcgVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVzLmxlbmd0aCA/IG5ldyBWYWx1ZXMoKSA6IG51bGw7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9ialtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBvYmpba2V5XS5vdmVycmlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgYWxsb3cvdmFsaWQvaW52YWxpZCB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSBDb21tb24uc3ltYm9scy5vdmVycmlkZSwgJ092ZXJyaWRlIG11c3QgYmUgdGhlIGZpcnN0IHZhbHVlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga2V5ID09PSAnX2ludmFsaWRzJyA/ICdfdmFsaWRzJyA6ICdfaW52YWxpZHMnO1xuICAgICAgICAgICAgaWYgKG9ialtvdGhlcl0pIHtcbiAgICAgICAgICAgICAgICBvYmpbb3RoZXJdLnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmpbb3RoZXJdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5ID09PSAnX3ZhbGlkcycgfHwgIW9iai5fZmxhZ3Mub25seSwgJ1NldHRpbmcgaW52YWxpZCB2YWx1ZScsIHZhbHVlLCAnbGVhdmVzIHNjaGVtYSByZWplY3RpbmcgYWxsIHZhbHVlcyBkdWUgdG8gcHJldmlvdXMgdmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgICAgICBvYmpbb3RoZXJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ialtrZXldLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMuYW55XSA9IHtcbiAgICB2ZXJzaW9uOiBDb21tb24udmVyc2lvbixcbiAgICBjb21waWxlOiBDb21waWxlLmNvbXBpbGUsXG4gICAgcm9vdDogJyRfcm9vdCdcbn07XG5cblxuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgSG9layBmcm9tIGRlZXAgY2xvbmluZyBzY2hlbWEgb2JqZWN0cyAobXVzdCBiZSBvbiBwcm90b3R5cGUpXG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGVueSA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5pbnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmRpc2FsbG93ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXF1YWwgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUudmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXhpc3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucmVxdWlyZWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUubm90ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUub3B0aW9ucyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmZXJlbmNlcyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQmFzZSgpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhbnknLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBvbmx5OiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBhbHRlcmF0aW9uczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGV4YW1wbGVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgbWV0YXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgbm90ZXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgc2hhcmVkOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgdGFnczogeyBpbml0OiBbXSB9LFxuICAgICAgICB3aGVuczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjdXN0b20nLCBhcmdzOiB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBtZXRob2QgfSkge1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FueS5jdXN0b20nLCB7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbWV0aG9kJywgJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICBtZXRob2QobWVzc2FnZXMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZzKHsgbWVzc2FnZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcmVkOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkgJiYgc2NoZW1hLl9mbGFncy5pZCwgJ1NjaGVtYSBtdXN0IGJlIGEgc2NoZW1hIHdpdGggYW4gaWQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQgPSBvYmouJF90ZXJtcy5zaGFyZWQgfHwgW107XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuc2hhcmVkLnB1c2goc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGNvZGUsIGxvY2FsKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoY29kZSAmJiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHdhcm5pbmcgY29kZScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3dhcm5pbmcnLCBhcmdzOiB7IGNvZGUsIGxvY2FsIH0sIHdhcm46IHRydWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29kZSwgbG9jYWwgfSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoY29kZSwgbG9jYWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29kZScsICdsb2NhbCddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb2RpZmllcnM6IHtcblxuICAgICAgICBrZWVwKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUua2VlcCA9IGVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZShydWxlLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUubWVzc2FnZSA9IE1lc3NhZ2VzLmNvbXBpbGUobWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybihydWxlLCBlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBydWxlLndhcm4gPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXNjW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoWydleGFtcGxlcycsICdleHRlcm5hbHMnLCAnbWV0YXMnLCAnbm90ZXMnLCAndGFncyddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtrZXkuc2xpY2UoMCwgLTEpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnYWx0ZXJhdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsdGVyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlclt0YXJnZXRdID0gYWRqdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouYWx0ZXIoYWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnd2hlbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgaXMsIG5vdCwgdGhlbiwgb3RoZXJ3aXNlLCBjb25jYXQgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmNhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQoY29uY2F0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKHJlZiwgeyBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIHN3aXRjaDogdmFsdWUuc3dpdGNoLCBicmVhazogdmFsdWUuYnJlYWsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoud2hlbihpcywgeyB0aGVuLCBvdGhlcndpc2UsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouc2hhcmVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYW55LmN1c3RvbSc6ICd7eyNsYWJlbH19IGZhaWxlZCBjdXN0b20gdmFsaWRhdGlvbiBiZWNhdXNlIHt7I2Vycm9yLm1lc3NhZ2V9fScsXG4gICAgICAgICdhbnkuZGVmYXVsdCc6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBkZWZhdWx0IG1ldGhvZCcsXG4gICAgICAgICdhbnkuZmFpbG92ZXInOiAne3sjbGFiZWx9fSB0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZmFpbG92ZXIgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5pbnZhbGlkJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgICdhbnkub25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUge2lmKCN2YWxpZHMubGVuZ3RoID09IDEsIFwiXCIsIFwib25lIG9mIFwiKX17eyN2YWxpZHN9fScsXG4gICAgICAgICdhbnkucmVmJzogJ3t7I2xhYmVsfX0ge3sjYXJnfX0gcmVmZXJlbmNlcyB7ezojcmVmfX0gd2hpY2gge3sjcmVhc29ufX0nLFxuICAgICAgICAnYW55LnJlcXVpcmVkJzogJ3t7I2xhYmVsfX0gaXMgcmVxdWlyZWQnLFxuICAgICAgICAnYW55LnVua25vd24nOiAne3sjbGFiZWx9fSBpcyBub3QgYWxsb3dlZCdcbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FsdGVybmF0aXZlcycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG1hdGNoOiB7IGRlZmF1bHQ6ICdhbnknIH0gICAgICAgICAgICAgICAgIC8vICdhbnknLCAnb25lJywgJ2FsbCdcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXRjaGVzOiB7IGluaXQ6IFtdLCByZWdpc3RlcjogUmVmLnRvU2libGluZyB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCAuLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHJ5KC4uLnNjaGVtYXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hcyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAgICAgLy8gTWF0Y2ggYWxsIG9yIG9uZVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLm5lc3QoaXRlbS5zY2hlbWEsIGBtYXRjaC4ke2l9YCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuJF92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZC5wdXNoKHJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGZhaWxlZC5tYXAoKGYpID0+IEVycm9ycy5kZXRhaWxzKGYsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYW55JywgY29udGV4dCkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggb25lXG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoID09PSAnb25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkLmxlbmd0aCA9PT0gMSA/IHsgdmFsdWU6IG1hdGNoZWRbMF0gfSA6IHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLm9uZScpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIGFsbFxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGggIT09IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbGwnLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc0FueU9iaiA9IChhbHRlcm5hdGl2ZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdGVybmF0aXZlLiRfdGVybXMubWF0Y2hlcy5zb21lKCh2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodi5zY2hlbWEudHlwZSA9PT0gJ2FsdGVybmF0aXZlcycgJiYgaXNBbnlPYmoodi5zY2hlbWEpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBpc0FueU9iaihzY2hlbWEpID8geyB2YWx1ZTogbWF0Y2hlZC5yZWR1Y2UoKGFjYywgdikgPT4gTWVyZ2UoYWNjLCB2LCB7IG1lcmdlQXJyYXlzOiBmYWxzZSB9KSkgfSA6IHsgdmFsdWU6IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggYW55XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFRyeVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBzY2hlbWE6IGl0ZW0uc2NoZW1hLCByZXBvcnRzOiByZXN1bHQuZXJyb3JzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25kaXRpb25hbFxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGl0ZW0ucmVmID8gaXRlbS5yZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGVzdHMgPSBpdGVtLmlzID8gW2l0ZW1dIDogaXRlbS5zd2l0Y2g7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpcywgdGhlbiwgb3RoZXJ3aXNlIH0gPSB0ZXN0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBgbWF0Y2guJHtpfSR7aXRlbS5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2lkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyd2lzZS4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KG90aGVyd2lzZSwgYCR7aWR9Lm90aGVyd2lzZWApLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbi4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KHRoZW4sIGAke2lkfS50aGVuYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9ycyhlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbmRpdGlvbmFsOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MubWF0Y2gsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgdGhpcy5fZmxhZ3MubWF0Y2gsICd3aXRoIGNvbmRpdGlvbmFsIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBicmVhayBvcHRpb24gd2l0aCBhbHRlcm5hdGl2ZXMgY29uZGl0aW9uYWwnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gbWF0Y2guaXMgPyBbbWF0Y2hdIDogbWF0Y2guc3dpdGNoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX3NldEZsYWcoJ19lbmRlZFN3aXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgIG1ldGhvZChtb2RlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydhbnknLCAnb25lJywgJ2FsbCddLmluY2x1ZGVzKG1vZGUpLCAnSW52YWxpZCBhbHRlcm5hdGl2ZXMgbWF0Y2ggbW9kZScsIG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgdGhpcy4kX3Rlcm1zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChtYXRjaC5zY2hlbWEsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgbW9kZSwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbWF0Y2gnLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cnk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hcy5sZW5ndGgsICdNaXNzaW5nIGFsdGVybmF0aXZlIHNjaGVtYXMnKTtcbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAndHJ5Jyk7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWF0Y2hlcy5wdXNoKHsgc2NoZW1hOiBvYmouJF9jb21waWxlKHNjaGVtYSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9wYXJlbnQoJ2xhYmVsJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wYXRoWzBdICE9PSAnaXMnICYmIHR5cGVvZiBpdGVtLl9mbGFncy5sYWJlbCAhPT0gJ3N0cmluZycgPyBpdGVtLmxhYmVsKG5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iai4kX21vZGlmeSh7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICAvLyBGbGFnIHdoZW4gYW4gYWx0ZXJuYXRpdmUgdHlwZSBpcyBhbiBhcnJheVxuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGl0ZW0pICYmXG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSAnYXJyYXknKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEuJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNjaGVtYS4kX21vZGlmeSh7IGVhY2ggfSk7XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UgfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ5KHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwocmVmLCB7IGlzLCB0aGVuLCBub3QsIG90aGVyd2lzZSwgc3dpdGNoOiBtYXRjaC5zd2l0Y2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwoaXMsIHsgdGhlbiwgb3RoZXJ3aXNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYWxsJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYWxsIG9mIHRoZSByZXF1aXJlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYW55JzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5tYXRjaCc6ICd7eyNsYWJlbH19IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMub25lJzogJ3t7I2xhYmVsfX0gbWF0Y2hlcyBtb3JlIHRoYW4gb25lIGFsbG93ZWQgdHlwZScsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMudHlwZXMnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9uZSBvZiB7eyN0eXBlc319J1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmVycm9ycyA9IGZ1bmN0aW9uIChmYWlsdXJlcywgeyBlcnJvciwgc3RhdGUgfSkge1xuXG4gICAgLy8gTm90aGluZyBtYXRjaGVkIGR1ZSB0byB0eXBlIGNyaXRlcmlhIHJ1bGVzXG5cbiAgICBpZiAoIWZhaWx1cmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYW55JykgfTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgZXJyb3JcblxuICAgIGlmIChmYWlsdXJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBmYWlsdXJlc1swXS5yZXBvcnRzIH07XG4gICAgfVxuXG4gICAgLy8gQW5hbHl6ZSByZWFzb25zXG5cbiAgICBjb25zdCB2YWxpZHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgY29tcGxleCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCB7IHJlcG9ydHMsIHNjaGVtYSB9IG9mIGZhaWx1cmVzKSB7XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgZXJyb3JzICghYWJvcnRFYXJseSlcblxuICAgICAgICBpZiAocmVwb3J0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnVubWF0Y2hlZChmYWlsdXJlcywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3VzdG9tIGVycm9yXG5cbiAgICAgICAgY29uc3QgcmVwb3J0ID0gcmVwb3J0c1swXTtcbiAgICAgICAgaWYgKHJlcG9ydCBpbnN0YW5jZW9mIEVycm9ycy5SZXBvcnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnVubWF0Y2hlZChmYWlsdXJlcywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJuYWwgb2JqZWN0IG9yIGFycmF5IGVycm9yXG5cbiAgICAgICAgaWYgKHJlcG9ydC5zdGF0ZS5wYXRoLmxlbmd0aCAhPT0gc3RhdGUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBsZXgucHVzaCh7IHR5cGU6IHNjaGVtYS50eXBlLCByZXBvcnQgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkc1xuXG4gICAgICAgIGlmIChyZXBvcnQuY29kZSA9PT0gJ2FueS5vbmx5Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZCBvZiByZXBvcnQubG9jYWwudmFsaWRzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRzLmFkZCh2YWxpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFzZSB0eXBlXG5cbiAgICAgICAgY29uc3QgW3R5cGUsIGNvZGVdID0gcmVwb3J0LmNvZGUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNvZGUgIT09ICdiYXNlJykge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRzLmFkZCh0eXBlKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgZXJyb3JzIGFyZSBiYXNlIHR5cGVzIG9yIHZhbGlkc1xuXG4gICAgaWYgKCFjb21wbGV4Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMudHlwZXMnLCB7IHR5cGVzOiBbLi4udmFsaWRzXSB9KSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb21wbGV4IGVycm9yXG5cbiAgICBpZiAoY29tcGxleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBjb21wbGV4WzBdLnJlcG9ydCB9O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG59O1xuXG5cbmludGVybmFscy51bm1hdGNoZWQgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGVycm9yKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZmFpbHVyZS5yZXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMubWF0Y2gnLCBFcnJvcnMuZGV0YWlscyhlcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKSB9O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhcnJheScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNpbmdsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICBzcGFyc2U6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGl0ZW1zOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcbiAgICAgICAgb3JkZXJlZDogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG5cbiAgICAgICAgX2V4Y2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX2luY2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX3JlcXVpcmVkczogeyBpbml0OiBbXSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnb2JqZWN0JyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHNjaGVtYS4kX2dldFJ1bGUoJ3NvcnQnKTtcbiAgICAgICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIHNvcnQuYXJncy5vcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHNpbmdsZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhcnJheS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfZ2V0UnVsZSgnaXRlbXMnKSAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKSB9OyAgICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5IHNvIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGhhczoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGFzJywgYXJnczogeyBzY2hlbWEgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIHByZWZzLCBlcnJvciB9LCB7IHNjaGVtYTogaGFzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIGFuY2VzdG9ycywgaGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcy4kX21hdGNoKHZhbHVlW2ldLCBsb2NhbFN0YXRlLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MYWJlbCA9IGhhcy5fZmxhZ3MubGFiZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5MYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc0tub3duJywgeyBwYXR0ZXJuTGFiZWwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNVbmtub3duJywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLml0ZW1zLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMsIGVycm9yc0FycmF5IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdXNpb25zID0gWy4uLnNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLCAuLi5yZXF1aXJlZHNdO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQXJyYXkgPSAhdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBlcnJvcnNBcnJheSgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlsID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB3YXNBcnJheSA/IGkgOiBuZXcgTnVtYmVyKGkpOyAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdXNpb24gb2Ygc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhjbHVzaW9uLiRfbWF0Y2goaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBleGNsdXNpb24pLCBwcmVmcywgeyBwcmVzZW5jZTogJ2lnbm9yZScgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmV4Y2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXJlZFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG9yZGVyZWQuJF92YWxpZGF0ZShpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuJF90ZXJtcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkub3JkZXJlZExlbmd0aCcsIHsgcG9zOiBpLCBsaW1pdDogc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGggfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gTm8gcmVhc29uIHRvIGNvbnRpbnVlIHNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB2YWxpZGF0ZSBvdGhlciB0aGFuIGFycmF5Lm9yZGVyZWRMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQ2hlY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBqbCA9IHJlcXVpcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgcmVxdWlyZWRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcmVxdWlyZWRzW2pdLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDaGVja3Nbal0gPSByZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UocmVxdWlyZWRzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gJiYgISFwcmVmcy5zdHJpcFVua25vd24uYXJyYXlzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGpsID0gaW5jbHVzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5jbHVzaW9uIG9mIGluY2x1c2lvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcmUtcnVubmluZyByZXF1aXJlZHMgdGhhdCBhbHJlYWR5IGRpZG4ndCBtYXRjaCBpbiB0aGUgcHJldmlvdXMgbG9vcFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGVjayA9IHJlcXVpcmVkcy5pbmRleE9mKGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDaGVjayAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1twcmV2aW91c0NoZWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gaW5jbHVzaW9uLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgZXJyb3IgaWYgb25seSBvbmUgaW5jbHVzaW9uIGRlZmluZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLmxlbmd0aCB8fCBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1ZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5pbmNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsRGVmYXVsdChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICBtYW5pZmVzdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhcnJheS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnb3JkZXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBvYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5vcmRlcmVkLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF2YWx1ZSB8fCAhdGhpcy5fZmxhZ3MuX2FycmF5SXRlbXMsICdDYW5ub3Qgc3BlY2lmeSBzaW5nbGUgcnVsZSB3aGVuIGFycmF5IGhhcyBhcnJheSBpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzaW5nbGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29ydDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieScsICdvcmRlciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogb3B0aW9ucy5vcmRlciB8fCAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ieSA9IENvbXBpbGUucmVmKG9wdGlvbnMuYnksIHsgYW5jZXN0b3I6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0dGluZ3MuYnkuYW5jZXN0b3IsICdDYW5ub3Qgc29ydCBieSBhbmNlc3RvcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzb3J0JywgYXJnczogeyBvcHRpb25zOiBzZXR0aW5ncyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYSB9LCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogc29ydGVkLCBlcnJvcnMgfSA9IGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIG9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSBzb3J0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuc29ydCcsIHsgb3JkZXI6IG9wdGlvbnMub3JkZXIsIGJ5OiBvcHRpb25zLmJ5ID8gb3B0aW9ucy5ieS5rZXkgOiAndmFsdWUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzcGFyc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3BhcnNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB2YWx1ZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdzcGFyc2UnLCB2YWx1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pcXVlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29tcGFyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIWNvbXBhcmF0b3IgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnLCAnY29tcGFyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lnbm9yZVVuZGVmaW5lZCcsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0geyBuYW1lOiAndW5pcXVlJywgYXJnczogeyBvcHRpb25zLCBjb21wYXJhdG9yIH0gfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5wYXRoID0gc2VwYXJhdG9yID8gY29tcGFyYXRvci5zcGxpdChzZXBhcmF0b3IpIDogW2NvbXBhcmF0b3JdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgZXJyb3IsIHNjaGVtYSB9LCB7IGNvbXBhcmF0b3I6IHJhdywgb3B0aW9ucyB9LCB7IGNvbXBhcmF0b3IsIHBhdGggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJpZ2ludDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBjb21wYXJhdG9yIHx8IERlZXBFcXVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhdGggPyBSZWFjaCh2YWx1ZVtpXSwgcGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZWNvcmRzLCAnRmFpbGVkIHRvIGZpbmQgdW5pcXVlIG1hcCBjb250YWluZXIgZm9yIHR5cGUnLCB0eXBlb2YgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbXBhcmF0b3InLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHNldDoge1xuICAgICAgICAgICAgZnJvbTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLml0ZW1zKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMub3JkZXJlZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouaXRlbXMoLi4uZGVzYy5pdGVtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoub3JkZXJlZCguLi5kZXNjLm9yZGVyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhcnJheS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICAgICdhcnJheS5leGNsdWRlcyc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgJ2FycmF5Lmhhc0tub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgezojcGF0dGVybkxhYmVsfScsXG4gICAgICAgICdhcnJheS5oYXNVbmtub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2gnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0gYW5kIHt7I3Vua25vd25NaXNzZXN9fSBvdGhlciByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319JyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sjdW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5vcmRlcmVkTGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IG1vc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5zb3J0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBzb3J0ZWQgaW4geyNvcmRlcn0gb3JkZXIgYnkge3sjYnl9fScsXG4gICAgICAgICdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gbWlzbWF0Y2hpbmcgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuc29ydC51bnN1cHBvcnRlZCc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIHVuc3VwcG9ydGVkIHR5cGUgeyN0eXBlfScsXG4gICAgICAgICdhcnJheS5zcGFyc2UnOiAne3sjbGFiZWx9fSBtdXN0IG5vdCBiZSBhIHNwYXJzZSBhcnJheSBpdGVtJyxcbiAgICAgICAgJ2FycmF5LnVuaXF1ZSc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCByZXF1aXJlZCBvZiByZXF1aXJlZHMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZC5fZmxhZ3MubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgdmFsdWUsIHsga25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB2YWx1ZSwgeyB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcmVkIG9mIG9yZGVyZWRzKSB7XG4gICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsRGVmYXVsdCA9IGZ1bmN0aW9uIChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gICAgbGV0IHRyYWlsaW5nVW5kZWZpbmVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSBvcmRlcmVkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHNbaV07XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvcmRlcmVkLiRfdmFsaWRhdGUodW5kZWZpbmVkLCBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcykudmFsdWU7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFpbGluZ1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3ZlcnJpZGVzLnVuc2hpZnQob3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIGlmIChvdmVycmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlLnB1c2goLi4ub3ZlcnJpZGVzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ2FycmF5JyB8fFxuICAgICAgICB0eXBlLl9mbGFncy5fYXJyYXlJdGVtcykge1xuXG4gICAgICAgIEFzc2VydCghb2JqLl9mbGFncy5zaW5nbGUsICdDYW5ub3Qgc3BlY2lmeSBhcnJheSBpdGVtIHdpdGggc2luZ2xlIHJ1bGUgZW5hYmxlZCcpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc2V0dGluZ3MsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3JkZXIgPSBzZXR0aW5ncy5vcmRlciA9PT0gJ2FzY2VuZGluZycgPyAxIDogLTE7XG4gICAgY29uc3QgYUZpcnN0ID0gLTEgKiBvcmRlcjtcbiAgICBjb25zdCBiRmlyc3QgPSBvcmRlcjtcblxuICAgIGNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgICAgIGxldCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnkpIHtcbiAgICAgICAgICAgIGEgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGEsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBiID0gc2V0dGluZ3MuYnkucmVzb2x2ZShiLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJywgdmFsdWUsIHsgdHlwZSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgLSBiKSAqIG9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKS5zb3J0KHNvcnQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnIgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIGFGaXJzdCwgYkZpcnN0KSB7XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgIH1cblxuICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0Jvb2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdib29sZWFuJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRydXRoeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZSh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplZCA9PT0gJ3RydWUnID8gdHJ1ZSA6IChub3JtYWxpemVkID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2NoZW1hLiRfdGVybXMudHJ1dGh5ICYmIHNjaGVtYS4kX3Rlcm1zLnRydXRoeS5oYXModmFsdWUsIG51bGwsIG51bGwsICFzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICAoc2NoZW1hLiRfdGVybXMuZmFsc3kgJiYgc2NoZW1hLiRfdGVybXMuZmFsc3kuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYm9vbGVhbi5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi52YWx1ZXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ3RydXRoeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnRydXRoeSA9IG9iai4kX3Rlcm1zLnRydXRoeSB8fCBuZXcgVmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIHRydXRoeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZhbHN5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICdmYWxzeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmZhbHN5ID0gb2JqLiRfdGVybXMuZmFsc3kgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBmYWxzeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnc2Vuc2l0aXZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzQm9vbCxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnRydXRoeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnV0aHkoLi4uZGVzYy50cnV0aHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mYWxzeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5mYWxzeSguLi5kZXNjLmZhbHN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYm9vbGVhbi5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZGF0ZScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydudW1iZXInLCAnc3RyaW5nJ10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaW50ZXJuYWxzLnBhcnNlKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmZvcm1hdCkgfHwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLl9mbGFncy5mb3JtYXQ7XG5cbiAgICAgICAgaWYgKCFwcmVmcy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAhZm9ybWF0IHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2RhdGUuZm9ybWF0JywgeyBmb3JtYXQgfSkgfTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGF0ZSB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gZGF0ZSA9PT0gJ25vdycgPyBEYXRlLm5vdygpIDogZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmdldFRpbWUoKSwgdG8sIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2RhdGUuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MuZGF0ZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZTogKGRhdGUpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPT09ICdub3cnID8gZGF0ZSA6IGludGVybmFscy5wYXJzZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiAoZGF0ZSkgPT4gZGF0ZSAhPT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgaGF2ZSBhIHZhbGlkIGRhdGUgZm9ybWF0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtYXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpLCAnVW5rbm93biBkYXRlIGZvcm1hdCcsIGZvcm1hdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Zvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzbzoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KCdpc28nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdqYXZhc2NyaXB0Jykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXModHlwZSksICdcInR5cGVcIiBtdXN0IGJlIG9uZSBvZiBcImphdmFzY3JpcHQsIHVuaXhcIicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNEYXRlLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCB7IHByZWZzIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2RhdGUuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiB7bXNnKFwiZGF0ZS5mb3JtYXQuXCIgKyAjZm9ybWF0KSB8fCAjZm9ybWF0fSBmb3JtYXQnLFxuICAgICAgICAnZGF0ZS5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5sZXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG4gICAgICAgICdkYXRlLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7OiNsaW1pdH19JyxcblxuICAgICAgICAvLyBNZXNzYWdlcyB1c2VkIGluIGRhdGUuZm9ybWF0XG5cbiAgICAgICAgJ2RhdGUuZm9ybWF0Lmlzbyc6ICdJU08gODYwMSBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LmphdmFzY3JpcHQnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQudW5peCc6ICd0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIHNlY29uZHMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJU09cblxuICAgIGlmIChmb3JtYXQgPT09ICdpc28nKSB7XG4gICAgICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBudW1iZXIgc3RyaW5nXG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaW1lc3RhbXBcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMSAqIHZhbHVlKTsgICAgICAgIC8vIENhc3RpbmcgdG8gbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAndW5peCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSgxMDAwICogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhaW5cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KCFzb3VyY2UgfHwgc291cmNlID09PSB0cnVlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgdHJ1ZSwgZmFsc3kgb3IgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9uczogbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBzb3VyY2UsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyhkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMpO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBNZXJnZShjb3B5LCBzb3VyY2UsIHsgbnVsbE92ZXJyaWRlLCBtZXJnZUFycmF5czogZmFsc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5zaGFsbG93O1xuICAgIEFzc2VydChBcnJheS5pc0FycmF5KGtleXMpLCAnSW52YWxpZCBrZXlzJyk7XG5cbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1lcmdlID0gc291cmNlID09PSB0cnVlID8gbnVsbCA6IG5ldyBTZXQoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGtleSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpOyAgICAgICAgICAgIC8vIFByZS1zcGxpdCBvcHRpbWl6YXRpb25cblxuICAgICAgICBjb25zdCByZWYgPSBSZWFjaChkZWZhdWx0cywga2V5KTtcbiAgICAgICAgaWYgKHJlZiAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlZiA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgc2Vlbi5zZXQocmVmLCBtZXJnZSAmJiBSZWFjaChzb3VyY2UsIGtleSkgfHwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgbWVyZ2UuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMsIHt9LCBzZWVuKTtcblxuICAgIGlmICghbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgbWVyZ2UpIHtcbiAgICAgICAgaW50ZXJuYWxzLnJlYWNoQ29weShjb3B5LCBzb3VyY2UsIGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVsbE92ZXJyaWRlID0gb3B0aW9ucy5udWxsT3ZlcnJpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVsbE92ZXJyaWRlIDogZmFsc2U7XG4gICAgcmV0dXJuIE1lcmdlKGNvcHksIHNvdXJjZSwgeyBudWxsT3ZlcnJpZGUsIG1lcmdlQXJyYXlzOiBmYWxzZSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYWNoQ29weSA9IGZ1bmN0aW9uIChkc3QsIHNyYywgcGF0aCkge1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKCEoc2VnbWVudCBpbiBzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWwgPSBzcmNbc2VnbWVudF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3JjID0gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gc3JjO1xuICAgIGxldCByZWYgPSBkc3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZbc2VnbWVudF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZWZbc2VnbWVudF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHJlZltzZWdtZW50XTtcbiAgICB9XG5cbiAgICByZWZbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuU29ydGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIGFkZChub2Rlcywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHJ1bGVzXG5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gW10uY29uY2F0KG9wdGlvbnMuYmVmb3JlIHx8IFtdKTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBbXS5jb25jYXQob3B0aW9ucy5hZnRlciB8fCBbXSk7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gb3B0aW9ucy5ncm91cCB8fCAnPyc7XG4gICAgICAgIGNvbnN0IHNvcnQgPSBvcHRpb25zLnNvcnQgfHwgMDsgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBmb3IgbWVyZ2luZyBvbmx5XG5cbiAgICAgICAgQXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgaXRzZWxmOiAke2dyb3VwfWApO1xuICAgICAgICBBc3NlcnQoIWJlZm9yZS5pbmNsdWRlcygnPycpLCAnSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBhZnRlciBpdHNlbGY6ICR7Z3JvdXB9YCk7XG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgIHNlcTogdGhpcy5faXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgZXZlbnRcblxuICAgICAgICBpZiAoIW9wdGlvbnMubWFudWFsKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgICAgIEFzc2VydCh2YWxpZCwgJ2l0ZW0nLCBncm91cCAhPT0gJz8nID8gYGFkZGVkIGludG8gZ3JvdXAgJHtncm91cH1gIDogJycsICdjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBtZXJnZShvdGhlcnMpIHtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3RoZXJzKSkge1xuICAgICAgICAgICAgb3RoZXJzID0gW290aGVyc107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG90aGVyLl9pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKTsgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgaXRlbXNcblxuICAgICAgICB0aGlzLl9pdGVtcy5zb3J0KGludGVybmFscy5tZXJnZVNvcnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tpXS5zZXEgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zb3J0KCk7XG4gICAgICAgIEFzc2VydCh2YWxpZCwgJ21lcmdlIGNyZWF0ZWQgYSBkZXBlbmRlbmNpZXMgZXJyb3InKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBzb3J0KCkge1xuXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc29ydCgpO1xuICAgICAgICBBc3NlcnQodmFsaWQsICdzb3J0IGNyZWF0ZWQgYSBkZXBlbmRlbmNpZXMgZXJyb3InKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG5cbiAgICBfc29ydCgpIHtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgZ3JhcGhcblxuICAgICAgICBjb25zdCBncmFwaCA9IHt9O1xuICAgICAgICBjb25zdCBncmFwaEFmdGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ICAgICAgICAgICAgLy8gQSBwcm90b3R5cGUgY2FuIGJ1bmdsZSBsb29rdXBzIHcvIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgICBjb25zdCBncm91cHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgY29uc3Qgc2VxID0gaXRlbS5zZXE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pcXVlIGFjcm9zcyBhbGwgaXRlbXNcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gaXRlbS5ncm91cDtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIEdyb3Vwc1xuXG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChzZXEpO1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBpbnRlcm1lZGlhcnkgZ3JhcGggdXNpbmcgJ2JlZm9yZSdcblxuICAgICAgICAgICAgZ3JhcGhbc2VxXSA9IGl0ZW0uYmVmb3JlO1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBzZWNvbmQgaW50ZXJtZWRpYXJ5IGdyYXBoIHdpdGggJ2FmdGVyJ1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFmdGVyIG9mIGl0ZW0uYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcl0gPSBncmFwaEFmdGVyc1thZnRlcl0gfHwgW107XG4gICAgICAgICAgICAgICAgZ3JhcGhBZnRlcnNbYWZ0ZXJdLnB1c2goc2VxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGFuZCBpbnRlcm1lZGlhcnkgZ3JhcGhcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ3JhcGhOb2RlSXRlbSBpbiBncmFwaFtub2RlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JhcGhbbm9kZV1bZ3JhcGhOb2RlSXRlbV07XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRHcm91cHMucHVzaCguLi5ncm91cHNbZ3JvdXBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JhcGhbbm9kZV0gPSBleHBhbmRlZEdyb3VwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lcmdlIGludGVybWVkaWFyeSBncmFwaCB1c2luZyBncmFwaEFmdGVycyBpbnRvIGZpbmFsIGdyYXBoXG5cbiAgICAgICAgZm9yIChjb25zdCBncm91cCBpbiBncmFwaEFmdGVycykge1xuICAgICAgICAgICAgaWYgKGdyb3Vwc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JvdXBzW2dyb3VwXSkge1xuICAgICAgICAgICAgICAgICAgICBncmFwaFtub2RlXS5wdXNoKC4uLmdyYXBoQWZ0ZXJzW2dyb3VwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmNlc3RvcnNcblxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIGluIGdyYXBoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoW25vZGVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0gPSBhbmNlc3RvcnNbY2hpbGRdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvcG8gc29ydFxuXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgY29uc3Qgc29ydGVkID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraSkgeyAgICAgICAgICAvLyBMb29waW5nIHRocm91Z2ggaXRlbS5zZXEgdmFsdWVzIG91dCBvZiBvcmRlclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraikgeyAgLy8gQXMgYWJvdmUsIHRoZXNlIGFyZSBpdGVtLnNlcSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbal0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNlc3RvcnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tqXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2VlQ291bnQgPSBhbmNlc3RvcnNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaG91bGRTZWVDb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFthbmNlc3RvcnNbal1ba11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzZWVuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbkNvdW50ID09PSBzaG91bGRTZWVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW25leHRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoICE9PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlcUluZGV4ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgc2VxSW5kZXhbaXRlbS5zZXFdID0gaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNvcnRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkSXRlbSA9IHNlcUluZGV4W3ZhbHVlXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChzb3J0ZWRJdGVtLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChzb3J0ZWRJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm1lcmdlU29ydCA9IChhLCBiKSA9PiB7XG5cbiAgICByZXR1cm4gYS5zb3J0ID09PSBiLnNvcnQgPyAwIDogKGEuc29ydCA8IGIuc29ydCA/IC0xIDogMSk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXBwbHlUb0RlZmF1bHRzID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzJyk7XG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFRvcG8gPSByZXF1aXJlKCdAaGFwaS90b3BvJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZW5hbWVEZWZhdWx0czoge1xuICAgICAgICBhbGlhczogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb2xkIHZhbHVlIGluIHBsYWNlXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSwgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVuYW1pbmcgbXVsdGlwbGUga2V5cyBpbnRvIHRoZSBzYW1lIHRhcmdldFxuICAgICAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnX2tleXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIHR5cGVvZjogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bmtub3duOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBrZXlzOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiB7IG1hcHBlZDogeyBmcm9tOiAnc2NoZW1hJywgdG86ICdrZXknIH0gfSB9LFxuICAgICAgICBwYXR0ZXJuczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIHJlbmFtZXM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCBrZXlzKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5rZXlzKGtleXMpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignb2JqZWN0LmJhc2UnLCB7IHR5cGU6IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB9KSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdGVzdFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhbGxvdyBjbG9uZSB2YWx1ZVxuXG4gICAgICAgIHZhbHVlID0gaW50ZXJuYWxzLmNsb25lKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIFJlbmFtZSBrZXlzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMucmVuYW1lKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcywgZXJyb3JzKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbnl0aGluZyBhbGxvd2VkXG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZWQga2V5c1xuXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBrZXldLCBhbmNlc3RvcnMsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGlsZC5zY2hlbWEuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnNjaGVtYS5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVua25vd24ga2V5c1xuXG4gICAgICAgIGlmICh1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2ZsYWdzLl9oYXNQYXR0ZXJuTWF0Y2gpIHtcblxuICAgICAgICAgICAgY29uc3QgZWFybHkgPSBpbnRlcm5hbHMudW5rbm93bihzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKGVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhcmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGVwZW5kZW5jaWVzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkZXAua2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpKGRlcC5rZXkucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IGludGVybmFscy5kZXBlbmRlbmNpZXNbZGVwLnJlbF0oc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoZmFpbGVkLmNvZGUsIHZhbHVlLCBmYWlsZWQuY29udGV4dCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICdhbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NlcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgICAgIGlmICghVGVtcGxhdGUuaXNUZW1wbGF0ZShzdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gQ29tcGlsZS5yZWYoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsICdNZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXNzZXJ0JywgYXJnczogeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHByZWZzLCBzdGF0ZSB9LCB7IHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhYm91dCA9IHN1YmplY3QucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gUmVmLmlzUmVmKHN1YmplY3QpID8gc3ViamVjdC5hYnNvbHV0ZShzdGF0ZSkgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfbWF0Y2goYWJvdXQsIHN0YXRlLmxvY2FsaXplKHBhdGgsIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSwgc2NoZW1hKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ29iamVjdC5hc3NlcnQnLCB7IHN1YmplY3QsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydzdWJqZWN0JywgJ3NjaGVtYScsICdtZXNzYWdlJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uc3RydWN0b3IsIG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicsICdjb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaW5zdGFuY2UnLCBhcmdzOiB7IGNvbnN0cnVjdG9yLCBuYW1lIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29uc3RydWN0b3IsIG5hbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuaW5zdGFuY2UnLCB7IHR5cGU6IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29uc3RydWN0b3InLCAnbmFtZSddXG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCAnT2JqZWN0IHNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFsbFxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoKSB7ICAgICAgICAgICAgIC8vIEFsbG93IG5vbmVcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG9iai4kX3Rlcm1zLmtleXMgPyBvYmouJF90ZXJtcy5rZXlzLmZpbHRlcigoY2hpbGQpID0+ICFzY2hlbWEuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkgOiBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gb2JqLiRfdGVybXMua2V5cy5wdXNoKHsga2V5LCBzY2hlbWE6IHRoaXMuJF9jb21waWxlKHNjaGVtYVtrZXldKSB9KSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ25hbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnb3InKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3hvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVnRXhwID0gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLiRfY29tcGlsZShwYXR0ZXJuLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydmYWxsdGhyb3VnaCcsICdtYXRjaGVzJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnBhdHRlcm5zID0gb2JqLiRfdGVybXMucGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0geyBbaXNSZWdFeHAgPyAncmVnZXgnIDogJ3NjaGVtYSddOiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gdGhpcy4kX2NvbXBpbGUob3B0aW9ucy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXRjaGVzLnR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gY29uZmlnLm1hdGNoZXMuJF9yb290LmFycmF5KCkuaXRlbXMoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9zZXRGbGFnKCdfaGFzUGF0dGVybk1hdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZhbGx0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdyZWYnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QucmVmVHlwZScsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVnZXgnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZ2V4JywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5hbWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmcm9tLCB0bywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnIHx8IGZyb20gaW5zdGFuY2VvZiBSZWdFeHAsICdSZW5hbWUgbWlzc2luZyB0aGUgZnJvbSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8IHRvIGluc3RhbmNlb2YgVGVtcGxhdGUsICdJbnZhbGlkIHJlbmFtZSB0byBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0byAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUga2V5IHRvIHNhbWUgbmFtZTonLCBmcm9tKTtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxpYXMnLCAnaWdub3JlVW5kZWZpbmVkJywgJ292ZXJyaWRlJywgJ211bHRpcGxlJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcyA9IG9iai4kX3Rlcm1zLnJlbmFtZXMgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZW5hbWUgb2Ygb2JqLiRfdGVybXMucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVuYW1lLmZyb20gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIHRoZSBzYW1lIGtleSBtdWx0aXBsZSB0aW1lcycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHRvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZW5hbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogQXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5yZW5hbWVEZWZhdWx0cywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdhbnknKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2NoZW1hJywgYXJnczogeyB0eXBlIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgdHlwZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ2FueScgfHwgdmFsdWUudHlwZSA9PT0gdHlwZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5zY2hlbWEnLCB7IHR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5rbm93bjoge1xuICAgICAgICAgICAgbWV0aG9kKGFsbG93KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Vua25vd24nLCBhbGxvdyAhPT0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGhvdXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aG91dCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHhvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAneG9yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBkZWZhdWx0KHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9wYXJlbnQoJ2RlZmF1bHQnLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvLlNvcnRlcigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRvcG8uYWRkKGNoaWxkLCB7IGFmdGVyOiBjaGlsZC5zY2hlbWEuJF9yb290UmVmZXJlbmNlcygpLCBncm91cDogY2hpbGQua2V5IH0pLCBjaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5rZXlzID0gbmV3IGludGVybmFscy5LZXlzKC4uLnRvcG8ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmtleXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoua2V5cyhkZXNjLmtleXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVsLCBrZXkgPSBudWxsLCBwZWVycywgb3B0aW9ucyB9IG9mIGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGludGVybmFscy5kZXBlbmRlbmN5KG9iaiwgcmVsLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZ2V4LCBzY2hlbWEsIHJ1bGUsIGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0gb2YgZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucGF0dGVybihyZWdleCB8fCBzY2hlbWEsIHJ1bGUsIHsgZmFsbHRocm91Z2gsIG1hdGNoZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGZyb20sIHRvLCBvcHRpb25zIH0gb2YgZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZW5hbWUoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnb2JqZWN0LmFuZCc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIHt7I3ByZXNlbnRXaXRoTGFiZWxzfX0gd2l0aG91dCBpdHMgcmVxdWlyZWQgcGVlcnMge3sjbWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QuYXNzZXJ0JzogJ3t7I2xhYmVsfX0gaXMgaW52YWxpZCBiZWNhdXNlIHtpZigjc3ViamVjdC5rZXksIGBcImAgKyAjc3ViamVjdC5rZXkgKyBgXCIgZmFpbGVkIHRvIGAgKyAoI21lc3NhZ2UgfHwgXCJwYXNzIHRoZSBhc3NlcnRpb24gdGVzdFwiKSwgI21lc3NhZ2UgfHwgXCJ0aGUgYXNzZXJ0aW9uIGZhaWxlZFwiKX0nLFxuICAgICAgICAnb2JqZWN0LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9mIHR5cGUge3sjdHlwZX19JyxcbiAgICAgICAgJ29iamVjdC5pbnN0YW5jZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge3s6I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYXQgbGVhc3Qge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1pc3NpbmcnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5uYW5kJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbXVzdCBub3QgZXhpc3Qgc2ltdWx0YW5lb3VzbHkgd2l0aCB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3Qub3hvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBvcHRpb25hbCBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LnBhdHRlcm4ubWF0Y2gnOiAne3sjbGFiZWx9fSBrZXlzIGZhaWxlZCB0byBtYXRjaCBwYXR0ZXJuIHJlcXVpcmVtZW50cycsXG4gICAgICAgICdvYmplY3QucmVmVHlwZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgcmVmZXJlbmNlJyxcbiAgICAgICAgJ29iamVjdC5yZWdleCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBSZWdFeHAgb2JqZWN0JyxcbiAgICAgICAgJ29iamVjdC5yZW5hbWUubXVsdGlwbGUnOiAne3sjbGFiZWx9fSBjYW5ub3QgcmVuYW1lIHt7OiNmcm9tfX0gYmVjYXVzZSBtdWx0aXBsZSByZW5hbWVzIGFyZSBkaXNhYmxlZCBhbmQgYW5vdGhlciBrZXkgd2FzIGFscmVhZHkgcmVuYW1lZCB0byB7ezojdG99fScsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm92ZXJyaWRlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCB7ezojdG99fSBleGlzdHMnLFxuICAgICAgICAnb2JqZWN0LnNjaGVtYSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgc2NoZW1hIG9mIHt7I3R5cGV9fSB0eXBlJyxcbiAgICAgICAgJ29iamVjdC51bmtub3duJzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICAnb2JqZWN0LndpdGgnOiAne3s6I21haW5XaXRoTGFiZWx9fSBtaXNzaW5nIHJlcXVpcmVkIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3Qud2l0aG91dCc6ICd7ezojbWFpbldpdGhMYWJlbH19IGNvbmZsaWN0IHdpdGggZm9yYmlkZGVuIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3QueG9yJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIGV4Y2x1c2l2ZSBwZWVycyB7eyNwZWVyc1dpdGhMYWJlbHN9fSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZnMpIHtcblxuICAgIC8vIE9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZWZzLm5vbkVudW1lcmFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUodmFsdWUsIHsgc2hhbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25cblxuICAgIGNvbnN0IGNsb25lID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIGNsb25lLnByb3RvdHlwZSA9IENsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbmFtZScsIHsgdmFsdWU6IHZhbHVlLm5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsICdsZW5ndGgnLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuYXNzaWduKGNsb25lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuXG5pbnRlcm5hbHMuZGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChzY2hlbWEsIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGtleSA9PT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgcmVsLCAna2V5IG11c3QgYmUgYSBzdHJpbmdzJyk7XG5cbiAgICAvLyBFeHRyYWN0IG9wdGlvbnMgZnJvbSBwZWVycyBhcnJheVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwZWVycy5sZW5ndGggPiAxICYmIHR5cGVvZiBwZWVyc1twZWVycy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcgPyBwZWVycy5wb3AoKSA6IHt9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnc2VwYXJhdG9yJywgJ2lzUHJlc2VudCddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwLCBwcmVmaXg6IGZhbHNlIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoICE9PSBjb3VudCAmJlxuICAgICAgICAgICAgcHJlc2VudC5sZW5ndGggIT09IGNvdW50KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC5hbmQnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudFdpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtaXNzaW5nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6ICdvYmplY3QubWlzc2luZycsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgcGVlcnM6IGRlcC5wYXRocyxcbiAgICAgICAgICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG94b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlc2VudC5sZW5ndGggfHxcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICAgICAgY29udGV4dC5wcmVzZW50V2l0aExhYmVscyA9IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KTtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogJ29iamVjdC5veG9yJywgY29udGV4dCB9O1xuICAgIH0sXG5cbiAgICB3aXRoKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC53aXRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZGVwLmtleS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLmtleS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcjogcGVlci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcGVlci5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdpdGhvdXQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3Qud2l0aG91dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGRlcC5rZXkua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5rZXkua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXI6IHBlZXIua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHBlZXIua2V5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB4b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzUHJlc2VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMuaXNQcmVzZW50ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pc1ByZXNlbnQgOiAocmVzb2x2ZWQpID0+IHJlc29sdmVkICE9PSB1bmRlZmluZWQ7XG59O1xuXG5cbmludGVybmFscy5yZW5hbWUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpIHtcblxuICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlbmFtZSBvZiBzY2hlbWEuJF90ZXJtcy5yZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiByZW5hbWUuZnJvbSAhPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZW5hbWUuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAodmFsdWVbcmVuYW1lLmZyb21dICE9PSB1bmRlZmluZWQgfHwgIXJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChyZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcm9tIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHJlbmFtZS50bykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlbmFtZS5mcm9tLmV4ZWMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBmcm9tLCB0bzogcmVuYW1lLnRvLCBtYXRjaCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IG1hdGNoLmZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBtYXRjaC50bztcbiAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSB0by5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbWF0Y2gubWF0Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgIHJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHRvKSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWUub3B0aW9ucy5vdmVycmlkZSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVt0b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0b10gPSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuYW1lZFt0b10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy51bmtub3duID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7XG4gICAgICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4ucmVnZXgudGVzdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICdydWxlJywgYHBhdHRlcm4uJHtpfWAsIG1hdGNoID8gJ3Bhc3MnIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uc2NoZW1hLiRfbWF0Y2goa2V5LCBzdGF0ZS5uZXN0KHBhdHRlcm4uc2NoZW1hLCBgcGF0dGVybi4ke2l9YCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHsgc2NoZW1hOiBwYXR0ZXJuLnJ1bGUsIGtleSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXR0ZXJuLnJ1bGUuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tpXS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF0dGVybiBtYXRjaGVzIHJ1bGVzXG5cbiAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cG0gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXS5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIHN0cG0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cG0uJF92YWxpZGF0ZShtYXRjaCwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQuZXJyb3JzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucGF0dGVybi5tYXRjaCcsIHZhbHVlLCBkZXRhaWxzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHsgICAgIC8vIElmIG5vIGtleXMgb3IgcGF0dGVybnMgc3BlY2lmaWVkLCB1bmtub3duIGtleXMgYWxsb3dlZFxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuc3RyaXBVbmtub3duICYmICFzY2hlbWEuX2ZsYWdzLnVua25vd24gfHxcbiAgICAgICAgcHJlZnMuc2tpcEZ1bmN0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biA/IChwcmVmcy5zdHJpcFVua25vd24gPT09IHRydWUgPyB0cnVlIDogISFwcmVmcy5zdHJpcFVua25vd24ub2JqZWN0cykgOiBmYWxzZTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvcmJpZFVua25vd24gPSAhQ29tbW9uLmRlZmF1bHQoc2NoZW1hLl9mbGFncy51bmtub3duLCBwcmVmcy5hbGxvd1Vua25vd24pO1xuICAgIGlmIChmb3JiaWRVbmtub3duKSB7XG4gICAgICAgIGZvciAoY29uc3QgdW5wcm9jZXNzZWRLZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgdW5wcm9jZXNzZWRLZXldLCBbXSk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnVua25vd24nLCB2YWx1ZVt1bnByb2Nlc3NlZEtleV0sIHsgY2hpbGQ6IHVucHJvY2Vzc2VkS2V5IH0sIGxvY2FsU3RhdGUsIHByZWZzLCB7IGZsYWdzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EZXBlbmRlbmN5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocmVsLCBrZXksIHBlZXJzLCBwYXRocywgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVsID0gcmVsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wZWVycyA9IHBlZXJzO1xuICAgICAgICB0aGlzLnBhdGhzID0gcGF0aHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgICAgIHJlbDogdGhpcy5yZWwsXG4gICAgICAgICAgICBwZWVyczogdGhpcy5wYXRoc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVzYy5rZXkgPSB0aGlzLmtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgZGVzYy5vcHRpb25zID0geyAuLi5kZXNjLm9wdGlvbnMsIHNlcGFyYXRvcjogdGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IC4uLmRlc2Mub3B0aW9ucywgaXNQcmVzZW50OiB0aGlzLm9wdGlvbnMuaXNQcmVzZW50IH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5LZXlzID0gY2xhc3MgZXh0ZW5kcyBBcnJheSB7XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zbGljZSgpO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXlzLnNldChyZXN1bHRbaV0ua2V5LCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcG9zID0ga2V5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0geyBrZXksIHNjaGVtYTogcmVzdWx0W3Bvc10uc2NoZW1hLmNvbmNhdChpdGVtLnNjaGVtYSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVvZjogJ2Z1bmN0aW9uJ1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBhcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW5Bcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluQXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXhBcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Z1bmN0aW9uLmFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IG9mIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5jbGFzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjbGFzcycsXG4gICAgICAgICdmdW5jdGlvbi5tYXhBcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBsZXNzZXIgb3IgZXF1YWwgdG8ge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1pbkFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IGdyZWF0ZXIgb3IgZXF1YWwgdG8ge3sjbn19J1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2xpbmsnLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBzY2hlbWFDaGFpbjogdHJ1ZVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGxpbms6IHsgaW5pdDogbnVsbCwgbWFuaWZlc3Q6ICdzaW5nbGUnLCByZWdpc3RlcjogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBhcmdzKHNjaGVtYSwgcmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZWYocmVmKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgIEFzc2VydChzY2hlbWEuJF90ZXJtcy5saW5rLCAnVW5pbml0aWFsaXplZCBsaW5rIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IGxpbmtlZCA9IGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICAgICAgcmV0dXJuIGxpbmtlZC4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KGxpbmtlZCwgYGxpbms6JHtyZWYuZGlzcGxheX06JHtsaW5rZWQudHlwZX1gKSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICBtZXRob2QocmVmKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuJF90ZXJtcy5saW5rLCAnQ2Fubm90IHJlaW5pdGlhbGl6ZSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIHJlZiA9IENvbXBpbGUucmVmKHJlZik7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocmVmLnR5cGUgPT09ICd2YWx1ZScgfHwgcmVmLnR5cGUgPT09ICdsb2NhbCcsICdJbnZhbGlkIHJlZmVyZW5jZSB0eXBlOicsIHJlZi50eXBlKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocmVmLnR5cGUgPT09ICdsb2NhbCcgfHwgcmVmLmFuY2VzdG9yID09PSAncm9vdCcgfHwgcmVmLmFuY2VzdG9yID4gMCwgJ0xpbmsgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5saW5rID0gW3sgcmVmIH1dO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZWxhdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KHRoaXMuJF90ZXJtcy5saW5rLCAnVW5pbml0aWFsaXplZCBsaW5rIHNjaGVtYScpO1xuICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzb3VyY2UpLCAnSW52YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgICAgICBBc3NlcnQoc291cmNlLnR5cGUgIT09ICdsaW5rJywgJ0Nhbm5vdCBtZXJnZSB0eXBlIGxpbmsgd2l0aCBhbm90aGVyIGxpbmsnKTtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMucHVzaCh7IGNvbmNhdDogc291cmNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBBc3NlcnQoZGVzYy5saW5rLCAnSW52YWxpZCBsaW5rIGRlc2NyaXB0aW9uIG1pc3NpbmcgbGluaycpO1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWYoZGVzYy5saW5rKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgbGV0IGxpbmtlZCA9IHN0YXRlLm1haW5zdGF5LmxpbmtzLmdldChzY2hlbWEpO1xuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtlZC5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZiA9IHNjaGVtYS4kX3Rlcm1zLmxpbmtbMF0ucmVmO1xuICAgIGNvbnN0IHsgcGVyc3BlY3RpdmUsIHBhdGggfSA9IGludGVybmFscy5wZXJzcGVjdGl2ZShyZWYsIHN0YXRlKTtcbiAgICBpbnRlcm5hbHMuYXNzZXJ0KHBlcnNwZWN0aXZlLCAnd2hpY2ggaXMgb3V0c2lkZSBvZiBzY2hlbWEgYm91bmRhcmllcycsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbGlua2VkID0gcGF0aC5sZW5ndGggPyBwZXJzcGVjdGl2ZS4kX3JlYWNoKHBhdGgpIDogcGVyc3BlY3RpdmU7XG4gICAgfVxuICAgIGNhdGNoIChpZ25vcmVFcnIpIHtcbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydChmYWxzZSwgJ3RvIG5vbi1leGlzdGluZyBzY2hlbWEnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbHMuYXNzZXJ0KGxpbmtlZC50eXBlICE9PSAnbGluaycsICd3aGljaCBpcyBhbm90aGVyIGxpbmsnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIGlmICghc2NoZW1hLl9mbGFncy5yZWxhdGl2ZSkge1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5saW5rcy5zZXQoc2NoZW1hLCBsaW5rZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbn07XG5cblxuaW50ZXJuYWxzLnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKHJlZiwgc3RhdGUpIHtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICBmb3IgKGNvbnN0IHsgc2NoZW1hLCBrZXkgfSBvZiBzdGF0ZS5zY2hlbWFzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnJvbSBwYXJlbnQgdG8gcm9vdFxuICAgICAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuX2ZsYWdzLmlkIHx8IGtleTtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc2NoZW1hLCBwYXRoOiByZWYucGF0aC5zbGljZSgxKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMuc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzaGFyZWQgb2Ygc2NoZW1hLiRfdGVybXMuc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuX2ZsYWdzLmlkID09PSByZWYucGF0aFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNoYXJlZCwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBudWxsLCBwYXRoOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzdGF0ZS5zY2hlbWFzW3N0YXRlLnNjaGVtYXMubGVuZ3RoIC0gMV0uc2NoZW1hLCBwYXRoOiByZWYucGF0aCB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzdGF0ZS5zY2hlbWFzW3JlZi5hbmNlc3Rvcl0gJiYgc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbn07XG5cblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmIChjb25kaXRpb24pIHsgICAgICAgICAgICAgICAgLy8gTWFudWFsIGNoZWNrIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXJyb3IgbWVzc2FnZSBvbiBzdWNjZXNzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBBc3NlcnQoZmFsc2UsIGBcIiR7RXJyb3JzLmxhYmVsKHNjaGVtYS5fZmxhZ3MsIHN0YXRlLCBwcmVmcyl9XCIgY29udGFpbnMgbGluayByZWZlcmVuY2UgXCIke3JlZi5kaXNwbGF5fVwiICR7bWVzc2FnZX1gKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBudW1iZXJSeDogL15cXHMqWystXT8oPzooPzpcXGQrKD86XFwuXFxkKik/KXwoPzpcXC5cXGQrKSkoPzplKFsrLV0/XFxkKykpP1xccyokL2ksXG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8sXG4gICAgZXhwb25lbnRpYWxQYXJ0UmVnZXg6IC9bZUVdWystXT9cXGQrJC8sXG4gICAgbGVhZGluZ1NpZ25BbmRaZXJvc1JlZ2V4OiAvXlsrLV0/KDAqKT8vLFxuICAgIGRvdFJlZ2V4OiAvXFwuLyxcbiAgICB0cmFpbGluZ1plcm9zUmVnZXg6IC8wKyQvLFxuICAgIGRlY2ltYWxQbGFjZXModmFsdWUpIHtcblxuICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBkaW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBjb25zdCBlaW5kZXggPSBzdHIuaW5kZXhPZignZScpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGRpbmRleCA8IDAgPyAwIDogKGVpbmRleCA8IDAgPyBzdHIubGVuZ3RoIDogZWluZGV4KSAtIGRpbmRleCAtIDEpICtcbiAgICAgICAgICAgIChlaW5kZXggPCAwID8gMCA6IE1hdGgubWF4KDAsIC1wYXJzZUludChzdHIuc2xpY2UoZWluZGV4ICsgMSkpKSlcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbnVtYmVyJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgdW5zYWZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpIH07XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSkgIT09IGludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoU3RyaW5nKHJlc3VsdC52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHJlc3VsdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5pbmZpbml0eScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvbW1vbi5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlIH07XG5cbiAgICAgICAgaWYgKHByZWZzLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuJF9nZXRSdWxlKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHJ1bGUuYXJncy5saW1pdCk7ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNvbmNlcHR1YWxseSBlcXVpdmFsZW50IHRvIHVzaW5nIHRvRml4ZWQgYnV0IGl0IHNob3VsZCBiZSBtdWNoIGZhc3RlclxuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmVzdWx0LnZhbHVlICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IDA7ICAgICAgICAgICAvLyAtMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgdmFsdWUgPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcblxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbXBhcmU6IHtcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZSwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5pc051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBudW1iZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2dyZWF0ZXInLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVnZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaW50ZWdlcicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC50cnVuYyh2YWx1ZSkgLSB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5pbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVzcycsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICBtZXRob2QoYmFzZSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZURlY2ltYWxQbGFjZSA9IHR5cGVvZiBiYXNlID09PSAnbnVtYmVyJyA/IGludGVybmFscy5kZWNpbWFsUGxhY2VzKGJhc2UpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwZmFjdG9yID0gTWF0aC5wb3coMTAsIGJhc2VEZWNpbWFsUGxhY2UpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ211bHRpcGxlJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VEZWNpbWFsUGxhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZmFjdG9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBiYXNlLCBiYXNlRGVjaW1hbFBsYWNlLCBwZmFjdG9yIH0sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGVjaW1hbFBsYWNlID0gaW50ZXJuYWxzLmRlY2ltYWxQbGFjZXModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRGVjaW1hbFBsYWNlID4gYmFzZURlY2ltYWxQbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZSB3aXRoIGhpZ2hlciBwcmVjaXNpb24gdGhhbiBiYXNlIGNhbiBuZXZlciBiZSBhIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGZhY3RvciAqIHZhbHVlKSAlIE1hdGgucm91bmQocGZhY3RvciAqIGJhc2UpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Jhc2VEZWNpbWFsUGxhY2UnLFxuICAgICAgICAgICAgICAgICdwZmFjdG9yJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbmVnYXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ25lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9ydDoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdwb3J0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA8PSA2NTUzNSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLnBvcnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb3NpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbigncG9zaXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcmVjaXNpb246IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSwgJ2xpbWl0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3ByZWNpc2lvbicsIGFyZ3M6IHsgbGltaXQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZXMgPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKGludGVybmFscy5wcmVjaXNpb25SeCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBNYXRoLm1heCgocGxhY2VzWzFdID8gcGxhY2VzWzFdLmxlbmd0aCA6IDApIC0gKHBsYWNlc1syXSA/IHBhcnNlSW50KHBsYWNlc1syXSwgMTApIDogMCksIDApO1xuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFscyA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wcmVjaXNpb24nLCB7IGxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2lnbjoge1xuICAgICAgICAgICAgbWV0aG9kKHNpZ24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ25lZ2F0aXZlJywgJ3Bvc2l0aXZlJ10uaW5jbHVkZXMoc2lnbiksICdJbnZhbGlkIHNpZ24nLCBzaWduKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzaWduJywgYXJnczogeyBzaWduIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgc2lnbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2lnbiA9PT0gJ25lZ2F0aXZlJyAmJiB2YWx1ZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9PT0gJ3Bvc2l0aXZlJyAmJiB2YWx1ZSA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYG51bWJlci4ke3NpZ259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zYWZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bnNhZmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdudW1iZXIuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLmdyZWF0ZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5pbmZpbml0eSc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBpbmZpbml0eScsXG4gICAgICAgICdudW1iZXIuaW50ZWdlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICAgICdudW1iZXIubGVzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm1heCc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIG11bHRpcGxlIG9mIHt7I211bHRpcGxlfX0nLFxuICAgICAgICAnbnVtYmVyLm5lZ2F0aXZlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgICdudW1iZXIucG9ydCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBwb3J0JyxcbiAgICAgICAgJ251bWJlci5wb3NpdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnByZWNpc2lvbic6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBubyBtb3JlIHRoYW4ge3sjbGltaXR9fSBkZWNpbWFsIHBsYWNlcycsXG4gICAgICAgICdudW1iZXIudW5zYWZlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHNhZmUgbnVtYmVyJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy5leHBvbmVudGlhbFBhcnRSZWdleCwgJycpXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy5kb3RSZWdleCwgJycpXG4gICAgICAgIC5yZXBsYWNlKGludGVybmFscy50cmFpbGluZ1plcm9zUmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMubGVhZGluZ1NpZ25BbmRaZXJvc1JlZ2V4LCAnJyk7XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemVEZWNpbWFsID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgc3RyID0gc3RyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHBsdXMgc2lnbnNcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zIGlmIHRoZXJlIGlzIGEgZGVjaW1hbCBwb2ludCBhbmQgdW5lY2Vzc2FyeSBkZWNpbWFsIHBvaW50c1xuICAgICAgICAucmVwbGFjZSgvXFwuMCokLywgJycpXG4gICAgICAgIC8vIEFkZCBhIGludGVnZXIgMCBpZiB0aGUgbnVtYmVycyBzdGFydHMgd2l0aCBhIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pXFwuKFteXFwuXSopJC8sICckMTAuJDInKVxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvc1xuICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMC05XSkvLCAnJDEkMicpO1xuXG4gICAgaWYgKHN0ci5pbmNsdWRlcygnLicpICYmXG4gICAgICAgIHN0ci5lbmRzV2l0aCgnMCcpKSB7XG5cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSAnLTAnKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnb2JqZWN0JyxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXModmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jb2RlcyA9IHtcbiAgICBFTVBUWV9TVFJJTkc6ICdBZGRyZXNzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyxcbiAgICBGT1JCSURERU5fVU5JQ09ERTogJ0FkZHJlc3MgY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycsXG4gICAgTVVMVElQTEVfQVRfQ0hBUjogJ0FkZHJlc3MgY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBAIGNoYXJhY3RlcicsXG4gICAgTUlTU0lOR19BVF9DSEFSOiAnQWRkcmVzcyBtdXN0IGNvbnRhaW4gb25lIEAgY2hhcmFjdGVyJyxcbiAgICBFTVBUWV9MT0NBTDogJ0FkZHJlc3MgbG9jYWwgcGFydCBjYW5ub3QgYmUgZW1wdHknLFxuICAgIEFERFJFU1NfVE9PX0xPTkc6ICdBZGRyZXNzIHRvbyBsb25nJyxcbiAgICBMT0NBTF9UT09fTE9ORzogJ0FkZHJlc3MgbG9jYWwgcGFydCB0b28gbG9uZycsXG4gICAgRU1QVFlfTE9DQUxfU0VHTUVOVDogJ0FkZHJlc3MgbG9jYWwgcGFydCBjb250YWlucyBlbXB0eSBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQnLFxuICAgIElOVkFMSURfTE9DQUxfQ0hBUlM6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInLFxuICAgIERPTUFJTl9OT05fRU1QVFlfU1RSSU5HOiAnRG9tYWluIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyxcbiAgICBET01BSU5fVE9PX0xPTkc6ICdEb21haW4gdG9vIGxvbmcnLFxuICAgIERPTUFJTl9JTlZBTElEX1VOSUNPREVfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycsXG4gICAgRE9NQUlOX0lOVkFMSURfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInLFxuICAgIERPTUFJTl9JTlZBTElEX1RMRFNfQ0hBUlM6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCB0bGQgY2hhcmFjdGVyJyxcbiAgICBET01BSU5fU0VHTUVOVFNfQ09VTlQ6ICdEb21haW4gbGFja3MgdGhlIG1pbmltdW0gcmVxdWlyZWQgbnVtYmVyIG9mIHNlZ21lbnRzJyxcbiAgICBET01BSU5fU0VHTUVOVFNfQ09VTlRfTUFYOiAnRG9tYWluIGNvbnRhaW5zIHRvbyBtYW55IHNlZ21lbnRzJyxcbiAgICBET01BSU5fRk9SQklEREVOX1RMRFM6ICdEb21haW4gdXNlcyBmb3JiaWRkZW4gVExEJyxcbiAgICBET01BSU5fRU1QVFlfU0VHTUVOVDogJ0RvbWFpbiBjb250YWlucyBlbXB0eSBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQnLFxuICAgIERPTUFJTl9MT05HX1NFR01FTlQ6ICdEb21haW4gY29udGFpbnMgZG90LXNlcGFyYXRlZCBzZWdtZW50IHRoYXQgaXMgdG9vIGxvbmcnXG59O1xuXG5cbmV4cG9ydHMuY29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG5cbiAgICByZXR1cm4geyBjb2RlLCBlcnJvcjogZXhwb3J0cy5jb2Rlc1tjb2RlXSB9O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaW5Eb21haW5TZWdtZW50czogMixcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGRvbWFpbkNvbnRyb2xSeDogL1tcXHgwMC1cXHgyMEBcXDpcXC9cXFxcIyFcXCQmXFwnXFwoXFwpXFwqXFwrLDs9XFw/XS8sICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sICsgc3BhY2UgKyBzZXBhcmF0b3JzXG4gICAgdGxkU2VnbWVudFJ4OiAvXlthLXpBLVpdKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvLFxuICAgIGRvbWFpblNlZ21lbnRSeDogL15bYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKT8kLyxcbiAgICBVUkw6IFVybC5VUkwgfHwgVVJMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbn07XG5cblxuZXhwb3J0cy5hbmFseXplID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoIWRvbWFpbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBudWxsIC8gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX05PTl9FTVBUWV9TVFJJTkcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBkb21haW4gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChkb21haW4ubGVuZ3RoID4gMjU2KSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1RPT19MT05HJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChkb21haW4pO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX1VOSUNPREVfQ0hBUlMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5ub3JtYWxpemUoJ05GQycpO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbHMuZG9tYWluQ29udHJvbFJ4LnRlc3QoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX0NIQVJTJyk7XG4gICAgfVxuXG4gICAgZG9tYWluID0gaW50ZXJuYWxzLnB1bnljb2RlKGRvbWFpbik7XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNSBzZWN0aW9uIDIuMy4xXG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0Z1bGx5UXVhbGlmaWVkICYmXG4gICAgICAgIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWluRG9tYWluU2VnbWVudHMgPSBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzIHx8IGludGVybmFscy5taW5Eb21haW5TZWdtZW50cztcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA8IG1pbkRvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UX01BWCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGxkcyA9IG9wdGlvbnMudGxkcztcbiAgICBpZiAodGxkcykge1xuICAgICAgICBjb25zdCB0bGQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGxkcy5kZW55ICYmIHRsZHMuZGVueS5oYXModGxkKSB8fFxuICAgICAgICAgICAgdGxkcy5hbGxvdyAmJiAhdGxkcy5hbGxvdy5oYXModGxkKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9GT1JCSURERU5fVExEUycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fRU1QVFlfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0xPTkdfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5kb21haW5TZWdtZW50UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0lOVkFMSURfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnRsZFNlZ21lbnRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fSU5WQUxJRF9UTERTX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFleHBvcnRzLmFuYWx5emUoZG9tYWluLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLnB1bnljb2RlID0gZnVuY3Rpb24gKGRvbWFpbikge1xuXG4gICAgaWYgKGRvbWFpbi5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKC8lL2csICclMjUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5VUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IERvbWFpbiA9IHJlcXVpcmUoJy4vZG9tYWluJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGVuY29kZXI6IG5ldyAoVXRpbC5UZXh0RW5jb2RlciB8fCBUZXh0RW5jb2RlcikoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuXG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5lbWFpbChlbWFpbCwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuZW1haWwgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBlbWFpbCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbWFpbCkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0VNUFRZX1NUUklORycpO1xuICAgIH1cblxuICAgIC8vIFVuaWNvZGVcblxuICAgIGNvbnN0IGFzY2lpID0gIWludGVybmFscy5ub25Bc2NpaVJ4LnRlc3QoZW1haWwpO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRk9SQklEREVOX1VOSUNPREUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtYWlsID0gZW1haWwubm9ybWFsaXplKCdORkMnKTtcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBzdHJ1Y3R1cmVcblxuICAgIGNvbnN0IHBhcnRzID0gZW1haWwuc3BsaXQoJ0AnKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAyID8gRXJyb3JzLmNvZGUoJ01VTFRJUExFX0FUX0NIQVInKSA6IEVycm9ycy5jb2RlKCdNSVNTSU5HX0FUX0NIQVInKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbG9jYWwsIGRvbWFpbl0gPSBwYXJ0cztcblxuICAgIGlmICghbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdFTVBUWV9MT0NBTCcpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pZ25vcmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4zXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0FERFJFU1NfVE9PX0xPTkcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuZW5jb2Rlci5lbmNvZGUobG9jYWwpLmxlbmd0aCA+IDY0KSB7ICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuMVxuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdMT0NBTF9UT09fTE9ORycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGFydHNcblxuICAgIHJldHVybiBpbnRlcm5hbHMubG9jYWwobG9jYWwsIGFzY2lpKSB8fCBEb21haW4uYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMubG9jYWwgPSBmdW5jdGlvbiAobG9jYWwsIGFzY2lpKSB7XG5cbiAgICBjb25zdCBzZWdtZW50cyA9IGxvY2FsLnNwbGl0KCcuJyk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRU1QVFlfTE9DQUxfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzY2lpKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5hdGV4dFJ4LnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0lOVkFMSURfTE9DQUxfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5hdGV4dFJ4LnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gaW50ZXJuYWxzLmJpbmFyeShjaGFyKTtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmF0b21SeC50ZXN0KGJpbmFyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0lOVkFMSURfTE9DQUxfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmJpbmFyeSA9IGZ1bmN0aW9uIChjaGFyKSB7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbnRlcm5hbHMuZW5jb2Rlci5lbmNvZGUoY2hhcikpLm1hcCgodikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2KSkuam9pbignJyk7XG59O1xuXG5cbi8qXG4gICAgRnJvbSBSRkMgNTMyMTpcblxuICAgICAgICBNYWlsYm94ICAgICAgICAgPSAgIExvY2FsLXBhcnQgXCJAXCIgKCBEb21haW4gLyBhZGRyZXNzLWxpdGVyYWwgKVxuXG4gICAgICAgIExvY2FsLXBhcnQgICAgICA9ICAgRG90LXN0cmluZyAvIFF1b3RlZC1zdHJpbmdcbiAgICAgICAgRG90LXN0cmluZyAgICAgID0gICBBdG9tICooXCIuXCIgIEF0b20pXG4gICAgICAgIEF0b20gICAgICAgICAgICA9ICAgMSphdGV4dFxuICAgICAgICBhdGV4dCAgICAgICAgICAgPSAgIEFMUEhBIC8gRElHSVQgLyBcIiFcIiAvIFwiI1wiIC8gXCIkXCIgLyBcIiVcIiAvIFwiJlwiIC8gXCInXCIgLyBcIipcIiAvIFwiK1wiIC8gXCItXCIgLyBcIi9cIiAvIFwiPVwiIC8gXCI/XCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcIntcIiAvIFwifFwiIC8gXCJ9XCIgLyBcIn5cIlxuXG4gICAgICAgIERvbWFpbiAgICAgICAgICA9ICAgc3ViLWRvbWFpbiAqKFwiLlwiIHN1Yi1kb21haW4pXG4gICAgICAgIHN1Yi1kb21haW4gICAgICA9ICAgTGV0LWRpZyBbTGRoLXN0cl1cbiAgICAgICAgTGV0LWRpZyAgICAgICAgID0gICBBTFBIQSAvIERJR0lUXG4gICAgICAgIExkaC1zdHIgICAgICAgICA9ICAgKiggQUxQSEEgLyBESUdJVCAvIFwiLVwiICkgTGV0LWRpZ1xuXG4gICAgICAgIEFMUEhBICAgICAgICAgICA9ICAgJXg0MS01QSAvICV4NjEtN0EgICAgICAgIDsgYS16LCBBLVpcbiAgICAgICAgRElHSVQgICAgICAgICAgID0gICAleDMwLTM5ICAgICAgICAgICAgICAgICAgOyAwLTlcblxuICAgIEZyb20gUkZDIDY1MzE6XG5cbiAgICAgICAgc3ViLWRvbWFpbiAgICAgID0vICBVLWxhYmVsXG4gICAgICAgIGF0ZXh0ICAgICAgICAgICA9LyAgVVRGOC1ub24tYXNjaWlcblxuICAgICAgICBVVEY4LW5vbi1hc2NpaSAgPSAgIFVURjgtMiAvIFVURjgtMyAvIFVURjgtNFxuXG4gICAgICAgIFVURjgtMiAgICAgICAgICA9ICAgJXhDMi1ERiBVVEY4LXRhaWxcbiAgICAgICAgVVRGOC0zICAgICAgICAgID0gICAleEUwICV4QTAtQkYgVVRGOC10YWlsIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEUxLUVDIDIoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEVEICV4ODAtOUYgVVRGOC10YWlsIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEVFLUVGIDIoIFVURjgtdGFpbCApXG4gICAgICAgIFVURjgtNCAgICAgICAgICA9ICAgJXhGMCAleDkwLUJGIDIoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEYxLUYzIDMoIFVURjgtdGFpbCApIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEY0ICV4ODAtOEYgMiggVVRGOC10YWlsIClcblxuICAgICAgICBVVEY4LXRhaWwgICAgICAgPSAgICV4ODAtQkZcblxuICAgIE5vdGU6IFRoZSBmb2xsb3dpbmcgYXJlIG5vdCBzdXBwb3J0ZWQ6XG5cbiAgICAgICAgUkZDIDUzMjE6IGFkZHJlc3MtbGl0ZXJhbCwgUXVvdGVkLXN0cmluZ1xuICAgICAgICBSRkMgNTMyMjogb2JzLSosIENGV1NcbiovXG5cblxuaW50ZXJuYWxzLmF0ZXh0UnggPSAvXltcXHchI1xcJCUmJ1xcKlxcK1xcLS89XFw/XFxeYFxce1xcfFxcfX5dKyQvOyAgICAgICAgICAgICAgIC8vIF8gaW5jbHVkZWQgaW4gXFx3XG5cblxuaW50ZXJuYWxzLmF0b21SeCA9IG5ldyBSZWdFeHAoW1xuXG4gICAgLy8gICV4QzItREYgVVRGOC10YWlsXG4gICAgJyg/OltcXFxceGMyLVxcXFx4ZGZdW1xcXFx4ODAtXFxcXHhiZl0pJyxcblxuICAgIC8vICAleEUwICV4QTAtQkYgVVRGOC10YWlsICAgICAgICAgICAgICAleEUxLUVDIDIoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhFRCAleDgwLTlGIFVURjgtdGFpbCAgICAgICAgICAgICAgJXhFRS1FRiAyKCBVVEY4LXRhaWwgKVxuICAgICcoPzpcXFxceGUwW1xcXFx4YTAtXFxcXHhiZl1bXFxcXHg4MC1cXFxceGJmXSl8KD86W1xcXFx4ZTEtXFxcXHhlY11bXFxcXHg4MC1cXFxceGJmXXsyfSl8KD86XFxcXHhlZFtcXFxceDgwLVxcXFx4OWZdW1xcXFx4ODAtXFxcXHhiZl0pfCg/OltcXFxceGVlLVxcXFx4ZWZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pJyxcblxuICAgIC8vICAleEYwICV4OTAtQkYgMiggVVRGOC10YWlsICkgICAgICAgICAgICAleEYxLUYzIDMoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhGNCAleDgwLThGIDIoIFVURjgtdGFpbCApXG4gICAgJyg/OlxcXFx4ZjBbXFxcXHg5MC1cXFxceGJmXVtcXFxceDgwLVxcXFx4YmZdezJ9KXwoPzpbXFxcXHhmMS1cXFxceGYzXVtcXFxceDgwLVxcXFx4YmZdezN9KXwoPzpcXFxceGY0W1xcXFx4ODAtXFxcXHg4Zl1bXFxcXHg4MC1cXFxceGJmXXsyfSknXG5cbl0uam9pbignfCcpKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgLy8gRXNjYXBlIF4kLiorLT89ITp8XFwvKClbXXt9LFxuXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxeXFwkXFwuXFwqXFwrXFwtXFw/XFw9XFwhXFw6XFx8XFxcXFxcL1xcKFxcKVxcW1xcXVxce1xcfVxcLF0vZywgJ1xcXFwkJicpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRXNjYXBlUmVnZXggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJmYzM5ODYgPSB7fTtcblxuICAgIGNvbnN0IGhleERpZ2l0ID0gJ1xcXFxkQS1GYS1mJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhFWERJRyA9IERJR0lUIC8gXCJBXCIgLyBcIkJcIiAvIFwiQ1wiIC8gXCJEXCIgLyBcIkVcIiAvIFwiRlwiXG4gICAgY29uc3QgaGV4RGlnaXRPbmx5ID0gJ1snICsgaGV4RGlnaXQgKyAnXSc7XG5cbiAgICBjb25zdCB1bnJlc2VydmVkID0gJ1xcXFx3LVxcXFwufic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVucmVzZXJ2ZWQgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAgICBjb25zdCBzdWJEZWxpbXMgPSAnIVxcXFwkJlxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWItZGVsaW1zID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICAgIGNvbnN0IHBjdEVuY29kZWQgPSAnJScgKyBoZXhEaWdpdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwY3QtZW5jb2RlZCA9IFwiJVwiIEhFWERJRyBIRVhESUdcbiAgICBjb25zdCBwY2hhciA9IHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpAJzsgICAgICAgICAgICAgICAgICAgLy8gcGNoYXIgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxuICAgIGNvbnN0IHBjaGFyT25seSA9ICdbJyArIHBjaGFyICsgJ10nO1xuICAgIGNvbnN0IGRlY09jdGVjdCA9ICcoPzowezAsMn1cXFxcZHwwP1sxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSknOyAgICAgLy8gZGVjLW9jdGV0ID0gRElHSVQgLyAleDMxLTM5IERJR0lUIC8gXCIxXCIgMkRJR0lUIC8gXCIyXCIgJXgzMC0zNCBESUdJVCAvIFwiMjVcIiAleDMwLTM1ICA7IDAtOSAvIDEwLTk5IC8gMTAwLTE5OSAvIDIwMC0yNDkgLyAyNTAtMjU1XG5cbiAgICByZmMzOTg2LmlwdjRhZGRyZXNzID0gJyg/OicgKyBkZWNPY3RlY3QgKyAnXFxcXC4pezN9JyArIGRlY09jdGVjdDsgICAgICAgICAgICAvLyBJUHY0YWRkcmVzcyA9IGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldFxuXG4gICAgLypcbiAgICAgICAgaDE2ID0gMSo0SEVYRElHIDsgMTYgYml0cyBvZiBhZGRyZXNzIHJlcHJlc2VudGVkIGluIGhleGFkZWNpbWFsXG4gICAgICAgIGxzMzIgPSAoIGgxNiBcIjpcIiBoMTYgKSAvIElQdjRhZGRyZXNzIDsgbGVhc3Qtc2lnbmlmaWNhbnQgMzIgYml0cyBvZiBhZGRyZXNzXG4gICAgICAgIElQdjZhZGRyZXNzID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgICAgICAgICAgICAgICAgIC8gWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgKi9cblxuICAgIGNvbnN0IGgxNiA9IGhleERpZ2l0T25seSArICd7MSw0fSc7XG4gICAgY29uc3QgbHMzMiA9ICcoPzonICsgaDE2ICsgJzonICsgaDE2ICsgJ3wnICsgcmZjMzk4Ni5pcHY0YWRkcmVzcyArICcpJztcbiAgICBjb25zdCBJUHY2U2l4SGV4ID0gJyg/OicgKyBoMTYgKyAnOil7Nn0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Rml2ZUhleCA9ICc6Oig/OicgKyBoMTYgKyAnOil7NX0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Rm91ckhleCA9ICcoPzonICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezR9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlRocmVlSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwxfScgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7M30nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2VHdvSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwyfScgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7Mn0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2T25lSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCwzfScgKyBoMTYgKyAnKT86OicgKyBoMTYgKyAnOicgKyBsczMyO1xuICAgIGNvbnN0IElQdjZOb25lSGV4ID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw0fScgKyBoMTYgKyAnKT86OicgKyBsczMyO1xuICAgIGNvbnN0IElQdjZOb25lSGV4MiA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNX0nICsgaDE2ICsgJyk/OjonICsgaDE2O1xuICAgIGNvbnN0IElQdjZOb25lSGV4MyA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNn0nICsgaDE2ICsgJyk/OjonO1xuXG4gICAgcmZjMzk4Ni5pcHY0Q2lkciA9ICcoPzpcXFxcZHxbMS0yXVxcXFxkfDNbMC0yXSknOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJUHY0IGNpZHIgPSBESUdJVCAvICV4MzEtMzIgRElHSVQgLyBcIjNcIiAleDMwLTMyICA7IDAtOSAvIDEwLTI5IC8gMzAtMzJcbiAgICByZmMzOTg2LmlwdjZDaWRyID0gJyg/OjB7MCwyfVxcXFxkfDA/WzEtOV1cXFxcZHwxWzAxXVxcXFxkfDEyWzAtOF0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVB2NiBjaWRyID0gRElHSVQgLyAleDMxLTM5IERJR0lUIC8gXCIxXCIgJXgwLTEgRElHSVQgLyBcIjEyXCIgJXgwLTg7ICAgMC05IC8gMTAtOTkgLyAxMDAtMTE5IC8gMTIwLTEyOFxuICAgIHJmYzM5ODYuaXB2NmFkZHJlc3MgPSAnKD86JyArIElQdjZTaXhIZXggKyAnfCcgKyBJUHY2Rml2ZUhleCArICd8JyArIElQdjZGb3VySGV4ICsgJ3wnICsgSVB2NlRocmVlSGV4ICsgJ3wnICsgSVB2NlR3b0hleCArICd8JyArIElQdjZPbmVIZXggKyAnfCcgKyBJUHY2Tm9uZUhleCArICd8JyArIElQdjZOb25lSGV4MiArICd8JyArIElQdjZOb25lSGV4MyArICcpJztcbiAgICByZmMzOTg2LmlwdkZ1dHVyZSA9ICd2JyArIGhleERpZ2l0T25seSArICcrXFxcXC5bJyArIHVucmVzZXJ2ZWQgKyBzdWJEZWxpbXMgKyAnOl0rJzsgICAgICAvLyBJUHZGdXR1cmUgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG5cbiAgICByZmMzOTg2LnNjaGVtZSA9ICdbYS16QS1aXVthLXpBLVpcXFxcZCstXFxcXC5dKic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjaGVtZSA9IEFMUEhBICooIEFMUEhBIC8gRElHSVQgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgKVxuICAgIHJmYzM5ODYuc2NoZW1lUmVnZXggPSBuZXcgUmVnRXhwKHJmYzM5ODYuc2NoZW1lKTtcblxuICAgIGNvbnN0IHVzZXJpbmZvID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOl0qJzsgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyaW5mbyA9ICooIHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgY29uc3QgSVBMaXRlcmFsID0gJ1xcXFxbKD86JyArIHJmYzM5ODYuaXB2NmFkZHJlc3MgKyAnfCcgKyByZmMzOTg2LmlwdkZ1dHVyZSArICcpXFxcXF0nOyAgICAvLyBJUC1saXRlcmFsID0gXCJbXCIgKCBJUHY2YWRkcmVzcyAvIElQdkZ1dHVyZSAgKSBcIl1cIlxuICAgIGNvbnN0IHJlZ05hbWUgPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICddezEsMjU1fSc7ICAgICAgICAgICAgICAgICAvLyByZWctbmFtZSA9ICooIHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgKVxuICAgIGNvbnN0IGhvc3QgPSAnKD86JyArIElQTGl0ZXJhbCArICd8JyArIHJmYzM5ODYuaXB2NGFkZHJlc3MgKyAnfCcgKyByZWdOYW1lICsgJyknOyAgICAgICAvLyBob3N0ID0gSVAtbGl0ZXJhbCAvIElQdjRhZGRyZXNzIC8gcmVnLW5hbWVcbiAgICBjb25zdCBwb3J0ID0gJ1xcXFxkKic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3J0ID0gKkRJR0lUXG4gICAgY29uc3QgYXV0aG9yaXR5ID0gJyg/OicgKyB1c2VyaW5mbyArICdAKT8nICsgaG9zdCArICcoPzo6JyArIHBvcnQgKyAnKT8nOyAgICAgICAgICAgICAgIC8vIGF1dGhvcml0eSAgID0gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF1cbiAgICBjb25zdCBhdXRob3JpdHlDYXB0dXJlID0gJyg/OicgKyB1c2VyaW5mbyArICdAKT8oJyArIGhvc3QgKyAnKSg/OjonICsgcG9ydCArICcpPyc7XG5cbiAgICAvKlxuICAgICAgICBzZWdtZW50ICAgICAgID0gKnBjaGFyXG4gICAgICAgIHNlZ21lbnQtbnogICAgPSAxKnBjaGFyXG4gICAgICAgIHBhdGggICAgICAgICAgPSBwYXRoLWFiZW1wdHkgICAgOyBiZWdpbnMgd2l0aCBcIi9cIiAnfCcgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLWFic29sdXRlICAgOyBiZWdpbnMgd2l0aCBcIi9cIiBidXQgbm90IFwiLy9cIlxuICAgICAgICAgICAgICAgICAgICAvIHBhdGgtbm9zY2hlbWUgICA7IGJlZ2lucyB3aXRoIGEgbm9uLWNvbG9uIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLXJvb3RsZXNzICAgOyBiZWdpbnMgd2l0aCBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLWVtcHR5ICAgICAgOyB6ZXJvIGNoYXJhY3RlcnNcbiAgICAgICAgcGF0aC1hYmVtcHR5ICA9ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICAgICBwYXRoLWFic29sdXRlID0gXCIvXCIgWyBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKSBdXG4gICAgICAgIHBhdGgtcm9vdGxlc3MgPSBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICovXG5cbiAgICBjb25zdCBzZWdtZW50ID0gcGNoYXJPbmx5ICsgJyonO1xuICAgIGNvbnN0IHNlZ21lbnROeiA9IHBjaGFyT25seSArICcrJztcbiAgICBjb25zdCBzZWdtZW50TnpOYyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ0AnICsgJ10rJztcbiAgICBjb25zdCBwYXRoRW1wdHkgPSAnJztcbiAgICBjb25zdCBwYXRoQWJFbXB0eSA9ICcoPzpcXFxcLycgKyBzZWdtZW50ICsgJykqJztcbiAgICBjb25zdCBwYXRoQWJzb2x1dGUgPSAnXFxcXC8oPzonICsgc2VnbWVudE56ICsgcGF0aEFiRW1wdHkgKyAnKT8nO1xuICAgIGNvbnN0IHBhdGhSb290bGVzcyA9IHNlZ21lbnROeiArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhOb1NjaGVtZSA9IHNlZ21lbnROek5jICsgcGF0aEFiRW1wdHk7XG4gICAgY29uc3QgcGF0aEFiTm9BdXRob3JpdHkgPSAnKD86XFxcXC9cXFxcL1xcXFwvJyArIHNlZ21lbnQgKyBwYXRoQWJFbXB0eSArICcpJzsgICAgIC8vIFVzZWQgYnkgZmlsZTovLy9cblxuICAgIC8vIGhpZXItcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aFxuXG4gICAgcmZjMzk4Ni5oaWVyUGFydCA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoUm9vdGxlc3MgKyAnfCcgKyBwYXRoQWJOb0F1dGhvcml0eSArICcpJztcbiAgICByZmMzOTg2LmhpZXJQYXJ0Q2FwdHVyZSA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5Q2FwdHVyZSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aFJvb3RsZXNzICsgJyknO1xuXG4gICAgLy8gcmVsYXRpdmUtcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5IC8gcGF0aC1hYnNvbHV0ZSAvIHBhdGgtbm9zY2hlbWUgLyBwYXRoLWVtcHR5XG5cbiAgICByZmMzOTg2LnJlbGF0aXZlUmVmID0gJyg/OicgKyAnKD86XFxcXC9cXFxcLycgKyBhdXRob3JpdHkgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhOb1NjaGVtZSArICd8JyArIHBhdGhFbXB0eSArICcpJztcbiAgICByZmMzOTg2LnJlbGF0aXZlUmVmQ2FwdHVyZSA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5Q2FwdHVyZSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aE5vU2NoZW1lICsgJ3wnICsgcGF0aEVtcHR5ICsgJyknO1xuXG4gICAgLy8gcXVlcnkgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuICAgIC8vIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIltcIiAvIFwiXVwiIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LnF1ZXJ5ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCAnfCcgZW5kIG9mIHRoZSBsaW5lLlxuICAgIHJmYzM5ODYucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgPSAnWycgKyBwY2hhciArICdcXFxcW1xcXFxdXFxcXC9cXFxcP10qKD89I3wkKSc7XG5cbiAgICAvLyBmcmFnbWVudCA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LmZyYWdtZW50ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qJztcblxuICAgIHJldHVybiByZmMzOTg2O1xufTtcblxuaW50ZXJuYWxzLnJmYzM5ODYgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoKTtcblxuXG5leHBvcnRzLmlwID0ge1xuICAgIHY0Q2lkcjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NENpZHIsXG4gICAgdjZDaWRyOiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY2Q2lkcixcbiAgICBpcHY0OiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY0YWRkcmVzcyxcbiAgICBpcHY2OiBpbnRlcm5hbHMucmZjMzk4Ni5pcHY2YWRkcmVzcyxcbiAgICBpcHZmdXR1cmU6IGludGVybmFscy5yZmMzOTg2LmlwdkZ1dHVyZVxufTtcblxuXG5pbnRlcm5hbHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgY29uc3QgcmZjID0gaW50ZXJuYWxzLnJmYzM5ODY7XG5cbiAgICAvLyBDb25zdHJ1Y3QgZXhwcmVzc2lvblxuXG4gICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyA/IHJmYy5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA6IHJmYy5xdWVyeTtcbiAgICBjb25zdCBzdWZmaXggPSAnKD86XFxcXD8nICsgcXVlcnkgKyAnKT8nICsgJyg/OiMnICsgcmZjLmZyYWdtZW50ICsgJyk/JztcblxuICAgIC8vIHJlbGF0aXZlLXJlZiA9IHJlbGF0aXZlLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgY29uc3QgcmVsYXRpdmUgPSBvcHRpb25zLmRvbWFpbiA/IHJmYy5yZWxhdGl2ZVJlZkNhcHR1cmUgOiByZmMucmVsYXRpdmVSZWY7XG5cbiAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHJlbGF0aXZlICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gc2NoZW1lc1xuXG4gICAgbGV0IGN1c3RvbVNjaGVtZSA9ICcnO1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5zY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIG9wdGlvbnMuc2NoZW1lID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1lKSwgJ3NjaGVtZSBtdXN0IGJlIGEgUmVnRXhwLCBTdHJpbmcsIG9yIEFycmF5Jyk7XG5cbiAgICAgICAgY29uc3Qgc2NoZW1lcyA9IFtdLmNvbmNhdChvcHRpb25zLnNjaGVtZSk7XG4gICAgICAgIEFzc2VydChzY2hlbWVzLmxlbmd0aCA+PSAxLCAnc2NoZW1lIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHNjaGVtZSBzcGVjaWZpZWQnKTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHRvIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNjaGVtZXNcblxuICAgICAgICBjb25zdCBzZWxlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gc2NoZW1lc1tpXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycsICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBSZWdFeHAgb3IgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2goc2NoZW1lLnNvdXJjZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEFzc2VydChyZmMuc2NoZW1lUmVnZXgudGVzdChzY2hlbWUpLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgdmFsaWQgc2NoZW1lJyk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKEVzY2FwZVJlZ2V4KHNjaGVtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VzdG9tU2NoZW1lID0gc2VsZWN0aW9ucy5qb2luKCd8Jyk7XG4gICAgfVxuXG4gICAgLy8gVVJJID0gc2NoZW1lIFwiOlwiIGhpZXItcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG5cbiAgICBjb25zdCBzY2hlbWUgPSBjdXN0b21TY2hlbWUgPyAnKD86JyArIGN1c3RvbVNjaGVtZSArICcpJyA6IHJmYy5zY2hlbWU7XG4gICAgY29uc3QgYWJzb2x1dGUgPSAnKD86JyArIHNjaGVtZSArICc6JyArIChvcHRpb25zLmRvbWFpbiA/IHJmYy5oaWVyUGFydENhcHR1cmUgOiByZmMuaGllclBhcnQpICsgJyknO1xuICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSA/ICcoPzonICsgYWJzb2x1dGUgKyAnfCcgKyByZWxhdGl2ZSArICcpJyA6IGFic29sdXRlO1xuICAgIHJldHVybiBpbnRlcm5hbHMud3JhcChwcmVmaXggKyBzdWZmaXgsIGN1c3RvbVNjaGVtZSk7XG59O1xuXG5cbmludGVybmFscy53cmFwID0gZnVuY3Rpb24gKHJhdywgc2NoZW1lKSB7XG5cbiAgICByYXcgPSBgKD89LikoPyFodHRwcz9cXDovKD86JHxbXi9dKSkoPyFodHRwcz9cXDovLy8pKD8haHR0cHM/XFw6W14vXSkke3Jhd31gOyAgICAgLy8gUmVxdWlyZSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFuZCBleHBsaWNpdGx5IGZvcmJpZCAnaHR0cDovJyBvciBIVFRQIHdpdGggZW1wdHkgZG9tYWluXG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYXcsXG4gICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGBeJHtyYXd9JGApLFxuICAgICAgICBzY2hlbWVcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMudXJpUmVnZXggPSBpbnRlcm5hbHMuY3JlYXRlUmVnZXgoe30pO1xuXG5cbmV4cG9ydHMucmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWUgfHxcbiAgICAgICAgb3B0aW9ucy5hbGxvd1JlbGF0aXZlIHx8XG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmVPbmx5IHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzIHx8XG4gICAgICAgIG9wdGlvbnMuZG9tYWluKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVSZWdleChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnVyaVJlZ2V4O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBVcmkgPSByZXF1aXJlKCcuL3VyaScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMucmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAvLyBDSURSXG5cbiAgICBBc3NlcnQob3B0aW9ucy5jaWRyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMuY2lkciA9PT0gJ3N0cmluZycsICdvcHRpb25zLmNpZHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGNvbnN0IGNpZHIgPSBvcHRpb25zLmNpZHIgPyBvcHRpb25zLmNpZHIudG9Mb3dlckNhc2UoKSA6ICdvcHRpb25hbCc7XG4gICAgQXNzZXJ0KFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMoY2lkciksICdvcHRpb25zLmNpZHIgbXVzdCBiZSBvbmUgb2YgcmVxdWlyZWQsIG9wdGlvbmFsLCBmb3JiaWRkZW4nKTtcblxuICAgIC8vIFZlcnNpb25zXG5cbiAgICBBc3NlcnQob3B0aW9ucy52ZXJzaW9uID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMudmVyc2lvbiA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnZlcnNpb24pLCAnb3B0aW9ucy52ZXJzaW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nJyk7XG4gICAgbGV0IHZlcnNpb25zID0gb3B0aW9ucy52ZXJzaW9uIHx8IFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHtcbiAgICAgICAgdmVyc2lvbnMgPSBbdmVyc2lvbnNdO1xuICAgIH1cblxuICAgIEFzc2VydCh2ZXJzaW9ucy5sZW5ndGggPj0gMSwgJ29wdGlvbnMudmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb25zW2ldID09PSAnc3RyaW5nJywgJ29wdGlvbnMudmVyc2lvbiBtdXN0IG9ubHkgY29udGFpbiBzdHJpbmdzJyk7XG4gICAgICAgIHZlcnNpb25zW2ldID0gdmVyc2lvbnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgQXNzZXJ0KFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddLmluY2x1ZGVzKHZlcnNpb25zW2ldKSwgJ29wdGlvbnMudmVyc2lvbiBjb250YWlucyB1bmtub3duIHZlcnNpb24gJyArIHZlcnNpb25zW2ldICsgJyAtIG11c3QgYmUgb25lIG9mIGlwdjQsIGlwdjYsIGlwdmZ1dHVyZScpO1xuICAgIH1cblxuICAgIHZlcnNpb25zID0gQXJyYXkuZnJvbShuZXcgU2V0KHZlcnNpb25zKSk7XG5cbiAgICAvLyBSZWdleFxuXG4gICAgY29uc3QgcGFydHMgPSB2ZXJzaW9ucy5tYXAoKHZlcnNpb24pID0+IHtcblxuICAgICAgICAvLyBGb3JiaWRkZW5cblxuICAgICAgICBpZiAoY2lkciA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiBVcmkuaXBbdmVyc2lvbl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXF1aXJlZFxuXG4gICAgICAgIGNvbnN0IGNpZHJwYXJ0ID0gYFxcXFwvJHt2ZXJzaW9uID09PSAnaXB2NCcgPyBVcmkuaXAudjRDaWRyIDogVXJpLmlwLnY2Q2lkcn1gO1xuXG4gICAgICAgIGlmIChjaWRyID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7VXJpLmlwW3ZlcnNpb25dfSR7Y2lkcnBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsXG5cbiAgICAgICAgcmV0dXJuIGAke1VyaS5pcFt2ZXJzaW9uXX0oPzoke2NpZHJwYXJ0fSk/YDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJhdyA9IGAoPzoke3BhcnRzLmpvaW4oJ3wnKX0pYDtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke3Jhd30kYCk7XG4gICAgcmV0dXJuIHsgY2lkciwgdmVyc2lvbnMsIHJlZ2V4LCByYXcgfTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBodHRwOi8vZGF0YS5pYW5hLm9yZy9UTEQvdGxkcy1hbHBoYS1ieS1kb21haW4udHh0XG4vLyAjIFZlcnNpb24gMjAyNDAxMjkwMCwgTGFzdCBVcGRhdGVkIE1vbiBKYW4gMjkgMDc6MDc6MDEgMjAyNCBVVENcblxuXG5pbnRlcm5hbHMudGxkcyA9IFtcbiAgICAnQUFBJyxcbiAgICAnQUFSUCcsXG4gICAgJ0FCQicsXG4gICAgJ0FCQk9UVCcsXG4gICAgJ0FCQlZJRScsXG4gICAgJ0FCQycsXG4gICAgJ0FCTEUnLFxuICAgICdBQk9HQURPJyxcbiAgICAnQUJVREhBQkknLFxuICAgICdBQycsXG4gICAgJ0FDQURFTVknLFxuICAgICdBQ0NFTlRVUkUnLFxuICAgICdBQ0NPVU5UQU5UJyxcbiAgICAnQUNDT1VOVEFOVFMnLFxuICAgICdBQ08nLFxuICAgICdBQ1RPUicsXG4gICAgJ0FEJyxcbiAgICAnQURTJyxcbiAgICAnQURVTFQnLFxuICAgICdBRScsXG4gICAgJ0FFRycsXG4gICAgJ0FFUk8nLFxuICAgICdBRVROQScsXG4gICAgJ0FGJyxcbiAgICAnQUZMJyxcbiAgICAnQUZSSUNBJyxcbiAgICAnQUcnLFxuICAgICdBR0FLSEFOJyxcbiAgICAnQUdFTkNZJyxcbiAgICAnQUknLFxuICAgICdBSUcnLFxuICAgICdBSVJCVVMnLFxuICAgICdBSVJGT1JDRScsXG4gICAgJ0FJUlRFTCcsXG4gICAgJ0FLRE4nLFxuICAgICdBTCcsXG4gICAgJ0FMSUJBQkEnLFxuICAgICdBTElQQVknLFxuICAgICdBTExGSU5BTlonLFxuICAgICdBTExTVEFURScsXG4gICAgJ0FMTFknLFxuICAgICdBTFNBQ0UnLFxuICAgICdBTFNUT00nLFxuICAgICdBTScsXG4gICAgJ0FNQVpPTicsXG4gICAgJ0FNRVJJQ0FORVhQUkVTUycsXG4gICAgJ0FNRVJJQ0FORkFNSUxZJyxcbiAgICAnQU1FWCcsXG4gICAgJ0FNRkFNJyxcbiAgICAnQU1JQ0EnLFxuICAgICdBTVNURVJEQU0nLFxuICAgICdBTkFMWVRJQ1MnLFxuICAgICdBTkRST0lEJyxcbiAgICAnQU5RVUFOJyxcbiAgICAnQU5aJyxcbiAgICAnQU8nLFxuICAgICdBT0wnLFxuICAgICdBUEFSVE1FTlRTJyxcbiAgICAnQVBQJyxcbiAgICAnQVBQTEUnLFxuICAgICdBUScsXG4gICAgJ0FRVUFSRUxMRScsXG4gICAgJ0FSJyxcbiAgICAnQVJBQicsXG4gICAgJ0FSQU1DTycsXG4gICAgJ0FSQ0hJJyxcbiAgICAnQVJNWScsXG4gICAgJ0FSUEEnLFxuICAgICdBUlQnLFxuICAgICdBUlRFJyxcbiAgICAnQVMnLFxuICAgICdBU0RBJyxcbiAgICAnQVNJQScsXG4gICAgJ0FTU09DSUFURVMnLFxuICAgICdBVCcsXG4gICAgJ0FUSExFVEEnLFxuICAgICdBVFRPUk5FWScsXG4gICAgJ0FVJyxcbiAgICAnQVVDVElPTicsXG4gICAgJ0FVREknLFxuICAgICdBVURJQkxFJyxcbiAgICAnQVVESU8nLFxuICAgICdBVVNQT1NUJyxcbiAgICAnQVVUSE9SJyxcbiAgICAnQVVUTycsXG4gICAgJ0FVVE9TJyxcbiAgICAnQVZJQU5DQScsXG4gICAgJ0FXJyxcbiAgICAnQVdTJyxcbiAgICAnQVgnLFxuICAgICdBWEEnLFxuICAgICdBWicsXG4gICAgJ0FaVVJFJyxcbiAgICAnQkEnLFxuICAgICdCQUJZJyxcbiAgICAnQkFJRFUnLFxuICAgICdCQU5BTUVYJyxcbiAgICAnQkFORCcsXG4gICAgJ0JBTksnLFxuICAgICdCQVInLFxuICAgICdCQVJDRUxPTkEnLFxuICAgICdCQVJDTEFZQ0FSRCcsXG4gICAgJ0JBUkNMQVlTJyxcbiAgICAnQkFSRUZPT1QnLFxuICAgICdCQVJHQUlOUycsXG4gICAgJ0JBU0VCQUxMJyxcbiAgICAnQkFTS0VUQkFMTCcsXG4gICAgJ0JBVUhBVVMnLFxuICAgICdCQVlFUk4nLFxuICAgICdCQicsXG4gICAgJ0JCQycsXG4gICAgJ0JCVCcsXG4gICAgJ0JCVkEnLFxuICAgICdCQ0cnLFxuICAgICdCQ04nLFxuICAgICdCRCcsXG4gICAgJ0JFJyxcbiAgICAnQkVBVFMnLFxuICAgICdCRUFVVFknLFxuICAgICdCRUVSJyxcbiAgICAnQkVOVExFWScsXG4gICAgJ0JFUkxJTicsXG4gICAgJ0JFU1QnLFxuICAgICdCRVNUQlVZJyxcbiAgICAnQkVUJyxcbiAgICAnQkYnLFxuICAgICdCRycsXG4gICAgJ0JIJyxcbiAgICAnQkhBUlRJJyxcbiAgICAnQkknLFxuICAgICdCSUJMRScsXG4gICAgJ0JJRCcsXG4gICAgJ0JJS0UnLFxuICAgICdCSU5HJyxcbiAgICAnQklOR08nLFxuICAgICdCSU8nLFxuICAgICdCSVonLFxuICAgICdCSicsXG4gICAgJ0JMQUNLJyxcbiAgICAnQkxBQ0tGUklEQVknLFxuICAgICdCTE9DS0JVU1RFUicsXG4gICAgJ0JMT0cnLFxuICAgICdCTE9PTUJFUkcnLFxuICAgICdCTFVFJyxcbiAgICAnQk0nLFxuICAgICdCTVMnLFxuICAgICdCTVcnLFxuICAgICdCTicsXG4gICAgJ0JOUFBBUklCQVMnLFxuICAgICdCTycsXG4gICAgJ0JPQVRTJyxcbiAgICAnQk9FSFJJTkdFUicsXG4gICAgJ0JPRkEnLFxuICAgICdCT00nLFxuICAgICdCT05EJyxcbiAgICAnQk9PJyxcbiAgICAnQk9PSycsXG4gICAgJ0JPT0tJTkcnLFxuICAgICdCT1NDSCcsXG4gICAgJ0JPU1RJSycsXG4gICAgJ0JPU1RPTicsXG4gICAgJ0JPVCcsXG4gICAgJ0JPVVRJUVVFJyxcbiAgICAnQk9YJyxcbiAgICAnQlInLFxuICAgICdCUkFERVNDTycsXG4gICAgJ0JSSURHRVNUT05FJyxcbiAgICAnQlJPQURXQVknLFxuICAgICdCUk9LRVInLFxuICAgICdCUk9USEVSJyxcbiAgICAnQlJVU1NFTFMnLFxuICAgICdCUycsXG4gICAgJ0JUJyxcbiAgICAnQlVJTEQnLFxuICAgICdCVUlMREVSUycsXG4gICAgJ0JVU0lORVNTJyxcbiAgICAnQlVZJyxcbiAgICAnQlVaWicsXG4gICAgJ0JWJyxcbiAgICAnQlcnLFxuICAgICdCWScsXG4gICAgJ0JaJyxcbiAgICAnQlpIJyxcbiAgICAnQ0EnLFxuICAgICdDQUInLFxuICAgICdDQUZFJyxcbiAgICAnQ0FMJyxcbiAgICAnQ0FMTCcsXG4gICAgJ0NBTFZJTktMRUlOJyxcbiAgICAnQ0FNJyxcbiAgICAnQ0FNRVJBJyxcbiAgICAnQ0FNUCcsXG4gICAgJ0NBTk9OJyxcbiAgICAnQ0FQRVRPV04nLFxuICAgICdDQVBJVEFMJyxcbiAgICAnQ0FQSVRBTE9ORScsXG4gICAgJ0NBUicsXG4gICAgJ0NBUkFWQU4nLFxuICAgICdDQVJEUycsXG4gICAgJ0NBUkUnLFxuICAgICdDQVJFRVInLFxuICAgICdDQVJFRVJTJyxcbiAgICAnQ0FSUycsXG4gICAgJ0NBU0EnLFxuICAgICdDQVNFJyxcbiAgICAnQ0FTSCcsXG4gICAgJ0NBU0lOTycsXG4gICAgJ0NBVCcsXG4gICAgJ0NBVEVSSU5HJyxcbiAgICAnQ0FUSE9MSUMnLFxuICAgICdDQkEnLFxuICAgICdDQk4nLFxuICAgICdDQlJFJyxcbiAgICAnQ0MnLFxuICAgICdDRCcsXG4gICAgJ0NFTlRFUicsXG4gICAgJ0NFTycsXG4gICAgJ0NFUk4nLFxuICAgICdDRicsXG4gICAgJ0NGQScsXG4gICAgJ0NGRCcsXG4gICAgJ0NHJyxcbiAgICAnQ0gnLFxuICAgICdDSEFORUwnLFxuICAgICdDSEFOTkVMJyxcbiAgICAnQ0hBUklUWScsXG4gICAgJ0NIQVNFJyxcbiAgICAnQ0hBVCcsXG4gICAgJ0NIRUFQJyxcbiAgICAnQ0hJTlRBSScsXG4gICAgJ0NIUklTVE1BUycsXG4gICAgJ0NIUk9NRScsXG4gICAgJ0NIVVJDSCcsXG4gICAgJ0NJJyxcbiAgICAnQ0lQUklBTkknLFxuICAgICdDSVJDTEUnLFxuICAgICdDSVNDTycsXG4gICAgJ0NJVEFERUwnLFxuICAgICdDSVRJJyxcbiAgICAnQ0lUSUMnLFxuICAgICdDSVRZJyxcbiAgICAnQ0snLFxuICAgICdDTCcsXG4gICAgJ0NMQUlNUycsXG4gICAgJ0NMRUFOSU5HJyxcbiAgICAnQ0xJQ0snLFxuICAgICdDTElOSUMnLFxuICAgICdDTElOSVFVRScsXG4gICAgJ0NMT1RISU5HJyxcbiAgICAnQ0xPVUQnLFxuICAgICdDTFVCJyxcbiAgICAnQ0xVQk1FRCcsXG4gICAgJ0NNJyxcbiAgICAnQ04nLFxuICAgICdDTycsXG4gICAgJ0NPQUNIJyxcbiAgICAnQ09ERVMnLFxuICAgICdDT0ZGRUUnLFxuICAgICdDT0xMRUdFJyxcbiAgICAnQ09MT0dORScsXG4gICAgJ0NPTScsXG4gICAgJ0NPTUNBU1QnLFxuICAgICdDT01NQkFOSycsXG4gICAgJ0NPTU1VTklUWScsXG4gICAgJ0NPTVBBTlknLFxuICAgICdDT01QQVJFJyxcbiAgICAnQ09NUFVURVInLFxuICAgICdDT01TRUMnLFxuICAgICdDT05ET1MnLFxuICAgICdDT05TVFJVQ1RJT04nLFxuICAgICdDT05TVUxUSU5HJyxcbiAgICAnQ09OVEFDVCcsXG4gICAgJ0NPTlRSQUNUT1JTJyxcbiAgICAnQ09PS0lORycsXG4gICAgJ0NPT0wnLFxuICAgICdDT09QJyxcbiAgICAnQ09SU0lDQScsXG4gICAgJ0NPVU5UUlknLFxuICAgICdDT1VQT04nLFxuICAgICdDT1VQT05TJyxcbiAgICAnQ09VUlNFUycsXG4gICAgJ0NQQScsXG4gICAgJ0NSJyxcbiAgICAnQ1JFRElUJyxcbiAgICAnQ1JFRElUQ0FSRCcsXG4gICAgJ0NSRURJVFVOSU9OJyxcbiAgICAnQ1JJQ0tFVCcsXG4gICAgJ0NST1dOJyxcbiAgICAnQ1JTJyxcbiAgICAnQ1JVSVNFJyxcbiAgICAnQ1JVSVNFUycsXG4gICAgJ0NVJyxcbiAgICAnQ1VJU0lORUxMQScsXG4gICAgJ0NWJyxcbiAgICAnQ1cnLFxuICAgICdDWCcsXG4gICAgJ0NZJyxcbiAgICAnQ1lNUlUnLFxuICAgICdDWU9VJyxcbiAgICAnQ1onLFxuICAgICdEQUJVUicsXG4gICAgJ0RBRCcsXG4gICAgJ0RBTkNFJyxcbiAgICAnREFUQScsXG4gICAgJ0RBVEUnLFxuICAgICdEQVRJTkcnLFxuICAgICdEQVRTVU4nLFxuICAgICdEQVknLFxuICAgICdEQ0xLJyxcbiAgICAnRERTJyxcbiAgICAnREUnLFxuICAgICdERUFMJyxcbiAgICAnREVBTEVSJyxcbiAgICAnREVBTFMnLFxuICAgICdERUdSRUUnLFxuICAgICdERUxJVkVSWScsXG4gICAgJ0RFTEwnLFxuICAgICdERUxPSVRURScsXG4gICAgJ0RFTFRBJyxcbiAgICAnREVNT0NSQVQnLFxuICAgICdERU5UQUwnLFxuICAgICdERU5USVNUJyxcbiAgICAnREVTSScsXG4gICAgJ0RFU0lHTicsXG4gICAgJ0RFVicsXG4gICAgJ0RITCcsXG4gICAgJ0RJQU1PTkRTJyxcbiAgICAnRElFVCcsXG4gICAgJ0RJR0lUQUwnLFxuICAgICdESVJFQ1QnLFxuICAgICdESVJFQ1RPUlknLFxuICAgICdESVNDT1VOVCcsXG4gICAgJ0RJU0NPVkVSJyxcbiAgICAnRElTSCcsXG4gICAgJ0RJWScsXG4gICAgJ0RKJyxcbiAgICAnREsnLFxuICAgICdETScsXG4gICAgJ0ROUCcsXG4gICAgJ0RPJyxcbiAgICAnRE9DUycsXG4gICAgJ0RPQ1RPUicsXG4gICAgJ0RPRycsXG4gICAgJ0RPTUFJTlMnLFxuICAgICdET1QnLFxuICAgICdET1dOTE9BRCcsXG4gICAgJ0RSSVZFJyxcbiAgICAnRFRWJyxcbiAgICAnRFVCQUknLFxuICAgICdEVU5MT1AnLFxuICAgICdEVVBPTlQnLFxuICAgICdEVVJCQU4nLFxuICAgICdEVkFHJyxcbiAgICAnRFZSJyxcbiAgICAnRFonLFxuICAgICdFQVJUSCcsXG4gICAgJ0VBVCcsXG4gICAgJ0VDJyxcbiAgICAnRUNPJyxcbiAgICAnRURFS0EnLFxuICAgICdFRFUnLFxuICAgICdFRFVDQVRJT04nLFxuICAgICdFRScsXG4gICAgJ0VHJyxcbiAgICAnRU1BSUwnLFxuICAgICdFTUVSQ0snLFxuICAgICdFTkVSR1knLFxuICAgICdFTkdJTkVFUicsXG4gICAgJ0VOR0lORUVSSU5HJyxcbiAgICAnRU5URVJQUklTRVMnLFxuICAgICdFUFNPTicsXG4gICAgJ0VRVUlQTUVOVCcsXG4gICAgJ0VSJyxcbiAgICAnRVJJQ1NTT04nLFxuICAgICdFUk5JJyxcbiAgICAnRVMnLFxuICAgICdFU1EnLFxuICAgICdFU1RBVEUnLFxuICAgICdFVCcsXG4gICAgJ0VVJyxcbiAgICAnRVVST1ZJU0lPTicsXG4gICAgJ0VVUycsXG4gICAgJ0VWRU5UUycsXG4gICAgJ0VYQ0hBTkdFJyxcbiAgICAnRVhQRVJUJyxcbiAgICAnRVhQT1NFRCcsXG4gICAgJ0VYUFJFU1MnLFxuICAgICdFWFRSQVNQQUNFJyxcbiAgICAnRkFHRScsXG4gICAgJ0ZBSUwnLFxuICAgICdGQUlSV0lORFMnLFxuICAgICdGQUlUSCcsXG4gICAgJ0ZBTUlMWScsXG4gICAgJ0ZBTicsXG4gICAgJ0ZBTlMnLFxuICAgICdGQVJNJyxcbiAgICAnRkFSTUVSUycsXG4gICAgJ0ZBU0hJT04nLFxuICAgICdGQVNUJyxcbiAgICAnRkVERVgnLFxuICAgICdGRUVEQkFDSycsXG4gICAgJ0ZFUlJBUkknLFxuICAgICdGRVJSRVJPJyxcbiAgICAnRkknLFxuICAgICdGSURFTElUWScsXG4gICAgJ0ZJRE8nLFxuICAgICdGSUxNJyxcbiAgICAnRklOQUwnLFxuICAgICdGSU5BTkNFJyxcbiAgICAnRklOQU5DSUFMJyxcbiAgICAnRklSRScsXG4gICAgJ0ZJUkVTVE9ORScsXG4gICAgJ0ZJUk1EQUxFJyxcbiAgICAnRklTSCcsXG4gICAgJ0ZJU0hJTkcnLFxuICAgICdGSVQnLFxuICAgICdGSVRORVNTJyxcbiAgICAnRkonLFxuICAgICdGSycsXG4gICAgJ0ZMSUNLUicsXG4gICAgJ0ZMSUdIVFMnLFxuICAgICdGTElSJyxcbiAgICAnRkxPUklTVCcsXG4gICAgJ0ZMT1dFUlMnLFxuICAgICdGTFknLFxuICAgICdGTScsXG4gICAgJ0ZPJyxcbiAgICAnRk9PJyxcbiAgICAnRk9PRCcsXG4gICAgJ0ZPT1RCQUxMJyxcbiAgICAnRk9SRCcsXG4gICAgJ0ZPUkVYJyxcbiAgICAnRk9SU0FMRScsXG4gICAgJ0ZPUlVNJyxcbiAgICAnRk9VTkRBVElPTicsXG4gICAgJ0ZPWCcsXG4gICAgJ0ZSJyxcbiAgICAnRlJFRScsXG4gICAgJ0ZSRVNFTklVUycsXG4gICAgJ0ZSTCcsXG4gICAgJ0ZST0dBTlMnLFxuICAgICdGUk9OVElFUicsXG4gICAgJ0ZUUicsXG4gICAgJ0ZVSklUU1UnLFxuICAgICdGVU4nLFxuICAgICdGVU5EJyxcbiAgICAnRlVSTklUVVJFJyxcbiAgICAnRlVUQk9MJyxcbiAgICAnRllJJyxcbiAgICAnR0EnLFxuICAgICdHQUwnLFxuICAgICdHQUxMRVJZJyxcbiAgICAnR0FMTE8nLFxuICAgICdHQUxMVVAnLFxuICAgICdHQU1FJyxcbiAgICAnR0FNRVMnLFxuICAgICdHQVAnLFxuICAgICdHQVJERU4nLFxuICAgICdHQVknLFxuICAgICdHQicsXG4gICAgJ0dCSVonLFxuICAgICdHRCcsXG4gICAgJ0dETicsXG4gICAgJ0dFJyxcbiAgICAnR0VBJyxcbiAgICAnR0VOVCcsXG4gICAgJ0dFTlRJTkcnLFxuICAgICdHRU9SR0UnLFxuICAgICdHRicsXG4gICAgJ0dHJyxcbiAgICAnR0dFRScsXG4gICAgJ0dIJyxcbiAgICAnR0knLFxuICAgICdHSUZUJyxcbiAgICAnR0lGVFMnLFxuICAgICdHSVZFUycsXG4gICAgJ0dJVklORycsXG4gICAgJ0dMJyxcbiAgICAnR0xBU1MnLFxuICAgICdHTEUnLFxuICAgICdHTE9CQUwnLFxuICAgICdHTE9CTycsXG4gICAgJ0dNJyxcbiAgICAnR01BSUwnLFxuICAgICdHTUJIJyxcbiAgICAnR01PJyxcbiAgICAnR01YJyxcbiAgICAnR04nLFxuICAgICdHT0RBRERZJyxcbiAgICAnR09MRCcsXG4gICAgJ0dPTERQT0lOVCcsXG4gICAgJ0dPTEYnLFxuICAgICdHT08nLFxuICAgICdHT09EWUVBUicsXG4gICAgJ0dPT0cnLFxuICAgICdHT09HTEUnLFxuICAgICdHT1AnLFxuICAgICdHT1QnLFxuICAgICdHT1YnLFxuICAgICdHUCcsXG4gICAgJ0dRJyxcbiAgICAnR1InLFxuICAgICdHUkFJTkdFUicsXG4gICAgJ0dSQVBISUNTJyxcbiAgICAnR1JBVElTJyxcbiAgICAnR1JFRU4nLFxuICAgICdHUklQRScsXG4gICAgJ0dST0NFUlknLFxuICAgICdHUk9VUCcsXG4gICAgJ0dTJyxcbiAgICAnR1QnLFxuICAgICdHVScsXG4gICAgJ0dVQVJESUFOJyxcbiAgICAnR1VDQ0knLFxuICAgICdHVUdFJyxcbiAgICAnR1VJREUnLFxuICAgICdHVUlUQVJTJyxcbiAgICAnR1VSVScsXG4gICAgJ0dXJyxcbiAgICAnR1knLFxuICAgICdIQUlSJyxcbiAgICAnSEFNQlVSRycsXG4gICAgJ0hBTkdPVVQnLFxuICAgICdIQVVTJyxcbiAgICAnSEJPJyxcbiAgICAnSERGQycsXG4gICAgJ0hERkNCQU5LJyxcbiAgICAnSEVBTFRIJyxcbiAgICAnSEVBTFRIQ0FSRScsXG4gICAgJ0hFTFAnLFxuICAgICdIRUxTSU5LSScsXG4gICAgJ0hFUkUnLFxuICAgICdIRVJNRVMnLFxuICAgICdISVBIT1AnLFxuICAgICdISVNBTUlUU1UnLFxuICAgICdISVRBQ0hJJyxcbiAgICAnSElWJyxcbiAgICAnSEsnLFxuICAgICdIS1QnLFxuICAgICdITScsXG4gICAgJ0hOJyxcbiAgICAnSE9DS0VZJyxcbiAgICAnSE9MRElOR1MnLFxuICAgICdIT0xJREFZJyxcbiAgICAnSE9NRURFUE9UJyxcbiAgICAnSE9NRUdPT0RTJyxcbiAgICAnSE9NRVMnLFxuICAgICdIT01FU0VOU0UnLFxuICAgICdIT05EQScsXG4gICAgJ0hPUlNFJyxcbiAgICAnSE9TUElUQUwnLFxuICAgICdIT1NUJyxcbiAgICAnSE9TVElORycsXG4gICAgJ0hPVCcsXG4gICAgJ0hPVEVMUycsXG4gICAgJ0hPVE1BSUwnLFxuICAgICdIT1VTRScsXG4gICAgJ0hPVycsXG4gICAgJ0hSJyxcbiAgICAnSFNCQycsXG4gICAgJ0hUJyxcbiAgICAnSFUnLFxuICAgICdIVUdIRVMnLFxuICAgICdIWUFUVCcsXG4gICAgJ0hZVU5EQUknLFxuICAgICdJQk0nLFxuICAgICdJQ0JDJyxcbiAgICAnSUNFJyxcbiAgICAnSUNVJyxcbiAgICAnSUQnLFxuICAgICdJRScsXG4gICAgJ0lFRUUnLFxuICAgICdJRk0nLFxuICAgICdJS0FOTycsXG4gICAgJ0lMJyxcbiAgICAnSU0nLFxuICAgICdJTUFNQVQnLFxuICAgICdJTURCJyxcbiAgICAnSU1NTycsXG4gICAgJ0lNTU9CSUxJRU4nLFxuICAgICdJTicsXG4gICAgJ0lOQycsXG4gICAgJ0lORFVTVFJJRVMnLFxuICAgICdJTkZJTklUSScsXG4gICAgJ0lORk8nLFxuICAgICdJTkcnLFxuICAgICdJTksnLFxuICAgICdJTlNUSVRVVEUnLFxuICAgICdJTlNVUkFOQ0UnLFxuICAgICdJTlNVUkUnLFxuICAgICdJTlQnLFxuICAgICdJTlRFUk5BVElPTkFMJyxcbiAgICAnSU5UVUlUJyxcbiAgICAnSU5WRVNUTUVOVFMnLFxuICAgICdJTycsXG4gICAgJ0lQSVJBTkdBJyxcbiAgICAnSVEnLFxuICAgICdJUicsXG4gICAgJ0lSSVNIJyxcbiAgICAnSVMnLFxuICAgICdJU01BSUxJJyxcbiAgICAnSVNUJyxcbiAgICAnSVNUQU5CVUwnLFxuICAgICdJVCcsXG4gICAgJ0lUQVUnLFxuICAgICdJVFYnLFxuICAgICdKQUdVQVInLFxuICAgICdKQVZBJyxcbiAgICAnSkNCJyxcbiAgICAnSkUnLFxuICAgICdKRUVQJyxcbiAgICAnSkVUWlQnLFxuICAgICdKRVdFTFJZJyxcbiAgICAnSklPJyxcbiAgICAnSkxMJyxcbiAgICAnSk0nLFxuICAgICdKTVAnLFxuICAgICdKTkonLFxuICAgICdKTycsXG4gICAgJ0pPQlMnLFxuICAgICdKT0JVUkcnLFxuICAgICdKT1QnLFxuICAgICdKT1knLFxuICAgICdKUCcsXG4gICAgJ0pQTU9SR0FOJyxcbiAgICAnSlBSUycsXG4gICAgJ0pVRUdPUycsXG4gICAgJ0pVTklQRVInLFxuICAgICdLQVVGRU4nLFxuICAgICdLRERJJyxcbiAgICAnS0UnLFxuICAgICdLRVJSWUhPVEVMUycsXG4gICAgJ0tFUlJZTE9HSVNUSUNTJyxcbiAgICAnS0VSUllQUk9QRVJUSUVTJyxcbiAgICAnS0ZIJyxcbiAgICAnS0cnLFxuICAgICdLSCcsXG4gICAgJ0tJJyxcbiAgICAnS0lBJyxcbiAgICAnS0lEUycsXG4gICAgJ0tJTScsXG4gICAgJ0tJTkRMRScsXG4gICAgJ0tJVENIRU4nLFxuICAgICdLSVdJJyxcbiAgICAnS00nLFxuICAgICdLTicsXG4gICAgJ0tPRUxOJyxcbiAgICAnS09NQVRTVScsXG4gICAgJ0tPU0hFUicsXG4gICAgJ0tQJyxcbiAgICAnS1BNRycsXG4gICAgJ0tQTicsXG4gICAgJ0tSJyxcbiAgICAnS1JEJyxcbiAgICAnS1JFRCcsXG4gICAgJ0tVT0tHUk9VUCcsXG4gICAgJ0tXJyxcbiAgICAnS1knLFxuICAgICdLWU9UTycsXG4gICAgJ0taJyxcbiAgICAnTEEnLFxuICAgICdMQUNBSVhBJyxcbiAgICAnTEFNQk9SR0hJTkknLFxuICAgICdMQU1FUicsXG4gICAgJ0xBTkNBU1RFUicsXG4gICAgJ0xBTkQnLFxuICAgICdMQU5EUk9WRVInLFxuICAgICdMQU5YRVNTJyxcbiAgICAnTEFTQUxMRScsXG4gICAgJ0xBVCcsXG4gICAgJ0xBVElOTycsXG4gICAgJ0xBVFJPQkUnLFxuICAgICdMQVcnLFxuICAgICdMQVdZRVInLFxuICAgICdMQicsXG4gICAgJ0xDJyxcbiAgICAnTERTJyxcbiAgICAnTEVBU0UnLFxuICAgICdMRUNMRVJDJyxcbiAgICAnTEVGUkFLJyxcbiAgICAnTEVHQUwnLFxuICAgICdMRUdPJyxcbiAgICAnTEVYVVMnLFxuICAgICdMR0JUJyxcbiAgICAnTEknLFxuICAgICdMSURMJyxcbiAgICAnTElGRScsXG4gICAgJ0xJRkVJTlNVUkFOQ0UnLFxuICAgICdMSUZFU1RZTEUnLFxuICAgICdMSUdIVElORycsXG4gICAgJ0xJS0UnLFxuICAgICdMSUxMWScsXG4gICAgJ0xJTUlURUQnLFxuICAgICdMSU1PJyxcbiAgICAnTElOQ09MTicsXG4gICAgJ0xJTksnLFxuICAgICdMSVBTWScsXG4gICAgJ0xJVkUnLFxuICAgICdMSVZJTkcnLFxuICAgICdMSycsXG4gICAgJ0xMQycsXG4gICAgJ0xMUCcsXG4gICAgJ0xPQU4nLFxuICAgICdMT0FOUycsXG4gICAgJ0xPQ0tFUicsXG4gICAgJ0xPQ1VTJyxcbiAgICAnTE9MJyxcbiAgICAnTE9ORE9OJyxcbiAgICAnTE9UVEUnLFxuICAgICdMT1RUTycsXG4gICAgJ0xPVkUnLFxuICAgICdMUEwnLFxuICAgICdMUExGSU5BTkNJQUwnLFxuICAgICdMUicsXG4gICAgJ0xTJyxcbiAgICAnTFQnLFxuICAgICdMVEQnLFxuICAgICdMVERBJyxcbiAgICAnTFUnLFxuICAgICdMVU5EQkVDSycsXG4gICAgJ0xVWEUnLFxuICAgICdMVVhVUlknLFxuICAgICdMVicsXG4gICAgJ0xZJyxcbiAgICAnTUEnLFxuICAgICdNQURSSUQnLFxuICAgICdNQUlGJyxcbiAgICAnTUFJU09OJyxcbiAgICAnTUFLRVVQJyxcbiAgICAnTUFOJyxcbiAgICAnTUFOQUdFTUVOVCcsXG4gICAgJ01BTkdPJyxcbiAgICAnTUFQJyxcbiAgICAnTUFSS0VUJyxcbiAgICAnTUFSS0VUSU5HJyxcbiAgICAnTUFSS0VUUycsXG4gICAgJ01BUlJJT1RUJyxcbiAgICAnTUFSU0hBTExTJyxcbiAgICAnTUFUVEVMJyxcbiAgICAnTUJBJyxcbiAgICAnTUMnLFxuICAgICdNQ0tJTlNFWScsXG4gICAgJ01EJyxcbiAgICAnTUUnLFxuICAgICdNRUQnLFxuICAgICdNRURJQScsXG4gICAgJ01FRVQnLFxuICAgICdNRUxCT1VSTkUnLFxuICAgICdNRU1FJyxcbiAgICAnTUVNT1JJQUwnLFxuICAgICdNRU4nLFxuICAgICdNRU5VJyxcbiAgICAnTUVSQ0tNU0QnLFxuICAgICdNRycsXG4gICAgJ01IJyxcbiAgICAnTUlBTUknLFxuICAgICdNSUNST1NPRlQnLFxuICAgICdNSUwnLFxuICAgICdNSU5JJyxcbiAgICAnTUlOVCcsXG4gICAgJ01JVCcsXG4gICAgJ01JVFNVQklTSEknLFxuICAgICdNSycsXG4gICAgJ01MJyxcbiAgICAnTUxCJyxcbiAgICAnTUxTJyxcbiAgICAnTU0nLFxuICAgICdNTUEnLFxuICAgICdNTicsXG4gICAgJ01PJyxcbiAgICAnTU9CSScsXG4gICAgJ01PQklMRScsXG4gICAgJ01PREEnLFxuICAgICdNT0UnLFxuICAgICdNT0knLFxuICAgICdNT00nLFxuICAgICdNT05BU0gnLFxuICAgICdNT05FWScsXG4gICAgJ01PTlNURVInLFxuICAgICdNT1JNT04nLFxuICAgICdNT1JUR0FHRScsXG4gICAgJ01PU0NPVycsXG4gICAgJ01PVE8nLFxuICAgICdNT1RPUkNZQ0xFUycsXG4gICAgJ01PVicsXG4gICAgJ01PVklFJyxcbiAgICAnTVAnLFxuICAgICdNUScsXG4gICAgJ01SJyxcbiAgICAnTVMnLFxuICAgICdNU0QnLFxuICAgICdNVCcsXG4gICAgJ01UTicsXG4gICAgJ01UUicsXG4gICAgJ01VJyxcbiAgICAnTVVTRVVNJyxcbiAgICAnTVVTSUMnLFxuICAgICdNVicsXG4gICAgJ01XJyxcbiAgICAnTVgnLFxuICAgICdNWScsXG4gICAgJ01aJyxcbiAgICAnTkEnLFxuICAgICdOQUInLFxuICAgICdOQUdPWUEnLFxuICAgICdOQU1FJyxcbiAgICAnTkFUVVJBJyxcbiAgICAnTkFWWScsXG4gICAgJ05CQScsXG4gICAgJ05DJyxcbiAgICAnTkUnLFxuICAgICdORUMnLFxuICAgICdORVQnLFxuICAgICdORVRCQU5LJyxcbiAgICAnTkVURkxJWCcsXG4gICAgJ05FVFdPUksnLFxuICAgICdORVVTVEFSJyxcbiAgICAnTkVXJyxcbiAgICAnTkVXUycsXG4gICAgJ05FWFQnLFxuICAgICdORVhURElSRUNUJyxcbiAgICAnTkVYVVMnLFxuICAgICdORicsXG4gICAgJ05GTCcsXG4gICAgJ05HJyxcbiAgICAnTkdPJyxcbiAgICAnTkhLJyxcbiAgICAnTkknLFxuICAgICdOSUNPJyxcbiAgICAnTklLRScsXG4gICAgJ05JS09OJyxcbiAgICAnTklOSkEnLFxuICAgICdOSVNTQU4nLFxuICAgICdOSVNTQVknLFxuICAgICdOTCcsXG4gICAgJ05PJyxcbiAgICAnTk9LSUEnLFxuICAgICdOT1JUT04nLFxuICAgICdOT1cnLFxuICAgICdOT1dSVVonLFxuICAgICdOT1dUVicsXG4gICAgJ05QJyxcbiAgICAnTlInLFxuICAgICdOUkEnLFxuICAgICdOUlcnLFxuICAgICdOVFQnLFxuICAgICdOVScsXG4gICAgJ05ZQycsXG4gICAgJ05aJyxcbiAgICAnT0JJJyxcbiAgICAnT0JTRVJWRVInLFxuICAgICdPRkZJQ0UnLFxuICAgICdPS0lOQVdBJyxcbiAgICAnT0xBWUFOJyxcbiAgICAnT0xBWUFOR1JPVVAnLFxuICAgICdPTExPJyxcbiAgICAnT00nLFxuICAgICdPTUVHQScsXG4gICAgJ09ORScsXG4gICAgJ09ORycsXG4gICAgJ09OTCcsXG4gICAgJ09OTElORScsXG4gICAgJ09PTycsXG4gICAgJ09QRU4nLFxuICAgICdPUkFDTEUnLFxuICAgICdPUkFOR0UnLFxuICAgICdPUkcnLFxuICAgICdPUkdBTklDJyxcbiAgICAnT1JJR0lOUycsXG4gICAgJ09TQUtBJyxcbiAgICAnT1RTVUtBJyxcbiAgICAnT1RUJyxcbiAgICAnT1ZIJyxcbiAgICAnUEEnLFxuICAgICdQQUdFJyxcbiAgICAnUEFOQVNPTklDJyxcbiAgICAnUEFSSVMnLFxuICAgICdQQVJTJyxcbiAgICAnUEFSVE5FUlMnLFxuICAgICdQQVJUUycsXG4gICAgJ1BBUlRZJyxcbiAgICAnUEFZJyxcbiAgICAnUENDVycsXG4gICAgJ1BFJyxcbiAgICAnUEVUJyxcbiAgICAnUEYnLFxuICAgICdQRklaRVInLFxuICAgICdQRycsXG4gICAgJ1BIJyxcbiAgICAnUEhBUk1BQ1knLFxuICAgICdQSEQnLFxuICAgICdQSElMSVBTJyxcbiAgICAnUEhPTkUnLFxuICAgICdQSE9UTycsXG4gICAgJ1BIT1RPR1JBUEhZJyxcbiAgICAnUEhPVE9TJyxcbiAgICAnUEhZU0lPJyxcbiAgICAnUElDUycsXG4gICAgJ1BJQ1RFVCcsXG4gICAgJ1BJQ1RVUkVTJyxcbiAgICAnUElEJyxcbiAgICAnUElOJyxcbiAgICAnUElORycsXG4gICAgJ1BJTksnLFxuICAgICdQSU9ORUVSJyxcbiAgICAnUElaWkEnLFxuICAgICdQSycsXG4gICAgJ1BMJyxcbiAgICAnUExBQ0UnLFxuICAgICdQTEFZJyxcbiAgICAnUExBWVNUQVRJT04nLFxuICAgICdQTFVNQklORycsXG4gICAgJ1BMVVMnLFxuICAgICdQTScsXG4gICAgJ1BOJyxcbiAgICAnUE5DJyxcbiAgICAnUE9ITCcsXG4gICAgJ1BPS0VSJyxcbiAgICAnUE9MSVRJRScsXG4gICAgJ1BPUk4nLFxuICAgICdQT1NUJyxcbiAgICAnUFInLFxuICAgICdQUkFNRVJJQ0EnLFxuICAgICdQUkFYSScsXG4gICAgJ1BSRVNTJyxcbiAgICAnUFJJTUUnLFxuICAgICdQUk8nLFxuICAgICdQUk9EJyxcbiAgICAnUFJPRFVDVElPTlMnLFxuICAgICdQUk9GJyxcbiAgICAnUFJPR1JFU1NJVkUnLFxuICAgICdQUk9NTycsXG4gICAgJ1BST1BFUlRJRVMnLFxuICAgICdQUk9QRVJUWScsXG4gICAgJ1BST1RFQ1RJT04nLFxuICAgICdQUlUnLFxuICAgICdQUlVERU5USUFMJyxcbiAgICAnUFMnLFxuICAgICdQVCcsXG4gICAgJ1BVQicsXG4gICAgJ1BXJyxcbiAgICAnUFdDJyxcbiAgICAnUFknLFxuICAgICdRQScsXG4gICAgJ1FQT04nLFxuICAgICdRVUVCRUMnLFxuICAgICdRVUVTVCcsXG4gICAgJ1JBQ0lORycsXG4gICAgJ1JBRElPJyxcbiAgICAnUkUnLFxuICAgICdSRUFEJyxcbiAgICAnUkVBTEVTVEFURScsXG4gICAgJ1JFQUxUT1InLFxuICAgICdSRUFMVFknLFxuICAgICdSRUNJUEVTJyxcbiAgICAnUkVEJyxcbiAgICAnUkVEU1RPTkUnLFxuICAgICdSRURVTUJSRUxMQScsXG4gICAgJ1JFSEFCJyxcbiAgICAnUkVJU0UnLFxuICAgICdSRUlTRU4nLFxuICAgICdSRUlUJyxcbiAgICAnUkVMSUFOQ0UnLFxuICAgICdSRU4nLFxuICAgICdSRU5UJyxcbiAgICAnUkVOVEFMUycsXG4gICAgJ1JFUEFJUicsXG4gICAgJ1JFUE9SVCcsXG4gICAgJ1JFUFVCTElDQU4nLFxuICAgICdSRVNUJyxcbiAgICAnUkVTVEFVUkFOVCcsXG4gICAgJ1JFVklFVycsXG4gICAgJ1JFVklFV1MnLFxuICAgICdSRVhST1RIJyxcbiAgICAnUklDSCcsXG4gICAgJ1JJQ0hBUkRMSScsXG4gICAgJ1JJQ09IJyxcbiAgICAnUklMJyxcbiAgICAnUklPJyxcbiAgICAnUklQJyxcbiAgICAnUk8nLFxuICAgICdST0NLUycsXG4gICAgJ1JPREVPJyxcbiAgICAnUk9HRVJTJyxcbiAgICAnUk9PTScsXG4gICAgJ1JTJyxcbiAgICAnUlNWUCcsXG4gICAgJ1JVJyxcbiAgICAnUlVHQlknLFxuICAgICdSVUhSJyxcbiAgICAnUlVOJyxcbiAgICAnUlcnLFxuICAgICdSV0UnLFxuICAgICdSWVVLWVUnLFxuICAgICdTQScsXG4gICAgJ1NBQVJMQU5EJyxcbiAgICAnU0FGRScsXG4gICAgJ1NBRkVUWScsXG4gICAgJ1NBS1VSQScsXG4gICAgJ1NBTEUnLFxuICAgICdTQUxPTicsXG4gICAgJ1NBTVNDTFVCJyxcbiAgICAnU0FNU1VORycsXG4gICAgJ1NBTkRWSUsnLFxuICAgICdTQU5EVklLQ09ST01BTlQnLFxuICAgICdTQU5PRkknLFxuICAgICdTQVAnLFxuICAgICdTQVJMJyxcbiAgICAnU0FTJyxcbiAgICAnU0FWRScsXG4gICAgJ1NBWE8nLFxuICAgICdTQicsXG4gICAgJ1NCSScsXG4gICAgJ1NCUycsXG4gICAgJ1NDJyxcbiAgICAnU0NCJyxcbiAgICAnU0NIQUVGRkxFUicsXG4gICAgJ1NDSE1JRFQnLFxuICAgICdTQ0hPTEFSU0hJUFMnLFxuICAgICdTQ0hPT0wnLFxuICAgICdTQ0hVTEUnLFxuICAgICdTQ0hXQVJaJyxcbiAgICAnU0NJRU5DRScsXG4gICAgJ1NDT1QnLFxuICAgICdTRCcsXG4gICAgJ1NFJyxcbiAgICAnU0VBUkNIJyxcbiAgICAnU0VBVCcsXG4gICAgJ1NFQ1VSRScsXG4gICAgJ1NFQ1VSSVRZJyxcbiAgICAnU0VFSycsXG4gICAgJ1NFTEVDVCcsXG4gICAgJ1NFTkVSJyxcbiAgICAnU0VSVklDRVMnLFxuICAgICdTRVZFTicsXG4gICAgJ1NFVycsXG4gICAgJ1NFWCcsXG4gICAgJ1NFWFknLFxuICAgICdTRlInLFxuICAgICdTRycsXG4gICAgJ1NIJyxcbiAgICAnU0hBTkdSSUxBJyxcbiAgICAnU0hBUlAnLFxuICAgICdTSEFXJyxcbiAgICAnU0hFTEwnLFxuICAgICdTSElBJyxcbiAgICAnU0hJS1NIQScsXG4gICAgJ1NIT0VTJyxcbiAgICAnU0hPUCcsXG4gICAgJ1NIT1BQSU5HJyxcbiAgICAnU0hPVUpJJyxcbiAgICAnU0hPVycsXG4gICAgJ1NJJyxcbiAgICAnU0lMSycsXG4gICAgJ1NJTkEnLFxuICAgICdTSU5HTEVTJyxcbiAgICAnU0lURScsXG4gICAgJ1NKJyxcbiAgICAnU0snLFxuICAgICdTS0knLFxuICAgICdTS0lOJyxcbiAgICAnU0tZJyxcbiAgICAnU0tZUEUnLFxuICAgICdTTCcsXG4gICAgJ1NMSU5HJyxcbiAgICAnU00nLFxuICAgICdTTUFSVCcsXG4gICAgJ1NNSUxFJyxcbiAgICAnU04nLFxuICAgICdTTkNGJyxcbiAgICAnU08nLFxuICAgICdTT0NDRVInLFxuICAgICdTT0NJQUwnLFxuICAgICdTT0ZUQkFOSycsXG4gICAgJ1NPRlRXQVJFJyxcbiAgICAnU09IVScsXG4gICAgJ1NPTEFSJyxcbiAgICAnU09MVVRJT05TJyxcbiAgICAnU09ORycsXG4gICAgJ1NPTlknLFxuICAgICdTT1knLFxuICAgICdTUEEnLFxuICAgICdTUEFDRScsXG4gICAgJ1NQT1JUJyxcbiAgICAnU1BPVCcsXG4gICAgJ1NSJyxcbiAgICAnU1JMJyxcbiAgICAnU1MnLFxuICAgICdTVCcsXG4gICAgJ1NUQURBJyxcbiAgICAnU1RBUExFUycsXG4gICAgJ1NUQVInLFxuICAgICdTVEFURUJBTksnLFxuICAgICdTVEFURUZBUk0nLFxuICAgICdTVEMnLFxuICAgICdTVENHUk9VUCcsXG4gICAgJ1NUT0NLSE9MTScsXG4gICAgJ1NUT1JBR0UnLFxuICAgICdTVE9SRScsXG4gICAgJ1NUUkVBTScsXG4gICAgJ1NUVURJTycsXG4gICAgJ1NUVURZJyxcbiAgICAnU1RZTEUnLFxuICAgICdTVScsXG4gICAgJ1NVQ0tTJyxcbiAgICAnU1VQUExJRVMnLFxuICAgICdTVVBQTFknLFxuICAgICdTVVBQT1JUJyxcbiAgICAnU1VSRicsXG4gICAgJ1NVUkdFUlknLFxuICAgICdTVVpVS0knLFxuICAgICdTVicsXG4gICAgJ1NXQVRDSCcsXG4gICAgJ1NXSVNTJyxcbiAgICAnU1gnLFxuICAgICdTWScsXG4gICAgJ1NZRE5FWScsXG4gICAgJ1NZU1RFTVMnLFxuICAgICdTWicsXG4gICAgJ1RBQicsXG4gICAgJ1RBSVBFSScsXG4gICAgJ1RBTEsnLFxuICAgICdUQU9CQU8nLFxuICAgICdUQVJHRVQnLFxuICAgICdUQVRBTU9UT1JTJyxcbiAgICAnVEFUQVInLFxuICAgICdUQVRUT08nLFxuICAgICdUQVgnLFxuICAgICdUQVhJJyxcbiAgICAnVEMnLFxuICAgICdUQ0knLFxuICAgICdURCcsXG4gICAgJ1RESycsXG4gICAgJ1RFQU0nLFxuICAgICdURUNIJyxcbiAgICAnVEVDSE5PTE9HWScsXG4gICAgJ1RFTCcsXG4gICAgJ1RFTUFTRUsnLFxuICAgICdURU5OSVMnLFxuICAgICdURVZBJyxcbiAgICAnVEYnLFxuICAgICdURycsXG4gICAgJ1RIJyxcbiAgICAnVEhEJyxcbiAgICAnVEhFQVRFUicsXG4gICAgJ1RIRUFUUkUnLFxuICAgICdUSUFBJyxcbiAgICAnVElDS0VUUycsXG4gICAgJ1RJRU5EQScsXG4gICAgJ1RJUFMnLFxuICAgICdUSVJFUycsXG4gICAgJ1RJUk9MJyxcbiAgICAnVEonLFxuICAgICdUSk1BWFgnLFxuICAgICdUSlgnLFxuICAgICdUSycsXG4gICAgJ1RLTUFYWCcsXG4gICAgJ1RMJyxcbiAgICAnVE0nLFxuICAgICdUTUFMTCcsXG4gICAgJ1ROJyxcbiAgICAnVE8nLFxuICAgICdUT0RBWScsXG4gICAgJ1RPS1lPJyxcbiAgICAnVE9PTFMnLFxuICAgICdUT1AnLFxuICAgICdUT1JBWScsXG4gICAgJ1RPU0hJQkEnLFxuICAgICdUT1RBTCcsXG4gICAgJ1RPVVJTJyxcbiAgICAnVE9XTicsXG4gICAgJ1RPWU9UQScsXG4gICAgJ1RPWVMnLFxuICAgICdUUicsXG4gICAgJ1RSQURFJyxcbiAgICAnVFJBRElORycsXG4gICAgJ1RSQUlOSU5HJyxcbiAgICAnVFJBVkVMJyxcbiAgICAnVFJBVkVMRVJTJyxcbiAgICAnVFJBVkVMRVJTSU5TVVJBTkNFJyxcbiAgICAnVFJVU1QnLFxuICAgICdUUlYnLFxuICAgICdUVCcsXG4gICAgJ1RVQkUnLFxuICAgICdUVUknLFxuICAgICdUVU5FUycsXG4gICAgJ1RVU0hVJyxcbiAgICAnVFYnLFxuICAgICdUVlMnLFxuICAgICdUVycsXG4gICAgJ1RaJyxcbiAgICAnVUEnLFxuICAgICdVQkFOSycsXG4gICAgJ1VCUycsXG4gICAgJ1VHJyxcbiAgICAnVUsnLFxuICAgICdVTklDT00nLFxuICAgICdVTklWRVJTSVRZJyxcbiAgICAnVU5PJyxcbiAgICAnVU9MJyxcbiAgICAnVVBTJyxcbiAgICAnVVMnLFxuICAgICdVWScsXG4gICAgJ1VaJyxcbiAgICAnVkEnLFxuICAgICdWQUNBVElPTlMnLFxuICAgICdWQU5BJyxcbiAgICAnVkFOR1VBUkQnLFxuICAgICdWQycsXG4gICAgJ1ZFJyxcbiAgICAnVkVHQVMnLFxuICAgICdWRU5UVVJFUycsXG4gICAgJ1ZFUklTSUdOJyxcbiAgICAnVkVSU0lDSEVSVU5HJyxcbiAgICAnVkVUJyxcbiAgICAnVkcnLFxuICAgICdWSScsXG4gICAgJ1ZJQUpFUycsXG4gICAgJ1ZJREVPJyxcbiAgICAnVklHJyxcbiAgICAnVklLSU5HJyxcbiAgICAnVklMTEFTJyxcbiAgICAnVklOJyxcbiAgICAnVklQJyxcbiAgICAnVklSR0lOJyxcbiAgICAnVklTQScsXG4gICAgJ1ZJU0lPTicsXG4gICAgJ1ZJVkEnLFxuICAgICdWSVZPJyxcbiAgICAnVkxBQU5ERVJFTicsXG4gICAgJ1ZOJyxcbiAgICAnVk9ES0EnLFxuICAgICdWT0xWTycsXG4gICAgJ1ZPVEUnLFxuICAgICdWT1RJTkcnLFxuICAgICdWT1RPJyxcbiAgICAnVk9ZQUdFJyxcbiAgICAnVlUnLFxuICAgICdXQUxFUycsXG4gICAgJ1dBTE1BUlQnLFxuICAgICdXQUxURVInLFxuICAgICdXQU5HJyxcbiAgICAnV0FOR0dPVScsXG4gICAgJ1dBVENIJyxcbiAgICAnV0FUQ0hFUycsXG4gICAgJ1dFQVRIRVInLFxuICAgICdXRUFUSEVSQ0hBTk5FTCcsXG4gICAgJ1dFQkNBTScsXG4gICAgJ1dFQkVSJyxcbiAgICAnV0VCU0lURScsXG4gICAgJ1dFRCcsXG4gICAgJ1dFRERJTkcnLFxuICAgICdXRUlCTycsXG4gICAgJ1dFSVInLFxuICAgICdXRicsXG4gICAgJ1dIT1NXSE8nLFxuICAgICdXSUVOJyxcbiAgICAnV0lLSScsXG4gICAgJ1dJTExJQU1ISUxMJyxcbiAgICAnV0lOJyxcbiAgICAnV0lORE9XUycsXG4gICAgJ1dJTkUnLFxuICAgICdXSU5ORVJTJyxcbiAgICAnV01FJyxcbiAgICAnV09MVEVSU0tMVVdFUicsXG4gICAgJ1dPT0RTSURFJyxcbiAgICAnV09SSycsXG4gICAgJ1dPUktTJyxcbiAgICAnV09STEQnLFxuICAgICdXT1cnLFxuICAgICdXUycsXG4gICAgJ1dUQycsXG4gICAgJ1dURicsXG4gICAgJ1hCT1gnLFxuICAgICdYRVJPWCcsXG4gICAgJ1hGSU5JVFknLFxuICAgICdYSUhVQU4nLFxuICAgICdYSU4nLFxuICAgICdYTi0tMTFCNEMzRCcsXG4gICAgJ1hOLS0xQ0syRTFCJyxcbiAgICAnWE4tLTFRUVcyM0EnLFxuICAgICdYTi0tMlNDUko5QycsXG4gICAgJ1hOLS0zMFJSN1knLFxuICAgICdYTi0tM0JTVDAwTScsXG4gICAgJ1hOLS0zRFM0NDNHJyxcbiAgICAnWE4tLTNFMEI3MDdFJyxcbiAgICAnWE4tLTNIQ1JKOUMnLFxuICAgICdYTi0tM1BYVThLJyxcbiAgICAnWE4tLTQyQzJEOUEnLFxuICAgICdYTi0tNDVCUjVDWUwnLFxuICAgICdYTi0tNDVCUko5QycsXG4gICAgJ1hOLS00NVExMUMnLFxuICAgICdYTi0tNERCUkswQ0UnLFxuICAgICdYTi0tNEdCUklNJyxcbiAgICAnWE4tLTU0QjdGVEEwQ0MnLFxuICAgICdYTi0tNTVRVzQyRycsXG4gICAgJ1hOLS01NVFYNUQnLFxuICAgICdYTi0tNVNVMzRKOTM2QkdTRycsXG4gICAgJ1hOLS01VFpNNUcnLFxuICAgICdYTi0tNkZSWjgyRycsXG4gICAgJ1hOLS02UVE5ODZCM1hMJyxcbiAgICAnWE4tLTgwQURYSEtTJyxcbiAgICAnWE4tLTgwQU8yMUEnLFxuICAgICdYTi0tODBBUUVDRFIxQScsXG4gICAgJ1hOLS04MEFTRUhEQicsXG4gICAgJ1hOLS04MEFTV0cnLFxuICAgICdYTi0tOFkwQTA2M0EnLFxuICAgICdYTi0tOTBBM0FDJyxcbiAgICAnWE4tLTkwQUUnLFxuICAgICdYTi0tOTBBSVMnLFxuICAgICdYTi0tOURCUTJBJyxcbiAgICAnWE4tLTlFVDUyVScsXG4gICAgJ1hOLS05S1JUMDBBJyxcbiAgICAnWE4tLUI0VzYwNUZFUkQnLFxuICAgICdYTi0tQkNLMUI5QTVEUkU0QycsXG4gICAgJ1hOLS1DMUFWRycsXG4gICAgJ1hOLS1DMkJSN0cnLFxuICAgICdYTi0tQ0NLMkIzQicsXG4gICAgJ1hOLS1DQ0tXQ1hFVEQnLFxuICAgICdYTi0tQ0c0QktJJyxcbiAgICAnWE4tLUNMQ0hDMEVBMEIyRzJBOUdDRCcsXG4gICAgJ1hOLS1DWlI2OTRCJyxcbiAgICAnWE4tLUNaUlMwVCcsXG4gICAgJ1hOLS1DWlJVMkQnLFxuICAgICdYTi0tRDFBQ0ozQicsXG4gICAgJ1hOLS1EMUFMRicsXG4gICAgJ1hOLS1FMUE0QycsXG4gICAgJ1hOLS1FQ0tWRFRDOUQnLFxuICAgICdYTi0tRUZWWTg4SCcsXG4gICAgJ1hOLS1GQ1Q0MjlLJyxcbiAgICAnWE4tLUZIQkVJJyxcbiAgICAnWE4tLUZJUTIyOEM1SFMnLFxuICAgICdYTi0tRklRNjRCJyxcbiAgICAnWE4tLUZJUVM4UycsXG4gICAgJ1hOLS1GSVFaOVMnLFxuICAgICdYTi0tRkpRNzIwQScsXG4gICAgJ1hOLS1GTFczNTFFJyxcbiAgICAnWE4tLUZQQ1JKOUMzRCcsXG4gICAgJ1hOLS1GWkMyQzlFMkMnLFxuICAgICdYTi0tRlpZUzhENjlVVkdNJyxcbiAgICAnWE4tLUcyWFg0OEMnLFxuICAgICdYTi0tR0NLUjNGMEYnLFxuICAgICdYTi0tR0VDUko5QycsXG4gICAgJ1hOLS1HSzNBVDFFJyxcbiAgICAnWE4tLUgyQlJFRzNFVkUnLFxuICAgICdYTi0tSDJCUko5QycsXG4gICAgJ1hOLS1IMkJSSjlDOEMnLFxuICAgICdYTi0tSFhUODE0RScsXG4gICAgJ1hOLS1JMUI2QjFBNkEyRScsXG4gICAgJ1hOLS1JTVI1MTNOJyxcbiAgICAnWE4tLUlPMEE3SScsXG4gICAgJ1hOLS1KMUFFRicsXG4gICAgJ1hOLS1KMUFNSCcsXG4gICAgJ1hOLS1KNlcxOTNHJyxcbiAgICAnWE4tLUpMUTQ4ME4yUkcnLFxuICAgICdYTi0tSlZSMTg5TScsXG4gICAgJ1hOLS1LQ1JYNzdEMVg0QScsXG4gICAgJ1hOLS1LUFJXMTNEJyxcbiAgICAnWE4tLUtQUlk1N0QnLFxuICAgICdYTi0tS1BVVDNJJyxcbiAgICAnWE4tLUwxQUNDJyxcbiAgICAnWE4tLUxHQkJBVDFBRDhKJyxcbiAgICAnWE4tLU1HQjlBV0JGJyxcbiAgICAnWE4tLU1HQkEzQTNFSlQnLFxuICAgICdYTi0tTUdCQTNBNEYxNkEnLFxuICAgICdYTi0tTUdCQTdDMEJCTjBBJyxcbiAgICAnWE4tLU1HQkFBTTdBOEgnLFxuICAgICdYTi0tTUdCQUIyQkQnLFxuICAgICdYTi0tTUdCQUgxQTNISktSRCcsXG4gICAgJ1hOLS1NR0JBSTlBWkdRUDZKJyxcbiAgICAnWE4tLU1HQkFZSDdHUEEnLFxuICAgICdYTi0tTUdCQkgxQScsXG4gICAgJ1hOLS1NR0JCSDFBNzFFJyxcbiAgICAnWE4tLU1HQkMwQTlBWkNHJyxcbiAgICAnWE4tLU1HQkNBN0RaRE8nLFxuICAgICdYTi0tTUdCQ1BRNkdQQTFBJyxcbiAgICAnWE4tLU1HQkVSUDRBNUQ0QVInLFxuICAgICdYTi0tTUdCR1U4MkEnLFxuICAgICdYTi0tTUdCSTRFQ0VYUCcsXG4gICAgJ1hOLS1NR0JQTDJGSCcsXG4gICAgJ1hOLS1NR0JUM0RIRCcsXG4gICAgJ1hOLS1NR0JUWDJCJyxcbiAgICAnWE4tLU1HQlg0Q0QwQUInLFxuICAgICdYTi0tTUlYODkxRicsXG4gICAgJ1hOLS1NSzFCVTQ0QycsXG4gICAgJ1hOLS1NWFRRMU0nLFxuICAgICdYTi0tTkdCQzVBWkQnLFxuICAgICdYTi0tTkdCRTlFMEEnLFxuICAgICdYTi0tTkdCUlgnLFxuICAgICdYTi0tTk9ERScsXG4gICAgJ1hOLS1OUVY3RicsXG4gICAgJ1hOLS1OUVY3RlMwMEVNQScsXG4gICAgJ1hOLS1OWVFZMjZBJyxcbiAgICAnWE4tLU8zQ1c0SCcsXG4gICAgJ1hOLS1PR0JQRjhGTCcsXG4gICAgJ1hOLS1PVFU3OTZEJyxcbiAgICAnWE4tLVAxQUNGJyxcbiAgICAnWE4tLVAxQUknLFxuICAgICdYTi0tUEdCUzBESCcsXG4gICAgJ1hOLS1QU1NZMlUnLFxuICAgICdYTi0tUTdDRTZBJyxcbiAgICAnWE4tLVE5SllCNEMnLFxuICAgICdYTi0tUUNLQTFQTUMnLFxuICAgICdYTi0tUVhBNkEnLFxuICAgICdYTi0tUVhBTScsXG4gICAgJ1hOLS1SSFFWOTZHJyxcbiAgICAnWE4tLVJPVlU4OEInLFxuICAgICdYTi0tUlZDMUUwQU0zRScsXG4gICAgJ1hOLS1TOUJSSjlDJyxcbiAgICAnWE4tLVNFUzU1NEcnLFxuICAgICdYTi0tVDYwQjU2QScsXG4gICAgJ1hOLS1UQ0tXRScsXG4gICAgJ1hOLS1USVE0OVhRWUonLFxuICAgICdYTi0tVU5VUDRZJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRFUi1DVEInLFxuICAgICdYTi0tVkVSTUdFTlNCRVJBVFVORy1QV0InLFxuICAgICdYTi0tVkhRVVYnLFxuICAgICdYTi0tVlVRODYxQicsXG4gICAgJ1hOLS1XNFI4NUVMOEZIVTVETlJBJyxcbiAgICAnWE4tLVc0UlM0MEwnLFxuICAgICdYTi0tV0dCSDFDJyxcbiAgICAnWE4tLVdHQkw2QScsXG4gICAgJ1hOLS1YSFE1MjFCJyxcbiAgICAnWE4tLVhLQzJBTDNIWUUyQScsXG4gICAgJ1hOLS1YS0MyREwzQTVFRTBIJyxcbiAgICAnWE4tLVk5QTNBUScsXG4gICAgJ1hOLS1ZRlJPNEk2N08nLFxuICAgICdYTi0tWUdCSTJBTU1YJyxcbiAgICAnWE4tLVpGUjE2NEInLFxuICAgICdYWFgnLFxuICAgICdYWVonLFxuICAgICdZQUNIVFMnLFxuICAgICdZQUhPTycsXG4gICAgJ1lBTUFYVU4nLFxuICAgICdZQU5ERVgnLFxuICAgICdZRScsXG4gICAgJ1lPRE9CQVNISScsXG4gICAgJ1lPR0EnLFxuICAgICdZT0tPSEFNQScsXG4gICAgJ1lPVScsXG4gICAgJ1lPVVRVQkUnLFxuICAgICdZVCcsXG4gICAgJ1lVTicsXG4gICAgJ1pBJyxcbiAgICAnWkFQUE9TJyxcbiAgICAnWkFSQScsXG4gICAgJ1pFUk8nLFxuICAgICdaSVAnLFxuICAgICdaTScsXG4gICAgJ1pPTkUnLFxuICAgICdaVUVSSUNIJyxcbiAgICAnWlcnXG5dO1xuXG5cbi8vIEtlZXAgYXMgdXBwZXItY2FzZSB0byBtYWtlIHVwZGF0aW5nIGZyb20gc291cmNlIGVhc2llclxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTZXQoaW50ZXJuYWxzLnRsZHMubWFwKCh0bGQpID0+IHRsZC50b0xvd2VyQ2FzZSgpKSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERvbWFpbiA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2RvbWFpbicpO1xuY29uc3QgRW1haWwgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi9lbWFpbCcpO1xuY29uc3QgSXAgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi9pcCcpO1xuY29uc3QgRXNjYXBlUmVnZXggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleCcpO1xuY29uc3QgVGxkcyA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL3RsZHMnKTtcbmNvbnN0IFVyaSA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL3VyaScpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHRsZHM6IFRsZHMgaW5zdGFuY2VvZiBTZXQgPyB7IHRsZHM6IHsgYWxsb3c6IFRsZHMsIGRlbnk6IG51bGwgfSB9IDogZmFsc2UsICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBiYXNlNjRSZWdleDoge1xuICAgICAgICAvLyBwYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgdHJ1ZToge1xuICAgICAgICAgICAgLy8gdXJsU2FmZVxuICAgICAgICAgICAgdHJ1ZTogL14oPzpbXFx3XFwtXXsyfVtcXHdcXC1dezJ9KSooPzpbXFx3XFwtXXsyfT09fFtcXHdcXC1dezN9PSk/JC8sXG4gICAgICAgICAgICBmYWxzZTogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlOiB7XG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9KD09KT98W1xcd1xcLV17M309Pyk/JC8sXG4gICAgICAgICAgICBmYWxzZTogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kL1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhVXJpUmVnZXg6IC9eZGF0YTpbXFx3Ky4tXStcXC9bXFx3Ky4tXSs7KChjaGFyc2V0PVtcXHctXSt8YmFzZTY0KSwpPyguKikkLyxcbiAgICBoZXhSZWdleDoge1xuICAgICAgICB3aXRoUHJlZml4OiAvXjB4WzAtOWEtZl0rJC9pLFxuICAgICAgICB3aXRoT3B0aW9uYWxQcmVmaXg6IC9eKD86MHgpP1swLTlhLWZdKyQvaSxcbiAgICAgICAgd2l0aG91dFByZWZpeDogL15bMC05YS1mXSskL2lcbiAgICB9LFxuICAgIGlwUmVnZXg6IElwLnJlZ2V4KHsgY2lkcjogJ2ZvcmJpZGRlbicgfSkucmVnZXgsXG4gICAgaXNvRHVyYXRpb25SZWdleDogL15QKD8hJCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtXKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/JC8sXG5cbiAgICBndWlkQnJhY2tldHM6IHtcbiAgICAgICAgJ3snOiAnfScsICdbJzogJ10nLCAnKCc6ICcpJywgJyc6ICcnXG4gICAgfSxcbiAgICBndWlkVmVyc2lvbnM6IHtcbiAgICAgICAgdXVpZHYxOiAnMScsXG4gICAgICAgIHV1aWR2MjogJzInLFxuICAgICAgICB1dWlkdjM6ICczJyxcbiAgICAgICAgdXVpZHY0OiAnNCcsXG4gICAgICAgIHV1aWR2NTogJzUnLFxuICAgICAgICB1dWlkdjY6ICc2JyxcbiAgICAgICAgdXVpZHY3OiAnNycsXG4gICAgICAgIHV1aWR2ODogJzgnXG4gICAgfSxcbiAgICBndWlkU2VwYXJhdG9yczogbmV3IFNldChbdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgJy0nLCAnOiddKSxcblxuICAgIG5vcm1hbGl6YXRpb25Gb3JtczogWydORkMnLCAnTkZEJywgJ05GS0MnLCAnTkZLRCddXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3RyaW5nJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgdHJ1bmNhdGU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIHJlcGxhY2VtZW50czogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemUgPSBzY2hlbWEuJF9nZXRSdWxlKCdub3JtYWxpemUnKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZShub3JtYWxpemUuYXJncy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FzaW5nID0gc2NoZW1hLiRfZ2V0UnVsZSgnY2FzZScpO1xuICAgICAgICAgICAgaWYgKGNhc2luZykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2FzaW5nLmFyZ3MuZGlyZWN0aW9uID09PSAndXBwZXInID8gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSA6IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgICAgICAgICBpZiAodHJpbSAmJlxuICAgICAgICAgICAgICAgIHRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVwbGFjZW1lbnQgb2Ygc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZXBsYWNlbWVudC5wYXR0ZXJuLCByZXBsYWNlbWVudC5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZXggPSBzY2hlbWEuJF9nZXRSdWxlKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChoZXggJiZcbiAgICAgICAgICAgICAgICBoZXguYXJncy5vcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX2dldFJ1bGUoJ2lzb0RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IGludGVybmFscy5pc29EYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWF4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gcnVsZS5hcmdzLmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbGltaXQucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQ29tbW9uLmxpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVmJywgbGltaXQsIHsgcmVmOiBydWxlLmFyZ3MubGltaXQsIGFyZzogJ2xpbWl0JywgcmVhc29uOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInIH0sIHN0YXRlLCBwcmVmcykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N0cmluZy5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHNjaGVtYS4kX2dldFJ1bGUoJ21pbicpO1xuICAgICAgICAgICAgaWYgKG1pbiAmJlxuICAgICAgICAgICAgICAgIG1pbi5hcmdzLmxpbWl0ID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuZW1wdHknKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYWxwaGFudW06IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eW2EtekEtWjAtOV0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiYXNlNjQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsncGFkZGluZ1JlcXVpcmVkJywgJ3VybFNhZmUnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyB1cmxTYWZlOiBmYWxzZSwgcGFkZGluZ1JlcXVpcmVkOiB0cnVlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLCAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy51cmxTYWZlID09PSAnYm9vbGVhbicsICd1cmxTYWZlIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Jhc2U2NCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBpbnRlcm5hbHMuYmFzZTY0UmVnZXhbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdW29wdGlvbnMudXJsU2FmZV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmJhc2U2NCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChkaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2xvd2VyJywgJ3VwcGVyJ10uaW5jbHVkZXMoZGlyZWN0aW9uKSwgJ0ludmFsaWQgY2FzZTonLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Nhc2UnLCBhcmdzOiB7IGRpcmVjdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRpcmVjdGlvbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbG93ZXInICYmIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3VwcGVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihgc3RyaW5nLiR7ZGlyZWN0aW9ufWNhc2VgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlZGl0Q2FyZDoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGxldCBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtdWwgPSAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpICogbXVsO1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAoY2hhciAtIChjaGFyID4gOSkgKiA5KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsID0gbXVsIF4gMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBzdW0gJSAxMCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmNyZWRpdENhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhVXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkYXRhVXJpJywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLmRhdGFVcmlSZWdleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzJdICE9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0cmVnZXggPSBpbnRlcm5hbHMuYmFzZTY0UmVnZXhbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdLmZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZTY0cmVnZXgudGVzdChtYXRjaGVzWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kYXRhVXJpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBpbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2RvbWFpbicsIGFyZ3M6IHsgb3B0aW9ucyB9LCBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCB7IGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKERvbWFpbi5pc1ZhbGlkKHZhbHVlLCBhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kb21haW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdpZ25vcmVMZW5ndGgnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAnbXVsdGlwbGUnLCAnc2VwYXJhdG9yJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMubXVsdGlwbGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5tdWx0aXBsZSA9PT0gJ2Jvb2xlYW4nLCAnbXVsdGlwbGUgb3B0aW9uIG11c3QgYmUgYW4gYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxzKlske29wdGlvbnMuc2VwYXJhdG9yID8gRXNjYXBlUmVnZXgob3B0aW9ucy5zZXBhcmF0b3IpIDogJywnfV1cXFxccypgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdlbWFpbCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWxzID0gb3B0aW9ucy5tdWx0aXBsZSA/IHZhbHVlLnNwbGl0KHJlZ2V4KSA6IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGVtYWlscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUVtYWlsLmlzVmFsaWQoZW1haWwsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcy5wdXNoKGVtYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW52YWxpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmVtYWlsJywgeyB2YWx1ZSwgaW52YWxpZHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgYWxpYXM6ICd1dWlkJyxcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsndmVyc2lvbicsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmVyc2lvbk51bWJlcnMgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBbXS5jb25jYXQob3B0aW9ucy52ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbnMubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhbGlkIHZlcnNpb24gc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk51bWJlciA9IGludGVybmFscy5ndWlkVmVyc2lvbnNbdmVyc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9uTnVtYmVyLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGludGVybmFscy5ndWlkVmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXQuaGFzKHZlcnNpb25OdW1iZXIpLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBub3QgYmUgYSBkdXBsaWNhdGUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbk51bWJlcnMgKz0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5hZGQodmVyc2lvbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLmd1aWRTZXBhcmF0b3JzLmhhcyhvcHRpb25zLnNlcGFyYXRvciksICdzZXBhcmF0b3IgbXVzdCBiZSBvbmUgb2YgdHJ1ZSwgZmFsc2UsIFwiLVwiLCBvciBcIjpcIicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnWzotXT8nIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IHRydWUgPyAnWzotXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IGZhbHNlID8gJ1tdPycgOiBgXFxcXCR7b3B0aW9ucy5zZXBhcmF0b3J9YDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXihbXFxcXFt7XFxcXChdPylbMC05QS1GXXs4fSgke3NlcGFyYXRvcn0pWzAtOUEtRl17NH1cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyB8fCAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyA/ICc4OUFCJyA6ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1swLTlBLUZdezEyfShbXFxcXF19XFxcXCldPykkYCwgJ2knKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdndWlkJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaGluZyBicmFjZXNcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZ3VpZEJyYWNrZXRzW3Jlc3VsdHNbMV1dICE9PSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhleDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieXRlQWxpZ25lZCcsICdwcmVmaXgnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBieXRlQWxpZ25lZDogZmFsc2UsIHByZWZpeDogZmFsc2UsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICdib29sZWFuJywgJ2J5dGVBbGlnbmVkIG11c3QgYmUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wcmVmaXggPT09ICdib29sZWFuJyB8fCBvcHRpb25zLnByZWZpeCA9PT0gJ29wdGlvbmFsJywgJ3ByZWZpeCBtdXN0IGJlIGJvb2xlYW4gb3IgXCJvcHRpb25hbFwiJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGV4JywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZSA9IG9wdGlvbnMucHJlZml4ID09PSAnb3B0aW9uYWwnID9cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmhleFJlZ2V4LndpdGhPcHRpb25hbFByZWZpeCA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJlZml4ID09PSB0cnVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5oZXhSZWdleC53aXRoUHJlZml4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5oZXhSZWdleC53aXRob3V0UHJlZml4O1xuICAgICAgICAgICAgICAgIGlmICghcmUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXgnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlQWxpZ25lZCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXhBbGlnbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBob3N0bmFtZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdob3N0bmFtZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIHsgbWluRG9tYWluU2VnbWVudHM6IDEgfSkgfHxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmlwUmVnZXgudGVzdCh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ob3N0bmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc2Vuc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2luc2Vuc2l0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXA6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnY2lkcicsICd2ZXJzaW9uJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaWRyLCB2ZXJzaW9ucywgcmVnZXggfSA9IElwLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gPyB2ZXJzaW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaXAnLCBhcmdzOiB7IG9wdGlvbnM6IHsgY2lkciwgdmVyc2lvbiB9IH0sIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pcFZlcnNpb24nLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIsIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwJywgeyB2YWx1ZSwgY2lkcjogb3B0aW9ucy5jaWRyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0RhdGU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaXNvRGF0ZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignc3RyaW5nLmlzb0RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc29EdXJhdGlvbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzb0R1cmF0aW9uUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXNvRHVyYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdsZW5ndGgnLCBsaW1pdCwgJz0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQsIGVuY29kaW5nIH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RpbmcgPyBCdWZmZXIgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nKSA6IHZhbHVlLmxlbmd0aDsgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUobGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSwgZW5jb2RpbmcgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2VuY29kaW5nJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvd2VyY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzZSgnbG93ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdtYXgnLCBsaW1pdCwgJzw9JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbGltaXQnLCAnZW5jb2RpbmcnXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21pbicsIGxpbWl0LCAnPj0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbm9ybWFsaXplOiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybSA9ICdORkMnKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLm5vcm1hbGl6YXRpb25Gb3Jtcy5pbmNsdWRlcyhmb3JtKSwgJ25vcm1hbGl6YXRpb24gZm9ybSBtdXN0IGJlIG9uZSBvZiAnICsgaW50ZXJuYWxzLm5vcm1hbGl6YXRpb25Gb3Jtcy5qb2luKCcsICcpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdub3JtYWxpemUnLCBhcmdzOiB7IGZvcm0gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9LCB7IGZvcm0gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZS5ub3JtYWxpemUoZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignc3RyaW5nLm5vcm1hbGl6ZScsIHsgdmFsdWUsIGZvcm0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICAgIGFsaWFzOiAncmVnZXgnLFxuICAgICAgICAgICAgbWV0aG9kKHJlZ2V4LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChyZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3JlZ2V4IG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXJlZ2V4LmZsYWdzLmluY2x1ZGVzKCdnJykgJiYgIXJlZ2V4LmZsYWdzLmluY2x1ZGVzKCd5JyksICdyZWdleCBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaW52ZXJ0JywgJ25hbWUnXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBbJ3N0cmluZy5wYXR0ZXJuJywgb3B0aW9ucy5pbnZlcnQgPyAnLmludmVydCcgOiAnJywgb3B0aW9ucy5uYW1lID8gJy5uYW1lJyA6ICcuYmFzZSddLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwYXR0ZXJuJywgYXJnczogeyByZWdleCwgb3B0aW9ucyB9LCBlcnJvckNvZGUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgcmVnZXgsIG9wdGlvbnMgfSwgeyBlcnJvckNvZGUgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybk1hdGNoID0gcmVnZXgudGVzdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybk1hdGNoIF4gb3B0aW9ucy5pbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGVycm9yQ29kZSwgeyBuYW1lOiBvcHRpb25zLm5hbWUsIHJlZ2V4LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ3JlZ2V4JywgJ29wdGlvbnMnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVwbGFjZToge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKEVzY2FwZVJlZ2V4KHBhdHRlcm4pLCAnZycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwLCAncGF0dGVybiBtdXN0IGJlIGEgUmVnRXhwJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycsICdyZXBsYWNlbWVudCBtdXN0IGJlIGEgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMucHVzaCh7IHBhdHRlcm4sIHJlcGxhY2VtZW50IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgndG9rZW4nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eXFx3KyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnRva2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpbToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd0cmltJywgYXJnczogeyBlbmFibGVkIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZW5hYmxlZCB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRyaW0oKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnRyaW0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1bmNhdGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3RydW5jYXRlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBwZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCd1cHBlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd1JlbGF0aXZlJywgJ2FsbG93UXVlcnlTcXVhcmVCcmFja2V0cycsICdkb21haW4nLCAncmVsYXRpdmVPbmx5JywgJ3NjaGVtZScsICdlbmNvZGVVcmknXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucy5kb21haW4sIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlZ2V4LCBzY2hlbWUgfSA9IFVyaS5yZWdleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvcHRpb25zLmRvbWFpbiA/IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zLmRvbWFpbikgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd1cmknLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXgsIGRvbWFpbiwgc2NoZW1lIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgZG9tYWluLCBzY2hlbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKFsnaHR0cDovJywgJ2h0dHBzOi8nXS5pbmNsdWRlcyh2YWx1ZSkpIHsgICAgICAgICAgICAvLyBzY2hlbWU6LyBpcyB0ZWNobmljYWxseSB2YWxpZCBidXQgbWFrZXMgbm8gc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2ggJiYgaGVscGVycy5wcmVmcy5jb252ZXJ0ICYmIG9wdGlvbnMuZW5jb2RlVXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVVUkkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoZW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmFsbG93UmVsYXRpdmUgfHwgbWF0Y2hlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEb21haW4uaXNWYWxpZChtYXRjaGVkLCBkb21haW4pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJywgeyB2YWx1ZTogbWF0Y2hlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnLCB7IHNjaGVtZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSBvZiBkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzdHJpbmcuYWxwaGFudW0nOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlNjQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgYmFzZTY0IHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuY3JlZGl0Q2FyZCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjcmVkaXQgY2FyZCcsXG4gICAgICAgICdzdHJpbmcuZGF0YVVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRhVXJpIHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuZG9tYWluJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGEgdmFsaWQgZG9tYWluIG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmVtYWlsJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgICAgICAgJ3N0cmluZy5lbXB0eSc6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkIHRvIGJlIGVtcHR5JyxcbiAgICAgICAgJ3N0cmluZy5ndWlkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIEdVSUQnLFxuICAgICAgICAnc3RyaW5nLmhleCc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmhleEFsaWduJzogJ3t7I2xhYmVsfX0gaGV4IGRlY29kZWQgcmVwcmVzZW50YXRpb24gbXVzdCBiZSBieXRlIGFsaWduZWQnLFxuICAgICAgICAnc3RyaW5nLmhvc3RuYW1lJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGhvc3RuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5pcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXBWZXJzaW9uJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3sjdmVyc2lvbn19IHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXNvRGF0ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4gaXNvIGZvcm1hdCcsXG4gICAgICAgICdzdHJpbmcuaXNvRHVyYXRpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZHVyYXRpb24nLFxuICAgICAgICAnc3RyaW5nLmxlbmd0aCc6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5sb3dlcmNhc2UnOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcubWF4JzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5taW4nOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubm9ybWFsaXplJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB1bmljb2RlIG5vcm1hbGl6ZWQgaW4gdGhlIHt7I2Zvcm19fSBmb3JtJyxcbiAgICAgICAgJ3N0cmluZy50b2tlbic6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4ubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IGZhaWxzIHRvIG1hdGNoIHRoZSB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQuYmFzZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uaW52ZXJ0Lm5hbWUnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBtYXRjaGVzIHRoZSBpbnZlcnRlZCB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudHJpbSc6ICd7eyNsYWJlbH19IG11c3Qgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgJ3N0cmluZy51cmknOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpJyxcbiAgICAgICAgJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7I3NjaGVtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnVyaVJlbGF0aXZlT25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICAnc3RyaW5nLnVwcGVyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIHVwcGVyY2FzZSBjaGFyYWN0ZXJzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnRsZHMgfHwgb3B0aW9uczsgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICAvLyBtaW5Eb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID4gMCwgJ21pbkRvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyBtYXhEb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1heERvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1heERvbWFpblNlZ21lbnRzID4gMCwgJ21heERvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyB0bGRzXG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSB0cnVlIHx8XG4gICAgICAgIG9wdGlvbnMudGxkcyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudGxkcyA9PT0gJ29iamVjdCcsICd0bGRzIG11c3QgYmUgdHJ1ZSwgZmFsc2UsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgY29uc3QgZGVueSA9IG9wdGlvbnMudGxkcy5kZW55O1xuICAgIGlmIChkZW55KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlbnkpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bGRzOiB7IGRlbnk6IG5ldyBTZXQoZGVueSkgfSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zLnRsZHMuZGVueSBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuZGVueSBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLnRsZHMuYWxsb3csICdDYW5ub3Qgc3BlY2lmeSBib3RoIHRsZHMuYWxsb3cgYW5kIHRsZHMuZGVueSBsaXN0cycpO1xuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5kZW55LCAndGxkcy5kZW55Jyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy50bGRzLmFsbG93O1xuICAgIGlmICghYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ID09PSB0cnVlKSB7XG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsb3cpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgYWxsb3c6IG5ldyBTZXQoYWxsb3cpIH0gfSk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyhvcHRpb25zLnRsZHMuYWxsb3csICd0bGRzLmFsbG93Jyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZVRsZHMgPSBmdW5jdGlvbiAoc2V0LCBzb3VyY2UpIHtcblxuICAgIGZvciAoY29uc3QgdGxkIG9mIHNldCkge1xuICAgICAgICBBc3NlcnQoRG9tYWluLmlzVmFsaWQodGxkLCB7IG1pbkRvbWFpblNlZ21lbnRzOiAxLCBtYXhEb21haW5TZWdtZW50czogMSB9KSwgYCR7c291cmNlfSBtdXN0IGNvbnRhaW4gdmFsaWQgdG9wIGxldmVsIGRvbWFpbiBuYW1lc2ApO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmlzb0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKC8uKlQuKlsrLV1cXGRcXGQkLy50ZXN0KHZhbHVlKSkgeyAgICAgICAgICAgICAvLyBBZGQgbWlzc2luZyB0cmFpbGluZyB6ZXJvcyB0byB0aW1lc2hpZnRcbiAgICAgICAgdmFsdWUgKz0gJzAwJztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn07XG5cblxuaW50ZXJuYWxzLmxlbmd0aCA9IGZ1bmN0aW9uIChzY2hlbWEsIG5hbWUsIGxpbWl0LCBvcGVyYXRvciwgZW5jb2RpbmcpIHtcblxuICAgIEFzc2VydCghZW5jb2RpbmcgfHwgQnVmZmVyICYmIEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX2FkZFJ1bGUoeyBuYW1lLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0LCBlbmNvZGluZyB9LCBvcGVyYXRvciB9KTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuTWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuXG4gICAgc2xpY2UoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuTWFwKHRoaXMpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzeW1ib2wnLFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXA6IHsgaW5pdDogbmV3IGludGVybmFscy5NYXAoKSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHNjaGVtYS4kX3Rlcm1zLm1hcC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbG9va3VwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Mub25seSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wubWFwJywgeyBtYXA6IHNjaGVtYS4kX3Rlcm1zLm1hcCB9KSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIG1ldGhvZChpdGVyYWJsZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICFpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdC5lbnRyaWVzKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSwgJ0l0ZXJhYmxlIG11c3QgYmUgYW4gaXRlcmFibGUgb3Igb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoZW50cnkgJiYgZW50cnlbU3ltYm9sLml0ZXJhdG9yXSwgJ0VudHJ5IG11c3QgYmUgYW4gaXRlcmFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGtleSAhPT0gJ3N5bWJvbCcsICdLZXkgbXVzdCBub3QgYmUgb2YgdHlwZSBvYmplY3QsIGZ1bmN0aW9uLCBvciBTeW1ib2wnKTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsICdWYWx1ZSBtdXN0IGJlIGEgU3ltYm9sJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnZhbGlkKC4uLnN5bWJvbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hcCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5tYXAoZGVzYy5tYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzeW1ib2wuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICAnc3ltYm9sLm1hcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I21hcH19J1xuICAgIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2JpbmFyeScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydzdHJpbmcnLCAnb2JqZWN0J10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IEJ1ZmZlci5mcm9tKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmVuY29kaW5nKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlRXJyKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYmluYXJ5LmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIGVuY29kaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZW5jb2RpbmcnLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYmluYXJ5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYmluYXJ5LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nJyxcbiAgICAgICAgJ2JpbmFyeS5sZW5ndGgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYXQgbGVhc3Qge3sjbGltaXR9fSBieXRlcydcbiAgICB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0eXBlczoge1xuICAgICAgICBhbHRlcm5hdGl2ZXM6IHJlcXVpcmUoJy4vdHlwZXMvYWx0ZXJuYXRpdmVzJyksXG4gICAgICAgIGFueTogcmVxdWlyZSgnLi90eXBlcy9hbnknKSxcbiAgICAgICAgYXJyYXk6IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSxcbiAgICAgICAgYm9vbGVhbjogcmVxdWlyZSgnLi90eXBlcy9ib29sZWFuJyksXG4gICAgICAgIGRhdGU6IHJlcXVpcmUoJy4vdHlwZXMvZGF0ZScpLFxuICAgICAgICBmdW5jdGlvbjogcmVxdWlyZSgnLi90eXBlcy9mdW5jdGlvbicpLFxuICAgICAgICBsaW5rOiByZXF1aXJlKCcuL3R5cGVzL2xpbmsnKSxcbiAgICAgICAgbnVtYmVyOiByZXF1aXJlKCcuL3R5cGVzL251bWJlcicpLFxuICAgICAgICBvYmplY3Q6IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0JyksXG4gICAgICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3R5cGVzL3N5bWJvbCcpXG4gICAgfSxcbiAgICBhbGlhc2VzOiB7XG4gICAgICAgIGFsdDogJ2FsdGVybmF0aXZlcycsXG4gICAgICAgIGJvb2w6ICdib29sZWFuJyxcbiAgICAgICAgZnVuYzogJ2Z1bmN0aW9uJ1xuICAgIH1cbn07XG5cblxuaWYgKEJ1ZmZlcikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgaW50ZXJuYWxzLnR5cGVzLmJpbmFyeSA9IHJlcXVpcmUoJy4vdHlwZXMvYmluYXJ5Jyk7XG59XG5cblxuaW50ZXJuYWxzLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByb290ID0ge1xuICAgICAgICBfdHlwZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoaW50ZXJuYWxzLnR5cGVzKSlcbiAgICB9O1xuXG4gICAgLy8gVHlwZXNcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiByb290Ll90eXBlcykge1xuICAgICAgICByb290W3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KCFhcmdzLmxlbmd0aCB8fCBbJ2FsdGVybmF0aXZlcycsICdsaW5rJywgJ29iamVjdCddLmluY2x1ZGVzKHR5cGUpLCAnVGhlJywgdHlwZSwgJ3R5cGUgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIGludGVybmFscy50eXBlc1t0eXBlXSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2hvcnRjdXRzXG5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ2FsbG93JywgJ2N1c3RvbScsICdkaXNhbGxvdycsICdlcXVhbCcsICdleGlzdCcsICdmb3JiaWRkZW4nLCAnaW52YWxpZCcsICdub3QnLCAnb25seScsICdvcHRpb25hbCcsICdvcHRpb25zJywgJ3ByZWZzJywgJ3ByZWZlcmVuY2VzJywgJ3JlcXVpcmVkJywgJ3N0cmlwJywgJ3ZhbGlkJywgJ3doZW4nXSkge1xuICAgICAgICByb290W21ldGhvZF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbnkoKVttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1ldGhvZHNcblxuICAgIE9iamVjdC5hc3NpZ24ocm9vdCwgaW50ZXJuYWxzLm1ldGhvZHMpO1xuXG4gICAgLy8gQWxpYXNlc1xuXG4gICAgZm9yIChjb25zdCBhbGlhcyBpbiBpbnRlcm5hbHMuYWxpYXNlcykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbnRlcm5hbHMuYWxpYXNlc1thbGlhc107XG4gICAgICAgIHJvb3RbYWxpYXNdID0gcm9vdFt0YXJnZXRdO1xuICAgIH1cblxuICAgIHJvb3QueCA9IHJvb3QuZXhwcmVzc2lvbjtcblxuICAgIC8vIFRyYWNlXG5cbiAgICBpZiAoVHJhY2Uuc2V0dXApIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgVHJhY2Uuc2V0dXAocm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbmludGVybmFscy5tZXRob2RzID0ge1xuXG4gICAgVmFsaWRhdGlvbkVycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLFxuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNhY2hlOiBDYWNoZS5wcm92aWRlcixcblxuICAgIGFzc2VydCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCB0cnVlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgYXR0ZW1wdCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hc3NlcnQodmFsdWUsIHNjaGVtYSwgZmFsc2UsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5idWlsZCA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmJ1aWxkKHRoaXMsIGRlc2MpO1xuICAgIH0sXG5cbiAgICBjaGVja1ByZWZlcmVuY2VzKHByZWZzKSB7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuICAgIH0sXG5cbiAgICBjb21waWxlKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBDb21waWxlLmNvbXBpbGUodGhpcywgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZGVmYXVsdHMobW9kaWZpZXIpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnbW9kaWZpZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RpZmllcihqb2lbdHlwZV0oKSk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdtb2RpZmllciBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYSBvYmplY3QnKTtcblxuICAgICAgICAgICAgam9pW3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBleHByZXNzaW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBleHRlbmQoLi4uZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KGV4dGVuc2lvbnMsICdleHRlbmQnKTtcblxuICAgICAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgICAgICBBc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGgsICdZb3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IG9uZSBleHRlbnNpb24nKTtcbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgU2NoZW1hcy5leHRlbnNpb25zKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgam9pLl90eXBlcyA9IG5ldyBTZXQoam9pLl90eXBlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGpvaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbiwgU2NoZW1hcy5leHRlbnNpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZCA9IGludGVybmFscy5leHBhbmRFeHRlbnNpb24oZXh0ZW5zaW9uLCBqb2kpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGpvaVtpdGVtLnR5cGVdID09PSB1bmRlZmluZWQgfHwgam9pLl90eXBlcy5oYXMoaXRlbS50eXBlKSwgJ0Nhbm5vdCBvdmVycmlkZSBuYW1lJywgaXRlbS50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBpdGVtLmJhc2UgfHwgdGhpcy5hbnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBFeHRlbmQudHlwZShiYXNlLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGpvaS5fdHlwZXMuYWRkKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgam9pW2l0ZW0udHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9LFxuXG4gICAgaXNFcnJvcjogRXJyb3JzLlZhbGlkYXRpb25FcnJvci5pc0Vycm9yLFxuICAgIGlzRXhwcmVzc2lvbjogVGVtcGxhdGUuaXNUZW1wbGF0ZSxcbiAgICBpc1JlZjogUmVmLmlzUmVmLFxuICAgIGlzU2NoZW1hOiBDb21tb24uaXNTY2hlbWEsXG5cbiAgICBpbiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlZi5pbiguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgb3ZlcnJpZGU6IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLFxuXG4gICAgcmVmKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmNyZWF0ZSguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgdHlwZXMoKSB7XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMuX3R5cGVzKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRoaXNbdHlwZV0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgICAgICB0eXBlc1t0YXJnZXRdID0gdGhpc1t0YXJnZXRdKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgYW5ub3RhdGUsIGFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJnc1swXSA6IG51bGw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lc3NhZ2UgIT09IG51bGwgPyBhcmdzWzFdIDogYXJnc1swXTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEudmFsaWRhdGUodmFsdWUsIENvbW1vbi5wcmVmZXJlbmNlcyh7IGVycm9yczogeyBzdGFjazogdHJ1ZSB9IH0sIG9wdGlvbnMgfHwge30pKTtcblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3BsYXkgPSBhbm5vdGF0ZSAmJiB0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicgPyBlcnJvci5hbm5vdGF0ZSgpIDogZXJyb3IubWVzc2FnZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9ycy5WYWxpZGF0aW9uRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIGVycm9yID0gQ2xvbmUoZXJyb3IpO1xuICAgIH1cblxuICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlID8gYCR7bWVzc2FnZX0gJHtkaXNwbGF5fWAgOiBkaXNwbGF5O1xuICAgIHRocm93IGVycm9yO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBBc3NlcnQocm9vdCwgJ011c3QgYmUgaW52b2tlZCBvbiBhIEpvaSBpbnN0YW5jZS4nKTtcblxuICAgIHNjaGVtYS4kX3Jvb3QgPSByb290O1xuXG4gICAgaWYgKCFzY2hlbWEuX2RlZmluaXRpb24uYXJncyB8fFxuICAgICAgICAhYXJncy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuX2RlZmluaXRpb24uYXJncyhzY2hlbWEsIC4uLmFyZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMuZXhwYW5kRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbiwgam9pKSB7XG5cbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl07XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygam9pLl90eXBlcykge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUudGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbik7XG4gICAgICAgICAgICBpdGVtLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaXRlbS5iYXNlID0gam9pW3R5cGVdKCk7XG4gICAgICAgICAgICBleHRlbmRlZC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZGVkO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yb290KCk7XG4iLCAiaW1wb3J0IHsgZ2VuZXJhdGVFcnJvclJlc3BvbnNlcyB9IGZyb20gJy4uL3NjaGVtYXMvY29tbW9uLmpzJ1xuaW1wb3J0IHsgSm9pIH0gZnJvbSAnLi4vc2NoZW1hcy92YWxpZGF0b3IuanMnXG5cbmNvbnN0IGRvY3VtZW50YXRpb24gPSB7XG4gIHN1bW1hcnk6ICdIZWxsbyAzJyxcbiAgdGFnczogWydIZWxsbyBUd28gU2VjdGlvbiddLFxuICBkZXNjcmlwdGlvbjogJ0hlbGxvIDMgdGVtcGxhdGUuJyxcbiAgbWV0aG9kUmVzcG9uc2VzOiBbXG4gICAge1xuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQW4gb2JqZWN0IHJldHVybmluZyBoZWxsbzMgcmVzcG9uc2UgYm9keS4nLFxuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiB7XG4gICAgICAgICAgICBleGFtcGxlczoge1xuICAgICAgICAgICAgICBSZXNwb25zZUV4YW1wbGUxOiB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeTogJ1Jlc3BvbnNlIEV4YW1wbGUgMScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGhlbGxvMzogJ3Jlc3BvbnNlLWV4YW1wbGUtMScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgUmVzcG9uc2VFeGFtcGxlMjoge1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6ICdSZXNwb25zZSBFeGFtcGxlIDInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICBoZWxsbzM6ICdyZXNwb25zZS1leGFtcGxlLTInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VNb2RlbHM6IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnSGVsbG9UaHJlZVNjaGVtYScsXG4gICAgICB9LFxuICAgIH0sXG4gICAgLi4uZ2VuZXJhdGVFcnJvclJlc3BvbnNlcyhbNDAwLCA0MDEsIDQwNCwgNTAwXSwgJ2dldHRpbmcgZ2V0dGluZyBoZWxsbyAzJyksXG4gIF0sXG4gIHJlcXVlc3RCb2R5OiB7XG4gICAgZGVzY3JpcHRpb246ICdIZWxsbyAzIHJlcXVlc3QgYm9keScsXG4gICAgY29udGVudDoge1xuICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiB7XG4gICAgICAgIGV4YW1wbGVzOiB7XG4gICAgICAgICAgUmVxdWVzdEV4YW1wbGUxOiB7XG4gICAgICAgICAgICBzdW1tYXJ5OiAnUmVxdWVzdEV4YW1wbGUgMScsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBoZWxsbzM6ICdyZXF1ZXN0LWV4YW1wbGUtMScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgUmVxdWVzdEV4YW1wbGUyOiB7XG4gICAgICAgICAgICBzdW1tYXJ5OiAnUmVxdWVzdCBFeGFtcGxlIDInLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgaGVsbG8zOiAncmVxdWVzdC1leGFtcGxlLTInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxufVxuXG5jb25zdCBzY2hlbWEgPSB7XG4gIHJlc3BvbnNlOiBKb2kub2JqZWN0KHtcbiAgICBoZWxsbzM6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICB9KSxcbiAgYm9keTogSm9pLm9iamVjdCh7XG4gICAgaGVsbG8zOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgfSksXG59XG5cbmNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaGVsbG8zOiBldmVudC5ib2R5LmhlbGxvMyxcbiAgICB9KSxcbiAgfVxufVxuXG5leHBvcnQgeyBkb2N1bWVudGF0aW9uLCBoYW5kbGVyLCBzY2hlbWEgfVxuIiwgIi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgZXJyb3IgcmVzcG9uc2VzIGZvciBhbiBlbmRwb2ludFxuICogQHBhcmFtIHtudW1iZXJbXX0gc3RhdHVzQ29kZXMgIC0gbGlzdCBvZiBlcnJvciByZXNwb25zZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB3aGVuIC0gZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvclJlc3BvbnNlcyhzdGF0dXNDb2Rlcywgd2hlbikge1xuICBjb25zdCByZXNwb25zZXMgPSBbXVxuICBjb25zdCBwb3N0VGV4dCA9ICdUaGUgZXhhbXBsZXMgc2hvdyBhbGwgcG9zc2libGUgYGNvZGVgIGFuZCBgbWVzc2FnZWAgdmFsdWVzLCBub3QgbGltaXRlZCB0byB0aGlzIGVuZHBvaW50LidcbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwMCkpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBBbiBlcnJvciBtZXNzYWdlIHdoZW4gJHt3aGVufS4gJHtwb3N0VGV4dH1gLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlTW9kZWxzOiB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9qc29uJzogJ0Vycm9yUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDQwMSkpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDEsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBVbmF1dGhvcmlzZWQgdXNlciB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdVbmF1dGhvcml6ZWRSZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RhdHVzQ29kZXMuaW5jbHVkZXMoNDAzKSkge1xuICAgIHJlc3BvbnNlcy5wdXNoKHtcbiAgICAgIHN0YXR1c0NvZGU6IDQwMyxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogYEZvcmJpZGRlbiB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdGb3JiaWRkZW5SZXNwb25zZScsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RhdHVzQ29kZXMuaW5jbHVkZXMoNDA0KSkge1xuICAgIHJlc3BvbnNlcy5wdXNoKHtcbiAgICAgIHN0YXR1c0NvZGU6IDQwNCxcbiAgICAgIHJlc3BvbnNlQm9keToge1xuICAgICAgICBkZXNjcmlwdGlvbjogYFJlc291cmNlIG5vdCBmb3VuZCB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdOb3RGb3VuZFJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdGF0dXNDb2Rlcy5pbmNsdWRlcyg0MjkpKSB7XG4gICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgc3RhdHVzQ29kZTogNDI5LFxuICAgICAgcmVzcG9uc2VCb2R5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgUmF0ZSBsaW1pdGVkIHdoZW4gJHt3aGVufS4gJHtwb3N0VGV4dH1gLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlTW9kZWxzOiB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9qc29uJzogJ1JhdGVMaW1pdGVkUmVzcG9uc2UnLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGVzLmluY2x1ZGVzKDUwMCkpIHtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICByZXNwb25zZUJvZHk6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGBBIHNlcnZlciBlcnJvciB3aGVuICR7d2hlbn0uICR7cG9zdFRleHR9YCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU1vZGVsczoge1xuICAgICAgICAnYXBwbGljYXRpb24vanNvbic6ICdTZXJ2ZXJFcnJvclJlc3BvbnNlJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZXNcbn1cblxuZXhwb3J0IHtcbiAgZ2VuZXJhdGVFcnJvclJlc3BvbnNlcyxcbn1cbiIsICJpbXBvcnQgSm9pRGF0ZSBmcm9tICdAam9pL2RhdGUnXG5pbXBvcnQgSm9pQmFzZSBmcm9tICdqb2knXG5cbi8qKiBAdHlwZSB7IGltcG9ydChcImpvaVwiKS5Sb290IH0gKi9cbmNvbnN0IEpvaSA9IEpvaUJhc2UuZXh0ZW5kKEpvaURhdGUpXG5cbmV4cG9ydCB7IEpvaSB9XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFPQSxRQUFJLGVBQWUsbUVBQW1FLE1BQU0sRUFBRTtBQUs5RixZQUFRLFNBQVMsU0FBVSxRQUFRO0FBQ2pDLFVBQUksS0FBSyxVQUFVLFNBQVMsYUFBYSxRQUFRO0FBQy9DLGVBQU8sYUFBYSxNQUFNO0FBQUEsTUFDNUI7QUFDQSxZQUFNLElBQUksVUFBVSwrQkFBK0IsTUFBTTtBQUFBLElBQzNEO0FBTUEsWUFBUSxTQUFTLFNBQVUsVUFBVTtBQUNuQyxVQUFJLE9BQU87QUFDWCxVQUFJLE9BQU87QUFFWCxVQUFJLFVBQVU7QUFDZCxVQUFJLFVBQVU7QUFFZCxVQUFJLE9BQU87QUFDWCxVQUFJLE9BQU87QUFFWCxVQUFJLE9BQU87QUFDWCxVQUFJLFFBQVE7QUFFWixVQUFJLGVBQWU7QUFDbkIsVUFBSSxlQUFlO0FBR25C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TUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEs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O0FBQUEsRUFDSDtBQUNGLEdBUGdCOyIsCiAgIm5hbWVzIjogWyJzb3VyY2VGaWxlIiwgIm5lZWRsZSIsICJzZWN0aW9uIiwgInBhdGgiLCAiZm9ybWF0IiwgImxvY2FsZSIsICJ0byIsICJmcm9tIiwgIm5vdyIsICJzaWduIiwgInRva2VuIiwgIm9yZGluYWwiLCAiaSIsICJkaWZmIiwgImxvY2FsZURhdGEiLCAiaG91cnMiLCAibWludXRlcyIsICJ0b2tlbnMiLCAibWVyaWRpZW0iLCAieWVhcnMiLCAibW9udGhzIiwgIndlZWtzIiwgImRheXMiLCAic2Vjb25kcyIsICJtaWxsaXNlY29uZHMiLCAib2Zmc2V0IiwgInRocmVzaG9sZHMiLCAic2NoZW1hIiwgIkpvaSIsICJyZXF1aXJlX2xpYiIsICJtZXNzYWdlIiwgInNjaGVtYSIsICJKb2kiLCAic2NoZW1hIiwgInJ1bGUiLCAic2NoZW1hIiwgInNjaGVtYSIsICJyZXF1aXJlX2xpYiIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgImlkIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9saWIiLCAic2NoZW1hIiwgImNsb25lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAicmVxdWlyZV9lcnJvcnMiLCAic2NoZW1lIiwgInNjaGVtYSIsICJzY2hlbWEiLCAic2NoZW1hIiwgInJlcXVpcmVfbGliIiwgInNjaGVtYSIsICJKb2lCYXNlIiwgIkpvaURhdGUiXQp9Cg==
